/**
 * @license
 * ts-browser-helpers v0.16.3
 * Copyright 2022-2025 repalash <palash@shaders.app>
 * MIT License
 * See ./dependencies.txt for bundled third-party dependencies and licenses.
 */
class I {
  constructor() {
    this._eventListeners = {}, this.dispatchEvent = this.dispatchEvent.bind(this), this.addEventListener = this.addEventListener.bind(this), this.removeEventListener = this.removeEventListener.bind(this), this.hasEventListener = this.hasEventListener.bind(this);
  }
  addEventListener(e, t) {
    const i = this._eventListeners;
    i[e] === void 0 && (i[e] = []), i[e].includes(t) || i[e].push(t);
  }
  hasEventListener(e, t) {
    const i = this._eventListeners;
    return i[e] !== void 0 && i[e].includes(t);
  }
  removeEventListener(e, t) {
    const r = this._eventListeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    const i = this._eventListeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
    }
  }
}
async function X(n) {
  return new Promise((e) => setTimeout(e, Math.max(0, n)));
}
function g() {
  return (typeof performance > "u" ? Date : performance).now();
}
class Z extends I {
  constructor() {
    super(...arguments), this._onPointerDown = (e) => {
      if (e.button !== 0 || !this._element) return;
      this._pointerUp = void 0;
      const t = e.clientX / this._element.clientWidth * 2 - 1, i = -(e.clientY / this._element.clientHeight) * 2 + 1, r = g();
      this._pointerDown = { x: t, y: i, time: r }, this._pointer = this._pointerDown, this.dispatchEvent({ type: "dragStart", pointer: this._pointerDown });
    }, this._onPointerMove = (e) => {
      if (!this._pointerDown || !this._pointer || !this._element) return;
      const t = e.clientX / this._element.clientWidth * 2 - 1, i = -(e.clientY / this._element.clientHeight) * 2 + 1, r = g();
      this.dispatchEvent({
        type: "drag",
        pointer: this._pointer,
        drag: { x: t - this._pointerDown.x, y: i - this._pointerDown.y, time: r - this._pointerDown.time },
        delta: { x: t - this._pointer.x, y: i - this._pointer.y, time: r - this._pointer.time }
      }), this._pointer = { x: t, y: i, time: g() }, e.buttons % 2 === 0 && this._onPointerUp(e);
    }, this._onPointerUp = (e) => {
      if (e.button !== 0 || !this._pointerDown || !this._element) return;
      const t = e.clientX / this._element.clientWidth * 2 - 1, i = -(e.clientY / this._element.clientHeight) * 2 + 1, r = g();
      this._pointerUp = { x: t, y: i, time: r }, this.dispatchEvent({
        type: "dragEnd",
        pointer: this._pointerUp,
        drag: {
          x: this._pointerUp.x - this._pointerDown.x,
          y: this._pointerUp.y - this._pointerDown.y,
          time: this._pointerUp.time - this._pointerDown.time
        }
      }), this._pointerDown = void 0, this._pointer = void 0;
    };
  }
  get element() {
    return this._element;
  }
  set element(e) {
    this._element !== e && (this._element && this._removeElement(), this._element = e, this._element && this._addElement());
  }
  _removeElement() {
    var e, t, i, r, s;
    (e = this._element) == null || e.removeEventListener("pointerdown", this._onPointerDown), (t = this._element) == null || t.removeEventListener("pointermove", this._onPointerMove), (i = this._element) == null || i.removeEventListener("pointerup", this._onPointerUp), (r = this._element) == null || r.removeEventListener("pointercancel", this._onPointerUp), (s = this._element) == null || s.removeEventListener("pointerout", this._onPointerUp);
  }
  _addElement() {
    var e, t, i, r, s;
    (e = this._element) == null || e.addEventListener("pointerdown", this._onPointerDown), (t = this._element) == null || t.addEventListener("pointermove", this._onPointerMove), (i = this._element) == null || i.addEventListener("pointerup", this._onPointerUp), (r = this._element) == null || r.addEventListener("pointercancel", this._onPointerUp), (s = this._element) == null || s.addEventListener("pointerout", this._onPointerUp);
  }
  dispose() {
    this.element = void 0;
  }
}
/*!
 * Fork Of -
 * JavaScript Undo Manager 1.0.0
 * Simple JavaScript undo/redo command manager supporting transactions with no dependencies.
 *
 * Copyright: Alexey Grinko, 2017
 * Git repository: https://github.com/agrinko/js-undo-manager.git
 *
 * @license MIT - https://opensource.org/licenses/MIT
 *
 * Changes -
 * 1. Added presets commands
 * 2. Port to TypeScript
 * 3. Remove transactions
 */
class Q {
  constructor(e) {
    this.options = {
      limit: 500,
      // maximum commands stack size
      debug: !1,
      // whether to emit execution status in console
      bindHotKeys: !1
      // whether to bind "undo" and "redo" commands to "Ctrl+Z", "Ctrl+Y" & "Ctrl+Shift+Z" hot keys
      // useTransactions: true   // whether to initialize transactions manager
    }, this.enabled = !0, this.presets = {}, this._keyDown = (t) => {
      if (!this.enabled) return;
      const i = t.ctrlKey || t.metaKey;
      t.code === "KeyZ" && i && !t.shiftKey ? this.undo() : (t.code === "KeyZ" && i && t.shiftKey || t.code === "KeyY" && t.ctrlKey) && this.redo();
    }, Object.assign(this.options, e), this.limit = e.limit, this.options = e, this.reset(), e.bindHotKeys && this.bindHotKeys(), this.log(`Initialized with stack limit of ${this.limit} commands`);
  }
  /**
   * Bind 'undo' and 'redo' actions to 'Ctrl/Cmd+Z', 'Ctrl+Y' & 'Ctrl/Cmd+Shift+Z' hot keys.
   * It is a basic implementation for quick testing and should be replaced with custom event handlers
   * for more flexible processing.
   * @returns {JSUndoManager}
   */
  bindHotKeys() {
    return this.log("Bound 'undo' and 'redo' actions to 'Ctrl/Cmd+Z', 'Ctrl+Y' & 'Ctrl/Cmd+Shift+Z' hot keys"), (this.options.hotKeyRoot ?? document).addEventListener("keydown", this._keyDown), this;
  }
  dispose() {
    return (this.options.hotKeyRoot ?? document).removeEventListener("keydown", this._keyDown), this.reset();
  }
  /**
   * Remember executed command containing "redo" and "undo" functions
   * @param {Object|Function} command - either an object with "redo" and "undo" functions
   * @returns {JSUndoManager}
   */
  record(e) {
    return this.enabled ? (this._record(e), this) : this;
  }
  replaceLast(e) {
    const t = this.peek();
    if (t)
      return this.log("replace", t, "with", e), this.stack[this.sp] = e, this;
  }
  /**
   * Execute function and record it with its opposite "undo" function
   * @param {Object|Function} command - either an object with "redo" and "undo" functions
   * @param {Function} [undo] - "undo" function, used if the first argument is also a function
   * @returns {JSUndoManager}
   */
  execute(e) {
    if (!this.enabled) return;
    let t = this._rc(e), i = t.redo;
    return this.record.apply(this, t), this.log("Executing function..."), i.apply(e), this;
  }
  _rc(e) {
    if (e.type) {
      const t = this.presets[e.type];
      if (typeof t == "function")
        return t(e);
      throw console.error(e, t, this.presets), new Error("Preset command not found");
    } else
      return e;
  }
  _record(e) {
    this.enabled && (this.log("Recording command", e), this._rebase(), this.stack.push(e), this.sp++, this._keepLimit());
  }
  //forget "future" commands if stack pointer is not at the end
  _rebase() {
    this.canRedo() && (this.stack.length = this.sp + 1);
  }
  //sustain limited size of stack; cut extra commands starting with the latest ones
  _keepLimit() {
    if (this.stack.length <= this.limit)
      return;
    let e = this.stack.length - this.limit;
    this.log("Stack size reached its limit: ${this.limit} commands. Cutting off most old commands..."), e === 1 ? this.stack.shift() : this.stack.splice(0, e), this.sp -= e;
  }
  /**
   * Undo previous command if possible
   * @returns {JSUndoManager}
   */
  undo() {
    if (!this.canUndo())
      return this;
    let e = this.stack[this.sp];
    return this.log("undo"), this.sp--, this._rc(e).undo(), this;
  }
  /**
   * Check whether undoing previous command is possible
   * @returns {boolean}
   */
  canUndo() {
    return this.sp >= 0 && this.enabled;
  }
  /**
   * Get the last command that was done
   */
  peek() {
    return this.canUndo() ? this.stack[this.sp] : null;
  }
  /**
   * Redo the command which was previously undone
   * @returns {JSUndoManager}
   */
  redo() {
    if (!this.canRedo())
      return this;
    let e = this.stack[this.sp + 1];
    return this.log("redo"), this.sp++, this._rc(e).redo(), this;
  }
  /**
   * Check whether redoing command is possible
   * @returns {boolean}
   */
  canRedo() {
    return this.sp < this.stack.length - 1 && this.enabled;
  }
  /**
   * Gets the last command that was undone
   */
  peekForward() {
    return this.canRedo() ? this.stack[this.sp + 1] : null;
  }
  /**
   * Change stack size limit initially defined in the constructor options
   * @param {number} limit
   */
  setLimit(e) {
    let t = this.stack.length - this.sp - 1;
    if (e < 1 || typeof e != "number")
      throw new TypeError(`JSUndoManager.setLimit(): unexpected argument limit=${e}. Should be a positive number`);
    return e < t ? console.warn(`JSUndoManager.setLimit(): cannot set stack limit (${e}) less than the number of 'redoable' commands (${t})`) : (this.limit = Math.floor(e), this._keepLimit()), this;
  }
  /**
   * Reset all commands from memory
   */
  reset() {
    return this.log("reset"), this.stack = [], this.sp = -1, this;
  }
  /**
   * Check whether the commands stack is empty
   * @returns {boolean}
   */
  isEmpty() {
    return !this.stack.length;
  }
  /**
   * Check whether the commands stack size reaches its limit
   * @returns {boolean}
   */
  isFull() {
    return this.stack.length === this.limit;
  }
  /**
   * Get number of commands in memory stack
   * @returns {Number}
   */
  getSize() {
    return this.stack.length;
  }
  log(e, ...t) {
    this.options.debug && console.log(`Command Manager: ${e}`, ...t);
  }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const p = class p {
  constructor(e = p.DECAY_MILLISECONDS) {
    this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(e);
  }
  setDecayTime(e) {
    this.naturalFrequency = 1 / Math.max(p.MIN_DECAY_MILLISECONDS, e);
  }
  update(e, t, i, r) {
    const s = 2e-4 * this.naturalFrequency;
    if (e == null || r === 0 || e === t && this.velocity === 0)
      return t;
    if (i < 0)
      return e;
    const o = e - t, c = this.velocity + this.naturalFrequency * o, a = o + i * c, u = Math.exp(-this.naturalFrequency * i), h = (c - this.naturalFrequency * a) * u, w = -this.naturalFrequency * (h + c * u);
    return Math.abs(h) < s * Math.abs(r) && w * o >= 0 ? (this.velocity = 0, t) : (this.velocity = h, t + a * u);
  }
};
p.SETTLING_TIME = 1e4, p.MIN_DECAY_MILLISECONDS = 1e-3, p.DECAY_MILLISECONDS = 50;
let k = p;
function j() {
  const n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  return n.style.display = "block", n;
}
function ee({ innerHTML: n = "", id: e, classList: t, addToBody: i = !0, elementTag: r = "div" }) {
  const s = document.createElement(r);
  return e && (s.id = e), s.innerHTML = n, t && s.classList.add(...t), i && document.body.appendChild(s), s;
}
async function T(n) {
  return new Promise((e, t) => {
    const i = new Image();
    i.onload = () => e(i), i.onerror = t, i.crossOrigin = "anonymous", i.decoding = "sync", i.src = n;
  });
}
function P(n, e = document.head) {
  const t = document.createElement("style");
  return t.type = "text/css", t.innerText = n, e == null || e.appendChild(t), t;
}
async function te(n, e = document.head) {
  return new Promise((t, i) => {
    const r = document.createElement("script");
    r.setAttribute("src", n), r.addEventListener("load", () => t(r)), r.addEventListener("error", i), e.appendChild(r);
  });
}
async function ne(n, e) {
  var i;
  n.innerHTML = e;
  const t = n.getElementsByTagName("script");
  for (let r = 0; r < t.length; r++) {
    const s = t[r], o = M(s);
    let c = !1;
    await new Promise((a) => {
      o.onload = a, o.onerror = () => {
        c = !0, a(void 0);
      };
    }), !c && ((i = s.parentNode) == null || i.replaceChild(o, s));
  }
}
function M(n, e) {
  e = e ?? document.createElement("script"), e.type = n.type || "text/javascript", e.text = n.text;
  for (let t = 0; t < n.attributes.length; t++) {
    const i = n.attributes[t];
    e.setAttribute(i.name, i.value);
  }
  return e;
}
function ie(n) {
  if (!window)
    return console.warn("window is required"), "";
  let e = "";
  const t = new Uint8Array(n), i = t.byteLength;
  for (let r = 0; r < i; r++)
    e += String.fromCharCode(t[r]);
  return window.btoa(e);
}
function re(n) {
  if (!window)
    return console.warn("window is required"), new Uint8Array(0);
  const e = window.atob(n), t = e.length, i = new Uint8Array(t);
  for (let r = 0; r < t; r++)
    i[r] = e.charCodeAt(r);
  return i.buffer;
}
const R = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function se(n, e) {
  return new R[n](e);
}
function oe(n) {
  return n.replace(
    /\w\S*/g,
    function(e) {
      return e.charAt(0).toUpperCase() + e.substr(1).toLowerCase();
    }
  );
}
function ce(n) {
  return n.replace(
    /([-_][a-z])/ig,
    (e) => e.toUpperCase().replace("-", "").replace("_", "")
  );
}
function ae(n) {
  if (!n || n === "" || n.match(/__MACOSX\/.*\._/)) return "";
  n = n.replace(/\?.*$/, "");
  const e = n.split(/[\\/]/).pop() ?? "", t = e.lastIndexOf(".");
  return e === "" || t < 1 ? "" : e.slice(t + 1);
}
function le(n) {
  return n.substring(n.lastIndexOf("/") + 1);
}
function F(n) {
  return n.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
}
function f(n, e, t) {
  return n.replace(new RegExp(F(e), "g"), t);
}
function ue(n, e, t, {
  replaceAll: i = !1,
  prepend: r = !1,
  append: s = !1,
  notFoundCallback: o = () => {
  }
} = {}) {
  if (o && !n.includes(e))
    return o(), n;
  let c = t;
  return r ? c = t + e : s && (c = e + t), i ? n.replaceAll(e, c) : n.replace(e, c);
}
function he(n) {
  return n.sort(), n[0].split("").map((e, t) => n[n.length - 1][t] === e ? e : "\0").join("").split("\0").at(0) || "";
}
const fe = (n, ...e) => String.raw({ raw: n }, ...e), $ = (n, ...e) => String.raw({ raw: n }, ...e), de = (n, ...e) => String.raw({ raw: n }, ...e), B = (n, ...e) => {
  let t = String.raw({ raw: n }, ...e);
  return t = f(t, "%", "%25"), t = f(t, "> <", "><"), t = f(t, "; }", ";}"), t = f(t, "<", "%3c"), t = f(t, ">", "%3e"), t = f(t, '"', "'"), t = f(t, "#", "%23"), t = f(t, "{", "%7b"), t = f(t, "}", "%7d"), t = f(t, "|", "%7c"), t = f(t, "^", "%5e"), t = f(t, "`", "%60"), t = f(t, "@", "%40"), t = f(t, "&", "&amp;"), t = f(t, `
`, "%0A"), "data:image/svg+xml;charset=UTF-8," + t;
};
function pe(n = document.head) {
  return P($`
      ::-webkit-scrollbar
      {
        width: 8px;  /* for vertical scrollbars */
        height: 8px; /* for horizontal scrollbars */
      }
      ::-webkit-scrollbar-track
      {
        background: rgba(64, 64, 64, 0.4);
        border-radius: 6px;
      }
      ::-webkit-scrollbar-thumb
      {
        background: rgba(128, 128, 128, 0.2);
        border-radius: 6px;
      }
      ::-webkit-scrollbar-corner {background: rgba(0,0,0,0.5);}
    `, n);
}
function N(n, e) {
  const t = window.URL.createObjectURL(n), i = document.createElement("a");
  i.style.display = "none", i.href = t, i.download = e, document.body.appendChild(i), i.click(), setTimeout(() => {
    document.body.removeChild(i), window.URL.revokeObjectURL(t);
  }, 1e3);
}
async function q(n) {
  return new Promise((e, t) => {
    const i = new FileReader();
    i.onload = (r) => e(i.result), i.onerror = (r) => t(i.error), i.onabort = (r) => t(new Error("Read aborted")), i.readAsDataURL(n);
  });
}
function me(n, e) {
  return N(n, e ?? n.name);
}
async function ge(n = !1, e = !1, t) {
  const i = document.createElement("input");
  i.type = "file", i.multiple = n, i.accept = t || "*", i.webkitdirectory = e, i.style.display = "none", document.body.appendChild(i), i.click();
  const r = await new Promise((s) => {
    i.onchange = (o) => {
      s(Array.from(i.files || []));
    };
  });
  return document.body.removeChild(i), r;
}
function we() {
  let n = !1;
  return function(e) {
    (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0, 4))) && (n = !0);
  }(navigator.userAgent || navigator.vendor || window.opera), n;
}
function ye(n) {
  return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function ve(n) {
  return n < 31308e-7 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
function be(n, e = 1, t = 1) {
  const i = document.createElement("canvas");
  i.width = e, i.height = t;
  const r = i.getContext("2d");
  r.fillStyle = "#" + n, r.fillRect(0, 0, e, t);
  const s = i.toDataURL();
  return i.remove(), s;
}
function H(n, e) {
  let t;
  do
    t = Object.getOwnPropertyDescriptor(n, e);
  while (!t && (n = Object.getPrototypeOf(n)));
  return t;
}
function W(n, e, t = !0, i = !1) {
  const r = H(n, e);
  return !!(r != null && r.set) || t && (r == null ? void 0 : r.writable) !== !1 && (r == null ? void 0 : r.get) === void 0 || i && !r;
}
function S(n, e, t, i = !0, r = !1) {
  return n && W(n, e, i, r) ? (n[e] = t, !0) : !1;
}
function Ee(n, ...e) {
  return typeof n == "function" && (n = n(...e)), n;
}
function xe(n, e, t) {
  for (const i of t) {
    const r = n[i];
    r !== void 0 && S(e, i, r, !0);
  }
  return e;
}
function Ce(n, e) {
  for (const t of e)
    if (!n.includes(t)) return !1;
  return !0;
}
function Y(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    if (e(n[t])) return t;
  return -1;
}
function ke(n, e) {
  return function(...t) {
    return n(), e && e.call(this, ...t);
  };
}
function _e(n, e) {
  return function(...t) {
    return n(...t), e && e.call(this, ...t);
  };
}
function Se(n, e, t = !1) {
  for (typeof n == "string" && (n = n.split(".")); n.length > 0; ) {
    if (!e) return e;
    const i = n.splice(0, 1)[0];
    if (!(i.length < 1))
      if (Array.isArray(e))
        e = e[parseInt(i)];
      else if (typeof e == "object" && i in e)
        e = e[i];
      else {
        if (t)
          throw new Error("invalid access, check " + i + " in " + e);
        return;
      }
  }
  return e;
}
function Ue(n, e) {
  return Object.keys(n).find((t) => n[t] === e);
}
function v(n, e) {
  return Object.hasOwn ? Object.hasOwn(n, e) : n.hasOwnProperty(e);
}
function Le(n, e, t = !0) {
  const i = t ? n : {}, r = Object.keys(n);
  for (const s of r) i[s] = e(n[s], s);
  return i;
}
function _(n, e) {
  return Object.fromEntries(Object.entries(n).map((t) => e(t)));
}
const b = {
  // object
  priority: 1 / 0,
  serialize: (n, e) => _(n, ([t, i]) => [t, d.Serialize(i, e, !1)]),
  deserialize: (n, e, t) => Object.assign(e || {}, _(n, ([i, r]) => [i, d.Deserialize(r, e == null ? void 0 : e[i], t, !1)])),
  isType: (n) => (n.constructor || Object) === Object
}, l = class l {
  static GetSerializer(e) {
    return l.Serializers.find((t) => t.isType(e));
  }
  static RegisterSerializer(...e) {
    for (const t of e) {
      const i = t.priority ?? 1e10, r = Y(l.Serializers, (s) => s.priority !== void 0 && s.priority < i);
      r >= 0 ? l.Serializers.splice(r + 1, 0, t) : l.Serializers.push(t);
    }
  }
  static UnregisterSerializer(...e) {
    for (const t of e) {
      const i = l.Serializers.indexOf(t);
      i >= 0 && l.Serializers.splice(i, 1);
    }
  }
  /**
   * Serialize an object
   * @param obj - object to serialize
   * @param meta - Optional object to store common meta-data/resources across the serialization process of multiple objects
   * @param isThis - true if called from inside the serialization function, like custom {@link IJSONSerializable.toJSON}.
   */
  static Serialize(e, t, i = !1) {
    if (typeof e == "function") return;
    if (!i) {
      const o = l.GetSerializer(e);
      if (o) return o.serialize(e, t);
      if (typeof e.toJSON == "function") {
        const c = e.toJSON(t, !0);
        return e.serializableClassId && c && (c.serializableClassId = e.serializableClassId), c;
      }
    }
    let r = e.constructor ?? Object;
    const s = {};
    for (; r && r !== Object; ) {
      const o = l.TypeMap.get(r) ?? [];
      for (const [c, a] of o)
        s[c] = l.Serialize(e[a], t, !1);
      r = Object.getPrototypeOf(r);
    }
    return e.serializableClassId && (s.serializableClassId = e.serializableClassId), s;
  }
  /**
   * Deserialize an object
   * @param data - data to deserialize
   * @param obj - current object that's set. If of the same class/type the data is deserialized into that instead of creating new objects.
   * @param meta - Optional object to retrieve common meta-data/resources across the deserialization process of multiple objects. Objects in meta must be class instances, not js objects. (like Material, Texture, Object3D etc)
   * @param isThis - true if called from inside the deserialization function, like custom {@link IJSONSerializable.fromJSON}
   */
  static Deserialize(e, t, i, r = !1) {
    if (e === void 0 || t === e) return t;
    if (e && typeof e == "object" && (e.constructor || Object) === Object && e.resource && typeof e.resource == "string" && e.uuid) {
      const o = i == null ? void 0 : i[e.resource];
      if (o) {
        if (e = o[e.uuid], typeof e == "object" && (e.__useCount = e.__useCount ? e.__useCount + 1 : 1), e || console.warn(`Resource ${e.resource} with uuid ${e.uuid} not found`), t === e) return t;
        if (e && typeof e == "object") {
          if ((e.constructor || Object) !== Object)
            return t && console.warn("replacing object", t, "with deserialized object from meta", e), e;
          console.error("Deserialize; meta should only have class instances, not js objects", e, t, i);
        }
      } else
        return console.warn(`Resource ${e.resource} not found`), t;
    }
    if (e && typeof e == "object" && (e.constructor || Object) !== Object && !Array.isArray(e) && !e.serializableClassId) {
      if (e instanceof Blob) return e;
      console.warn("Data might already be deserialized. It will be cloned, or copied to source", e, "source", t, e.constructor, e.constructor !== Object);
    }
    if (e && typeof e == "object")
      if (e.serializableClassId && (!t || t.serializableClassId !== e.serializableClassId)) {
        const o = l.SerializableClasses.get(e.serializableClassId);
        o && (o.DataInConstructor ? t = new o(e) : t = new o());
      } else (e.constructor || Object) === Object && !t ? t = {} : Array.isArray(e) && !t && (t = []);
    if (typeof t == "function")
      return console.error("cannot deserialize a function", t, e), t;
    if (!r) {
      const o = l.GetSerializer(e);
      if (o && o !== b) return o.deserialize(e, t, i);
    }
    if (!e || t === void 0 || t === null || typeof t != "object")
      return e;
    if (!r && typeof (t == null ? void 0 : t.fromJSON) == "function")
      return t.fromJSON(e, i, !0), t;
    let s = t.constructor ?? Object;
    if (s === Object) return b.deserialize(e, t, i);
    for (; s && s !== Object; ) {
      const o = l.TypeMap.get(s) ?? [];
      for (const [c, a] of o) {
        const u = t[a], h = l.Deserialize(e[c], u, i, !1);
        h !== u && S(t, a, h, !0);
      }
      s = Object.getPrototypeOf(s);
    }
    return t;
  }
};
l.TypeMap = /* @__PURE__ */ new Map(), l.SerializableClasses = /* @__PURE__ */ new Map(), l.Serializers = [
  {
    // arrays
    priority: 0,
    isType: (e) => Array.isArray(e),
    serialize: (e, t) => e.map((i) => l.Serialize(i, t, !1)),
    deserialize: (e, t, i) => {
      const r = e.length;
      Array.isArray(t) || (t = []);
      for (let s = 0; s < r; s++) {
        const o = e[s], c = t.length > s ? l.Deserialize(o, t[s], i, !1) : l.Deserialize(o, void 0, i, !1);
        t.length <= s ? t.push(c) : t[s] = c;
      }
      return t;
    }
  },
  {
    // primitives
    priority: 0,
    isType: (e) => !e || typeof e != "object",
    serialize: (e) => {
      if (e && typeof e == "number") {
        if (e === 1 / 0) return "Infinity";
        if (e === -1 / 0) return "-Infinity";
        if (isNaN(e)) return "NaN";
      }
      return e;
    },
    deserialize: (e, t) => {
      if (typeof t == "number") {
        if (e === "Infinity") return 1 / 0;
        if (e === "-Infinity") return -1 / 0;
        if (e === "NaN") return NaN;
        if (typeof e == "number" || !e) return e;
      }
      return e;
    }
  },
  b
];
let d = l;
const m = class m {
  static callFunction(e, t, i = []) {
    if (!t) return e(...i);
    if (e.name && t[e.name] === e) return e.call(t, ...i);
    m.methodMap.has(t) || m.methodMap.set(t, /* @__PURE__ */ new WeakMap());
    const r = m.methodMap.get(t);
    if (!r.has(e)) {
      let s = t;
      for (; s; ) {
        const o = Object.values(Object.getOwnPropertyDescriptors(s));
        for (let c of o)
          if (c.value === e)
            return r.set(e, !0), e.call(t, ...i);
        s = Object.getPrototypeOf(s);
      }
      r.set(e, !1);
    }
    return r.get(e) ? e.call(t, ...i) : e(...i);
  }
};
m.methodMap = /* @__PURE__ */ new WeakMap();
let E = m;
function x(n, e = "param") {
  if (!n) throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
  return (t, i, r) => {
    const s = {
      get() {
        return this[`_oc_${i}`];
      },
      set(o) {
        var u;
        const c = this[`_oc_${i}`];
        if (c === o) return;
        this[`_oc_${i}`] = o;
        const a = e === "param" ? [i, o, c, this] : e === "object" ? [{ key: i, value: o, oldValue: c, target: this }] : [];
        typeof n == "string" ? (u = this[n]) == null || u.call(this, ...a) : typeof n == "function" && E.callFunction(n, this, a);
      }
    };
    if (r)
      return v(r, "value") && delete r.value, v(r, "writable") && delete r.writable, v(r, "initializer") && delete r.initializer, Object.assign(r, s);
    Object.defineProperty(t, i, s);
  };
}
function ze(n, e = "void") {
  if (!n) throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
  return x(n, e);
}
function Ae(n, e = "object") {
  if (!n) throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
  return x(n, e);
}
function Oe(n) {
  return x((e, t, i, r) => {
    if (!r.dispatchEvent) throw new Error("onChangeDispatchEvent: target does not have dispatchEvent");
    r.dispatchEvent({ type: n || `${e}-changed`, detail: { key: e, value: t, oldValue: i } });
  }, "param");
}
function De(n) {
  return (e, t) => {
    const i = e.constructor;
    if (i === Object) throw new Error("All properties in an object are serialized by default");
    d.TypeMap.has(i) || d.TypeMap.set(i, []), d.TypeMap.get(i).push([n || t, t]);
  };
}
function Ie(n) {
  return (e) => (e = class extends e {
    constructor() {
      super(...arguments), this.serializableClassId = n;
    }
    // static DataInConstructor = false // if constructor is equivalent to fromJSON, see LUTCubeTextureWrapper.
  }, d.SerializableClasses.set(n, e), e);
}
async function Te(n, e, t) {
  const i = typeof e == "string" ? new TextEncoder().encode(e) : e, r = await crypto.subtle.digest("SHA-256", i), s = crypto.getRandomValues(new Uint8Array(12)), o = Array.from(s).map((y) => String.fromCharCode(y)).join(""), c = { name: "AES-GCM", iv: s }, a = await crypto.subtle.importKey("raw", r, c, !1, ["encrypt"]), u = typeof n == "string" ? new TextEncoder().encode(n) : n, h = await crypto.subtle.encrypt(c, a, u), w = new Uint8Array(h), C = Array.from(w), A = C.map((y) => String.fromCharCode(y)).join(""), O = t ? typeof t == "string" ? t : new TextDecoder().decode(t) : "", D = t ? typeof t == "string" ? new TextEncoder().encode(t) : Array.from(t) : [];
  return typeof n == "string" ? O + o + A : new Uint8Array([...D, ...s, ...C]);
}
async function Pe(n, e) {
  const t = typeof e == "string" ? new TextEncoder().encode(e) : e, i = await crypto.subtle.digest("SHA-256", t), r = n.slice(0, 12), o = { name: "AES-GCM", iv: typeof r == "string" ? new Uint8Array(Array.from(r).map((h) => h.charCodeAt(0))) : r }, c = await crypto.subtle.importKey("raw", i, o, !1, ["decrypt"]), a = n.slice(12), u = typeof a == "string" ? new Uint8Array(Array.from(a).map((h) => h.charCodeAt(0))) : a;
  try {
    const h = await crypto.subtle.decrypt(o, c, u);
    return typeof n == "string" ? new TextDecoder().decode(h) : new Uint8Array(h);
  } catch {
    throw new Error("Decrypt failed");
  }
}
async function Me() {
  return "showOpenFilePicker" in window ? window.showOpenFilePicker().then((n) => n[0]) : window.chooseFileSystemEntries();
}
function Re() {
  if ("showSaveFilePicker" in window) {
    const e = {
      types: [{
        description: "Text file",
        accept: { "text/plain": [".txt"] }
      }]
    };
    return window.showSaveFilePicker(e);
  }
  const n = {
    type: "save-file",
    accepts: [{
      description: "Text file",
      extensions: ["txt"],
      mimeTypes: ["text/plain"]
    }]
  };
  return window.chooseFileSystemEntries(n);
}
function Fe(n) {
  return n.text ? n.text() : K(n);
}
function K(n) {
  return new Promise((e) => {
    const t = new FileReader();
    t.addEventListener("loadend", (i) => {
      const r = (i.srcElement || i.target).result;
      e(r);
    }), t.readAsText(n);
  });
}
async function $e(n, e) {
  if (n.createWriter) {
    const i = await n.createWriter();
    await i.write(0, e), await i.close();
    return;
  }
  const t = await n.createWritable();
  await t.write(e), await t.close();
}
async function Be(n, e) {
  const t = {};
  return e && (t.writable = !0, t.mode = "readwrite"), await n.queryPermission(t) === "granted" || await n.requestPermission(t) === "granted";
}
function U(n, e = 8192, t = !1) {
  var o;
  if (!n.width || !n.height) throw new Error("Invalid bitmap");
  const i = document.createElement("canvas");
  i.width = Math.min(e, n.width), i.height = Math.floor(1 + i.width * n.height / n.width);
  const r = n instanceof ImageBitmap, s = r && t && Math.abs(i.width - n.width) < 0.5 ? i.getContext("bitmaprenderer") : void 0;
  return s ? s.transferFromImageBitmap(n) : (o = i.getContext("2d")) == null || o.drawImage(n, 0, 0, i.width, i.height), r && t && n.close(), i;
}
function Ne(n, e = 8192, t = !1, i = "image/png") {
  if (!n.width || !n.height) return "";
  const r = U(n, e, !1), s = r.toDataURL(i);
  return r.remove(), t && n instanceof ImageBitmap && n.close(), s;
}
async function qe(n, e = 8192, t = !1, i = "image/png") {
  if (!n.width || !n.height) return Promise.reject("Invalid bitmap");
  const r = U(n, e, !1);
  return new Promise((s, o) => {
    r.toBlob((c) => {
      c ? s(c) : o("Could not get blob"), r.remove(), t && n instanceof ImageBitmap && n.close();
    }, i);
  });
}
async function He(n) {
  return new Promise((e, t) => {
    const i = new Image();
    i.addEventListener("load", () => {
      const r = document.createElement("canvas");
      r.width = i.width, r.height = i.height;
      const s = r.getContext("2d");
      if (!s) {
        t(new Error("Could not get 2d context"));
        return;
      }
      s.drawImage(i, 0, 0, r.width, r.height);
      const o = s.getImageData(0, 0, r.width, r.height);
      e(o), r.remove(), i.remove();
    }, !1), i.addEventListener("error", (r) => {
      i.remove(), t(r);
    }, !1), i.src = n;
  });
}
function V(n, {
  backgroundColor: e = "",
  scale: t = 1,
  width: i = 512,
  height: r = 512
}) {
  const s = document.createElement("canvas"), o = s.getContext("2d"), c = t, a = i, u = r;
  return s.width = a * c, s.height = u * c, s.style.width = `${a}`, s.style.height = `${u}`, (e == null ? void 0 : e.length) > 0 && (o.fillStyle = e, o.fillRect(0, 0, s.width, s.height)), o.drawImage(n, 0, 0, s.width, s.height), s;
}
function We(n) {
  const e = document.createElement("canvas");
  return e.width = n.width, e.height = n.height, e.getContext("2d").putImageData(n, 0, 0), e;
}
function Ye() {
  const n = document.createElement("canvas");
  return n.getContext && n.getContext("2d") ? n.toDataURL("image/webp").startsWith("data:image/webp") : !1;
}
function Ke(n) {
  const e = document.createElement("canvas");
  e.width = n.width, e.height = n.height;
  const t = e.getContext("2d");
  if (!t) throw new Error("Unable to get 2d context");
  return t.translate(0, n.height), t.scale(1, -1), t.drawImage(n, 0, 0), e;
}
function Ve(n) {
  return new Promise((e, t) => {
    const i = new Image(), r = URL.createObjectURL(n);
    i.onload = () => {
      URL.revokeObjectURL(r), e(i);
    }, i.onerror = (s) => {
      URL.revokeObjectURL(r), t(s);
    }, i.src = r;
  });
}
const Je = (n) => `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='16' height='16' fill='%23${n}'/%3E%3C/svg%3E%0A`, Ge = (n) => `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='8' cy='8' r='7' fill='%23${n}'/%3E%3C/svg%3E%0A`, Xe = (n) => `data:image/svg+xml,%3Csvg viewBox='0 0 80 14' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext style='font: 8px "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace; fill: white;' x='9' y='9'%3E${n}%3C/text%3E%3C/svg%3E%0A`, L = async (n, e) => {
  const t = await T(n);
  return V(t, e);
}, J = async (n, e) => await L(n, e).then((t) => t.toDataURL("image/png")), G = async (n) => q(await (await fetch(n)).blob());
async function Ze(n, e = G) {
  const t = n.match(/(((ftp|https?):\/\/)[\-\w@:%_\+.~#?,&\/\/=]+)/g);
  if (t)
    for (const i of t) {
      const r = await e(i);
      n = n.replace(i, r);
    }
  return n;
}
function z(n, e, { width: t, height: i }, r = !0) {
  const s = `
<svg viewBox="0 0 ${t} ${i}" xmlns="http://www.w3.org/2000/svg">
    <style>
    ${e}
    </style>
    <foreignObject x="0" y="0" width="100%" height="100%">
        <div xmlns="http://www.w3.org/1999/xhtml" style="height: 100%; width: 100%; position: absolute: top:0; left:0">
            ${n}
        </div>
    </foreignObject>
</svg>
    `;
  return r ? B(s) : s;
}
async function Qe(n, e, t) {
  const i = z(n, e, t);
  return await L(i, t);
}
async function je(n, e, t) {
  const i = z(n, e, t);
  return await J(i, t);
}
function et(n, e) {
  return Math.abs(n) > Math.abs(e) ? n : e;
}
function tt(n, e, t) {
  const i = t ? 1 : 0, r = ~(1 << e);
  return n & r | i << e;
}
function nt(n, e) {
  const t = ~(1 << e);
  return n & t;
}
function it() {
  const n = (i, r) => i.toString(16).padStart(r, "0"), e = crypto.getRandomValues(new Uint8Array(16));
  e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
  const t = new DataView(e.buffer);
  return `${n(t.getUint32(0), 8)}-${n(t.getUint16(4), 4)}-${n(t.getUint16(6), 4)}-${n(t.getUint16(8), 4)}-${n(t.getUint32(10), 8)}${n(t.getUint16(14), 4)}`;
}
function rt(n, e = null) {
  return new URL(window.location.href).searchParams.get(n) ?? e;
}
function st(n, e, t = !1) {
  const i = new URLSearchParams(location.search);
  e == null ? i.has(n) && i.delete(n) : i.set(n, e), t ? window.location.search = i.toString() : window.history.replaceState({}, "", "?" + i.toString());
}
function ot(n, e = "/") {
  return n.join(e);
}
function ct(n, e) {
  const t = (e ? `var Module = { locateFile: function(s) { return "${e}"; } }; 
` : "") + `importScripts( "${n}" );`;
  return URL.createObjectURL(new Blob([t], { type: "text/javascript" }));
}
export {
  k as Damper,
  E as FnCaller,
  Q as JSUndoManager,
  ve as LinearToSRGB,
  Z as PointerDragHelper,
  ye as SRGBToLinear,
  d as Serialization,
  I as SimpleEventDispatcher,
  R as TYPED_ARRAYS,
  et as absMax,
  Pe as aesGcmDecrypt,
  Te as aesGcmEncrypt,
  ie as arrayBufferToBase64,
  re as base64ToArrayBuffer,
  q as blobToDataURL,
  Ve as blobToImage,
  Ke as canvasFlipY,
  nt as clearBit,
  M as cloneScriptTag,
  be as colorToDataUrl,
  xe as copyProps,
  j as createCanvasElement,
  ee as createDiv,
  T as createImage,
  te as createScriptFromURL,
  P as createStyles,
  $ as css,
  Se as deepAccessObject,
  N as downloadBlob,
  me as downloadFile,
  Ze as embedUrlRefs,
  F as escapeRegExp,
  Y as findLastIndex,
  Me as getFileHandle,
  le as getFilenameFromPath,
  Ue as getKeyByValue,
  Re as getNewFileHandle,
  Ee as getOrCall,
  H as getPropertyDescriptor,
  se as getTypedArray,
  rt as getUrlQueryParam,
  fe as glsl,
  de as html,
  Qe as htmlToCanvas,
  je as htmlToPng,
  z as htmlToSvg,
  Ne as imageBitmapToBase64,
  qe as imageBitmapToBlob,
  U as imageBitmapToCanvas,
  We as imageDataToCanvas,
  V as imageToCanvas,
  He as imageUrlToImageData,
  Ce as includesAll,
  W as isPropertyWritable,
  Ye as isWebpExportSupported,
  he as longestCommonPrefix,
  Je as makeColorSvg,
  Ge as makeColorSvgCircle,
  Xe as makeTextSvg,
  we as mobileAndTabletCheck,
  g as now,
  v as objectHasOwn,
  Le as objectMap,
  _ as objectMap2,
  x as onChange,
  ze as onChange2,
  Ae as onChange3,
  Oe as onChangeDispatchEvent,
  ae as parseFileExtension,
  ot as pathJoin,
  pe as prettyScrollbar,
  Fe as readFile,
  ct as remoteWorkerURL,
  f as replaceAll,
  ue as safeReplaceString,
  S as safeSetProperty,
  Ie as serializable,
  De as serialize,
  ne as setInnerHTMLWithScripts,
  st as setUrlQueryParam,
  L as svgToCanvas,
  J as svgToPng,
  B as svgUrl,
  X as timeout,
  ce as toCamelCase,
  oe as toTitleCase,
  tt as updateBit,
  ge as uploadFile,
  it as uuidV4,
  Be as verifyPermission,
  ke as wrapThisFunction,
  _e as wrapThisFunction2,
  $e as writeFile
};
//# sourceMappingURL=bundle.esm.js.map
