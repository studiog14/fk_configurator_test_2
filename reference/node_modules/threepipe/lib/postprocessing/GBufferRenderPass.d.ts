import { Color, Material, Texture, WebGLMultipleRenderTargets, WebGLRenderTarget } from 'three';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { IPassID, IPipelinePass } from './Pass';
import { ICamera, IMaterial, IRenderManager, IScene, IWebGLRenderer } from '../core';
import { UiObjectConfig } from 'uiconfig.js';
import { ValOrFunc } from 'ts-browser-helpers';
export declare class GBufferRenderPass<TP extends IPassID = IPassID, T extends WebGLMultipleRenderTargets | WebGLRenderTarget | undefined = WebGLMultipleRenderTargets | WebGLRenderTarget> extends RenderPass implements IPipelinePass<TP> {
    readonly passId: TP;
    target: ValOrFunc<T>;
    readonly isGBufferRenderPass = true;
    uiConfig: UiObjectConfig;
    enabled: boolean;
    scene?: IScene;
    before?: IPassID[];
    after?: IPassID[];
    required?: IPassID[];
    constructor(passId: TP, target: ValOrFunc<T>, material: Material, clearColor?: Color, clearAlpha?: number);
    private _transparentMats;
    private _transmissiveMats;
    preprocessMaterial: (material: IMaterial, renderToGBuffer?: boolean) => void;
    /**
     * Renders to {@link target}
     * @param renderer
     * @param _ - this is ignored
     * @param _1 - this is ignored
     * @param deltaTime
     * @param maskActive
     */
    render(renderer: IWebGLRenderer, _?: WebGLRenderTarget<Texture | Texture[]> | null, _1?: WebGLRenderTarget<Texture | Texture[]>, deltaTime?: number, maskActive?: boolean): void;
    beforeRender(scene: IScene, camera: ICamera, _: IRenderManager): void;
}
//# sourceMappingURL=GBufferRenderPass.d.ts.map