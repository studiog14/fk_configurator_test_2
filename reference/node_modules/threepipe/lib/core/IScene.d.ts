import { IObject3D, IObject3DEventMap, IObject3DUserData, IObjectSetDirtyOptions } from './IObject';
import { Color, Scene, Texture } from 'three';
import { IShaderPropertiesUpdater } from '../materials';
import { ICamera } from './ICamera';
import { Box3B } from '../three';
import { ITexture } from './ITexture';
import { IGeometry } from './IGeometry';
export interface AddObjectOptions {
    /**
     * Add directly to the {@link RootScene} object instead of {@link RootScene.modelRoot}
     * @default false
     */
    addToRoot?: boolean;
    /**
     * Automatically center the object in the scene.
     * @default false
     */
    autoCenter?: boolean;
    /**
     * Automatically center the geometries(pivots) in the object hierarchy before adding.
     * @default false
     */
    centerGeometries?: boolean;
    /**
     * This centers the geometry while keeping the world position, i.e the mesh(Object3D) positions will change.
     * {@link centerGeometries} must be true for this to work.
     * @default true
     */
    centerGeometriesKeepPosition?: boolean;
    /**
     * Add a license to the object
     */
    license?: string;
    /**
     * Automatically scale the object according to its bounding box and the {@link autoScaleRadius} setting
     * @default false
     */
    autoScale?: boolean;
    /**
     * Radius to use for {@link autoScale}
     * {@link autoScale} must be true for this to work.
     * @default 2
     */
    autoScaleRadius?: number;
    /**
     * any attached viewer config will be ignored if this is set to true
     * @default true
     */
    importConfig?: boolean;
    /**
     * Clear the viewer scene objects before the new object is added. Same as {@link disposeSceneObjects} but does not dispose the objects.
     */
    clearSceneObjects?: boolean;
    /**
     * Dispose all the scene objects before the new object is added. Same as {@link clearSceneObjects} but also disposes the objects.
     */
    disposeSceneObjects?: boolean;
}
export interface ISceneEventMap extends IObject3DEventMap {
    sceneUpdate: {
        hierarchyChanged?: boolean;
        refreshScene?: boolean;
        object?: IObject3D;
        change?: ISceneEventMap['objectUpdate']['change'];
        bubbleToParent?: boolean;
        geometry?: IGeometry | null;
        oldGeometry?: IGeometry | null;
        /**
         * @deprecated use {@link refreshScene} instead
         */
        sceneUpdate?: boolean;
    } & ISceneSetDirtyOptions;
    addSceneObject: {
        object: IObject3D;
        options?: AddObjectOptions;
        geometryChanged?: boolean;
        updateGround?: boolean;
    };
    mainCameraChange: {
        lastCamera: ICamera;
        camera: ICamera;
    };
    mainCameraUpdate: IObject3DEventMap['cameraUpdate'];
    renderCameraChange: {
        lastCamera: ICamera | undefined;
        camera: ICamera;
    };
    environmentChanged: {
        environment: ITexture | null;
    };
    backgroundChanged: {
        background: Texture | Color | 'environment' | null;
        backgroundColor: Color | null;
    };
    /**
     * @deprecated use {@link mainCameraChange} instead
     */
    activeCameraChange: ISceneEventMap['mainCameraChange'];
    /**
     * @deprecated use {@link mainCameraUpdate} instead
     */
    activeCameraUpdate: ISceneEventMap['mainCameraUpdate'];
    /**
     * @deprecated use {@link materialUpdate} instead
     */
    sceneMaterialUpdate: IObject3DEventMap['materialUpdate'];
    /**
     * @deprecated use {@link objectUpdate} or {@link sceneUpdate} instead
     */
    update: IObject3DEventMap['objectUpdate'];
}
export interface ISceneSetDirtyOptions extends IObjectSetDirtyOptions {
    refreshScene?: boolean;
}
export type ISceneUserData = IObject3DUserData;
export interface IWidget {
    attach(object: any): this;
    detach(): this;
    isWidget: true;
    object: any;
    update?(): void;
    dispose?(): void;
}
export interface IScene<TE extends ISceneEventMap = ISceneEventMap> extends Scene<TE>, IObject3D<TE>, IShaderPropertiesUpdater {
    readonly visible: boolean;
    readonly isScene: true;
    /**
     * Main camera that the user controls
     */
    mainCamera: ICamera;
    /**
     * Camera that in currently being rendered.
     */
    renderCamera: ICamera;
    type: 'Scene';
    toJSON(): any;
    modelRoot: IObject3D;
    addObject<T extends IObject3D>(imported: T, options?: AddObjectOptions): T & IObject3D;
    setDirty(e?: ISceneSetDirtyOptions): void;
    getBounds(precise?: boolean, ignoreInvisible?: boolean): Box3B;
    backgroundIntensity: number;
    envMapIntensity: number;
    fixedEnvMapDirection: boolean;
    environment: ITexture | null;
    background: ITexture | Color | null | 'environment';
    backgroundColor: Color | null;
    defaultCamera: ICamera;
    userData: ISceneUserData;
    /**
     * @deprecated use {@link getObjectByName} instead
     * @param name
     * @param parent
     */
    findObjectsByName(name: string, parent?: any): any[];
    /**
     * @deprecated renamed to {@link mainCamera}
     */
    activeCamera: ICamera;
    traverse(callback: (object: IObject3D) => void): void;
    traverseVisible(callback: (object: IObject3D) => void): void;
    traverseAncestors(callback: (object: IObject3D) => void): void;
    getObjectById<T extends IObject3D = IObject3D>(id: number): T | undefined;
    getObjectByName<T extends IObject3D = IObject3D>(name: string): T | undefined;
    getObjectByProperty<T extends IObject3D = IObject3D>(name: string, value: string): T | undefined;
    copy(source: this, recursive?: boolean): this;
    clone(recursive?: boolean): this;
    add(...object: IObject3D[]): this;
    remove(...object: IObject3D[]): this;
    parent: IObject3D | null;
    children: IObject3D[];
}
//# sourceMappingURL=IScene.d.ts.map