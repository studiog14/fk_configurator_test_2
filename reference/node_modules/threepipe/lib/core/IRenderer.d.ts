import { PartialRecord } from 'ts-browser-helpers';
import { Blending, Clock, ShaderMaterial, Texture, Vector2, Vector4, WebGLRenderer, WebGLRenderTarget } from 'three';
import { CreateRenderTargetOptions, IRenderTarget, RenderTargetManager } from '../rendering';
import { IShaderPropertiesUpdater } from '../materials';
import { EffectComposer2, IPassID, IPipelinePass } from '../postprocessing';
import { IScene } from './IScene';
import { BlobExt } from '../assetmanager';
export type TThreeRendererMode = 'shadowMapRender' | 'backgroundRender' | 'sceneRender' | 'opaqueRender' | 'transparentRender' | 'transmissionRender' | 'mainRenderPass' | 'screenSpaceRendering';
export type TThreeRendererModeUserData = PartialRecord<TThreeRendererMode, boolean>;
export interface IAnimationLoopEvent {
    renderer: IWebGLRenderer;
    deltaTime: number;
    time: number;
    xrFrame?: XRFrame;
}
export interface IRenderManagerUpdateEvent {
    change?: 'registerPass' | 'unregisterPass' | 'useLegacyLights' | 'passRefresh' | 'size' | 'rebuild' | string;
    data?: any;
    pass?: IPipelinePass;
}
export interface IRenderManagerEventMap {
    animationLoop: IAnimationLoopEvent;
    update: IRenderManagerUpdateEvent;
    resize: object;
    contextRestored: object;
    contextLost: {
        event: WebGLContextEvent;
    };
    preRender: {
        scene: IScene;
        renderToScreen: boolean;
    };
    postRender: {
        scene: IScene;
        renderToScreen: boolean;
    };
}
export interface RendererBlitOptions {
    source?: Texture;
    viewport?: Vector4;
    material?: ShaderMaterial;
    clear?: boolean;
    respectColorSpace?: boolean;
    blending?: Blending;
    transparent?: boolean;
}
export interface IRenderManager<TE extends IRenderManagerEventMap = IRenderManagerEventMap> extends RenderTargetManager<TE>, IShaderPropertiesUpdater {
    readonly renderer: IWebGLRenderer;
    readonly needsRender: boolean;
    rebuildPipeline(setDirty?: boolean): void;
    setSize(width: number, height: number): void;
    render(scene: IScene): void;
    reset(): void;
    resetShadows(): void;
    refreshPasses(): void;
    registerPass(pass: IPipelinePass, replaceId?: boolean): void;
    unregisterPass(pass: IPipelinePass): void;
    readonly frameCount: number;
    readonly totalFrameCount: number;
    pipeline: IPassID[];
    composer: EffectComposer2;
    readonly passes: IPipelinePass[];
    readonly isWebGL2: boolean;
    readonly composerTarget: IRenderTarget;
    readonly renderSize: Vector2;
    renderScale: number;
    readonly context: WebGLRenderingContext;
    useLegacyLights: boolean;
    webglRenderer: WebGLRenderer;
    clock: Clock;
    blit(destination: IRenderTarget | undefined | null, options?: RendererBlitOptions): void;
    clearColor({ r, g, b, a, target, depth, stencil, viewport }: {
        r?: number;
        g?: number;
        b?: number;
        a?: number;
        target?: IRenderTarget;
        depth?: boolean;
        stencil?: boolean;
        viewport?: Vector4;
    }): void;
    renderTargetToDataUrl(target: WebGLRenderTarget, mimeType?: string, quality?: number): string;
    renderTargetToBuffer(target: WebGLRenderTarget): Uint8Array | Uint16Array | Float32Array;
    exportRenderTarget(target: WebGLRenderTarget, mimeType?: 'auto' | string): BlobExt;
}
export interface IRenderManagerOptions {
    canvas: HTMLCanvasElement;
    alpha?: boolean;
    targetOptions?: CreateRenderTargetOptions;
    rgbm?: boolean;
    msaa?: boolean | number;
    depthBuffer?: boolean;
    renderScale?: number;
}
export interface IWebGLRenderer<TManager extends IRenderManager = IRenderManager> extends WebGLRenderer {
    renderManager: TManager;
    userData: TThreeRendererModeUserData & {
        __isIWebGLRenderer: true;
        [key: string]: any;
    };
    renderWithModes(ud: TThreeRendererModeUserData, render: () => void): void;
    /**
     * @deprecated use {@link renderManager} instead
     */
    baseRenderer?: IRenderManager;
}
export declare function upgradeWebGLRenderer<TManager extends IRenderManager = IRenderManager>(this: IWebGLRenderer<TManager>, manager: TManager): IWebGLRenderer<TManager>;
declare function renderWithModes(this: IWebGLRenderer, ud: TThreeRendererModeUserData, render: () => void): void;
/**
 * @deprecated renamed to {@link renderWithModes}, use {@link IWebGLRenderer.renderWithModes}
 */
export declare const setThreeRendererMode: typeof renderWithModes;
export {};
//# sourceMappingURL=IRenderer.d.ts.map