import { BaseEvent, BufferGeometry, Camera, IUniform, Material, Object3D, Scene, Shader, ShaderMaterial, ShaderMaterialParameters, WebGLRenderer } from 'three';
import { IMaterial, IMaterialEventMap, IMaterialParameters, IMaterialUserData } from '../IMaterial';
import { MaterialExtension } from '../../materials';
export declare class ShaderMaterial2<TE extends IMaterialEventMap = IMaterialEventMap> extends ShaderMaterial<TE> implements IMaterial<TE> {
    ['constructor']: typeof ShaderMaterial2;
    static readonly TypeSlug = "shaderMat";
    static readonly TYPE = "ShaderMaterial2";
    static readonly MaterialProperties: {
        fragmentShader: string;
        vertexShader: string;
        uniforms: {};
        defines: {};
        extensions: {};
        isRawShaderMaterial: boolean;
        uniformsGroups: {};
        wireframe: boolean;
        wireframeLinewidth: number;
        clipping: boolean;
        lights: boolean;
        fog: boolean;
        glslVersion: null;
        defaultAttributeValues: {};
        name: string;
        blending: 1;
        side: 0;
        vertexColors: boolean;
        opacity: number;
        transparent: boolean;
        blendSrc: 204;
        blendDst: 205;
        blendEquation: 100;
        blendSrcAlpha: null;
        blendDstAlpha: null;
        blendEquationAlpha: null;
        blendColor: string;
        blendAlpha: number;
        depthFunc: 3;
        depthTest: boolean;
        depthWrite: boolean;
        stencilWriteMask: number;
        stencilFunc: 519;
        stencilRef: number;
        stencilFuncMask: number;
        stencilFail: 7680;
        stencilZFail: 7680;
        stencilZPass: 7680;
        stencilWrite: boolean;
        clippingPlanes: null;
        clipIntersection: boolean;
        clipShadows: boolean;
        shadowSide: null;
        colorWrite: boolean;
        precision: null;
        polygonOffset: boolean;
        polygonOffsetFactor: number;
        polygonOffsetUnits: number;
        dithering: boolean;
        alphaToCoverage: boolean;
        premultipliedAlpha: boolean;
        forceSinglePass: boolean;
        visible: boolean;
        toneMapped: boolean;
        userData: {};
        alphaTest: number;
        alphaHash: boolean;
    };
    assetType: "material";
    userData: IMaterialUserData;
    readonly isAShaderMaterial = true;
    readonly appliedMeshes: Set<any>;
    readonly setDirty: (this: IMaterial, options?: import("../IMaterial").IMaterialSetDirtyOptions) => void;
    dispose(): this;
    clone(track?: boolean): this;
    dispatchEvent<T extends Extract<keyof (TE & IMaterialEventMap), string>>(event: BaseEvent<T> & (TE & IMaterialEventMap)[T]): void;
    readonly isRawShaderMaterial: boolean;
    type: 'ShaderMaterial' | 'RawShaderMaterial';
    constructor({ customMaterialExtensions, ...parameters }?: ShaderMaterialParameters & IMaterialParameters, isRawShaderMaterial?: boolean);
    materialExtensions: MaterialExtension[];
    extraUniformsToUpload: Record<string, IUniform>;
    registerMaterialExtensions: (this: IMaterial, customMaterialExtensions: MaterialExtension[]) => void;
    unregisterMaterialExtensions: (this: IMaterial, customMaterialExtensions: MaterialExtension[]) => void;
    customProgramCacheKey(): string;
    onBeforeCompile(shader: Shader, renderer: WebGLRenderer): void;
    onBeforeRender(renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, object: Object3D): void;
    onAfterRender(renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, object: Object3D): void;
    /**
     * Sets the values of this material based on the values of the passed material or an object with material properties
     * The input is expected to be a valid material or a deserialized material parameters object(including the deserialized userdata)
     * @param parameters - material or material parameters object
     */
    setValues(parameters: Material | (ShaderMaterialParameters)): this;
    toJSON(_?: any): any;
    fromJSON(_: any, _2?: any): this | null;
    /**
     * @deprecated use this directly
     */
    get materialObject(): this;
}
//# sourceMappingURL=ShaderMaterial2.d.ts.map