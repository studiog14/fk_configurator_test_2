import { BaseEvent, IUniform, Material, Shader, ShaderMaterial, ShaderMaterialParameters, WebGLRenderer } from 'three';
import { UiObjectConfig } from 'uiconfig.js';
import { IMaterial, IMaterialEventMap, IMaterialGenerator, IMaterialParameters, IMaterialTemplate, IMaterialUserData } from '../IMaterial';
import { MaterialExtension } from '../../materials';
import { SerializationMetaType } from '../../utils';
import { IObject3D } from '../IObject';
/**
 * And extension of three.js ShaderMaterial that can be assigned to objects, and support threepipe features, uiconfig, and serialization.
 *
 * @category Materials
 */
export declare class ObjectShaderMaterial<TE extends IMaterialEventMap = IMaterialEventMap> extends ShaderMaterial<TE> implements IMaterial<TE> {
    ['constructor']: typeof ObjectShaderMaterial;
    static readonly TypeSlug = "shmat";
    static readonly TYPE = "ObjectShaderMaterial";
    assetType: "material";
    userData: IMaterialUserData;
    readonly isObjectShaderMaterial = true;
    readonly appliedMeshes: Set<IObject3D>;
    readonly setDirty: (this: IMaterial, options?: import("../IMaterial").IMaterialSetDirtyOptions) => void;
    dispose(): this;
    clone(track?: boolean): this;
    dispatchEvent<T extends Extract<keyof (TE & IMaterialEventMap), string>>(event: BaseEvent<T> & (TE & IMaterialEventMap)[T]): void;
    generator?: IMaterialGenerator;
    constructor({ customMaterialExtensions, ...parameters }?: ShaderMaterialParameters & IMaterialParameters);
    materialExtensions: MaterialExtension[];
    extraUniformsToUpload: Record<string, IUniform>;
    registerMaterialExtensions: (this: IMaterial, customMaterialExtensions: MaterialExtension[]) => void;
    unregisterMaterialExtensions: (this: IMaterial, customMaterialExtensions: MaterialExtension[]) => void;
    customProgramCacheKey(): string;
    onBeforeCompile(shader: Shader, renderer: WebGLRenderer): void;
    onBeforeRender: (renderer: WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, object: import("three").Object3D) => void;
    onAfterRender: (renderer: WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, object: import("three").Object3D) => void;
    /**
     * Sets the values of this material based on the values of the passed material or an object with material properties
     * The input is expected to be a valid material or a deserialized material parameters object(including the deserialized userdata)
     * @param parameters - material or material parameters object
     * @param allowInvalidType - if true, the type of the oldMaterial is not checked. Objects without type are always allowed.
     * @param clearCurrentUserData - if undefined, then depends on material.isMaterial. if true, the current userdata is cleared before setting the new values, because it can have data which wont be overwritten if not present in the new material.
     */
    setValues(parameters: Material | (ShaderMaterialParameters & {
        type?: string;
    }), allowInvalidType?: boolean, clearCurrentUserData?: boolean | undefined): this;
    copy(source: Material | any): this;
    /**
     * Serializes this material to JSON.
     * @param meta - metadata for serialization
     * @param _internal - Calls only super.toJSON, does internal three.js serialization and `@serialize` tags. Set it to true only if you know what you are doing. This is used in Serialization->serializer->material
     */
    toJSON(meta?: SerializationMetaType, _internal?: boolean): any;
    /**
     * Deserializes the material from JSON.
     * Textures should be loaded and in meta.textures before calling this method.
     * todo - needs to be tested
     * @param data
     * @param meta
     * @param _internal
     */
    fromJSON(data: any, meta?: SerializationMetaType, _internal?: boolean): this | null;
    uiConfig: UiObjectConfig;
    static readonly MaterialProperties: {
        defines: {};
        uniforms: {};
        uniformsGroups: never[];
        vertexShader: string;
        fragmentShader: string;
        linewidth: number;
        wireframe: boolean;
        wireframeLinewidth: number;
        fog: boolean;
        lights: boolean;
        clipping: boolean;
        forceSinglePass: boolean;
        extensions: {
            derivatives: boolean;
            fragDepth: boolean;
            drawBuffers: boolean;
            shaderTextureLOD: boolean;
        };
        defaultAttributeValues: {
            color: number[];
            uv: number[];
            uv1: number[];
        };
        index0AttributeName: undefined;
        uniformsNeedUpdate: boolean;
        glslVersion: null;
        flatShading: boolean;
        name: string;
        blending: 1;
        side: 0;
        vertexColors: boolean;
        opacity: number;
        transparent: boolean;
        blendSrc: 204;
        blendDst: 205;
        blendEquation: 100;
        blendSrcAlpha: null;
        blendDstAlpha: null;
        blendEquationAlpha: null;
        blendColor: string;
        blendAlpha: number;
        depthFunc: 3;
        depthTest: boolean;
        depthWrite: boolean;
        stencilWriteMask: number;
        stencilFunc: 519;
        stencilRef: number;
        stencilFuncMask: number;
        stencilFail: 7680;
        stencilZFail: 7680;
        stencilZPass: 7680;
        stencilWrite: boolean;
        clippingPlanes: null;
        clipIntersection: boolean;
        clipShadows: boolean;
        shadowSide: null;
        colorWrite: boolean;
        precision: null;
        polygonOffset: boolean;
        polygonOffsetFactor: number;
        polygonOffsetUnits: number;
        dithering: boolean;
        alphaToCoverage: boolean;
        premultipliedAlpha: boolean;
        visible: boolean;
        toneMapped: boolean;
        userData: {};
        alphaTest: number;
        alphaHash: boolean;
    };
    static MaterialTemplate: IMaterialTemplate<ObjectShaderMaterial, Partial<typeof ObjectShaderMaterial.MaterialProperties>>;
}
//# sourceMappingURL=ObjectShaderMaterial.d.ts.map