import { IUniform, ShadowMapType, Texture, Vector2, Vector4, WebGLMultipleRenderTargets, WebGLRenderer, WebGLRenderTarget, WebGLRenderTargetOptions, WebGLShadowMap } from 'three';
import { EffectComposer2, IPassID, IPipelinePass } from '../postprocessing';
import { IRenderTarget } from './RenderTarget';
import { RenderTargetManager } from './RenderTargetManager';
import { IShaderPropertiesUpdater } from '../materials';
import { IRenderManager, type IRenderManagerOptions, IScene, IWebGLRenderer } from '../core';
import { Class } from 'ts-browser-helpers';
import { BlobExt } from '../assetmanager';
import { IRenderManagerEventMap, RendererBlitOptions } from '../core/IRenderer';
export declare class RenderManager<TE extends IRenderManagerEventMap = IRenderManagerEventMap> extends RenderTargetManager<IRenderManagerEventMap & TE> implements IShaderPropertiesUpdater, IRenderManager<IRenderManagerEventMap & TE> {
    private readonly _isWebGL2;
    private readonly _composer;
    private readonly _context;
    private readonly _renderSize;
    protected readonly _renderer: IWebGLRenderer<this>;
    private _renderScale;
    get renderScale(): number;
    set renderScale(value: number);
    shadowMapType: ShadowMapType;
    shadowMap: WebGLShadowMap;
    private _shadowMapTypeChanged;
    private _passes;
    private _pipeline;
    private _passesNeedsUpdate;
    private _frameCount;
    private _lastTime;
    private _totalFrameCount;
    static readonly POWER_PREFERENCE: 'high-performance' | 'low-power' | 'default';
    get renderer(): IWebGLRenderer<this>;
    /**
     * Use total frame count, if this is set to true, then frameCount won't be reset when the viewer is set to dirty.
     * Which will generate different random numbers for each frame during postprocessing steps. With TAA set properly, this will give a smoother result.
     */
    stableNoise: boolean;
    frameWaitTime: number;
    protected _dirty: boolean;
    /**
     * Set autoBuildPipeline = false to be able to set the pipeline manually.
     */
    autoBuildPipeline: boolean;
    rebuildPipeline(setDirty?: boolean): void;
    /**
     * Regenerates the render pipeline by resolving dependencies and sorting the passes.
     * This is called automatically when the passes are changed.
     */
    private _refreshPipeline;
    private _animationLoop;
    constructor({ canvas, alpha, renderScale, targetOptions }: IRenderManagerOptions);
    protected _initWebGLRenderer(canvas: HTMLCanvasElement, alpha: boolean): IWebGLRenderer<this>;
    setSize(width?: number, height?: number, force?: boolean): void;
    /**
     * Default value for renderToScreen in {@link render}
     */
    defaultRenderToScreen: boolean;
    render(scene: IScene, renderToScreen?: boolean): void;
    incRenderToScreen(): void;
    onPostFrame: () => void;
    get needsRender(): boolean;
    setDirty(reset?: boolean): void;
    reset(): void;
    resetShadows(): void;
    refreshPasses(): void;
    dispose(clear?: boolean): void;
    updateShaderProperties(material: {
        defines: Record<string, string | number | undefined>;
        uniforms: {
            [name: string]: IUniform;
        };
    }): this;
    registerPass(pass: IPipelinePass, replaceId?: boolean): void;
    unregisterPass(pass: IPipelinePass): void;
    get frameCount(): number;
    get totalFrameCount(): number;
    resetTotalFrameCount(): void;
    set pipeline(value: IPassID[]);
    get pipeline(): IPassID[];
    get composer(): EffectComposer2;
    get passes(): IPipelinePass[];
    get isWebGL2(): boolean;
    get composerTarget(): IRenderTarget;
    get composerTarget2(): IRenderTarget;
    /**
     * The size set in the three.js renderer.
     * Final size is renderSize * renderScale
     */
    get renderSize(): Vector2;
    get context(): WebGLRenderingContext;
    /**
     * Same as {@link renderer}
     */
    get webglRenderer(): WebGLRenderer;
    /**
     * @deprecated will be removed in the future
     */
    get useLegacyLights(): boolean;
    set useLegacyLights(v: boolean);
    get clock(): import("three").Clock;
    /**
     * blit - blits a texture to the screen or another render target.
     * @param destination - destination target, or screen if undefined or null
     * @param source - source Texture
     * @param viewport - viewport and scissor
     * @param material - override material
     * @param clear - clear before blit
     * @param respectColorSpace - does color space conversion when reading and writing to the target
     * @param blending - Note - Set to NormalBlending if transparent is set to false
     * @param transparent
     */
    blit(destination: IRenderTarget | undefined | null, { source, viewport, material, clear, respectColorSpace, blending, transparent }?: RendererBlitOptions): void;
    clearColor({ r, g, b, a, target, depth, stencil, viewport }: {
        r?: number;
        g?: number;
        b?: number;
        a?: number;
        target?: IRenderTarget;
        depth?: boolean;
        stencil?: boolean;
        viewport?: Vector4;
    }): void;
    /**
     * Converts a render target to a png/jpeg data url string.
     * Note: this will clamp the values to [0, 1] and converts to srgb for float and half-float render targets.
     * @param target
     * @param mimeType
     * @param quality
     * @param textureIndex - index of the texture to use in the render target (only in case of multiple render target)
     */
    renderTargetToDataUrl(target: WebGLMultipleRenderTargets | WebGLRenderTarget | IRenderTarget, mimeType?: string, quality?: number, textureIndex?: number): string;
    /**
     * Rend pixels from a render target into a new Uint8Array|Uint16Array|Float32Array buffer
     * @param target - render target to read from
     * @param textureIndex - index of the texture to use in the render target (only in case of multiple render target)
     */
    renderTargetToBuffer(target: WebGLMultipleRenderTargets | WebGLRenderTarget, textureIndex?: number): Uint8Array | Uint16Array | Float32Array;
    /**
     * Exports a render target to a blob. The type is automatically picked from exr to png based on the render target.
     * @param target - render target to export
     * @param mimeType - mime type to use.
     * If auto (default), then it will be picked based on the render target type.
     * @param textureIndex - index of the texture to use in the render target (only in case of multiple render target)
     */
    exportRenderTarget(target: WebGLRenderTarget<Texture | Texture[]>, mimeType?: string, textureIndex?: number): BlobExt;
    private _updated;
    protected _createTargetClass(clazz: Class<WebGLRenderTarget>, size: number[], options: WebGLRenderTargetOptions): IRenderTarget;
    /**
     * @deprecated use renderScale instead
     */
    get displayCanvasScaling(): number;
    /**
     * @deprecated use renderScale instead
     */
    set displayCanvasScaling(value: number);
}
//# sourceMappingURL=RenderManager.d.ts.map