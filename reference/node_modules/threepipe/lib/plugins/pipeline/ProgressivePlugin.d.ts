import { IUniform, Texture, TextureDataType, WebGLRenderTarget } from 'three';
import { IPassID, IPipelinePass } from '../../postprocessing';
import { ISerializedConfig, ThreeViewer } from '../../viewer';
import { PipelinePassPlugin } from '../base/PipelinePassPlugin';
import { ICamera, IRenderManager, IScene, IWebGLRenderer } from '../../core';
import { AddBlendTexturePass } from '../../postprocessing/AddBlendTexturePass';
import { ValOrFunc } from 'ts-browser-helpers';
import { IShaderPropertiesUpdater } from '../../materials';
import { SerializationMetaType } from '../../utils';
export type ProgressivePluginTarget = WebGLRenderTarget;
/**
 * Progressive Plugin
 *
 * Adds a post-render pass to blend the last frame with the current frame.
 * This can be used to create a progressive rendering effect which is useful for progressive shadows, gi, denoising, baking, anti-aliasing, and many other effects.
 * @category Plugins
 */
export declare class ProgressivePlugin extends PipelinePassPlugin<ProgressiveBlendPass, 'progressive'> implements IShaderPropertiesUpdater {
    readonly passId = "progressive";
    static readonly PluginType = "ProgressivePlugin";
    static readonly OldPluginType = "Progressive";
    /**
     * Different targets for different render cameras.
     * Need to save them all here since we need them in the next frame.
     * @protected
     */
    protected _targets: Map<string, ProgressivePluginTarget>;
    maxFrameCount: number;
    get texture(): Texture | undefined;
    get target(): ProgressivePluginTarget | undefined;
    getTarget(camera?: ICamera): ProgressivePluginTarget | undefined;
    get textures(): Texture<import("three").TextureEventMap>[];
    get mainTexture(): Texture<import("three").TextureEventMap> | undefined;
    /**
     * Note - this is not used right now
     */
    readonly bufferType: TextureDataType;
    constructor(maxFrameCount?: number, bufferType?: TextureDataType, // this is not used. todo use halffloat when rgbm = false
    enabled?: boolean);
    protected _createTarget(camera?: ICamera, recreate?: boolean): WebGLRenderTarget<Texture<import("three").TextureEventMap>> | undefined;
    protected _disposeTarget(camera?: ICamera): void;
    protected _createPass(): ProgressiveBlendPass;
    onAdded(viewer: ThreeViewer): void;
    onRemove(viewer: ThreeViewer): void;
    /**
     *
     * @param postRender - if called after rendering frame.
     */
    isConverged(postRender?: boolean): boolean;
    updateShaderProperties(material: {
        defines: Record<string, string | number | undefined>;
        uniforms: {
            [p: string]: IUniform;
        };
    }): this;
    /**
     * Get recording delta post render, For use with animations to sync with converge mode in canvas recorder. See PopmotionPlugin for usage.
     * @returns {number} - delta time in milliseconds, or 0 when converging, or -1 in case of not recording in converge mode
     */
    postFrameConvergedRecordingDelta(_?: string): number;
    get convergedPromise(): Promise<void>;
    fromJSON(data: ISerializedConfig & {
        pass?: any;
    }, meta?: SerializationMetaType): this | null | Promise<this | null>;
}
export declare class ProgressiveBlendPass extends AddBlendTexturePass implements IPipelinePass {
    readonly passId: IPassID;
    target?: ValOrFunc<WebGLRenderTarget | undefined>;
    before: string[];
    after: string[];
    required: string[];
    dirty: ValOrFunc<boolean>;
    constructor(passId: IPassID, target?: ValOrFunc<WebGLRenderTarget | undefined>, maxIntensity?: number);
    render(renderer: IWebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, deltaTime: number, maskActive: boolean): void;
    beforeRender(_: IScene, _1: ICamera, renderManager: IRenderManager): void;
}
//# sourceMappingURL=ProgressivePlugin.d.ts.map