import { AViewerPluginSync } from '../../viewer/AViewerPlugin';
import { shaderReplaceString } from '../../utils';
import { GBufferPlugin } from '../pipeline/GBufferPlugin';
/**
 * Base Screen Pass Extension Plugin
 *
 * Extend the class to add an extension to {@link ScreenPass} material.
 * See {@link TonemapPlugin} and {@link VignettePlugin} for examples.
 *
 *
 * @category Plugins
 */
export class AScreenPassExtensionPlugin extends AViewerPluginSync {
    set uniformsNeedUpdate(v) {
        if (v)
            this.setDirty();
    }
    constructor(shaderPatch = '') {
        super();
        /**
         * The priority of the material extension when applied to the material in ScreenPass
         * set to very low priority, so applied at the end
         */
        this.priority = -100;
        this._shaderPatch = '';
        this.computeCacheKey = (_) => this.isDisabled() ? '0' : '1';
        this._shaderPatch = shaderPatch;
        this.setDirty = this.setDirty.bind(this);
    }
    shaderExtender(shader, _, _1) {
        if (this.isDisabled())
            return;
        shader.fragmentShader = shaderReplaceString(shader.fragmentShader, '#glMarker', '\n' + this._shaderPatch + '\n', { prepend: true });
    }
    getUiConfig() {
        return this.uiConfig;
    }
    isCompatible(_) {
        return true; // (material as MeshStandardMaterial2).isMeshStandardMaterial2
    }
    setDirty() {
        this.__setDirty?.(); // this will update version which will set needsUpdate on material
        this._viewer?.renderManager.screenPass.setDirty();
    }
    fromJSON(data, meta) {
        // really old legacy
        if (data.pass) {
            data = { ...data };
            data.extension = { ...data.pass };
            delete data.extension.enabled;
            delete data.pass;
        }
        // legacy
        if (data.extension) {
            data = { ...data, ...data.extension };
            delete data.extension;
        }
        return super.fromJSON(data, meta);
    }
    onAdded(viewer) {
        super.onAdded(viewer);
        viewer.forPlugin(GBufferPlugin, (gbuffer) => {
            gbuffer.registerGBufferUpdater(this.constructor.PluginType, this.updateGBufferFlags.bind(this));
        }, (gbuffer) => {
            gbuffer.unregisterGBufferUpdater(this.constructor.PluginType);
        });
        viewer.renderManager.screenPass.material.registerMaterialExtensions([this]);
    }
    onRemove(viewer) {
        viewer.getPlugin(GBufferPlugin)?.unregisterGBufferUpdater(this.constructor.PluginType);
        viewer.renderManager.screenPass.material.unregisterMaterialExtensions([this]);
        super.onRemove(viewer);
    }
    updateGBufferFlags(_, _1) {
        return;
    }
}
//# sourceMappingURL=AScreenPassExtensionPlugin.js.map