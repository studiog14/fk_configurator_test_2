var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { RenderManager } from '../rendering';
import { HalfFloatType, LinearFilter, NoColorSpace, RGBM16ColorSpace, UnsignedByteType } from 'three';
import { ExtendedRenderPass, ScreenPass } from '../postprocessing';
import { uiFolderContainer } from 'uiconfig.js';
import { onChange3 } from 'ts-browser-helpers';
let ViewerRenderManager = class ViewerRenderManager extends RenderManager {
    constructor({ rgbm = true, msaa = false, depthBuffer = false, ...options }) {
        super({
            ...options,
            targetOptions: {
                samples: 0,
                // samples: msaa ? typeof msaa !== 'number' ? ViewerRenderManager.DEFAULT_MSAA_SAMPLES : msaa : 0,
                colorSpace: rgbm ? RGBM16ColorSpace : NoColorSpace,
                type: rgbm ? UnsignedByteType : HalfFloatType,
                depthBuffer: depthBuffer,
                generateMipmaps: /* msaa ? true : */ false, // todo: hack for now, fix blurTransmissionTarget in ExtendedRenderPass
                minFilter: /* msaa ? LinearMipMapLinearFilter : */ LinearFilter, // todo: hack for now, fix blurTransmissionTarget in ExtendedRenderPass
            },
        });
        this.rgbm = rgbm;
        this.msaa = msaa && this.isWebGL2;
        this.depthBuffer = depthBuffer;
        this.zPrepass = options.zPrepass || false;
        this.maxHDRIntensity = options.maxHDRIntensity ?? (rgbm ? 16 : 72);
        let doTransmissionFix = true; // const for debugging, todo could be made into a static prop maybe?
        if (!this._renderer.userData) {
            doTransmissionFix = false;
            this._renderer.userData = { __isIWebGLRenderer: true };
        }
        this._renderer.userData.renderTransmissionPass = !doTransmissionFix; // hack. used in WebGLRenderer.js
        this.renderPass = new ExtendedRenderPass(this);
        this.screenPass = new ScreenPass(options.screenShader || '');
        this.registerPass(this.renderPass);
        this.registerPass(this.screenPass);
    }
    _gbufferUnpackExtensionChanged(params) {
        this.dispatchEvent({ type: 'gbufferUnpackExtensionChanged', ...params });
    }
    render(scene, renderToScreen) {
        const cbf = this.screenPass.clipBackgroundForce;
        if (this.rgbm) {
            const val = !scene.background && !scene.backgroundColor;
            if (val !== cbf)
                this.screenPass.clipBackgroundForce = val;
        }
        super.render(scene, renderToScreen);
    }
};
ViewerRenderManager.DEFAULT_MSAA_SAMPLES = 4;
__decorate([
    onChange3(ViewerRenderManager.prototype._gbufferUnpackExtensionChanged)
], ViewerRenderManager.prototype, "gbufferUnpackExtension", void 0);
ViewerRenderManager = __decorate([
    uiFolderContainer('Render Manager')
], ViewerRenderManager);
export { ViewerRenderManager };
//# sourceMappingURL=ViewerRenderManager.js.map