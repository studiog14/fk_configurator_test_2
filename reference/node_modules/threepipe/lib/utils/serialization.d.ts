import { Serialization } from 'ts-browser-helpers';
import { ObjectLoader } from 'three';
import type { AssetImporter, AssetManager, MaterialManager } from '../assetmanager';
import { BlobExt, IAssetImporter, ImportResultExtras } from '../assetmanager';
import { ThreeViewer } from '../viewer';
import { ITexture } from '../core';
import { RenderManager } from '../rendering';
export declare class ThreeSerialization {
    /**
     * Serialize an object
     * {@link Serialization.Serialize}
     */
    static Serialize: typeof Serialization.Serialize;
    /**
     * Deserialize an object
     * {@link Serialization.Deserialize}
     */
    static Deserialize: typeof Serialization.Deserialize;
}
/**
 * Deep copy/clone from source to dest, assuming both are userData objects for three.js objects/materials/textures etc.
 * This will clone any property that can be cloned (apart from Object3D, Texture, Material) and deep copy the objects and arrays.
 * @note Keep synced with copyMaterialUserData in three.js -> Material.js todo: merge these functions? by putting this inside three.js?
 * @param dest
 * @param source
 * @param ignoredKeysInRoot - keys to ignore in the root object
 * @param isRoot - always true, used for recursion
 */
export declare function copyUserData(dest: any, source: any, ignoredKeysInRoot?: (string | symbol)[], isRoot?: boolean): any;
/**
 * Deep copy/clone from source to dest, assuming both are userData objects in Textures.
 * Same as {@link copyUserData} but ignores uuid in the root object.
 * @param dest
 * @param source
 * @param isRoot
 * @param ignoredKeysInRoot
 */
export declare function copyTextureUserData(dest: any, source: any, ignoredKeysInRoot?: string[], isRoot?: boolean): any;
/**
 * Deep copy/clone from source to dest, assuming both are userData objects in Materials.
 * Same as {@link copyUserData} but ignores uuid in the root object.
 * @note Keep synced with copyMaterialUserData in three.js -> Material.js
 * @param dest
 * @param source
 * @param isRoot
 * @param ignoredKeysInRoot
 */
export declare function copyMaterialUserData(dest: any, source: any, ignoredKeysInRoot?: string[], isRoot?: boolean): any;
/**
 * Deep copy/clone from source to dest, assuming both are userData objects in Object3D.
 * Same as {@link copyUserData} but ignores uuid in the root object.
 * @param dest
 * @param source
 * @param isRoot
 * @param ignoredKeysInRoot
 */
export declare function copyObject3DUserData(dest: any, source: any, ignoredKeysInRoot?: string[], isRoot?: boolean): any;
/**
 * Converts array buffers to base64 strings in meta.
 * This is useful when storing .json files, as storing as number arrays takes a lot of space.
 * Used in viewer.toJSON()
 * @param meta
 */
export declare function convertArrayBufferToStringsInMeta(meta: SerializationMetaType): void;
/**
 * Converts strings(base64 or utf-8) to array buffers in meta. This is the reverse of {@link convertArrayBufferToStringsInMeta}
 * Used in viewer.fromJSON()
 */
export declare function convertStringsToArrayBuffersInMeta(meta: SerializationMetaType): void;
export declare function getEmptyMeta(res?: Partial<SerializationResourcesType>): SerializationMetaType;
export interface SerializationResourcesType {
    geometries: Record<string, any>;
    materials: Record<string, any>;
    textures: Record<string, any>;
    images: Record<string, any>;
    shapes: Record<string, any>;
    skeletons: Record<string, any>;
    animations: Record<string, any>;
    extras: Record<string, any>;
    object?: any;
    [key: string]: any;
}
export interface SerializationMetaType extends SerializationResourcesType {
    _context: {
        assetImporter?: AssetImporter;
        objectLoader?: ObjectLoader;
        materialManager?: MaterialManager;
        assetManager?: AssetManager;
        renderManager?: RenderManager;
        imagePromises?: Promise<any>[];
        [key: string]: any;
    };
    __isLoadedResources?: boolean;
}
export declare class MetaImporter {
    /**
     * @param json
     * @param objLoader
     * @param extraResources - preloaded resources in the format of viewer config resources.
     */
    static ImportMeta(json: SerializationMetaType, extraResources?: Partial<SerializationResourcesType>): Promise<SerializationMetaType>;
    static LoadRootPathTextures({ textures, images }: Pick<SerializationMetaType, 'textures' | 'images'>, importer: IAssetImporter, usePreviewImages?: boolean): Promise<void>;
}
export declare function metaToResources(meta?: SerializationMetaType): Partial<SerializationResourcesType>;
export declare function metaFromResources(resources?: Partial<SerializationResourcesType>, viewer?: ThreeViewer): SerializationMetaType;
export declare function jsonToBlob(json: any): BlobExt;
/**
 * Used in {@link LUTCubeTextureWrapper} and {@link KTX2LoadPlugin} and imported in {@link ThreeViewer.loadConfigResources}
 * @param texture
 * @param meta
 * @param name
 * @param mime
 */
export declare function serializeTextureInExtras(texture: ITexture & ImportResultExtras, meta: any, name?: string, mime?: string): {
    uuid: string;
    url: any;
    userData: any;
    type: import("three").TextureDataType;
    name: string;
} | {
    uuid: string;
    resource: string;
};
//# sourceMappingURL=serialization.d.ts.map