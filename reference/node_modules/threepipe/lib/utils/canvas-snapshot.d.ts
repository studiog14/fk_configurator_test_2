export interface CanvasSnapshotRect {
    height: number;
    width: number;
    x: number;
    y: number;
    /**
     * Use if canvas.width !== canvas.clientWidth or height and rect is based on client rect
     * @default false
     */
    assumeClientRect?: boolean;
    /**
     * If true, assumes x, y, width, height are normalized to 0-1
     * @default false
     */
    normalized?: boolean;
}
export interface CanvasSnapshotOptions {
    getDataUrl?: boolean;
    mimeType?: string;
    quality?: number;
    /**
     * Crop Region to take snapshot. If not set, the whole canvas is used.
     */
    rect?: CanvasSnapshotRect;
    scale?: number;
    displayPixelRatio?: number;
    cloneCanvas?: boolean;
}
export declare class CanvasSnapshot {
    static Debug: boolean;
    static GetClonedCanvas(canvas: HTMLCanvasElement, { rect, displayPixelRatio, scale, }: CanvasSnapshotOptions): Promise<HTMLCanvasElement>;
    static GetDataUrl(canvas: HTMLCanvasElement, { mimeType, quality, ...options }: CanvasSnapshotOptions): Promise<string>;
    static GetImage(canvas: HTMLCanvasElement, options?: CanvasSnapshotOptions): Promise<HTMLImageElement>;
    static GetBlob(canvas: HTMLCanvasElement, options?: CanvasSnapshotOptions): Promise<Blob>;
    static GetFile(canvas: HTMLCanvasElement, filename?: string, options?: CanvasSnapshotOptions): Promise<File | string>;
    static GetTiledFiles(canvas: HTMLCanvasElement, filePrefix?: string, tileRows?: number, tileCols?: number, options?: CanvasSnapshotOptions): Promise<(File | string)[]>;
}
//# sourceMappingURL=canvas-snapshot.d.ts.map