/**
 * Bump Map Extension
 *
 * bumpTexture and bumpScale are added to the material
 *
 * Specification: https://webgi.xyz/docs/gltf-extensions/WEBGI_materials_bumpmap.html
 */
export class GLTFMaterialsBumpMapExtension {
}
GLTFMaterialsBumpMapExtension.WebGiMaterialsBumpMapExtension = 'WEBGI_materials_bumpmap';
GLTFMaterialsBumpMapExtension.Import = (parser) => new GLTFMaterialsBumpMapExtensionImport(parser);
GLTFMaterialsBumpMapExtension.Export = (writer) => new GLTFMaterialsBumpMapExtensionExport(writer);
// see GLTFDracoExportPlugin
GLTFMaterialsBumpMapExtension.Textures = {
    bumpTexture: 'R',
};
class GLTFMaterialsBumpMapExtensionImport {
    constructor(parser) {
        this.parser = parser;
        this.name = GLTFMaterialsBumpMapExtension.WebGiMaterialsBumpMapExtension;
    }
    // getMaterialType(materialIndex: number) { // todo: required?
    //
    //     const parser = this.parser
    //     const materialDef = parser.json.materials[ materialIndex ]
    //
    //     if (!materialDef.extensions || !materialDef.extensions[ this.name ]) return null
    //
    //     return MeshPhysicalMaterial
    //
    // }
    async extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const pending = [];
        const extension = materialDef.extensions[this.name];
        if (extension.bumpScale !== undefined) {
            materialParams.bumpScale = extension.bumpScale;
        }
        if (extension.bumpTexture !== undefined) {
            pending.push(parser.assignTexture(materialParams, 'bumpMap', extension.bumpTexture));
        }
        return Promise.all(pending);
    }
}
class GLTFMaterialsBumpMapExtensionExport {
    constructor(writer) {
        this.writer = writer;
        this.name = GLTFMaterialsBumpMapExtension.WebGiMaterialsBumpMapExtension;
    }
    writeMaterial(material, materialDef) {
        if (!material.isMeshStandardMaterial || material.bumpScale === 0)
            return;
        const writer = this.writer;
        const extensionsUsed = writer.extensionsUsed;
        const extensionDef = {};
        extensionDef.bumpScale = material.bumpScale;
        if (material.bumpMap && writer.checkEmptyMap(material.bumpMap)) {
            const bumpMapDef = { index: writer.processTexture(material.bumpMap) };
            writer.applyTextureTransform(bumpMapDef, material.bumpMap);
            extensionDef.bumpTexture = bumpMapDef;
        }
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[this.name] = extensionDef;
        extensionsUsed[this.name] = true;
    }
}
//# sourceMappingURL=GLTFMaterialsBumpMapExtension.js.map