/**
 * Light Map Extension
 *
 * lightMapTexture and lightMapIntensity are added to the material
 *
 * Specification: https://webgi.xyz/docs/gltf-extensions/WEBGI_materials_lightmap.html
 */
export class GLTFMaterialsLightMapExtension {
}
GLTFMaterialsLightMapExtension.WebGiMaterialsLightMapExtension = 'WEBGI_materials_lightmap';
GLTFMaterialsLightMapExtension.Import = (parser) => new GLTFMaterialsLightMapExtensionImport(parser);
GLTFMaterialsLightMapExtension.Export = (writer) => new GLTFMaterialsLightMapExtensionExport(writer);
// see GLTFDracoExportPlugin
GLTFMaterialsLightMapExtension.Textures = {
    lightMapTexture: 'RGB',
};
class GLTFMaterialsLightMapExtensionImport {
    constructor(parser) {
        this.parser = parser;
        this.name = GLTFMaterialsLightMapExtension.WebGiMaterialsLightMapExtension;
    }
    // getMaterialType(materialIndex: number) { // todo: required?
    //
    //     const parser = this.parser
    //     const materialDef = parser.json.materials[ materialIndex ]
    //
    //     if (!materialDef.extensions || !materialDef.extensions[ this.name ]) return null
    //
    //     return MeshPhysicalMaterial
    //
    // }
    async extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const pending = [];
        const extension = materialDef.extensions[this.name];
        if (extension.lightMapIntensity !== undefined) {
            materialParams.lightMapIntensity = extension.lightMapIntensity;
        }
        if (extension.lightMapTexture !== undefined) {
            pending.push(parser.assignTexture(materialParams, 'lightMap', extension.lightMapTexture));
        }
        return Promise.all(pending);
    }
}
class GLTFMaterialsLightMapExtensionExport {
    constructor(writer) {
        this.writer = writer;
        this.name = GLTFMaterialsLightMapExtension.WebGiMaterialsLightMapExtension;
    }
    writeMaterial(material, materialDef) {
        if (!material.isMeshStandardMaterial || material.lightMapIntensity === 0)
            return;
        const writer = this.writer;
        const extensionsUsed = writer.extensionsUsed;
        const extensionDef = {};
        extensionDef.lightMapIntensity = material.lightMapIntensity;
        if (material.lightMap && writer.checkEmptyMap(material.lightMap)) {
            const lightMapDef = { index: writer.processTexture(material.lightMap) };
            writer.applyTextureTransform(lightMapDef, material.lightMap);
            extensionDef.lightMapTexture = lightMapDef;
        }
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[this.name] = extensionDef;
        extensionsUsed[this.name] = true;
    }
}
//# sourceMappingURL=GLTFMaterialsLightMapExtension.js.map