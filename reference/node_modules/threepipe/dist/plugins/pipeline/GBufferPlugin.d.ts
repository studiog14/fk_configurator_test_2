import { BufferGeometry, Camera, DepthTexture, FloatType, IUniform, NormalMapTypes, Object3D, Scene, ShaderMaterialParameters, Texture, TextureDataType, UnsignedIntType, UnsignedShortType, Vector4, WebGLMultipleRenderTargets, WebGLRenderer, WebGLRenderTarget } from 'three';
import { GBufferRenderPass } from '../../postprocessing';
import { ThreeViewer } from '../../viewer';
import { MaterialExtension } from '../../materials';
import { PipelinePassPlugin } from '../base/PipelinePassPlugin';
import { ICamera, IMaterial, IMaterialParameters, IRenderManager, IScene, ITexture, ShaderMaterial2 } from '../../core';
export type GBufferPluginTarget = WebGLMultipleRenderTargets | WebGLRenderTarget;
export type GBufferPluginPass = GBufferRenderPass<'gbuffer', GBufferPluginTarget | undefined>;
export interface GBufferUpdaterContext {
    material: IMaterial;
    renderer: WebGLRenderer;
    scene: Scene;
    camera: Camera;
    geometry: BufferGeometry;
    object: Object3D;
}
export interface GBufferUpdater {
    updateGBufferFlags: (data: Vector4, context: GBufferUpdaterContext) => void;
}
/**
 * G-Buffer Plugin
 *
 * Adds a pre-render pass to render the g-buffer(depth+normal+flags) to render target(s) that can be used as gbuffer and for postprocessing.
 * @category Plugins
 */
export declare class GBufferPlugin extends PipelinePassPlugin<GBufferPluginPass, 'gbuffer'> {
    renderFlagsBuffer: boolean;
    renderDepthTexture: boolean;
    depthTextureType: typeof UnsignedShortType | typeof UnsignedIntType | typeof FloatType;
    readonly passId = "gbuffer";
    static readonly PluginType = "GBuffer";
    target?: GBufferPluginTarget;
    textures: Texture[];
    get normalDepthTexture(): ITexture | undefined;
    get flagsTexture(): ITexture | undefined;
    get depthTexture(): (ITexture & DepthTexture) | undefined;
    material?: GBufferMaterial;
    readonly bufferType: TextureDataType;
    readonly isPrimaryGBuffer: boolean;
    unpackExtension: MaterialExtension;
    private _isPrimaryGBufferSet;
    protected _createTargetAndMaterial(recreateTarget?: boolean): void;
    protected _disposeTarget(): void;
    protected _createPass(): GBufferRenderPass<"gbuffer", GBufferPluginTarget | undefined>;
    protected _beforeRender(scene: IScene, camera: ICamera, renderManager: IRenderManager): boolean;
    constructor(bufferType?: TextureDataType, isPrimaryGBuffer?: boolean, enabled?: boolean, renderFlagsBuffer?: boolean, renderDepthTexture?: boolean, depthTextureType?: typeof UnsignedShortType | typeof UnsignedIntType | typeof FloatType);
    registerGBufferUpdater(key: string, updater: GBufferUpdater['updateGBufferFlags']): void;
    unregisterGBufferUpdater(key: string): void;
    onRemove(viewer: ThreeViewer): void;
    /**
     * @deprecated use {@link normalDepthTexture} instead
     */
    getDepthNormal(): Texture<import('three').TextureEventMap> | undefined;
    /**
     * @deprecated use {@link flagsTexture} instead
     */
    getFlagsTexture(): Texture<import('three').TextureEventMap> | undefined;
    /**
     * @deprecated use {@link target} instead
     */
    getTarget(): GBufferPluginTarget | undefined;
    /**
     * @deprecated use {@link unpackExtension} instead
     */
    getUnpackSnippet(): string;
    /**
     * @deprecated use {@link unpackExtension} instead, it adds the same uniforms and defines
     * @param material
     */
    updateShaderProperties(material: {
        defines: Record<string, string | number | undefined>;
        uniforms: {
            [p: string]: IUniform;
        };
        needsUpdate?: boolean;
    }): this;
}
/**
 * Renders DepthNormal to a texture and flags to another
 */
export declare class GBufferMaterial extends ShaderMaterial2 {
    constructor(multipleRT?: boolean, parameters?: ShaderMaterialParameters & IMaterialParameters);
    flagUpdaters: Map<string, GBufferUpdater['updateGBufferFlags']>;
    normalMapType: NormalMapTypes;
    flatShading: boolean;
    onBeforeRender(renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, object: Object3D): void;
    onAfterRender(renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, object: Object3D): void;
    reset(): void;
}
/**
 * @deprecated use GBufferMaterial instead
 */
export declare class DepthNormalMaterial extends GBufferMaterial {
    constructor(multipleRT: boolean, parameters?: ShaderMaterialParameters & IMaterialParameters);
}
//# sourceMappingURL=GBufferPlugin.d.ts.map