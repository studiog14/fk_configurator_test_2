import { Camera, IUniform, OrthographicCamera, Vector3 } from 'three';
import { UiObjectConfig } from 'uiconfig.js';
import { ICamera, ICameraEventMap, ICameraUserData, TCameraControlsMode, ICameraSetDirtyOptions } from '../ICamera';
import { ICameraControls, TControlsCtor } from './ICameraControls';
import { IObject3D } from '../IObject';
import { CameraView, ICameraView } from './CameraView';
export declare class OrthographicCamera2<TE extends ICameraEventMap = ICameraEventMap> extends OrthographicCamera<TE & ICameraEventMap> implements ICamera<TE & ICameraEventMap> {
    assetType: "camera";
    get controls(): ICameraControls | undefined;
    name: string;
    private _controls?;
    private _currentControlsMode;
    controlsMode: TCameraControlsMode;
    /**
     * It should be the canvas actually
     * @private
     */
    private _canvas?;
    get isMainCamera(): boolean;
    userData: ICameraUserData;
    zoom: number;
    left: number;
    right: number;
    top: number;
    bottom: number;
    private _frustumSize;
    /**
     * Frustum size of the camera. This is used to calculate bounds (left, right, top, bottom) based on aspect ratio.
     * Set to 0 (or negative) value to disable automatic, and to set the bounds manually.
     */
    get frustumSize(): number;
    set frustumSize(value: number);
    readonly position: Vector3;
    /**
     * The target position of the camera (where the camera looks at). Also syncs with the controls.target, so it's not required to set that separately.
     * Note: this is always in world-space
     * Note: {@link autoLookAtTarget} must be set to `true` to make the camera look at the target when no controls are enabled
     */
    readonly target: Vector3;
    /**
     * Automatically manage aspect ratio based on window/canvas size.
     * Defaults to `true` if {@link domElement}(canvas) is set.
     */
    autoAspect: boolean;
    /**
     * Aspect ratio to use when {@link frustumSize} is defined
     */
    aspect: number;
    /**
     * Near clipping plane.
     * This is managed by RootScene for active cameras
     * To change the minimum that's possible set {@link minNearPlane}
     * To use a fixed value set {@link autoNearFar} to false and set {@link minNearPlane}
     */
    near: number;
    /**
     * Far clipping plane.
     * This is managed by RootScene for active cameras
     * To change the maximum that's possible set {@link maxFarPlane}
     * To use a fixed value set {@link autoNearFar} to false and set {@link maxFarPlane}
     */
    far: number;
    /**
     * Automatically make the camera look at the {@link target} on {@link setDirty} call
     * Defaults to false. Note that this must be set to true to make the camera look at the target without any controls
     */
    autoLookAtTarget: boolean;
    /**
     * Automatically manage near and far clipping planes based on scene size.
     */
    autoNearFar: boolean;
    /**
     * Minimum near clipping plane allowed. (Distance from camera)
     * Used in RootScene when {@link autoNearFar} is true.
     * @default 0.2
     */
    minNearPlane: number;
    /**
     * Maximum far clipping plane allowed. (Distance from camera)
     * Used in RootScene when {@link autoNearFar} is true.
     */
    maxFarPlane: number;
    constructor(controlsMode?: TCameraControlsMode, domElement?: HTMLCanvasElement, autoAspect?: boolean, frustumSize?: number, left?: number, right?: number, top?: number, bottom?: number, near?: number, far?: number, aspect?: number);
    private _interactionsDisabledBy;
    /**
     * If interactions are enabled for this camera. It can be disabled by some code or plugin.
     * see also {@link setInteractions}
     * @deprecated use {@link canUserInteract} to check if the user can interact with this camera
     * @readonly
     */
    get interactionsEnabled(): boolean;
    setInteractions(enabled: boolean, by: string): void;
    get canUserInteract(): boolean;
    setDirty(options?: ICameraSetDirtyOptions): void;
    /**
     * when aspect ratio is set to auto it must be refreshed on resize, this is done by the viewer for the main camera.
     * @param setDirty
     */
    refreshAspect(setDirty?: boolean): void;
    protected _nearFarChanged(): void;
    refreshUi: (this: ICamera) => void;
    refreshTarget: (this: ICamera, distanceFromTarget?: number, setDirty?: boolean) => void;
    activateMain: (this: ICamera, options?: Omit<ICameraEventMap["activateMain"], "bubbleToParent">, _internal?: boolean, _refresh?: boolean, canvas?: HTMLCanvasElement) => void;
    deactivateMain: (this: ICamera, options?: Omit<ICameraEventMap["activateMain"], "bubbleToParent">, _internal?: boolean, _refresh?: boolean, clearCanvas?: boolean) => void;
    refreshFrustum(setDirty?: boolean): void;
    private _controlsCtors;
    setControlsCtor(key: string, ctor: TControlsCtor, replace?: boolean): void;
    removeControlsCtor(key: string): void;
    private _controlsChanged;
    private _initCameraControls;
    private _disposeCameraControls;
    refreshCameraControls(setDirty?: boolean): void;
    /**
     * Serializes this camera with controls to JSON.
     * @param meta - metadata for serialization
     * @param baseOnly - Calls only super.toJSON, does internal three.js serialization. Set it to true only if you know what you are doing.
     */
    toJSON(meta?: any, baseOnly?: boolean): any;
    fromJSON(data: any, meta?: any): this | null;
    getView<T extends ICameraView = CameraView>(worldSpace?: boolean, _view?: T): T;
    setView(view: ICameraView): void;
    setViewFromCamera(camera: Camera | ICamera, distanceFromTarget?: number, worldSpace?: boolean): void;
    setViewToMain(eventOptions: Omit<ICameraEventMap['setView'], 'camera' | 'bubbleToParent'>): void;
    private _positionWorld;
    /**
     * See also cameraHelpers.glsl
     * @param material
     */
    updateShaderProperties(material: {
        defines: Record<string, string | number | undefined>;
        uniforms: {
            [p: string]: IUniform;
        };
    }): this;
    dispose(): void;
    setCanvas(canvas: HTMLCanvasElement | undefined, refresh?: boolean): void;
    private _camUi;
    uiConfig: UiObjectConfig;
    visible: boolean;
    get isActiveCamera(): boolean;
    /**
     * @deprecated use `<T>camera.controls` instead
     */
    getControls<T extends ICameraControls>(): T | undefined;
    /**
     * @deprecated use `this` instead
     */
    get cameraObject(): this;
    /**
     * @deprecated use `this` instead
     */
    get modelObject(): this;
    /**
     * @deprecated - use setDirty directly
     * @param setDirty
     */
    targetUpdated(setDirty?: boolean): void;
    traverse: (callback: (object: IObject3D) => void) => void;
    traverseVisible: (callback: (object: IObject3D) => void) => void;
    traverseAncestors: (callback: (object: IObject3D) => void) => void;
    getObjectById: <T extends IObject3D = IObject3D>(id: number) => T | undefined;
    getObjectByName: <T extends IObject3D = IObject3D>(name: string) => T | undefined;
    getObjectByProperty: <T extends IObject3D = IObject3D>(name: string, value: string) => T | undefined;
    copy: (source: ICamera | Camera | IObject3D, recursive?: boolean, distanceFromTarget?: number, worldSpace?: boolean) => this;
    clone: (recursive?: boolean) => this;
    add: (...object: IObject3D[]) => this;
    remove: (...object: IObject3D[]) => this;
    parent: IObject3D | null;
    children: IObject3D[];
}
/**
 * Empty class with the constructor same as OrthographicCamera in three.js.
 * This can be used to remain compatible with three.js construct signature.
 */
export declare class OrthographicCamera0 extends OrthographicCamera2 {
    constructor(left?: number, right?: number, top?: number, bottom?: number, near?: number, far?: number);
}
//# sourceMappingURL=OrthographicCamera2.d.ts.map