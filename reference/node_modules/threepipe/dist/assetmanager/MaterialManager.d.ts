import { Event, EventDispatcher, EventListener2, Material, Texture } from 'three';
import { IMaterial, IMaterialParameters, IMaterialTemplate, ITexture } from '../core';
import { MaterialExtension } from '../materials';
import { IMaterialEventMap } from '../core/IMaterial';
/**
 * Material Manager
 * Utility class to manage materials.
 * Maintains a library of materials and material templates that can be used to manage or create new materials.
 * Used in {@link AssetManager} to manage materials.
 * @category Asset Manager
 */
export declare class MaterialManager<TEventMap extends object = object> extends EventDispatcher<TEventMap> {
    readonly templates: IMaterialTemplate[];
    private _materials;
    constructor();
    /**
     * @param info: uuid or template name or material type
     * @param params
     */
    findOrCreate(info: string, params?: IMaterialParameters | Material): IMaterial | undefined;
    /**
     * Create a material from the template name or material type
     * @param nameOrType
     * @param register
     * @param params
     */
    create<TM extends IMaterial>(nameOrType: string, params?: IMaterialParameters, register?: boolean): TM | undefined;
    protected _create<TM extends IMaterial>(template: IMaterialTemplate<TM>, oldMaterial?: IMaterialParameters | Partial<TM>): TM | undefined;
    findTemplate(nameOrType: string, withGenerator?: boolean): IMaterialTemplate | undefined;
    protected _getMapsForMaterial(material: IMaterial): Set<ITexture<import('three').TextureEventMap>>;
    protected _disposeMaterial: (e: {
        target?: IMaterial;
    }) => void;
    private _materialMaps;
    protected _materialUpdate: EventListener2<'materialUpdate', IMaterialEventMap, IMaterial>;
    protected _textureUpdate: (this: IMaterial, e: Event<"update", Texture>) => void;
    private _refreshTextureRefs;
    registerMaterial(material: IMaterial): void;
    registerMaterials(materials: IMaterial[]): void;
    /**
     * This is done automatically on material dispose.
     * @param material
     */
    unregisterMaterial(material: IMaterial): void;
    clearMaterials(): void;
    registerMaterialTemplate(template: IMaterialTemplate): void;
    unregisterMaterialTemplate(template: IMaterialTemplate): void;
    dispose(disposeRuntimeMaterials?: boolean): void;
    findMaterial(uuid: string): IMaterial | undefined;
    findMaterialsByName(name: string | RegExp, regex?: boolean): IMaterial[];
    getMaterialsOfType<TM extends IMaterial = IMaterial>(typeSlug: string | undefined): TM[];
    getAllMaterials(): IMaterial[];
    /**
     * Creates a new material if a compatible template is found or apply minimal upgrades and returns the original material.
     * Also checks from the registered materials, if one with the same uuid is found, it is returned instead with the new parameters.
     * Also caches the response.
     * Returns the same material if its already upgraded.
     * @param material - the material to upgrade/check
     * @param useSourceMaterial - if false, will not use the source material parameters in the new material. default = true
     * @param materialTemplate - any specific material template to use instead of detecting from the material type.
     * @param createFromTemplate - if false, will not create a new material from the template, but will apply minimal upgrades to the material instead. default = true
     */
    convertToIMaterial(material: Material & {
        assetType?: 'material';
        iMaterial?: IMaterial;
    }, { useSourceMaterial, materialTemplate, createFromTemplate }?: {
        useSourceMaterial?: boolean;
        materialTemplate?: string;
        createFromTemplate?: boolean;
    }): IMaterial | undefined;
    protected _materialExtensions: MaterialExtension[];
    registerMaterialExtension(extension: MaterialExtension): void;
    unregisterMaterialExtension(extension: MaterialExtension): void;
    clearExtensions(): void;
    exportMaterial(material: IMaterial, filename?: string, minify?: boolean, download?: boolean): File;
    applyMaterial(material: IMaterial, nameRegexOrUuid: string, regex?: boolean): boolean;
    /**
     * copyProps from material to c
     * @param c
     * @param material
     */
    copyMaterialProps(c: IMaterial, material: IMaterial): boolean;
}
//# sourceMappingURL=MaterialManager.d.ts.map