import { EventDispatcher, EventListener, LoadingManager } from 'three';
import { IAssetImporter, ImportAssetOptions, ImportFilesOptions, ImportResult, ProcessRawOptions } from './IAssetImporter';
import { IAsset, IFile } from './IAsset';
import { IImporter, ILoader } from './IImporter';
export interface IAssetImporterEventMap {
    loaderCreate: {
        type: 'loaderCreate';
        loader: ILoader;
    };
    importFile: {
        type: 'importFile';
        path: string;
        state: 'downloading' | 'done' | 'error' | 'adding';
        progress?: number;
        loadedBytes?: number;
        totalBytes?: number;
        error?: any;
    };
    importFiles: {
        type: 'importFiles';
        files: Map<string, IFile>;
        state: 'start' | 'end';
    };
    processRaw: {
        type: 'processRaw';
        data: any;
        options: ProcessRawOptions;
        path?: string;
    };
    processRawStart: {
        type: 'processRawStart';
        data: any;
        options: ProcessRawOptions;
        path?: string;
    };
    /**
     * @deprecated use the {@link importFile} event instead
     */
    onLoad: {
        type: 'onLoad';
    };
    /**
     * @deprecated use the {@link importFile} event instead
     */
    onProgress: {
        type: 'onProgress';
        url: string;
        loaded: number;
        total: number;
    };
    /**
     * @deprecated use the {@link importFile} event instead
     */
    onError: {
        type: 'onError';
        url: string;
    };
    /**
     * @deprecated use the {@link importFile} event instead
     */
    onStart: {
        type: 'onStart';
        url: string;
        loaded: number;
        total: number;
    };
}
/**
 * Asset Importer
 *
 * Utility class to import assets from local files, blobs, urls, etc.
 * Used in {@link AssetManager} to import assets.
 * Acts as a wrapper over three.js LoadingManager and adds support for dynamically loading loaders, caching assets, better event dispatching and file tracking.
 * @category Asset Manager
 */
export declare class AssetImporter extends EventDispatcher<IAssetImporterEventMap> implements IAssetImporter {
    private _loadingManager;
    private _logger;
    protected _rootContext?: {
        path: string;
        rootUrl: string;
    };
    private _loaderCache;
    private _fileDatabase;
    private _cachedAssets;
    /**
     * If true, imported assets are cached in memory(as js/three.js objects) and can be reused later. They will be cleared when dispose event is fired on the object or {@link clearCache} is called.
     */
    cacheImportedAssets: boolean;
    static WHITE_IMAGE_DATA: ImageData;
    readonly importers: IImporter[];
    constructor(logging?: boolean);
    get loadingManager(): LoadingManager;
    get cachedAssets(): IAsset[];
    addImporter(...importers: IImporter[]): void;
    removeImporter(...importers: IImporter[]): void;
    import<T extends ImportResult | undefined = ImportResult>(assetOrPath?: string | IAsset | IAsset[] | File | File[], options?: ImportAssetOptions): Promise<(T | undefined)[]>;
    importSingle<T extends ImportResult | undefined = ImportResult>(asset?: string | IAsset | File, options?: ImportAssetOptions): Promise<T | undefined>;
    importPath<T extends ImportResult | undefined = ImportResult | undefined>(path: string, options?: ImportAssetOptions): Promise<T[]>;
    importAsset<T extends ImportResult | undefined = ImportResult | undefined>(asset?: IAsset, options?: ImportAssetOptions, onDownloadProgress?: (e: ProgressEvent) => void): Promise<T[]>;
    importFile<T extends ImportResult | undefined = ImportResult | undefined>(file?: File, options?: ImportAssetOptions, onDownloadProgress?: (e: ProgressEvent) => void): Promise<T[]>;
    /**
     * Import multiple local files/blobs from a map of files, like when a local folder is loaded, or when multiple files are dropped.
     * @param files
     * @param options
     */
    importFiles<T extends ImportResult | undefined = ImportResult | undefined>(files: Map<string, IFile>, options?: ImportFilesOptions): Promise<Map<string, T[]>>;
    private _loadFile;
    /**
     * Register a file in the database and return a loader for it. If the loader does not exist, it will be created.
     * @param path
     * @param file
     * @param extension
     * @param loader
     */
    registerFile(path: string, file?: IFile, extension?: string, loader?: ILoader): ILoader | undefined;
    /**
     * Remove a file from the database and revoke the object url if it exists.
     * @param path
     */
    unregisterFile(path: string): void;
    processRaw<T extends (ImportResult | undefined) = ImportResult>(res: T | T[], options: ProcessRawOptions, path?: string): Promise<T[]>;
    processRawSingle<T extends (ImportResult | undefined) = ImportResult>(res: T, options: ProcessRawOptions, path?: string): Promise<T>;
    dispose(): void;
    /**
     * Clear memory asset and loader cache. Browser cache and custom cache storage is not cleared with this.
     */
    clearCache(): void;
    unregisterAllFiles(): void;
    clearLoaderCache(): void;
    resolveURL(url: string): string;
    protected _urlModifiers: ((url: string) => string)[];
    addURLModifier(modifier: (url: string) => string): void;
    removeURLModifier(modifier: (url: string) => string): void;
    protected _urlModifier(url: string): string;
    private _isRootFile;
    private _getImporter;
    private _getLoader;
    private _createLoader;
    addEventListener<T extends keyof IAssetImporterEventMap>(type: T, listener: EventListener<IAssetImporterEventMap[T], T, this>): void;
    protected _onLoad(): void;
    protected _onProgress(url: string, loaded: number, total: number): void;
    protected _onError(url: string): void;
    protected _onStart(url: string, loaded: number, total: number): void;
    /**
     * @deprecated use {@link processRaw} instead
     * @param res
     * @param options
     */
    processImported(res: any, options: ProcessRawOptions, path?: string): Promise<any[]>;
}
//# sourceMappingURL=AssetImporter.d.ts.map