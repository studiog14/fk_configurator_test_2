import { Class } from 'ts-browser-helpers';
import { CreateRenderTargetOptions, IRenderTarget } from './RenderTarget';
import { EventDispatcher, Vector2, WebGLRenderTarget, WebGLRenderTargetOptions } from 'three';
export declare abstract class RenderTargetManager<TE extends object = object> extends EventDispatcher<TE> {
    abstract isWebGL2: boolean;
    abstract readonly renderSize: Vector2;
    abstract renderScale: number;
    private _trackedTargets;
    private _trackedTempTargets;
    private _releasedTempTargets;
    readonly maxTempPerKey = 5;
    protected constructor();
    trackTarget(target: IRenderTarget): void;
    removeTrackedTarget(target: IRenderTarget): void;
    createTarget<T extends IRenderTarget = IRenderTarget>({ sizeMultiplier, samples, colorSpace, type, format, depthBuffer, depthTexture, depthTextureType, depthTextureFormat, size, textureCount, ...op }?: CreateRenderTargetOptions, trackTarget?: boolean): T;
    /**
     * Dispose and remove tracked target. Release target in-case of temporary target.
     * To just dispose from the GPU memory and keep reference, call `target.dispose()` or `target.dispose(false)`
     * @param target
     * @param remove
     */
    disposeTarget(target: IRenderTarget, remove?: boolean): void;
    getTempTarget<T extends IRenderTarget = IRenderTarget>(op?: CreateRenderTargetOptions): T;
    releaseTempTarget(target: IRenderTarget): void;
    createTargetCustom<T extends IRenderTarget>({ width, height, count, }: {
        width: number;
        height: number;
        count?: number;
    }, options?: WebGLRenderTargetOptions, clazz?: Class<T>): T;
    protected abstract _createTargetClass(clazz: Class<WebGLRenderTarget>, size: number[], options: WebGLRenderTargetOptions): IRenderTarget;
    dispose(clear?: boolean): void;
    /**
     * Resizes all tracked targets with a sizeMultiplier based on the current renderSize and renderScale.
     * This must be automatically called by the renderer on resize, and manually when sizeMultiplier of a target changes.
     */
    resizeTrackedTargets(): void;
    resizeTrackedTarget(target: IRenderTarget): void;
    private _processNewTempTarget;
    private _setTargetOptions;
    private _setTargetTextureOptions;
    protected _processNewTarget(target: IRenderTarget, sizeMultiplier: number | undefined, trackTarget: boolean): IRenderTarget;
}
//# sourceMappingURL=RenderTargetManager.d.ts.map