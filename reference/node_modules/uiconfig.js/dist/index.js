/**
 * @license
 * uiconfig.js v0.1.5
 * Copyright 2022-2025 repalash <palash@shaders.app>
 * MIT License
 */

/**
 * @license
 * ts-browser-helpers v0.16.2
 * Copyright 2022-2025 repalash <palash@shaders.app>
 * MIT License
 * See ./dependencies.txt for bundled third-party dependencies and licenses.
 */
class I {
  constructor() {
    this._eventListeners = {}, this.dispatchEvent = this.dispatchEvent.bind(this), this.addEventListener = this.addEventListener.bind(this), this.removeEventListener = this.removeEventListener.bind(this), this.hasEventListener = this.hasEventListener.bind(this);
  }
  addEventListener(e, t) {
    const i = this._eventListeners;
    i[e] === void 0 && (i[e] = []), i[e].includes(t) || i[e].push(t);
  }
  hasEventListener(e, t) {
    const i = this._eventListeners;
    return i[e] !== void 0 && i[e].includes(t);
  }
  removeEventListener(e, t) {
    const r = this._eventListeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    const i = this._eventListeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
    }
  }
}
async function X(n) {
  return new Promise((e) => setTimeout(e, Math.max(0, n)));
}
function g() {
  return (typeof performance > "u" ? Date : performance).now();
}
/*!
 * Fork Of -
 * JavaScript Undo Manager 1.0.0
 * Simple JavaScript undo/redo command manager supporting transactions with no dependencies.
 *
 * Copyright: Alexey Grinko, 2017
 * Git repository: https://github.com/agrinko/js-undo-manager.git
 *
 * @license MIT - https://opensource.org/licenses/MIT
 *
 * Changes -
 * 1. Added presets commands
 * 2. Port to TypeScript
 * 3. Remove transactions
 */
class Q {
  constructor(e) {
    this.options = {
      limit: 500,
      // maximum commands stack size
      debug: !1,
      // whether to emit execution status in console
      bindHotKeys: !1
      // whether to bind "undo" and "redo" commands to "Ctrl+Z", "Ctrl+Y" & "Ctrl+Shift+Z" hot keys
      // useTransactions: true   // whether to initialize transactions manager
    }, this.enabled = !0, this.presets = {}, this._keyDown = (t) => {
      if (!this.enabled) return;
      const i = t.ctrlKey || t.metaKey;
      t.code === "KeyZ" && i && !t.shiftKey ? this.undo() : (t.code === "KeyZ" && i && t.shiftKey || t.code === "KeyY" && t.ctrlKey) && this.redo();
    }, Object.assign(this.options, e), this.limit = e.limit, this.options = e, this.reset(), e.bindHotKeys && this.bindHotKeys(), this.log(`Initialized with stack limit of ${this.limit} commands`);
  }
  /**
   * Bind 'undo' and 'redo' actions to 'Ctrl/Cmd+Z', 'Ctrl+Y' & 'Ctrl/Cmd+Shift+Z' hot keys.
   * It is a basic implementation for quick testing and should be replaced with custom event handlers
   * for more flexible processing.
   * @returns {JSUndoManager}
   */
  bindHotKeys() {
    return this.log("Bound 'undo' and 'redo' actions to 'Ctrl/Cmd+Z', 'Ctrl+Y' & 'Ctrl/Cmd+Shift+Z' hot keys"), (this.options.hotKeyRoot ?? document).addEventListener("keydown", this._keyDown), this;
  }
  dispose() {
    return (this.options.hotKeyRoot ?? document).removeEventListener("keydown", this._keyDown), this.reset();
  }
  /**
   * Remember executed command containing "redo" and "undo" functions
   * @param {Object|Function} command - either an object with "redo" and "undo" functions
   * @returns {JSUndoManager}
   */
  record(e) {
    return this.enabled ? (this._record(e), this) : this;
  }
  replaceLast(e) {
    const t = this.peek();
    if (t)
      return this.log("replace", t, "with", e), this.stack[this.sp] = e, this;
  }
  /**
   * Execute function and record it with its opposite "undo" function
   * @param {Object|Function} command - either an object with "redo" and "undo" functions
   * @param {Function} [undo] - "undo" function, used if the first argument is also a function
   * @returns {JSUndoManager}
   */
  execute(e) {
    if (!this.enabled) return;
    let t = this._rc(e), i = t.redo;
    return this.record.apply(this, t), this.log("Executing function..."), i.apply(e), this;
  }
  _rc(e) {
    if (e.type) {
      const t = this.presets[e.type];
      if (typeof t == "function")
        return t(e);
      throw console.error(e, t, this.presets), new Error("Preset command not found");
    } else
      return e;
  }
  _record(e) {
    this.enabled && (this.log("Recording command", e), this._rebase(), this.stack.push(e), this.sp++, this._keepLimit());
  }
  //forget "future" commands if stack pointer is not at the end
  _rebase() {
    this.canRedo() && (this.stack.length = this.sp + 1);
  }
  //sustain limited size of stack; cut extra commands starting with the latest ones
  _keepLimit() {
    if (this.stack.length <= this.limit)
      return;
    let e = this.stack.length - this.limit;
    this.log("Stack size reached its limit: ${this.limit} commands. Cutting off most old commands..."), e === 1 ? this.stack.shift() : this.stack.splice(0, e), this.sp -= e;
  }
  /**
   * Undo previous command if possible
   * @returns {JSUndoManager}
   */
  undo() {
    if (!this.canUndo())
      return this;
    let e = this.stack[this.sp];
    return this.log("undo"), this.sp--, this._rc(e).undo(), this;
  }
  /**
   * Check whether undoing previous command is possible
   * @returns {boolean}
   */
  canUndo() {
    return this.sp >= 0 && this.enabled;
  }
  /**
   * Get the last command that was done
   */
  peek() {
    return this.canUndo() ? this.stack[this.sp] : null;
  }
  /**
   * Redo the command which was previously undone
   * @returns {JSUndoManager}
   */
  redo() {
    if (!this.canRedo())
      return this;
    let e = this.stack[this.sp + 1];
    return this.log("redo"), this.sp++, this._rc(e).redo(), this;
  }
  /**
   * Check whether redoing command is possible
   * @returns {boolean}
   */
  canRedo() {
    return this.sp < this.stack.length - 1 && this.enabled;
  }
  /**
   * Gets the last command that was undone
   */
  peekForward() {
    return this.canRedo() ? this.stack[this.sp + 1] : null;
  }
  /**
   * Change stack size limit initially defined in the constructor options
   * @param {number} limit
   */
  setLimit(e) {
    let t = this.stack.length - this.sp - 1;
    if (e < 1 || typeof e != "number")
      throw new TypeError(`JSUndoManager.setLimit(): unexpected argument limit=${e}. Should be a positive number`);
    return e < t ? console.warn(`JSUndoManager.setLimit(): cannot set stack limit (${e}) less than the number of 'redoable' commands (${t})`) : (this.limit = Math.floor(e), this._keepLimit()), this;
  }
  /**
   * Reset all commands from memory
   */
  reset() {
    return this.log("reset"), this.stack = [], this.sp = -1, this;
  }
  /**
   * Check whether the commands stack is empty
   * @returns {boolean}
   */
  isEmpty() {
    return !this.stack.length;
  }
  /**
   * Check whether the commands stack size reaches its limit
   * @returns {boolean}
   */
  isFull() {
    return this.stack.length === this.limit;
  }
  /**
   * Get number of commands in memory stack
   * @returns {Number}
   */
  getSize() {
    return this.stack.length;
  }
  log(e, ...t) {
    this.options.debug && console.log(`Command Manager: ${e}`, ...t);
  }
}
function ee({ innerHTML: n = "", id: e, classList: t, addToBody: i = !0, elementTag: r = "div" }) {
  const s = document.createElement(r);
  return e && (s.id = e), s.innerHTML = n, t && s.classList.add(...t), i && document.body.appendChild(s), s;
}
function H(n, e) {
  let t;
  do
    t = Object.getOwnPropertyDescriptor(n, e);
  while (!t && (n = Object.getPrototypeOf(n)));
  return t;
}
function W(n, e, t = !0, i = !1) {
  const r = H(n, e);
  return !!(r != null && r.set) || t && (r == null ? void 0 : r.writable) !== !1 && (r == null ? void 0 : r.get) === void 0 || i && !r;
}
function S(n, e, t, i = !0, r = !1) {
  return n && W(n, e, i, r) ? (n[e] = t, !0) : !1;
}
function Ee(n, ...e) {
  return typeof n == "function" && (n = n(...e)), n;
}
function it() {
  const n = (i, r) => i.toString(16).padStart(r, "0"), e = crypto.getRandomValues(new Uint8Array(16));
  e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
  const t = new DataView(e.buffer);
  return `${n(t.getUint32(0), 8)}-${n(t.getUint16(4), 4)}-${n(t.getUint16(6), 4)}-${n(t.getUint16(8), 4)}-${n(t.getUint32(10), 8)}${n(t.getUint16(14), 4)}`;
}
function rt(n, e = null) {
  return new URL(window.location.href).searchParams.get(n) ?? e;
}

class UiConfigTypeMap {
}
UiConfigTypeMap.Map = new Map();
function generateValueConfig(obj, key, label, val) {
    val = val !== null && val !== void 0 ? val : obj[key];
    const config = val === null || val === void 0 ? void 0 : val.uiConfig;
    let result = undefined;
    if (config) {
        result = config;
    }
    else {
        const uiType = valueToUiType(val);
        if (uiType === 'folder') {
            result = generateUiFolder(key + '', val, {}, 'folder', true);
        }
        else if (uiType)
            result = {
                type: uiType,
                label: key + '',
                property: [obj, key],
            };
    }
    label = label !== null && label !== void 0 ? label : key + '';
    if (result && !result.label)
        result.label = label;
    return result;
}
function generateUiConfig(obj) {
    if (!obj)
        return [];
    let type = obj.constructor || Object;
    if (type === Array)
        type = Object;
    const result = [];
    const types = [];
    while (type && type !== Object) {
        types.push(type);
        type = Object.getPrototypeOf(type);
    }
    if (!types.length || Array.isArray(obj)) {
        const keys = typeof obj === 'object' ? Object.keys(obj) : Array.isArray(obj) ? obj.map((_, i) => i) : [];
        for (const key of keys) {
            const val = obj[key];
            if (val === undefined || val === null)
                continue;
            // if (Array.isArray(obj)) debugger
            // todo: make only the children of folder inside the value config dynamic instead of the whole thing? as in webgi
            const c = () => generateValueConfig(obj, key, key + '', val);
            if (c)
                result.push(c);
        }
    }
    // reversing so we get the parent first
    types.reverse().forEach(t => {
        var _a;
        (_a = UiConfigTypeMap.Map.get(t)) === null || _a === void 0 ? void 0 : _a.forEach(({ params, propKey, uiType }) => {
            let config;
            if (!uiType) {
                config = () => generateValueConfig(obj, propKey);
            }
            if (!config) {
                config = {
                    property: [obj, propKey],
                    type: uiType || 'input',
                    // ...params,
                    // ...extraParams,
                };
            }
            if (params) {
                const extraParams = typeof params.params === 'function' ? params.params(obj) : params.params || {};
                const params1 = Object.assign({}, params);
                delete params1.params;
                if (typeof config === 'function') {
                    const c1 = config;
                    config = () => Object.assign(c1(), Object.assign(Object.assign({}, params1), extraParams));
                }
                Object.assign(config, Object.assign(Object.assign({}, params1), extraParams));
            }
            result.push(config);
            // if (typeof obj.setDirty === 'function') {
            //     const changer = ()=>obj.setDirty()
            //     if (!obj.onChange) obj.onChange = changer
            //     else {
            //         const oldOnChange = obj.onChange
            //         Array.isArray(oldOnChange) ? oldOnChange.push(changer) : obj.onChange = [...oldOnChange, changer]
            //     }
            // }
        });
    });
    return result;
}
function generateUiFolder(label, obj, params = {}, type = 'folder', dynamic = false) {
    return Object.assign({ type, label, children: !dynamic ? generateUiConfig(obj) : () => generateUiConfig(obj), uuid: it() }, params);
}
function valueToUiType(val) {
    if (val === null || val === undefined)
        return null;
    if (Array.isArray(val))
        return 'folder';
    if (typeof val === 'boolean')
        return 'checkbox';
    if (typeof val === 'number')
        return 'number';
    if (typeof val === 'string')
        return 'input';
    if (typeof val === 'function')
        return 'button';
    if (typeof val.x === 'number')
        return 'vec';
    if (typeof val.r === 'number')
        return 'color';
    if (val.isTexture)
        return 'image';
    if (typeof val === 'object')
        return 'folder';
    return null;
}

/**
 * Decorator for uiConfig
 * @param action - function that will be called with the targetPrototype, propertyKey and uiConfigs, and should modify the uiConfigs
 */
function uiConfigDecorator(action) {
    return (targetPrototype, propertyKey) => {
        const type = targetPrototype.constructor;
        if (type === Object)
            throw new Error('Not possible to use uiConfig decorator on an object, use class instead');
        if (!UiConfigTypeMap.Map.has(type))
            UiConfigTypeMap.Map.set(type, []);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        action(targetPrototype, propertyKey, UiConfigTypeMap.Map.get(type));
    };
}
// for properties
function uiConfig(uiType, params) {
    return uiConfigDecorator((_, propertyKey, uiConfigs) => {
        const index = uiConfigs.findIndex(item => item.propKey === propertyKey);
        if (index && index < 0)
            uiConfigs.push({
                params: params || {},
                propKey: propertyKey,
                uiType,
            });
        else {
            throw new Error(`Property ${propertyKey} already has a uiConfig decorator`);
        }
    });
}
// for classes
function uiContainer(label, params, type = 'panel') {
    return (constructor) => {
        return class extends constructor {
            constructor() {
                super(...arguments);
                this.uiConfig = generateUiFolder(Ee(label, this) || '', this, params || {}, type);
            }
        };
    };
}

function uiMonitor(label, params) {
    return uiConfig('monitor', { label, params });
}
function uiSlider(label, bounds, stepSize, params) {
    return uiConfig('slider', { label, bounds, stepSize, params });
}
function uiVector(label, bounds, stepSize, params) {
    return uiConfig('vec', { label, bounds, stepSize, params });
}
function uiDropdown(label, children, params) {
    if (Array.isArray(children) && typeof children[0] === 'string')
        children = children.map((c) => ({ label: c, value: c }));
    return uiConfig('dropdown', { label, children: children, params });
}
function uiButton(label, params) {
    return uiConfig('button', { label, params });
}
function uiInput(label, params) {
    return uiConfig('input', { label, params });
}
function uiNumber(label, params) {
    return uiConfig('number', { label, params });
}
function uiColor(label, params) {
    return uiConfig('color', { label, params });
}
function uiImage(label, params) {
    return uiConfig('image', { label, params });
}
function uiToggle(label, params) {
    return uiConfig('checkbox', { label, params });
}
function uiPanelContainer(label, params) {
    return uiContainer(label, params, 'panel');
}
function uiFolderContainer(label, params) {
    return uiContainer(label, params, 'folder');
}

function createValueUiConfig(config) {
    return config;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function clonePrimitive(a) {
    if (a === null || typeof a !== 'object')
        return a;
    if (Array.isArray(a))
        return a.map(clonePrimitive);
    if (!a._ui_isPrimitive && typeof a.clone === 'function' && a._ui_primitiveClone !== false)
        return a.clone();
    return a;
}
function equalsPrimitive(a, b) {
    if (a === null || typeof a !== 'object')
        return a === b;
    if (Array.isArray(a))
        return Array.isArray(b) && a.length === b.length && a.every((v, i) => equalsPrimitive(v, b[i]));
    if (!a._ui_isPrimitive && typeof a.equals === 'function' && a._ui_primitiveEquals !== false)
        return !!a.equals(b);
    // direct equality check in case of objects
    return a === b;
}
function copyPrimitive(a, b) {
    if (b === null || typeof b !== 'object')
        return b;
    else if (Array.isArray(b)) {
        // const a = target[key]
        if (a && Array.isArray(a)) {
            if (a.length < b.length) {
                for (let i = 0; i < a.length; i++)
                    a[i] = copyPrimitive(a[i], b[i]);
                for (let i = a.length; i < b.length; i++)
                    a.push(clonePrimitive(b[i]));
            }
            else {
                for (let i = 0; i < b.length; i++)
                    a[i] = copyPrimitive(a[i], b[i]);
                a.length = b.length;
            }
            return a;
        }
        else
            return clonePrimitive(b);
    }
    else if (!b._ui_isPrimitive && typeof b.copy === 'function' && b._ui_primitiveCopy !== false) {
        // const a = target[key]
        if (a && typeof a === 'object' && !Array.isArray(a) && !a._ui_isPrimitive && typeof a.copy === 'function' && a._ui_primitiveCopy !== false) {
            a.copy(b);
            return a;
        }
        else
            return clonePrimitive(b);
    }
    else
        return b;
}

class UiConfigMethods {
    constructor(_renderer) {
        this._renderer = _renderer;
        this.undoEditingWaitTime = 2000;
        this.undoPresets = {
            ['UiConfigMethods_set']: (c) => {
                const ref = () => { var _a, _b; return (_b = (_a = c.config).uiRefresh) === null || _b === void 0 ? void 0 : _b.call(_a, false); };
                return {
                    undo: () => {
                        // console.log('undo', c.lastVal)
                        this.setValue(c.config, c.lastVal, c.props, undefined, false).then(ref);
                    },
                    redo: () => {
                        // console.log('redo', c.val)
                        this.setValue(c.config, c.val, c.props, undefined, false).then(ref);
                    },
                };
            },
            ['UiConfigMethods_action']: (c) => {
                const ref = () => { var _a, _b; return (_b = (_a = c.config).uiRefresh) === null || _b === void 0 ? void 0 : _b.call(_a, false); };
                return {
                    undo: () => __awaiter(this, void 0, void 0, function* () {
                        yield c.undo.call(c.target, ...c.args);
                        ref();
                    }),
                    redo: () => __awaiter(this, void 0, void 0, function* () {
                        yield c.redo.call(c.target, ...c.args);
                        ref();
                    }),
                };
            },
        };
    }
    getBinding(config, parent = true) {
        let prop = Ee(config.property, config);
        const path = Ee(config.path, config);
        if (prop === undefined && Object.hasOwn(config, 'value')) {
            prop = [config, 'value'];
        }
        if (prop === undefined && parent) {
            prop = Ee(config.parentProperty, config);
        }
        if (!prop || typeof prop[0] !== 'object' || !prop[1]) {
            // console.warn('Cannot determine property for uiConfig', config)
            return [undefined, ''];
        }
        if (typeof prop[1] === 'string' && path && path.length)
            prop = [prop[0], prop[1] + '.' + path];
        if (typeof prop[1] === 'string' && prop[1].includes('.')) {
            // json path
            const path1 = prop[1].split('.');
            let tar = prop[0];
            const key = path1.pop() || '';
            for (const p of path1) {
                tar = Array.isArray(tar) ? tar[parseInt(p)] : tar[p];
                if (!tar) {
                    console.warn('Cannot determine property, invalid property path', config, prop);
                    return [undefined, ''];
                }
            }
            prop = [tar, key];
        }
        if (Array.isArray(prop[0]) && typeof prop[1] === 'string')
            prop[1] = parseInt(prop[1]);
        return prop;
    }
    getRawValue(config) {
        const [tar, key] = this.getBinding(config);
        if (!tar)
            return undefined;
        const res = tar[key];
        return res;
    }
    /**
     * Get the value from config
     * @param config
     * @param val - existing value, new value can be copied to this if not equal.
     * @param copyOnEqual - whether the value should be copied to val if equal. Default is true.
     * @returns The value from the binding, cloned or copied if possible. If the value is equal and copyOnEqual is false, then undefined is returned. this can be used to check if the value is changed
     */
    getValue(config, val, copyOnEqual = true) {
        const [tar, key] = this.getBinding(config);
        if (!tar)
            return undefined;
        const res = tar[key];
        // console.log('get', config, res)
        if (val !== undefined && res !== undefined) {
            if (equalsPrimitive(val, res) && !copyOnEqual)
                return undefined; // returns undefined if equal
            return copyPrimitive(val, res);
        }
        return clonePrimitive(res);
    }
    dispatchOnChangeSync(config, props, ...args) {
        var _a, _b, _c;
        const changeEvent = {
            type: 'change',
            last: (_a = props.last) !== null && _a !== void 0 ? _a : true,
            config: (_b = props.config) !== null && _b !== void 0 ? _b : config,
            configPath: [config, ...props.configPath || []],
            target: config,
            value: props.value,
            lastValue: props.lastValue,
        };
        const changeArgs = [changeEvent, ...args];
        if (typeof config.onChange === 'function')
            config.onChange(...changeArgs);
        else if (Array.isArray(config.onChange)) {
            config.onChange.flat().forEach((c) => typeof c === 'function' && (c === null || c === void 0 ? void 0 : c(...changeArgs)));
        }
        else if (config.onChange) {
            console.error('Invalid onChange type, must be a function or array of functions', config.onChange);
        }
        (_c = config.parentOnChange) === null || _c === void 0 ? void 0 : _c.call(config, ...changeArgs);
    }
    recordUndo(com) {
        const um = this._renderer.undoManager;
        if (!um || !um.enabled)
            return;
        const c = com;
        if (c.type !== 'UiConfigMethods_set')
            return um.record(com);
        const lastCommand = um.peek();
        let sameType = !!lastCommand && lastCommand.type === 'UiConfigMethods_set' && lastCommand.config === c.config;
        if (sameType) {
            const cLast = lastCommand;
            if (!cLast.final && (c.time - cLast.time) < this.undoEditingWaitTime) {
                // replace cLast with c using lastVal from cLast
                c.lastVal = cLast.lastVal;
                c.val = clonePrimitive(c.val);
                um.replaceLast(c);
            }
            else {
                sameType = false;
            }
        }
        if (!sameType) {
            if (!equalsPrimitive(c.lastVal, c.val)) {
                c.val = clonePrimitive(c.val);
                um.record(c);
            }
        }
    }
    /**
     *
     * @param config
     * @param value
     * @param props - only the prop `last` need to be set, rest are optional. `lastValue` can be set if known (but it should be exactly equal to the value in the binding and not cloned). `config`, `configPath` are for parentOnChange, no need to set that.
     * @param forceOnChange
     * @param trackUndo
     */
    setValue(config_1, value_1, props_1, forceOnChange_1) {
        return __awaiter(this, arguments, void 0, function* (config, value, props, forceOnChange, trackUndo = true) {
            return this.runAtEvent(config, () => {
                var _a, _b;
                const [tar, key] = this.getBinding(config);
                const lastValueRaw = (_a = props.lastValue) !== null && _a !== void 0 ? _a : tar === null || tar === void 0 ? void 0 : tar[key];
                let failed = false;
                const final = (_b = props.last) !== null && _b !== void 0 ? _b : true;
                const same = equalsPrimitive(lastValueRaw, value);
                const lastValue = clonePrimitive(lastValueRaw);
                if (same)
                    failed = !final;
                else if (tar) {
                    const a = copyPrimitive(lastValueRaw, value);
                    if (a !== lastValueRaw)
                        failed = !S(tar, key, value, true, true);
                    else
                        failed = false;
                }
                else
                    failed = true;
                // console.log('set', config, value, lastValue, failed, same, final)
                if (failed) {
                    if (!forceOnChange)
                        return false;
                }
                if (trackUndo && !failed && (final || !same)) {
                    this.recordUndo({
                        type: 'UiConfigMethods_set',
                        config,
                        lastVal: lastValue,
                        val: value,
                        final,
                        props,
                        time: Date.now(),
                    });
                }
                this.dispatchOnChangeSync(config, Object.assign(Object.assign({}, props), { last: final, value, lastValue: lastValue }));
                return true;
            });
        });
    }
    /**
     *
     * @param config
     * @param props - only last needs to be set. check the docs for `setValue`
     */
    dispatchOnChange(config, props) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.runAtEvent(config, () => {
                this.dispatchOnChangeSync(config, props);
            });
        });
    }
    getLabel(config) {
        var _a, _b;
        return ((_a = Ee(config.label, config)) !== null && _a !== void 0 ? _a : (_b = this.getBinding(config)) === null || _b === void 0 ? void 0 : _b[1]) + '';
    }
    getChildren(config) {
        var _a;
        return ((_a = Ee(config.children, config)) !== null && _a !== void 0 ? _a : []).map(v => Ee(v)).flat(2).filter(v => v);
    }
    clickButton(config, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.runAtEvent(config, () => __awaiter(this, void 0, void 0, function* () {
                // const args: any[] = []
                // const prmpt = getOrCall(config.prompt)
                // if (prmpt) args.push(await this._renderer.prompt(...prmpt))
                var _a, _b, _c, _d, _e, _f;
                const binding = this.getBinding(config, false);
                const tar = binding[0];
                const key = binding[1];
                const args = Ee(config.sendArgs, config) === false ? [] : (_a = options === null || options === void 0 ? void 0 : options.args) !== null && _a !== void 0 ? _a : [];
                const actions = [];
                if (tar) {
                    const action = ((_b = tar[key]) !== null && _b !== void 0 ? _b : tar.value);
                    if (typeof action === 'function') {
                        actions.push([action, tar]);
                    }
                    else if (action) {
                        console.warn('Invalid action type for button', action);
                    }
                }
                if (typeof config.onClick === 'function') {
                    actions.push([config.onClick, config]);
                }
                for (const [action, targ] of actions) {
                    let res = yield action.call(targ, ...args); // if a function is returned, it is treated as undo function
                    const undo = typeof res === 'function' ? res : (_c = res === null || res === void 0 ? void 0 : res.undo) === null || _c === void 0 ? void 0 : _c.bind(res);
                    const resAction = typeof res !== 'function' ? (_d = res === null || res === void 0 ? void 0 : res.action) === null || _d === void 0 ? void 0 : _d.bind(res) : null;
                    const redo = typeof res === 'function' ? action : (_f = (_e = res === null || res === void 0 ? void 0 : res.redo) === null || _e === void 0 ? void 0 : _e.bind(res)) !== null && _f !== void 0 ? _f : resAction;
                    if (typeof resAction === 'function') {
                        res = yield resAction(); // execute the action now. adding await just in case
                    }
                    if (typeof undo === 'function') {
                        this.recordUndo({
                            type: 'UiConfigMethods_action',
                            config,
                            target: targ,
                            undo: undo,
                            redo: redo,
                            args,
                        });
                    }
                }
                yield this.dispatchOnChange(config, {});
                // this.dispatchOnChangeSync(config, {})
            }));
        });
    }
    runAtEvent(config, run) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const dispatchMode = (_a = Ee(config.dispatchMode, config)) !== null && _a !== void 0 ? _a : 'postFrame';
            if (dispatchMode === 'immediate')
                return run();
            return new Promise((resolve) => {
                const listener = () => __awaiter(this, void 0, void 0, function* () {
                    this._renderer.removeEventListener(dispatchMode, listener);
                    resolve(yield run());
                });
                this._renderer.addEventListener(dispatchMode, listener);
            });
        });
    }
    initUiConfig(config) {
        if (!config)
            return;
        if (!config.type) {
            console.warn('No type for config', config);
            config.type = 'input';
        }
        if (!config.uuid)
            config.uuid = it();
        if (config.property === undefined) {
            if (config.binding)
                config.property = config.binding;
            else if (config.value === undefined) {
                if (config.getValue || config.setValue) {
                    Object.defineProperty(config, 'value', {
                        get: () => config.getValue && config.getValue(),
                        set: (v) => config.setValue && config.setValue(v),
                    });
                    config.property = [config, 'value'];
                }
            }
            else if (config.getValue || config.setValue) {
                console.warn('getValue/setValue is ignored since value is provided', config);
            }
            if (config.property === undefined) ;
        }
    }
    getBounds(config, unbounded = false) {
        var _a, _b;
        const bounds = Ee(config.bounds);
        const max = ((_a = bounds === null || bounds === void 0 ? void 0 : bounds.length) !== null && _a !== void 0 ? _a : 0) >= 2 ? bounds[1] : unbounded ? Infinity : 1;
        const min = ((_b = bounds === null || bounds === void 0 ? void 0 : bounds.length) !== null && _b !== void 0 ? _b : 0) >= 1 ? bounds[0] : unbounded ? -Infinity : 0;
        const step = Ee(config.stepSize) || (unbounded ? 0.01 : Math.pow(10, Math.floor(Math.log10((max - min) / 100))));
        return { min, max, step };
    }
}

class UiConfigRendererBase extends I {
    get undoManager() {
        return this._undoManager;
    }
    set undoManager(value) {
        this._undoManager = value;
        if (this._undoManager)
            Object.assign(this._undoManager.presets, this.methods.undoPresets);
    }
    constructor(autoFrameEvents = true, methods, undoManager) {
        super();
        this._rafId = null;
        this.raf = () => {
            if (!this._autoFrameEvents)
                return;
            this.dispatchEvent({ type: 'preFrame' });
            this.dispatchEvent({ type: 'preRender' });
            this.dispatchEvent({ type: 'postRender' });
            this.dispatchEvent({ type: 'postFrame' });
            this._rafId = requestAnimationFrame(this.raf);
        };
        this._refreshQueue = {
            'preRender': [],
            'postRender': [],
            'preFrame': [],
            'postFrame': [],
        };
        this._lastModeTime = {
            'preRender': 0,
            'postRender': 0,
            'preFrame': 0,
            'postFrame': 0,
        };
        this.methods = methods || new UiConfigMethods(this);
        this.undoManager = undoManager === false ? undefined : undoManager || new Q({ bindHotKeys: true, limit: 1000, debug: rt('debugUndo') !== null });
        this._autoFrameEvents = autoFrameEvents;
        if (autoFrameEvents) {
            this.addEventListener('preFrame', () => this.refreshQueue('preFrame'));
            this.addEventListener('postFrame', () => this.refreshQueue('postFrame'));
            this.addEventListener('preRender', () => this.refreshQueue('preRender'));
            this.addEventListener('postRender', () => this.refreshQueue('postRender'));
        }
    }
    // call from render or onMount
    start() {
        if (this._rafId === null) {
            this._rafId = requestAnimationFrame(this.raf);
        }
    }
    // call from unmount or onDispose etc
    stop() {
        if (this._rafId !== null) {
            cancelAnimationFrame(this._rafId);
            this._rafId = null;
        }
    }
    refreshQueue(mode) {
        const l = this._refreshQueue[mode];
        const l2 = [];
        const t = g();
        const delta = t - this._lastModeTime[mode];
        l.forEach(value => {
            if (value[1] > 0.001) {
                value[1] -= delta;
                l2.push(value);
            }
            else
                this._refreshUiConfigObject(value[0]);
        }); // todo: add option to disable ui refresh like for when animating
        this._refreshQueue[mode] = l2;
        this._lastModeTime[mode] = t;
    }
    _addToRefreshQueue(mode, config, delay) {
        const uuid = config.uuid;
        const l = this._refreshQueue[mode];
        // if (uuid) {
        //     l = l.filter(v=>v[3] !== uuid)
        // }
        // console.warn('add to refresh queue:', uuid)
        const old = l.find(value => value[2] === uuid);
        if (!old)
            l.push([config, delay, uuid]);
        else {
            old[1] = Math.max(old[1], delay); // push delay
        }
        this._refreshQueue[mode] = l;
    }
    /**
     * Disposes the UI associated with a config, doesn't makes change to the object or its parent.
     * @param config
     * @param performDispose
     */
    disposeUiConfig(config, performDispose = true) {
        var _a, _b;
        if (!config)
            return;
        if (config.uiRef) {
            if (performDispose)
                (_b = (_a = config.uiRef).dispose) === null || _b === void 0 ? void 0 : _b.call(_a);
            config.uiRef = undefined;
        }
        config.uiRefType = undefined;
        config.uiRefresh = undefined;
    }
    addToRefreshQueue(mode, uiConfig, deep, delay) {
        const list = deep ? this._flattenUiConfig(uiConfig) : [uiConfig];
        for (const value of list) {
            if (mode === 'immediate')
                X(delay).then(() => this._refreshUiConfigObject(value));
            else
                this._addToRefreshQueue(mode, value, delay);
        }
    }
    _flattenUiConfig(uiC, list) {
        var _a;
        list = list !== null && list !== void 0 ? list : [];
        if (!uiC || !uiC.uiRef)
            return list;
        list.push(uiC);
        if (typeof uiC.children === 'function')
            return list; // todo call function, see below.
        (_a = uiC.children) === null || _a === void 0 ? void 0 : _a.forEach(value => {
            if (typeof value === 'function') {
                return;
                //  todo: call function. this is commented because it makes it slower and it doesnt matter much since result of function most likely wont have uiRef
                // value = value()
            }
            if (!value)
                return;
            if (Array.isArray(value))
                value.forEach(v1 => list = this._flattenUiConfig(v1, list));
            else
                list = this._flattenUiConfig(value, list);
        });
        return list;
    }
}

class UiConfigRenderer extends UiConfigRendererBase {
    constructor(container = document.body, autoFrameEvents = true, methods, undoManager) {
        super(autoFrameEvents, methods, undoManager);
        this.config = {
            type: 'panel',
            label: 'Configuration',
            children: [],
        };
        this._uiContainer = this._createUiContainer();
        container.appendChild(this._uiContainer);
        this.start();
    }
    unmount() {
        this.disposeUiConfig(this.config);
        this._uiContainer.remove();
        this.stop();
    }
    // appendUiConfig(uiConfig: UiObjectConfig): void {
    //     if (!uiConfig) return
    //     this._renderUiConfig(uiConfig)
    // }
    appendChild(config, params) {
        if (!config)
            return;
        Object.assign(config, params);
        this.config.children.push(config);
        this.refreshRoot();
    }
    removeChild(config) {
        const index = this.config.children.indexOf(config);
        if (index === -1)
            return;
        this.config.children.splice(index, 1);
        this.disposeUiConfig(config);
        this.refreshRoot();
    }
    refreshRoot(deep = true, mode = 'postFrame', delay = 0) {
        var _a, _b;
        (_b = (_a = this.config).uiRefresh) === null || _b === void 0 ? void 0 : _b.call(_a, deep, mode, delay);
    }
    _createUiContainer() {
        return ee({ id: 'uiConfigContainer', addToBody: false });
    }
}

export { UiConfigMethods, UiConfigRenderer, UiConfigRendererBase, UiConfigTypeMap, clonePrimitive, copyPrimitive, createValueUiConfig, equalsPrimitive, generateUiConfig, generateUiFolder, generateValueConfig, uiButton, uiColor, uiConfig, uiContainer, uiDropdown, uiFolderContainer, uiImage, uiInput, uiMonitor, uiNumber, uiPanelContainer, uiSlider, uiToggle, uiVector };
//# sourceMappingURL=index.js.map
