import { ExtendedShaderPass } from './ExtendedShaderPass';
import { ColorSpace, ShaderMaterialParameters, WebGLMultipleRenderTargets, WebGLRenderTarget } from 'three';
import { ICamera, IRenderManager, IScene, IWebGLRenderer, ShaderMaterial2 } from '../core';
import { IPassID, IPipelinePass } from './Pass';
import { UiObjectConfig } from 'uiconfig.js';
import { ViewerRenderManager } from '../viewer';
export type TViewerScreenShaderFrag = string | [string, string] | {
    pars?: string;
    main: string;
};
export type TViewerScreenShader = TViewerScreenShaderFrag | ShaderMaterialParameters | ShaderMaterial2;
export declare class ScreenPass extends ExtendedShaderPass implements IPipelinePass<'screen'> {
    uiConfig: UiObjectConfig;
    readonly passId = "screen";
    after: IPassID[];
    required: IPassID[];
    constructor(shader?: TViewerScreenShader, ...textureID: string[]);
    /**
     * Output Color Space
     * Note: this is ignored when renderToScreen is false (it will take the color space of the render target)
     */
    outputColorSpace: ColorSpace;
    private _lastReadBuffer?;
    render(renderer: IWebGLRenderer, writeBuffer?: WebGLMultipleRenderTargets | WebGLRenderTarget | null, readBuffer?: WebGLMultipleRenderTargets | WebGLRenderTarget, deltaTime?: number, maskActive?: boolean): void;
    reRender(renderer: IWebGLRenderer, writeBuffer?: WebGLMultipleRenderTargets | WebGLRenderTarget | null, deltaTime?: number, maskActive?: boolean): void;
    private _needsReRender;
    onPostFrame(renderManager: IRenderManager): void;
    dispose(): void;
    /**
     * Force clip background. If this is `true` {@link clipBackground} is overridden.
     * This happens when scene.background and scene.backgroundColor are both null.
     * This is set in {@link ViewerRenderManager.render}.
     */
    clipBackgroundForce: boolean;
    clipBackground: boolean;
    beforeRender(_: IScene, _1: ICamera, renderManager: ViewerRenderManager): void;
    setDirty(): void;
}
//# sourceMappingURL=ScreenPass.d.ts.map