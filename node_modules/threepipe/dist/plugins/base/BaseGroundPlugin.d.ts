import { AViewerPluginEventMap, AViewerPluginSync, ThreeViewer } from '../../viewer';
import { IGeometry, IMaterial, IScene, ISceneEventMap, Mesh2, PhysicalMaterial } from '../../core';
import { BufferGeometry, PlaneGeometry, Event } from 'three';
export declare class BaseGroundPlugin<TE extends AViewerPluginEventMap = AViewerPluginEventMap> extends AViewerPluginSync<TE> {
    static readonly PluginType: string;
    static readonly OldPluginType: string;
    get enabled(): boolean;
    set enabled(value: boolean);
    protected _geometry: IGeometry & PlaneGeometry;
    protected _mesh: Mesh2<IGeometry & PlaneGeometry, IMaterial>;
    private _transformNeedRefresh;
    constructor();
    visible: boolean;
    size: number;
    yOffset: number;
    renderToDepth: boolean;
    /**
     * If false, the ground will not be tonemapped in post processing.
     * note: this will only work when {@link GBufferPlugin} is being used. Also needs {@link renderToDepth} to be true.
     */
    tonemapGround: boolean;
    /**
     * If true, the camera will be limited to not go below the ground.
     * note: this will only work when {@link OrbitControls3} or three.js OrbitControls are being used.
     */
    limitCameraAboveGround: boolean;
    autoAdjustTransform: boolean;
    protected _material?: PhysicalMaterial;
    onAdded(viewer: ThreeViewer): void;
    onRemove(viewer: ThreeViewer): void;
    protected _postFrame(): void;
    protected _preRender(): void;
    dispose(): void;
    protected _removeMaterial(): void;
    protected _onSceneUpdate(event?: ISceneEventMap['addSceneObject' | 'sceneUpdate'] & Event<'addSceneObject' | 'sceneUpdate', IScene>): void;
    /**
     * Extra flag for plugins to disable transform refresh like when animating or dragging
     */
    enableRefreshTransform: boolean;
    refreshTransform(): void;
    refresh(): void;
    private _refresh2;
    private _cameraLimitsSet;
    private _cameraLastMaxPolarAngle;
    private _refreshCameraLimits;
    useModelBounds: boolean;
    protected _refreshTransform(): boolean;
    protected _createMesh(mesh?: Mesh2<IGeometry & PlaneGeometry, IMaterial>): Mesh2<IGeometry & PlaneGeometry, IMaterial>;
    setGeometry(g?: BufferGeometry): void;
    protected _createMaterial(material?: PhysicalMaterial): PhysicalMaterial;
    protected _refreshMaterial(): void;
    get material(): PhysicalMaterial<import('../../core').IMaterialEventMap> | undefined;
    get mesh(): Mesh2<IGeometry<import('three').NormalBufferAttributes, import('three').BufferGeometryEventMap> & PlaneGeometry, IMaterial<import('../../core').IMaterialEventMap>, import('../../core').IObject3DEventMap>;
    fromJSON(data: any, meta?: any): this | null;
}
declare module '../../core/IScene' {
    interface ISceneSetDirtyOptions {
        updateGround?: boolean;
    }
}
//# sourceMappingURL=BaseGroundPlugin.d.ts.map