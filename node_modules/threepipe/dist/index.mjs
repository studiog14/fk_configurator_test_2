/**
 * @license
 * threepipe v0.0.49
 * Copyright 2022-2025 repalash <palash@shaders.app>
 * Apache-2.0 License
 * See ./dependencies.txt for bundled third-party dependencies and licenses.
 */
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const $g = "158", Yo = { ROTATE: 0, DOLLY: 1, PAN: 2 }, Ko = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, DS = 0, Yy = 1, RS = 2, Zg = 1, BS = 2, Lr = 3, $n = 0, vn = 1, zi = 2, _n = 0, dr = 1, qd = 2, Xd = 3, Yd = 4, or = 5, kr = 100, zx = 101, Qx = 102, Rm = 103, Bm = 104, Pm = 200, Lm = 201, Um = 202, Fm = 203, Xl = 204, Yl = 205, Om = 206, Nm = 207, km = 208, Gm = 209, Hx = 210, ch = 211, hh = 212, uh = 213, dh = 214, Vx = 0, Wx = 1, jx = 2, Kl = 3, qx = 4, Xx = 5, Yx = 6, Kx = 7, _c = 0, PS = 1, LS = 2, Vr = 0, Jx = 1, $x = 2, Zx = 3, eA = 4, ew = 5, Ky = "attached", US = "detached", iu = 300, qr = 301, go = 302, Ia = 303, Kd = 304, xc = 306, xn = 1e3, Zt = 1001, Xr = 1002, pi = 1003, Jl = 1004, co = 1005, tt = 1006, nu = 1007, Qn = 1008, Jy = 1008, Ft = 1009, tw = 1010, iw = 1011, Lp = 1012, tA = 1013, qs = 1014, Xt = 1015, Qt = 1016, iA = 1017, nA = 1018, wa = 1020, FS = 1021, ei = 1023, OS = 1024, NS = 1025, Ea = 1026, $l = 1027, ao = 1028, nw = 1029, bl = 1030, sw = 1031, rw = 1033, Dd = 33776, ff = 33777, mf = 33778, Rd = 33779, zm = 35840, $y = 35841, Qm = 35842, Zy = 35843, aw = 36196, Hm = 37492, Vm = 37496, Wm = 37808, e0 = 37809, t0 = 37810, i0 = 37811, Jd = 37812, n0 = 37813, s0 = 37814, r0 = 37815, a0 = 37816, o0 = 37817, l0 = 37818, c0 = 37819, h0 = 37820, u0 = 37821, Bd = 36492, d0 = 36494, p0 = 36495, kS = 36283, f0 = 36284, m0 = 36285, g0 = 36286, jm = 2200, qm = 2201, GS = 2202, Zl = 2300, Ao = 2301, gf = 2302, Sl = 2400, Cl = 2401, $d = 2402, sA = 2500, ow = 2501, zS = 0, lw = 1, Xm = 2, Ym = 3e3, ga = 3001, kl = 3200, cw = 3201, Ts = 0, hw = 1, Wt = "", dt = "srgb", Mt = "srgb-linear", su = "display-p3", ru = "display-p3-linear", Es = "rgbm-16", Zd = "linear", mi = "srgb", ep = "rec709", tp = "p3", Or = 7680, Km = 519, QS = 512, HS = 513, VS = 514, WS = 515, jS = 516, qS = 517, XS = 518, YS = 519, ip = 35044, KS = "100", Jm = "300 es", $m = 1035, zr = 2e3, np = 2001;
class Vi {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const r = n.indexOf(t);
      r !== -1 && n.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const n = i.slice(0);
      for (let r = 0, a = n.length; r < a; r++)
        n[r].call(this, e);
      e.target = null;
    }
  }
}
const wn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let A0 = 1234567;
const ho = Math.PI / 180, ec = 180 / Math.PI;
function ps() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (wn[s & 255] + wn[s >> 8 & 255] + wn[s >> 16 & 255] + wn[s >> 24 & 255] + "-" + wn[e & 255] + wn[e >> 8 & 255] + "-" + wn[e >> 16 & 15 | 64] + wn[e >> 24 & 255] + "-" + wn[t & 63 | 128] + wn[t >> 8 & 255] + "-" + wn[t >> 16 & 255] + wn[t >> 24 & 255] + wn[i & 255] + wn[i >> 8 & 255] + wn[i >> 16 & 255] + wn[i >> 24 & 255]).toLowerCase();
}
function Di(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
function rA(s, e) {
  return (s % e + e) % e;
}
function JS(s, e, t, i, n) {
  return i + (s - e) * (n - i) / (t - e);
}
function $S(s, e, t) {
  return s !== e ? (t - s) / (e - s) : 0;
}
function vh(s, e, t) {
  return (1 - t) * s + t * e;
}
function ZS(s, e, t, i) {
  return vh(s, e, 1 - Math.exp(-t * i));
}
function eC(s, e = 1) {
  return e - Math.abs(rA(s, e * 2) - e);
}
function tC(s, e, t) {
  return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * (3 - 2 * s));
}
function iC(s, e, t) {
  return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * s * (s * (s * 6 - 15) + 10));
}
function nC(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function sC(s, e) {
  return s + Math.random() * (e - s);
}
function rC(s) {
  return s * (0.5 - Math.random());
}
function aC(s) {
  s !== void 0 && (A0 = s);
  let e = A0 += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function oC(s) {
  return s * ho;
}
function lC(s) {
  return s * ec;
}
function Zm(s) {
  return (s & s - 1) === 0 && s !== 0;
}
function uw(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function sp(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function cC(s, e, t, i, n) {
  const r = Math.cos, a = Math.sin, o = r(t / 2), l = a(t / 2), c = r((e + i) / 2), h = a((e + i) / 2), u = r((e - i) / 2), d = a((e - i) / 2), p = r((i - e) / 2), f = a((i - e) / 2);
  switch (n) {
    case "XYX":
      s.set(o * h, l * u, l * d, o * c);
      break;
    case "YZY":
      s.set(l * d, o * h, l * u, o * c);
      break;
    case "ZXZ":
      s.set(l * u, l * d, o * h, o * c);
      break;
    case "XZX":
      s.set(o * h, l * f, l * p, o * c);
      break;
    case "YXY":
      s.set(l * p, o * h, l * f, o * c);
      break;
    case "ZYZ":
      s.set(l * f, l * p, o * h, o * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n);
  }
}
function Yn(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function vt(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const ri = {
  DEG2RAD: ho,
  RAD2DEG: ec,
  generateUUID: ps,
  clamp: Di,
  euclideanModulo: rA,
  mapLinear: JS,
  inverseLerp: $S,
  lerp: vh,
  damp: ZS,
  pingpong: eC,
  smoothstep: tC,
  smootherstep: iC,
  randInt: nC,
  randFloat: sC,
  randFloatSpread: rC,
  seededRandom: aC,
  degToRad: oC,
  radToDeg: lC,
  isPowerOfTwo: Zm,
  ceilPowerOfTwo: uw,
  floorPowerOfTwo: sp,
  setQuaternionFromProperEuler: cC,
  normalize: vt,
  denormalize: Yn
};
class ie {
  constructor(e = 0, t = 0) {
    ie.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, n = e.elements;
    return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Di(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t), n = Math.sin(t), r = this.x - e.x, a = this.y - e.y;
    return this.x = r * i - a * n + e.x, this.y = r * n + a * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class yt {
  constructor(e, t, i, n, r, a, o, l, c) {
    yt.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, i, n, r, a, o, l, c);
  }
  set(e, t, i, n, r, a, o, l, c) {
    const h = this.elements;
    return h[0] = e, h[1] = n, h[2] = o, h[3] = t, h[4] = r, h[5] = l, h[6] = i, h[7] = a, h[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, n = t.elements, r = this.elements, a = i[0], o = i[3], l = i[6], c = i[1], h = i[4], u = i[7], d = i[2], p = i[5], f = i[8], y = n[0], A = n[3], m = n[6], v = n[1], g = n[4], _ = n[7], w = n[2], S = n[5], C = n[8];
    return r[0] = a * y + o * v + l * w, r[3] = a * A + o * g + l * S, r[6] = a * m + o * _ + l * C, r[1] = c * y + h * v + u * w, r[4] = c * A + h * g + u * S, r[7] = c * m + h * _ + u * C, r[2] = d * y + p * v + f * w, r[5] = d * A + p * g + f * S, r[8] = d * m + p * _ + f * C, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], o = e[5], l = e[6], c = e[7], h = e[8];
    return t * a * h - t * o * c - i * r * h + i * o * l + n * r * c - n * a * l;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], o = e[5], l = e[6], c = e[7], h = e[8], u = h * a - o * c, d = o * l - h * r, p = c * r - a * l, f = t * u + i * d + n * p;
    if (f === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const y = 1 / f;
    return e[0] = u * y, e[1] = (n * c - h * i) * y, e[2] = (o * i - n * a) * y, e[3] = d * y, e[4] = (h * t - n * l) * y, e[5] = (n * r - o * t) * y, e[6] = p * y, e[7] = (i * l - c * t) * y, e[8] = (a * t - i * r) * y, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, i, n, r, a, o) {
    const l = Math.cos(r), c = Math.sin(r);
    return this.set(
      i * l,
      i * c,
      -i * (l * a + c * o) + a + e,
      -n * c,
      n * l,
      -n * (-c * a + l * o) + o + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(Af.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Af.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Af.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      -i,
      0,
      i,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let n = 0; n < 9; n++)
      if (t[n] !== i[n]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Af = /* @__PURE__ */ new yt();
function dw(s) {
  for (let e = s.length - 1; e >= 0; --e)
    if (s[e] >= 65535) return !0;
  return !1;
}
const hC = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function Ml(s, e) {
  return new hC[s](e);
}
function Lh(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function uC() {
  const s = Lh("canvas");
  return s.style.display = "block", s;
}
const y0 = {};
function _h(s) {
  s in y0 || (y0[s] = !0, console.warn(s));
}
const v0 = /* @__PURE__ */ new yt().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), _0 = /* @__PURE__ */ new yt().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), Su = {
  [Mt]: {
    transfer: Zd,
    primaries: ep,
    toReference: (s) => s,
    fromReference: (s) => s
  },
  [dt]: {
    transfer: mi,
    primaries: ep,
    toReference: (s) => s.convertSRGBToLinear(),
    fromReference: (s) => s.convertLinearToSRGB()
  },
  [ru]: {
    transfer: Zd,
    primaries: tp,
    toReference: (s) => s.applyMatrix3(_0),
    fromReference: (s) => s.applyMatrix3(v0)
  },
  [su]: {
    transfer: mi,
    primaries: tp,
    toReference: (s) => s.convertSRGBToLinear().applyMatrix3(_0),
    fromReference: (s) => s.applyMatrix3(v0).convertLinearToSRGB()
  }
}, dC = /* @__PURE__ */ new Set([Mt, ru]), Rt = {
  enabled: !0,
  _workingColorSpace: Mt,
  get legacyMode() {
    return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled;
  },
  set legacyMode(s) {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !s;
  },
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(s) {
    if (!dC.has(s))
      throw new Error(`Unsupported working color space, "${s}".`);
    this._workingColorSpace = s;
  },
  convert: function(s, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return s;
    const i = Su[e].toReference, n = Su[t].fromReference;
    return n(i(s));
  },
  fromWorkingColorSpace: function(s, e) {
    return this.convert(s, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(s, e) {
    return this.convert(s, e, this._workingColorSpace);
  },
  getPrimaries: function(s) {
    return Su[s].primaries;
  },
  getTransfer: function(s) {
    return s === Wt || s === Es ? Zd : Su[s].transfer;
  }
};
function Gl(s) {
  return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function yf(s) {
  return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
let Jo;
class aA {
  static getDataURL(e, t = !1) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let i;
    if (e instanceof HTMLCanvasElement)
      i = e;
    else {
      Jo === void 0 && (Jo = Lh("canvas")), Jo.width = e.width, Jo.height = e.height;
      const n = Jo.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), i = Jo;
    }
    return !t && (i.width > 2048 || i.height > 2048) ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), i.toDataURL("image/jpeg", 0.6)) : i.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = Lh("canvas");
      t.width = e.width, t.height = e.height;
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const n = i.getImageData(0, 0, e.width, e.height), r = n.data;
      for (let a = 0; a < r.length; a++)
        r[a] = Gl(r[a] / 255) * 255;
      return i.putImageData(n, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Gl(t[i] / 255) * 255) : t[i] = Gl(t[i]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let pC = 0;
class Aa {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: pC++ }), this.uuid = ps(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, n = this.data;
    if (n !== null) {
      let r;
      if (Array.isArray(n)) {
        r = [];
        for (let a = 0, o = n.length; a < o; a++)
          n[a].isDataTexture ? r.push(vf(n[a].image)) : r.push(vf(n[a]));
      } else
        r = vf(n);
      i.url = r;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function vf(s) {
  if (typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap)
    return aA.getDataURL(s);
  if (s.data) {
    let e = [];
    try {
      e = Array.from(s.data);
    } catch (t) {
      t.message.includes("Invalid array length") ? console.warn("Serializing large texture, might not be saved in JSON structure.") : console.error(t), e = s.data;
    }
    return {
      data: e,
      width: s.width,
      height: s.height,
      type: s.data.constructor.name
    };
  } else
    return s.url !== void 0 ? s.url : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let fC = 0;
class Nt extends Vi {
  constructor(e = Nt.DEFAULT_IMAGE, t = Nt.DEFAULT_MAPPING, i = Zt, n = Zt, r = tt, a = Qn, o = ei, l = Ft, c = Nt.DEFAULT_ANISOTROPY, h = Wt) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: fC++ }), this.uuid = ps(), this.name = "", this.source = new Aa(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = a, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = l, this.offset = new ie(0, 0), this.repeat = new ie(1, 1), this.center = new ie(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new yt(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof h == "string" ? this.colorSpace = h : (_h("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = h === ga ? dt : Wt), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1, e instanceof ImageData && e !== Nt.DEFAULT_IMAGE && (this.needsUpdate = !0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      encoding: this.colorSpace === dt ? ga : Ym,
      // deprecated in r152, added for backwards compatibility, remove later
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), !t && e.textures && (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== iu) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case xn:
          e.x = e.x - Math.floor(e.x);
          break;
        case Zt:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Xr:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case xn:
          e.y = e.y - Math.floor(e.y);
          break;
        case Zt:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Xr:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0, this.dispatchEvent({ type: "update" }));
  }
  get encoding() {
    return _h("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === dt ? ga : Ym;
  }
  set encoding(e) {
    _h("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === ga ? dt : Wt;
  }
}
Nt.DEFAULT_IMAGE = null;
Nt.DEFAULT_MAPPING = iu;
Nt.DEFAULT_ANISOTROPY = 1;
class it {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    it.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = n;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, n) {
    return this.x = e, this.y = t, this.z = i, this.w = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, n = this.z, r = this.w, a = e.elements;
    return this.x = a[0] * t + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * t + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * t + a[6] * i + a[10] * n + a[14] * r, this.w = a[3] * t + a[7] * i + a[11] * n + a[15] * r, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, n, r;
    const l = e.elements, c = l[0], h = l[4], u = l[8], d = l[1], p = l[5], f = l[9], y = l[2], A = l[6], m = l[10];
    if (Math.abs(h - d) < 0.01 && Math.abs(u - y) < 0.01 && Math.abs(f - A) < 0.01) {
      if (Math.abs(h + d) < 0.1 && Math.abs(u + y) < 0.1 && Math.abs(f + A) < 0.1 && Math.abs(c + p + m - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const g = (c + 1) / 2, _ = (p + 1) / 2, w = (m + 1) / 2, S = (h + d) / 4, C = (u + y) / 4, E = (f + A) / 4;
      return g > _ && g > w ? g < 0.01 ? (i = 0, n = 0.707106781, r = 0.707106781) : (i = Math.sqrt(g), n = S / i, r = C / i) : _ > w ? _ < 0.01 ? (i = 0.707106781, n = 0, r = 0.707106781) : (n = Math.sqrt(_), i = S / n, r = E / n) : w < 0.01 ? (i = 0.707106781, n = 0.707106781, r = 0) : (r = Math.sqrt(w), i = C / r, n = E / r), this.set(i, n, r, t), this;
    }
    let v = Math.sqrt((A - f) * (A - f) + (u - y) * (u - y) + (d - h) * (d - h));
    return Math.abs(v) < 1e-3 && (v = 1), this.x = (A - f) / v, this.y = (u - y) / v, this.z = (d - h) / v, this.w = Math.acos((c + p + m - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class mC extends Vi {
  constructor(e = 1, t = 1, i = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new it(0, 0, e, t), this.scissorTest = !1, this.viewport = new it(0, 0, e, t);
    const n = { width: e, height: t, depth: 1 };
    i.encoding !== void 0 && (_h("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), i.colorSpace = i.encoding === ga ? dt : Wt), i = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: tt,
      depthBuffer: !0,
      stencilBuffer: !1,
      depthTexture: null,
      samples: 0
    }, i), this.texture = new Nt(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = i.generateMipmaps, this.texture.internalFormat = i.internalFormat, this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new Aa(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Zn extends mC {
  constructor(e = 1, t = 1, i = {}) {
    super(e, t, i), this.isWebGLRenderTarget = !0;
  }
}
class oA extends Nt {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = pi, this.minFilter = pi, this.wrapR = Zt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class qk extends Zn {
  constructor(e = 1, t = 1, i = 1) {
    super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = i, this.texture = new oA(null, e, t, i), this.texture.isRenderTargetTexture = !0;
  }
}
class lA extends Nt {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = pi, this.minFilter = pi, this.wrapR = Zt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Xk extends Zn {
  constructor(e = 1, t = 1, i = 1) {
    super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = i, this.texture = new lA(null, e, t, i), this.texture.isRenderTargetTexture = !0;
  }
}
class gC extends Zn {
  constructor(e = 1, t = 1, i = 1, n = {}) {
    super(e, t, n), this.isWebGLMultipleRenderTargets = !0;
    const r = this.texture;
    this.texture = [];
    for (let a = 0; a < i; a++)
      this.texture[a] = r.clone(), this.texture[a].isRenderTargetTexture = !0;
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      this.width = e, this.height = t, this.depth = i;
      for (let n = 0, r = this.texture.length; n < r; n++)
        this.texture[n].image.width = e, this.texture[n].image.height = t, this.texture[n].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, i = e.texture.length; t < i; t++)
      this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}
class rt {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = n;
  }
  static slerpFlat(e, t, i, n, r, a, o) {
    let l = i[n + 0], c = i[n + 1], h = i[n + 2], u = i[n + 3];
    const d = r[a + 0], p = r[a + 1], f = r[a + 2], y = r[a + 3];
    if (o === 0) {
      e[t + 0] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = u;
      return;
    }
    if (o === 1) {
      e[t + 0] = d, e[t + 1] = p, e[t + 2] = f, e[t + 3] = y;
      return;
    }
    if (u !== y || l !== d || c !== p || h !== f) {
      let A = 1 - o;
      const m = l * d + c * p + h * f + u * y, v = m >= 0 ? 1 : -1, g = 1 - m * m;
      if (g > Number.EPSILON) {
        const w = Math.sqrt(g), S = Math.atan2(w, m * v);
        A = Math.sin(A * S) / w, o = Math.sin(o * S) / w;
      }
      const _ = o * v;
      if (l = l * A + d * _, c = c * A + p * _, h = h * A + f * _, u = u * A + y * _, A === 1 - o) {
        const w = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
        l *= w, c *= w, h *= w, u *= w;
      }
    }
    e[t] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = u;
  }
  static multiplyQuaternionsFlat(e, t, i, n, r, a) {
    const o = i[n], l = i[n + 1], c = i[n + 2], h = i[n + 3], u = r[a], d = r[a + 1], p = r[a + 2], f = r[a + 3];
    return e[t] = o * f + h * u + l * p - c * d, e[t + 1] = l * f + h * d + c * u - o * p, e[t + 2] = c * f + h * p + o * d - l * u, e[t + 3] = h * f - o * u - l * d - c * p, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, i, n) {
    return this._x = e, this._y = t, this._z = i, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const i = e._x, n = e._y, r = e._z, a = e._order, o = Math.cos, l = Math.sin, c = o(i / 2), h = o(n / 2), u = o(r / 2), d = l(i / 2), p = l(n / 2), f = l(r / 2);
    switch (a) {
      case "XYZ":
        this._x = d * h * u + c * p * f, this._y = c * p * u - d * h * f, this._z = c * h * f + d * p * u, this._w = c * h * u - d * p * f;
        break;
      case "YXZ":
        this._x = d * h * u + c * p * f, this._y = c * p * u - d * h * f, this._z = c * h * f - d * p * u, this._w = c * h * u + d * p * f;
        break;
      case "ZXY":
        this._x = d * h * u - c * p * f, this._y = c * p * u + d * h * f, this._z = c * h * f + d * p * u, this._w = c * h * u - d * p * f;
        break;
      case "ZYX":
        this._x = d * h * u - c * p * f, this._y = c * p * u + d * h * f, this._z = c * h * f - d * p * u, this._w = c * h * u + d * p * f;
        break;
      case "YZX":
        this._x = d * h * u + c * p * f, this._y = c * p * u + d * h * f, this._z = c * h * f - d * p * u, this._w = c * h * u - d * p * f;
        break;
      case "XZY":
        this._x = d * h * u - c * p * f, this._y = c * p * u - d * h * f, this._z = c * h * f + d * p * u, this._w = c * h * u + d * p * f;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2, n = Math.sin(i);
    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, i = t[0], n = t[4], r = t[8], a = t[1], o = t[5], l = t[9], c = t[2], h = t[6], u = t[10], d = i + o + u;
    if (d > 0) {
      const p = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / p, this._x = (h - l) * p, this._y = (r - c) * p, this._z = (a - n) * p;
    } else if (i > o && i > u) {
      const p = 2 * Math.sqrt(1 + i - o - u);
      this._w = (h - l) / p, this._x = 0.25 * p, this._y = (n + a) / p, this._z = (r + c) / p;
    } else if (o > u) {
      const p = 2 * Math.sqrt(1 + o - i - u);
      this._w = (r - c) / p, this._x = (n + a) / p, this._y = 0.25 * p, this._z = (l + h) / p;
    } else {
      const p = 2 * Math.sqrt(1 + u - i - o);
      this._w = (a - n) / p, this._x = (r + c) / p, this._y = (l + h) / p, this._z = 0.25 * p;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Di(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const n = Math.min(1, t / i);
    return this.slerp(e, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x, n = e._y, r = e._z, a = e._w, o = t._x, l = t._y, c = t._z, h = t._w;
    return this._x = i * h + a * o + n * c - r * l, this._y = n * h + a * l + r * o - i * c, this._z = r * h + a * c + i * l - n * o, this._w = a * h - i * o - n * l - r * c, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x, n = this._y, r = this._z, a = this._w;
    let o = a * e._w + i * e._x + n * e._y + r * e._z;
    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1)
      return this._w = a, this._x = i, this._y = n, this._z = r, this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const p = 1 - t;
      return this._w = p * a + t * this._w, this._x = p * i + t * this._x, this._y = p * n + t * this._y, this._z = p * r + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const c = Math.sqrt(l), h = Math.atan2(c, o), u = Math.sin((1 - t) * h) / c, d = Math.sin(t * h) / c;
    return this._w = a * u + this._w * d, this._x = i * u + this._x * d, this._y = n * u + this._y * d, this._z = r * u + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), i = Math.sqrt(e), n = 2 * Math.PI * Math.random(), r = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(n),
      i * Math.sin(r),
      i * Math.cos(r),
      t * Math.sin(n)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class M {
  constructor(e = 0, t = 0, i = 0) {
    M.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i;
  }
  set(e, t, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(x0.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(x0.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, n = this.z, r = e.elements;
    return this.x = r[0] * t + r[3] * i + r[6] * n, this.y = r[1] * t + r[4] * i + r[7] * n, this.z = r[2] * t + r[5] * i + r[8] * n, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, n = this.z, r = e.elements, a = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
    return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * a, this;
  }
  applyQuaternion(e) {
    const t = this.x, i = this.y, n = this.z, r = e.x, a = e.y, o = e.z, l = e.w, c = 2 * (a * n - o * i), h = 2 * (o * t - r * n), u = 2 * (r * i - a * t);
    return this.x = t + l * c + a * u - o * h, this.y = i + l * h + o * c - r * u, this.z = n + l * u + r * h - a * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, i = this.y, n = this.z, r = e.elements;
    return this.x = r[0] * t + r[4] * i + r[8] * n, this.y = r[1] * t + r[5] * i + r[9] * n, this.z = r[2] * t + r[6] * i + r[10] * n, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x, n = e.y, r = e.z, a = t.x, o = t.y, l = t.z;
    return this.x = n * l - r * o, this.y = r * a - i * l, this.z = i * o - n * a, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return _f.copy(this).projectOnVector(e), this.sub(_f);
  }
  reflect(e) {
    return this.sub(_f.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Di(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y, n = this.z - e.z;
    return t * t + i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const n = Math.sin(t) * e;
    return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = i, this.z = n, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, i = Math.sqrt(1 - e ** 2);
    return this.x = i * Math.cos(t), this.y = i * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const _f = /* @__PURE__ */ new M(), x0 = /* @__PURE__ */ new rt();
class is {
  constructor(e = new M(1 / 0, 1 / 0, 1 / 0), t = new M(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(Fs.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(Fs.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = Fs.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const r = i.getAttribute("position");
      if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, o = r.count; a < o; a++)
          e.isMesh === !0 ? e.getVertexPosition(a, Fs) : Fs.fromBufferAttribute(r, a), Fs.applyMatrix4(e.matrixWorld), this.expandByPoint(Fs);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Cu.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), Cu.copy(i.boundingBox)), Cu.applyMatrix4(e.matrixWorld), this.union(Cu);
    }
    const n = e.children;
    for (let r = 0, a = n.length; r < a; r++)
      this.expandByObject(n[r], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Fs), Fs.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, i;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(jc), Mu.subVectors(this.max, jc), $o.subVectors(e.a, jc), Zo.subVectors(e.b, jc), el.subVectors(e.c, jc), sa.subVectors(Zo, $o), ra.subVectors(el, Zo), Qa.subVectors($o, el);
    let t = [
      0,
      -sa.z,
      sa.y,
      0,
      -ra.z,
      ra.y,
      0,
      -Qa.z,
      Qa.y,
      sa.z,
      0,
      -sa.x,
      ra.z,
      0,
      -ra.x,
      Qa.z,
      0,
      -Qa.x,
      -sa.y,
      sa.x,
      0,
      -ra.y,
      ra.x,
      0,
      -Qa.y,
      Qa.x,
      0
    ];
    return !xf(t, $o, Zo, el, Mu) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !xf(t, $o, Zo, el, Mu)) ? !1 : (Tu.crossVectors(sa, ra), t = [Tu.x, Tu.y, Tu.z], xf(t, $o, Zo, el, Mu));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Fs).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Fs).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Cr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Cr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Cr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Cr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Cr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Cr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Cr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Cr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Cr), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Cr = [
  /* @__PURE__ */ new M(),
  /* @__PURE__ */ new M(),
  /* @__PURE__ */ new M(),
  /* @__PURE__ */ new M(),
  /* @__PURE__ */ new M(),
  /* @__PURE__ */ new M(),
  /* @__PURE__ */ new M(),
  /* @__PURE__ */ new M()
], Fs = /* @__PURE__ */ new M(), Cu = /* @__PURE__ */ new is(), $o = /* @__PURE__ */ new M(), Zo = /* @__PURE__ */ new M(), el = /* @__PURE__ */ new M(), sa = /* @__PURE__ */ new M(), ra = /* @__PURE__ */ new M(), Qa = /* @__PURE__ */ new M(), jc = /* @__PURE__ */ new M(), Mu = /* @__PURE__ */ new M(), Tu = /* @__PURE__ */ new M(), Ha = /* @__PURE__ */ new M();
function xf(s, e, t, i, n) {
  for (let r = 0, a = s.length - 3; r <= a; r += 3) {
    Ha.fromArray(s, r);
    const o = n.x * Math.abs(Ha.x) + n.y * Math.abs(Ha.y) + n.z * Math.abs(Ha.z), l = e.dot(Ha), c = t.dot(Ha), h = i.dot(Ha);
    if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > o)
      return !1;
  }
  return !0;
}
const AC = /* @__PURE__ */ new is(), qc = /* @__PURE__ */ new M(), wf = /* @__PURE__ */ new M();
class ns {
  constructor(e = new M(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : AC.setFromPoints(e).getCenter(i);
    let n = 0;
    for (let r = 0, a = e.length; r < a; r++)
      n = Math.max(n, i.distanceToSquared(e[r]));
    return this.radius = Math.sqrt(n), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    qc.subVectors(e, this.center);
    const t = qc.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t), n = (i - this.radius) * 0.5;
      this.center.addScaledVector(qc, n / i), this.radius += n;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (wf.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(qc.copy(e.center).add(wf)), this.expandByPoint(qc.copy(e.center).sub(wf))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Mr = /* @__PURE__ */ new M(), Ef = /* @__PURE__ */ new M(), Iu = /* @__PURE__ */ new M(), aa = /* @__PURE__ */ new M(), bf = /* @__PURE__ */ new M(), Du = /* @__PURE__ */ new M(), Sf = /* @__PURE__ */ new M();
class wc {
  constructor(e = new M(), t = new M(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Mr)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Mr.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (Mr.copy(this.origin).addScaledVector(this.direction, t), Mr.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, n) {
    Ef.copy(e).add(t).multiplyScalar(0.5), Iu.copy(t).sub(e).normalize(), aa.copy(this.origin).sub(Ef);
    const r = e.distanceTo(t) * 0.5, a = -this.direction.dot(Iu), o = aa.dot(this.direction), l = -aa.dot(Iu), c = aa.lengthSq(), h = Math.abs(1 - a * a);
    let u, d, p, f;
    if (h > 0)
      if (u = a * l - o, d = a * o - l, f = r * h, u >= 0)
        if (d >= -f)
          if (d <= f) {
            const y = 1 / h;
            u *= y, d *= y, p = u * (u + a * d + 2 * o) + d * (a * u + d + 2 * l) + c;
          } else
            d = r, u = Math.max(0, -(a * d + o)), p = -u * u + d * (d + 2 * l) + c;
        else
          d = -r, u = Math.max(0, -(a * d + o)), p = -u * u + d * (d + 2 * l) + c;
      else
        d <= -f ? (u = Math.max(0, -(-a * r + o)), d = u > 0 ? -r : Math.min(Math.max(-r, -l), r), p = -u * u + d * (d + 2 * l) + c) : d <= f ? (u = 0, d = Math.min(Math.max(-r, -l), r), p = d * (d + 2 * l) + c) : (u = Math.max(0, -(a * r + o)), d = u > 0 ? r : Math.min(Math.max(-r, -l), r), p = -u * u + d * (d + 2 * l) + c);
    else
      d = a > 0 ? -r : r, u = Math.max(0, -(a * d + o)), p = -u * u + d * (d + 2 * l) + c;
    return i && i.copy(this.origin).addScaledVector(this.direction, u), n && n.copy(Ef).addScaledVector(Iu, d), p;
  }
  intersectSphere(e, t) {
    Mr.subVectors(e.center, this.origin);
    const i = Mr.dot(this.direction), n = Mr.dot(Mr) - i * i, r = e.radius * e.radius;
    if (n > r) return null;
    const a = Math.sqrt(r - n), o = i - a, l = i + a;
    return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, n, r, a, o, l;
    const c = 1 / this.direction.x, h = 1 / this.direction.y, u = 1 / this.direction.z, d = this.origin;
    return c >= 0 ? (i = (e.min.x - d.x) * c, n = (e.max.x - d.x) * c) : (i = (e.max.x - d.x) * c, n = (e.min.x - d.x) * c), h >= 0 ? (r = (e.min.y - d.y) * h, a = (e.max.y - d.y) * h) : (r = (e.max.y - d.y) * h, a = (e.min.y - d.y) * h), i > a || r > n || ((r > i || isNaN(i)) && (i = r), (a < n || isNaN(n)) && (n = a), u >= 0 ? (o = (e.min.z - d.z) * u, l = (e.max.z - d.z) * u) : (o = (e.max.z - d.z) * u, l = (e.min.z - d.z) * u), i > l || o > n) || ((o > i || i !== i) && (i = o), (l < n || n !== n) && (n = l), n < 0) ? null : this.at(i >= 0 ? i : n, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Mr) !== null;
  }
  intersectTriangle(e, t, i, n, r) {
    bf.subVectors(t, e), Du.subVectors(i, e), Sf.crossVectors(bf, Du);
    let a = this.direction.dot(Sf), o;
    if (a > 0) {
      if (n) return null;
      o = 1;
    } else if (a < 0)
      o = -1, a = -a;
    else
      return null;
    aa.subVectors(this.origin, e);
    const l = o * this.direction.dot(Du.crossVectors(aa, Du));
    if (l < 0)
      return null;
    const c = o * this.direction.dot(bf.cross(aa));
    if (c < 0 || l + c > a)
      return null;
    const h = -o * aa.dot(Sf);
    return h < 0 ? null : this.at(h / a, r);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ue {
  constructor(e, t, i, n, r, a, o, l, c, h, u, d, p, f, y, A) {
    Ue.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, i, n, r, a, o, l, c, h, u, d, p, f, y, A);
  }
  set(e, t, i, n, r, a, o, l, c, h, u, d, p, f, y, A) {
    const m = this.elements;
    return m[0] = e, m[4] = t, m[8] = i, m[12] = n, m[1] = r, m[5] = a, m[9] = o, m[13] = l, m[2] = c, m[6] = h, m[10] = u, m[14] = d, m[3] = p, m[7] = f, m[11] = y, m[15] = A, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Ue().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
  }
  copyPosition(e) {
    const t = this.elements, i = e.elements;
    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, i) {
    return this.set(
      e.x,
      t.x,
      i.x,
      0,
      e.y,
      t.y,
      i.y,
      0,
      e.z,
      t.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, i = e.elements, n = 1 / tl.setFromMatrixColumn(e, 0).length(), r = 1 / tl.setFromMatrixColumn(e, 1).length(), a = 1 / tl.setFromMatrixColumn(e, 2).length();
    return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * r, t[5] = i[5] * r, t[6] = i[6] * r, t[7] = 0, t[8] = i[8] * a, t[9] = i[9] * a, t[10] = i[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, i = e.x, n = e.y, r = e.z, a = Math.cos(i), o = Math.sin(i), l = Math.cos(n), c = Math.sin(n), h = Math.cos(r), u = Math.sin(r);
    if (e.order === "XYZ") {
      const d = a * h, p = a * u, f = o * h, y = o * u;
      t[0] = l * h, t[4] = -l * u, t[8] = c, t[1] = p + f * c, t[5] = d - y * c, t[9] = -o * l, t[2] = y - d * c, t[6] = f + p * c, t[10] = a * l;
    } else if (e.order === "YXZ") {
      const d = l * h, p = l * u, f = c * h, y = c * u;
      t[0] = d + y * o, t[4] = f * o - p, t[8] = a * c, t[1] = a * u, t[5] = a * h, t[9] = -o, t[2] = p * o - f, t[6] = y + d * o, t[10] = a * l;
    } else if (e.order === "ZXY") {
      const d = l * h, p = l * u, f = c * h, y = c * u;
      t[0] = d - y * o, t[4] = -a * u, t[8] = f + p * o, t[1] = p + f * o, t[5] = a * h, t[9] = y - d * o, t[2] = -a * c, t[6] = o, t[10] = a * l;
    } else if (e.order === "ZYX") {
      const d = a * h, p = a * u, f = o * h, y = o * u;
      t[0] = l * h, t[4] = f * c - p, t[8] = d * c + y, t[1] = l * u, t[5] = y * c + d, t[9] = p * c - f, t[2] = -c, t[6] = o * l, t[10] = a * l;
    } else if (e.order === "YZX") {
      const d = a * l, p = a * c, f = o * l, y = o * c;
      t[0] = l * h, t[4] = y - d * u, t[8] = f * u + p, t[1] = u, t[5] = a * h, t[9] = -o * h, t[2] = -c * h, t[6] = p * u + f, t[10] = d - y * u;
    } else if (e.order === "XZY") {
      const d = a * l, p = a * c, f = o * l, y = o * c;
      t[0] = l * h, t[4] = -u, t[8] = c * h, t[1] = d * u + y, t[5] = a * h, t[9] = p * u - f, t[2] = f * u - p, t[6] = o * h, t[10] = y * u + d;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(yC, e, vC);
  }
  lookAt(e, t, i) {
    const n = this.elements;
    return as.subVectors(e, t), as.lengthSq() === 0 && (as.z = 1), as.normalize(), oa.crossVectors(i, as), oa.lengthSq() === 0 && (Math.abs(i.z) === 1 ? as.x += 1e-4 : as.z += 1e-4, as.normalize(), oa.crossVectors(i, as)), oa.normalize(), Ru.crossVectors(as, oa), n[0] = oa.x, n[4] = Ru.x, n[8] = as.x, n[1] = oa.y, n[5] = Ru.y, n[9] = as.y, n[2] = oa.z, n[6] = Ru.z, n[10] = as.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, n = t.elements, r = this.elements, a = i[0], o = i[4], l = i[8], c = i[12], h = i[1], u = i[5], d = i[9], p = i[13], f = i[2], y = i[6], A = i[10], m = i[14], v = i[3], g = i[7], _ = i[11], w = i[15], S = n[0], C = n[4], E = n[8], x = n[12], b = n[1], D = n[5], O = n[9], Y = n[13], B = n[2], Q = n[6], j = n[10], X = n[14], Z = n[3], ee = n[7], J = n[11], W = n[15];
    return r[0] = a * S + o * b + l * B + c * Z, r[4] = a * C + o * D + l * Q + c * ee, r[8] = a * E + o * O + l * j + c * J, r[12] = a * x + o * Y + l * X + c * W, r[1] = h * S + u * b + d * B + p * Z, r[5] = h * C + u * D + d * Q + p * ee, r[9] = h * E + u * O + d * j + p * J, r[13] = h * x + u * Y + d * X + p * W, r[2] = f * S + y * b + A * B + m * Z, r[6] = f * C + y * D + A * Q + m * ee, r[10] = f * E + y * O + A * j + m * J, r[14] = f * x + y * Y + A * X + m * W, r[3] = v * S + g * b + _ * B + w * Z, r[7] = v * C + g * D + _ * Q + w * ee, r[11] = v * E + g * O + _ * j + w * J, r[15] = v * x + g * Y + _ * X + w * W, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[4], n = e[8], r = e[12], a = e[1], o = e[5], l = e[9], c = e[13], h = e[2], u = e[6], d = e[10], p = e[14], f = e[3], y = e[7], A = e[11], m = e[15];
    return f * (+r * l * u - n * c * u - r * o * d + i * c * d + n * o * p - i * l * p) + y * (+t * l * p - t * c * d + r * a * d - n * a * p + n * c * h - r * l * h) + A * (+t * c * u - t * o * p - r * a * u + i * a * p + r * o * h - i * c * h) + m * (-n * o * h - t * l * u + t * o * d + n * a * u - i * a * d + i * l * h);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, i) {
    const n = this.elements;
    return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], o = e[5], l = e[6], c = e[7], h = e[8], u = e[9], d = e[10], p = e[11], f = e[12], y = e[13], A = e[14], m = e[15], v = u * A * c - y * d * c + y * l * p - o * A * p - u * l * m + o * d * m, g = f * d * c - h * A * c - f * l * p + a * A * p + h * l * m - a * d * m, _ = h * y * c - f * u * c + f * o * p - a * y * p - h * o * m + a * u * m, w = f * u * l - h * y * l - f * o * d + a * y * d + h * o * A - a * u * A, S = t * v + i * g + n * _ + r * w;
    if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const C = 1 / S;
    return e[0] = v * C, e[1] = (y * d * r - u * A * r - y * n * p + i * A * p + u * n * m - i * d * m) * C, e[2] = (o * A * r - y * l * r + y * n * c - i * A * c - o * n * m + i * l * m) * C, e[3] = (u * l * r - o * d * r - u * n * c + i * d * c + o * n * p - i * l * p) * C, e[4] = g * C, e[5] = (h * A * r - f * d * r + f * n * p - t * A * p - h * n * m + t * d * m) * C, e[6] = (f * l * r - a * A * r - f * n * c + t * A * c + a * n * m - t * l * m) * C, e[7] = (a * d * r - h * l * r + h * n * c - t * d * c - a * n * p + t * l * p) * C, e[8] = _ * C, e[9] = (f * u * r - h * y * r - f * i * p + t * y * p + h * i * m - t * u * m) * C, e[10] = (a * y * r - f * o * r + f * i * c - t * y * c - a * i * m + t * o * m) * C, e[11] = (h * o * r - a * u * r - h * i * c + t * u * c + a * i * p - t * o * p) * C, e[12] = w * C, e[13] = (h * y * n - f * u * n + f * i * d - t * y * d - h * i * A + t * u * A) * C, e[14] = (f * o * n - a * y * n - f * i * l + t * y * l + a * i * A - t * o * A) * C, e[15] = (a * u * n - h * o * n + h * i * l - t * u * l - a * i * d + t * o * d) * C, this;
  }
  scale(e) {
    const t = this.elements, i = e.x, n = e.y, r = e.z;
    return t[0] *= i, t[4] *= n, t[8] *= r, t[1] *= i, t[5] *= n, t[9] *= r, t[2] *= i, t[6] *= n, t[10] *= r, t[3] *= i, t[7] *= n, t[11] *= r, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, n));
  }
  makeTranslation(e, t, i) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t), n = Math.sin(t), r = 1 - i, a = e.x, o = e.y, l = e.z, c = r * a, h = r * o;
    return this.set(
      c * a + i,
      c * o - n * l,
      c * l + n * o,
      0,
      c * o + n * l,
      h * o + i,
      h * l - n * a,
      0,
      c * l - n * o,
      h * l + n * a,
      r * l * l + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, i, n, r, a) {
    return this.set(
      1,
      i,
      r,
      0,
      e,
      1,
      a,
      0,
      t,
      n,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, i) {
    const n = this.elements, r = t._x, a = t._y, o = t._z, l = t._w, c = r + r, h = a + a, u = o + o, d = r * c, p = r * h, f = r * u, y = a * h, A = a * u, m = o * u, v = l * c, g = l * h, _ = l * u, w = i.x, S = i.y, C = i.z;
    return n[0] = (1 - (y + m)) * w, n[1] = (p + _) * w, n[2] = (f - g) * w, n[3] = 0, n[4] = (p - _) * S, n[5] = (1 - (d + m)) * S, n[6] = (A + v) * S, n[7] = 0, n[8] = (f + g) * C, n[9] = (A - v) * C, n[10] = (1 - (d + y)) * C, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
  }
  decompose(e, t, i) {
    const n = this.elements;
    let r = tl.set(n[0], n[1], n[2]).length();
    const a = tl.set(n[4], n[5], n[6]).length(), o = tl.set(n[8], n[9], n[10]).length();
    this.determinant() < 0 && (r = -r), e.x = n[12], e.y = n[13], e.z = n[14], Os.copy(this);
    const c = 1 / r, h = 1 / a, u = 1 / o;
    return Os.elements[0] *= c, Os.elements[1] *= c, Os.elements[2] *= c, Os.elements[4] *= h, Os.elements[5] *= h, Os.elements[6] *= h, Os.elements[8] *= u, Os.elements[9] *= u, Os.elements[10] *= u, t.setFromRotationMatrix(Os), i.x = r, i.y = a, i.z = o, this;
  }
  makePerspective(e, t, i, n, r, a, o = zr) {
    const l = this.elements, c = 2 * r / (t - e), h = 2 * r / (i - n), u = (t + e) / (t - e), d = (i + n) / (i - n);
    let p, f;
    if (o === zr)
      p = -(a + r) / (a - r), f = -2 * a * r / (a - r);
    else if (o === np)
      p = -a / (a - r), f = -a * r / (a - r);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
    return l[0] = c, l[4] = 0, l[8] = u, l[12] = 0, l[1] = 0, l[5] = h, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = p, l[14] = f, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(e, t, i, n, r, a, o = zr) {
    const l = this.elements, c = 1 / (t - e), h = 1 / (i - n), u = 1 / (a - r), d = (t + e) * c, p = (i + n) * h;
    let f, y;
    if (o === zr)
      f = (a + r) * u, y = -2 * u;
    else if (o === np)
      f = r * u, y = -1 * u;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
    return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * h, l[9] = 0, l[13] = -p, l[2] = 0, l[6] = 0, l[10] = y, l[14] = -f, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let n = 0; n < 16; n++)
      if (t[n] !== i[n]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
  }
}
const tl = /* @__PURE__ */ new M(), Os = /* @__PURE__ */ new Ue(), yC = /* @__PURE__ */ new M(0, 0, 0), vC = /* @__PURE__ */ new M(1, 1, 1), oa = /* @__PURE__ */ new M(), Ru = /* @__PURE__ */ new M(), as = /* @__PURE__ */ new M(), w0 = /* @__PURE__ */ new Ue(), E0 = /* @__PURE__ */ new rt();
class xi {
  constructor(e = 0, t = 0, i = 0, n = xi.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = n;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, i, n = this._order) {
    return this._x = e, this._y = t, this._z = i, this._order = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const n = e.elements, r = n[0], a = n[4], o = n[8], l = n[1], c = n[5], h = n[9], u = n[2], d = n[6], p = n[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Di(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-h, p), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(d, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Di(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(o, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, r), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Di(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, r));
        break;
      case "ZYX":
        this._y = Math.asin(-Di(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-a, c));
        break;
      case "YZX":
        this._z = Math.asin(Di(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(o, p));
        break;
      case "XZY":
        this._z = Math.asin(-Di(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-h, p), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return w0.makeRotationFromQuaternion(e), this.setFromRotationMatrix(w0, t, i);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return E0.setFromEuler(this), this.setFromQuaternion(E0, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
xi.DEFAULT_ORDER = "XYZ";
class cA {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let _C = 0;
const b0 = /* @__PURE__ */ new M(), il = /* @__PURE__ */ new rt(), Tr = /* @__PURE__ */ new Ue(), Bu = /* @__PURE__ */ new M(), Xc = /* @__PURE__ */ new M(), xC = /* @__PURE__ */ new M(), wC = /* @__PURE__ */ new rt(), S0 = /* @__PURE__ */ new M(1, 0, 0), C0 = /* @__PURE__ */ new M(0, 1, 0), M0 = /* @__PURE__ */ new M(0, 0, 1), EC = { type: "added" }, bC = { type: "removed" };
class ut extends Vi {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: _C++ }), this.uuid = ps(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ut.DEFAULT_UP.clone();
    const e = new M(), t = new xi(), i = new rt(), n = new M(1, 1, 1);
    function r() {
      i.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(r), i._onChange(a), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      modelViewMatrix: {
        value: new Ue()
      },
      normalMatrix: {
        value: new yt()
      }
    }), this.matrix = new Ue(), this.matrixWorld = new Ue(), this.matrixAutoUpdate = ut.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = ut.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new cA(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender(e, t, i, n, r, a) {
    this.dispatchEvent({ type: "beforeRender", renderer: e, scene: t, camera: i, geometry: n, material: r, group: a });
  }
  onAfterRender(e, t, i, n, r, a) {
    this.dispatchEvent({ type: "afterRender", renderer: e, scene: t, camera: i, geometry: n, material: r, group: a });
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return il.setFromAxisAngle(e, t), this.quaternion.multiply(il), this;
  }
  rotateOnWorldAxis(e, t) {
    return il.setFromAxisAngle(e, t), this.quaternion.premultiply(il), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(S0, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(C0, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(M0, e);
  }
  translateOnAxis(e, t) {
    return b0.copy(e).applyQuaternion(this.quaternion), this.position.add(b0.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(S0, e);
  }
  translateY(e) {
    return this.translateOnAxis(C0, e);
  }
  translateZ(e) {
    return this.translateOnAxis(M0, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Tr.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, i) {
    e.isVector3 ? Bu.copy(e) : Bu.set(e, t, i);
    const n = this.parent;
    this.updateWorldMatrix(!0, !1), Xc.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Tr.lookAt(Xc, Bu, this.up) : Tr.lookAt(Bu, Xc, this.up), this.quaternion.setFromRotationMatrix(Tr), n && (Tr.extractRotation(n.matrixWorld), il.setFromRotationMatrix(Tr), this.quaternion.premultiply(il.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(EC)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(bC)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Tr.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Tr.multiply(e.parent.matrixWorld)), e.applyMatrix4(Tr), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, n = this.children.length; i < n; i++) {
      const a = this.children[i].getObjectByProperty(e, t);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, t) {
    let i = [];
    this[e] === t && i.push(this);
    for (let n = 0, r = this.children.length; n < r; n++) {
      const a = this.children[n].getObjectsByProperty(e, t);
      a.length > 0 && (i = i.concat(a));
    }
    return i;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Xc, e, xC), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Xc, wC, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++)
      t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++)
      t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      (r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const n = this.children;
      for (let r = 0, a = n.length; r < a; r++) {
        const o = n[r];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", i = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {},
      extras: {}
    }, i.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const n = {};
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === !0 && (n.castShadow = !0), this.receiveShadow === !0 && (n.receiveShadow = !0), this.visible === !1 && (n.visible = !1), this.frustumCulled === !1 && (n.frustumCulled = !1), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON()));
    function r(o, l) {
      return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (n.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n.geometry = r(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let c = 0, h = l.length; c < h; c++) {
            const u = l[c];
            r(e.shapes, u);
          }
        else
          r(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          o.push(r(e.materials, this.material[l]));
        n.material = o;
      } else
        n.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (let o = 0; o < this.children.length; o++)
        n.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      n.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        n.animations.push(r(e.animations, l));
      }
    }
    if (t) {
      const o = a(e.geometries), l = a(e.materials), c = a(e.textures), h = a(e.images), u = a(e.shapes), d = a(e.skeletons), p = a(e.animations), f = a(e.nodes);
      o.length > 0 && (i.geometries = o), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), h.length > 0 && (i.images = h), u.length > 0 && (i.shapes = u), d.length > 0 && (i.skeletons = d), p.length > 0 && (i.animations = p), f.length > 0 && (i.nodes = f);
    }
    return i.object = n, i;
    function a(o) {
      const l = [];
      for (const c in o) {
        const h = o[c];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = {};
    for (const [i, n] of Object.entries(e.userData))
      this.userData[i] = !n || n && (n.isTexture || n.isObject3D) ? n : JSON.parse(JSON.stringify(n));
    if (t === !0)
      for (let i = 0; i < e.children.length; i++) {
        const n = e.children[i];
        this.add(n.clone());
      }
    return this;
  }
}
ut.DEFAULT_UP = /* @__PURE__ */ new M(0, 1, 0);
ut.DEFAULT_MATRIX_AUTO_UPDATE = !0;
ut.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Ns = /* @__PURE__ */ new M(), Ir = /* @__PURE__ */ new M(), Cf = /* @__PURE__ */ new M(), Dr = /* @__PURE__ */ new M(), nl = /* @__PURE__ */ new M(), sl = /* @__PURE__ */ new M(), T0 = /* @__PURE__ */ new M(), Mf = /* @__PURE__ */ new M(), Tf = /* @__PURE__ */ new M(), If = /* @__PURE__ */ new M();
let Pu = !1;
class hs {
  constructor(e = new M(), t = new M(), i = new M()) {
    this.a = e, this.b = t, this.c = i;
  }
  static getNormal(e, t, i, n) {
    n.subVectors(i, t), Ns.subVectors(e, t), n.cross(Ns);
    const r = n.lengthSq();
    return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, i, n, r) {
    Ns.subVectors(n, t), Ir.subVectors(i, t), Cf.subVectors(e, t);
    const a = Ns.dot(Ns), o = Ns.dot(Ir), l = Ns.dot(Cf), c = Ir.dot(Ir), h = Ir.dot(Cf), u = a * c - o * o;
    if (u === 0)
      return r.set(-2, -1, -1);
    const d = 1 / u, p = (c * l - o * h) * d, f = (a * h - o * l) * d;
    return r.set(1 - p - f, f, p);
  }
  static containsPoint(e, t, i, n) {
    return this.getBarycoord(e, t, i, n, Dr), Dr.x >= 0 && Dr.y >= 0 && Dr.x + Dr.y <= 1;
  }
  static getUV(e, t, i, n, r, a, o, l) {
    return Pu === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Pu = !0), this.getInterpolation(e, t, i, n, r, a, o, l);
  }
  static getInterpolation(e, t, i, n, r, a, o, l) {
    return this.getBarycoord(e, t, i, n, Dr), l.setScalar(0), l.addScaledVector(r, Dr.x), l.addScaledVector(a, Dr.y), l.addScaledVector(o, Dr.z), l;
  }
  static isFrontFacing(e, t, i, n) {
    return Ns.subVectors(i, t), Ir.subVectors(e, t), Ns.cross(Ir).dot(n) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, n) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
  }
  setFromAttributeAndIndices(e, t, i, n) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Ns.subVectors(this.c, this.b), Ir.subVectors(this.a, this.b), Ns.cross(Ir).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return hs.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return hs.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, i, n, r) {
    return Pu === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Pu = !0), hs.getInterpolation(e, this.a, this.b, this.c, t, i, n, r);
  }
  getInterpolation(e, t, i, n, r) {
    return hs.getInterpolation(e, this.a, this.b, this.c, t, i, n, r);
  }
  containsPoint(e) {
    return hs.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return hs.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a, n = this.b, r = this.c;
    let a, o;
    nl.subVectors(n, i), sl.subVectors(r, i), Mf.subVectors(e, i);
    const l = nl.dot(Mf), c = sl.dot(Mf);
    if (l <= 0 && c <= 0)
      return t.copy(i);
    Tf.subVectors(e, n);
    const h = nl.dot(Tf), u = sl.dot(Tf);
    if (h >= 0 && u <= h)
      return t.copy(n);
    const d = l * u - h * c;
    if (d <= 0 && l >= 0 && h <= 0)
      return a = l / (l - h), t.copy(i).addScaledVector(nl, a);
    If.subVectors(e, r);
    const p = nl.dot(If), f = sl.dot(If);
    if (f >= 0 && p <= f)
      return t.copy(r);
    const y = p * c - l * f;
    if (y <= 0 && c >= 0 && f <= 0)
      return o = c / (c - f), t.copy(i).addScaledVector(sl, o);
    const A = h * f - p * u;
    if (A <= 0 && u - h >= 0 && p - f >= 0)
      return T0.subVectors(r, n), o = (u - h) / (u - h + (p - f)), t.copy(n).addScaledVector(T0, o);
    const m = 1 / (A + y + d);
    return a = y * m, o = d * m, t.copy(i).addScaledVector(nl, a).addScaledVector(sl, o);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const pw = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, la = { h: 0, s: 0, l: 0 }, Lu = { h: 0, s: 0, l: 0 };
function Df(s, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s;
}
class se {
  constructor(e, t, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i);
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const n = e;
      n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n);
    } else
      this.setRGB(e, t, i);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = dt) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Rt.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, i, n = Rt.workingColorSpace) {
    return this.r = e, this.g = t, this.b = i, Rt.toWorkingColorSpace(this, n), this;
  }
  setHSL(e, t, i, n = Rt.workingColorSpace) {
    if (e = rA(e, 1), t = Di(t, 0, 1), i = Di(i, 0, 1), t === 0)
      this.r = this.g = this.b = i;
    else {
      const r = i <= 0.5 ? i * (1 + t) : i + t - i * t, a = 2 * i - r;
      this.r = Df(a, r, e + 1 / 3), this.g = Df(a, r, e), this.b = Df(a, r, e - 1 / 3);
    }
    return Rt.toWorkingColorSpace(this, n), this;
  }
  setStyle(e, t = dt) {
    function i(r) {
      r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let n;
    if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let r;
      const a = n[1], o = n[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(r[4]), this.setRGB(
              Math.min(255, parseInt(r[1], 10)) / 255,
              Math.min(255, parseInt(r[2], 10)) / 255,
              Math.min(255, parseInt(r[3], 10)) / 255,
              t
            );
          if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(r[4]), this.setRGB(
              Math.min(100, parseInt(r[1], 10)) / 100,
              Math.min(100, parseInt(r[2], 10)) / 100,
              Math.min(100, parseInt(r[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(r[4]), this.setHSL(
              parseFloat(r[1]) / 360,
              parseFloat(r[2]) / 100,
              parseFloat(r[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const r = n[1], a = r.length;
      if (a === 3)
        return this.setRGB(
          parseInt(r.charAt(0), 16) / 15,
          parseInt(r.charAt(1), 16) / 15,
          parseInt(r.charAt(2), 16) / 15,
          t
        );
      if (a === 6)
        return this.setHex(parseInt(r, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = dt) {
    const i = pw[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Gl(e.r), this.g = Gl(e.g), this.b = Gl(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = yf(e.r), this.g = yf(e.g), this.b = yf(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = dt) {
    return Rt.fromWorkingColorSpace(En.copy(this), e), Math.round(Di(En.r * 255, 0, 255)) * 65536 + Math.round(Di(En.g * 255, 0, 255)) * 256 + Math.round(Di(En.b * 255, 0, 255));
  }
  getHexString(e = dt) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Rt.workingColorSpace) {
    Rt.fromWorkingColorSpace(En.copy(this), t);
    const i = En.r, n = En.g, r = En.b, a = Math.max(i, n, r), o = Math.min(i, n, r);
    let l, c;
    const h = (o + a) / 2;
    if (o === a)
      l = 0, c = 0;
    else {
      const u = a - o;
      switch (c = h <= 0.5 ? u / (a + o) : u / (2 - a - o), a) {
        case i:
          l = (n - r) / u + (n < r ? 6 : 0);
          break;
        case n:
          l = (r - i) / u + 2;
          break;
        case r:
          l = (i - n) / u + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = c, e.l = h, e;
  }
  getRGB(e, t = Rt.workingColorSpace) {
    return Rt.fromWorkingColorSpace(En.copy(this), t), e.r = En.r, e.g = En.g, e.b = En.b, e;
  }
  getStyle(e = dt) {
    Rt.fromWorkingColorSpace(En.copy(this), e);
    const t = En.r, i = En.g, n = En.b;
    return e !== dt ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(n * 255)})`;
  }
  offsetHSL(e, t, i) {
    return this.getHSL(la), this.setHSL(la.h + e, la.s + t, la.l + i);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, i) {
    return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this;
  }
  lerpHSL(e, t) {
    this.getHSL(la), e.getHSL(Lu);
    const i = vh(la.h, Lu.h, t), n = vh(la.s, Lu.s, t), r = vh(la.l, Lu.l, t);
    return this.setHSL(i, n, r), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, i = this.g, n = this.b, r = e.elements;
    return this.r = r[0] * t + r[3] * i + r[6] * n, this.g = r[1] * t + r[4] * i + r[7] * n, this.b = r[2] * t + r[5] * i + r[8] * n, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const En = /* @__PURE__ */ new se();
se.NAMES = pw;
let SC = 0;
class Yi extends Vi {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: SC++ }), this.uuid = ps(), this.name = "", this.type = "Material", this.blending = dr, this.side = $n, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Xl, this.blendDst = Yl, this.blendEquation = kr, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new se(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Kl, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Km, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Or, this.stencilZFail = Or, this.stencilZPass = Or, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const n = this[t];
        n !== void 0 && (n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : Array.isArray(i) && n && typeof n.fromArray == "function" ? n.fromArray(i) : this[t] = i);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.6001,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== dr && (i.blending = this.blending), this.side !== $n && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== Xl && (i.blendSrc = this.blendSrc), this.blendDst !== Yl && (i.blendDst = this.blendDst), this.blendEquation !== kr && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== Kl && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Km && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Or && (i.stencilFail = this.stencilFail), this.stencilZFail !== Or && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Or && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function n(r) {
      const a = [];
      for (const o in r) {
        const l = r[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (t) {
      const r = n(e.textures), a = n(e.images);
      r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const n = t.length;
      i = new Array(n);
      for (let r = 0; r !== n; ++r)
        i[r] = t[r].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = fw({}, e.userData), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
function fw(s, e) {
  if (!e) return s;
  for (const t of Object.keys(e)) {
    if (t.startsWith("__") || typeof s[t] == "function" || typeof e[t] == "function") continue;
    const i = e[t], n = !i || i.isTexture || i.isObject3D || i.isMaterial;
    !n && typeof e[t].clone == "function" ? s[t] = e[t].clone() : !n && (typeof e[t] == "object" || Array.isArray(e[t])) ? s[t] = fw(Array.isArray(e[t]) ? [] : {}, e[t]) : s[t] = e[t];
  }
  return s;
}
class $s extends Yi {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new se(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = _c, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Gr = /* @__PURE__ */ CC();
function CC() {
  const s = new ArrayBuffer(4), e = new Float32Array(s), t = new Uint32Array(s), i = new Uint32Array(512), n = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27 ? (i[l] = 0, i[l | 256] = 32768, n[l] = 24, n[l | 256] = 24) : c < -14 ? (i[l] = 1024 >> -c - 14, i[l | 256] = 1024 >> -c - 14 | 32768, n[l] = -c - 1, n[l | 256] = -c - 1) : c <= 15 ? (i[l] = c + 15 << 10, i[l | 256] = c + 15 << 10 | 32768, n[l] = 13, n[l | 256] = 13) : c < 128 ? (i[l] = 31744, i[l | 256] = 64512, n[l] = 24, n[l | 256] = 24) : (i[l] = 31744, i[l | 256] = 64512, n[l] = 13, n[l | 256] = 13);
  }
  const r = new Uint32Array(2048), a = new Uint32Array(64), o = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13, h = 0;
    for (; (c & 8388608) === 0; )
      c <<= 1, h -= 8388608;
    c &= -8388609, h += 947912704, r[l] = c | h;
  }
  for (let l = 1024; l < 2048; ++l)
    r[l] = 939524096 + (l - 1024 << 13);
  for (let l = 1; l < 31; ++l)
    a[l] = l << 23;
  a[31] = 1199570944, a[32] = 2147483648;
  for (let l = 33; l < 63; ++l)
    a[l] = 2147483648 + (l - 32 << 23);
  a[63] = 3347054592;
  for (let l = 1; l < 64; ++l)
    l !== 32 && (o[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: n,
    mantissaTable: r,
    exponentTable: a,
    offsetTable: o
  };
}
function jn(s) {
  Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), s = Di(s, -65504, 65504), Gr.floatView[0] = s;
  const e = Gr.uint32View[0], t = e >> 23 & 511;
  return Gr.baseTable[t] + ((e & 8388607) >> Gr.shiftTable[t]);
}
function ph(s) {
  const e = s >> 10;
  return Gr.uint32View[0] = Gr.mantissaTable[Gr.offsetTable[e] + (s & 1023)] + Gr.exponentTable[e], Gr.floatView[0];
}
const Gn = {
  toHalfFloat: jn,
  fromHalfFloat: ph
}, qi = /* @__PURE__ */ new M(), Uu = /* @__PURE__ */ new ie();
class Je {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = ip, this.updateRange = { offset: 0, count: -1 }, this.gpuType = Xt, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, i) {
    e *= this.itemSize, i *= t.itemSize;
    for (let n = 0, r = this.itemSize; n < r; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        Uu.fromBufferAttribute(this, t), Uu.applyMatrix3(e), this.setXY(t, Uu.x, Uu.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        qi.fromBufferAttribute(this, t), qi.applyMatrix3(e), this.setXYZ(t, qi.x, qi.y, qi.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      qi.fromBufferAttribute(this, t), qi.applyMatrix4(e), this.setXYZ(t, qi.x, qi.y, qi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      qi.fromBufferAttribute(this, t), qi.applyNormalMatrix(e), this.setXYZ(t, qi.x, qi.y, qi.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      qi.fromBufferAttribute(this, t), qi.transformDirection(e), this.setXYZ(t, qi.x, qi.y, qi.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return this.normalized && (i = Yn(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return this.normalized && (i = vt(i, this.array)), this.array[e * this.itemSize + t] = i, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Yn(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Yn(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Yn(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Yn(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = vt(t, this.array), i = vt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, n) {
    return e *= this.itemSize, this.normalized && (t = vt(t, this.array), i = vt(i, this.array), n = vt(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this;
  }
  setXYZW(e, t, i, n, r) {
    return e *= this.itemSize, this.normalized && (t = vt(t, this.array), i = vt(i, this.array), n = vt(n, this.array), r = vt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== ip && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
class Yk extends Je {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i);
  }
}
class Kk extends Je {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i);
  }
}
class Jk extends Je {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i);
  }
}
class $k extends Je {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i);
  }
}
class hA extends Je {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class Zk extends Je {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i);
  }
}
class mw extends Je {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class eG extends Je {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = ph(this.array[e * this.itemSize]);
    return this.normalized && (t = Yn(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize] = jn(t), this;
  }
  getY(e) {
    let t = ph(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Yn(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize + 1] = jn(t), this;
  }
  getZ(e) {
    let t = ph(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Yn(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize + 2] = jn(t), this;
  }
  getW(e) {
    let t = ph(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Yn(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize + 3] = jn(t), this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = vt(t, this.array), i = vt(i, this.array)), this.array[e + 0] = jn(t), this.array[e + 1] = jn(i), this;
  }
  setXYZ(e, t, i, n) {
    return e *= this.itemSize, this.normalized && (t = vt(t, this.array), i = vt(i, this.array), n = vt(n, this.array)), this.array[e + 0] = jn(t), this.array[e + 1] = jn(i), this.array[e + 2] = jn(n), this;
  }
  setXYZW(e, t, i, n, r) {
    return e *= this.itemSize, this.normalized && (t = vt(t, this.array), i = vt(i, this.array), n = vt(n, this.array), r = vt(r, this.array)), this.array[e + 0] = jn(t), this.array[e + 1] = jn(i), this.array[e + 2] = jn(n), this.array[e + 3] = jn(r), this;
  }
}
class Te extends Je {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
class tG extends Je {
  constructor(e, t, i) {
    super(new Float64Array(e), t, i);
  }
}
let MC = 0;
const vs = /* @__PURE__ */ new Ue(), Rf = /* @__PURE__ */ new ut(), Va = /* @__PURE__ */ new M(), os = /* @__PURE__ */ new is(), Yc = /* @__PURE__ */ new is(), rn = /* @__PURE__ */ new M();
class Ze extends Vi {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: MC++ }), this.uuid = ps(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (dw(e) ? mw : hA)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: i
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const r = new yt().getNormalMatrix(e);
      i.applyNormalMatrix(r), i.needsUpdate = !0;
    }
    const n = this.attributes.tangent;
    return n !== void 0 && (n.transformDirection(e), n.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return vs.makeRotationFromQuaternion(e), this.applyMatrix4(vs), this;
  }
  rotateX(e) {
    return vs.makeRotationX(e), this.applyMatrix4(vs), this;
  }
  rotateY(e) {
    return vs.makeRotationY(e), this.applyMatrix4(vs), this;
  }
  rotateZ(e) {
    return vs.makeRotationZ(e), this.applyMatrix4(vs), this;
  }
  translate(e, t, i) {
    return vs.makeTranslation(e, t, i), this.applyMatrix4(vs), this;
  }
  scale(e, t, i) {
    return vs.makeScale(e, t, i), this.applyMatrix4(vs), this;
  }
  lookAt(e) {
    return Rf.lookAt(e), Rf.updateMatrix(), this.applyMatrix4(Rf.matrix), this;
  }
  /**
   * Centers the geometry based on the bounding box.
   * @param targetOffset Optional target vector to copy translation into.
   * @return {BufferGeometry}
   */
  center(e = void 0) {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Va).negate(), this.translate(Va.x, Va.y, Va.z), e && e.copy(Va), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const r = e[i];
      t.push(r.x, r.y, r.z || 0);
    }
    return this.setAttribute("position", new Te(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new is());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new M(-1 / 0, -1 / 0, -1 / 0),
        new M(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let i = 0, n = t.length; i < n; i++) {
          const r = t[i];
          os.setFromBufferAttribute(r), this.morphTargetsRelative ? (rn.addVectors(this.boundingBox.min, os.min), this.boundingBox.expandByPoint(rn), rn.addVectors(this.boundingBox.max, os.max), this.boundingBox.expandByPoint(rn)) : (this.boundingBox.expandByPoint(os.min), this.boundingBox.expandByPoint(os.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new ns());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new M(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (os.setFromBufferAttribute(e), t)
        for (let r = 0, a = t.length; r < a; r++) {
          const o = t[r];
          Yc.setFromBufferAttribute(o), this.morphTargetsRelative ? (rn.addVectors(os.min, Yc.min), os.expandByPoint(rn), rn.addVectors(os.max, Yc.max), os.expandByPoint(rn)) : (os.expandByPoint(Yc.min), os.expandByPoint(Yc.max));
        }
      os.getCenter(i);
      let n = 0;
      for (let r = 0, a = e.count; r < a; r++)
        rn.fromBufferAttribute(e, r), n = Math.max(n, i.distanceToSquared(rn));
      if (t)
        for (let r = 0, a = t.length; r < a; r++) {
          const o = t[r], l = this.morphTargetsRelative;
          for (let c = 0, h = o.count; c < h; c++)
            rn.fromBufferAttribute(o, c), l && (Va.fromBufferAttribute(e, c), rn.add(Va)), n = Math.max(n, i.distanceToSquared(rn));
        }
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = e.array, n = t.position.array, r = t.normal.array, a = t.uv.array, o = n.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Je(new Float32Array(4 * o), 4));
    const l = this.getAttribute("tangent").array, c = [], h = [];
    for (let b = 0; b < o; b++)
      c[b] = new M(), h[b] = new M();
    const u = new M(), d = new M(), p = new M(), f = new ie(), y = new ie(), A = new ie(), m = new M(), v = new M();
    function g(b, D, O) {
      u.fromArray(n, b * 3), d.fromArray(n, D * 3), p.fromArray(n, O * 3), f.fromArray(a, b * 2), y.fromArray(a, D * 2), A.fromArray(a, O * 2), d.sub(u), p.sub(u), y.sub(f), A.sub(f);
      const Y = 1 / (y.x * A.y - A.x * y.y);
      isFinite(Y) && (m.copy(d).multiplyScalar(A.y).addScaledVector(p, -y.y).multiplyScalar(Y), v.copy(p).multiplyScalar(y.x).addScaledVector(d, -A.x).multiplyScalar(Y), c[b].add(m), c[D].add(m), c[O].add(m), h[b].add(v), h[D].add(v), h[O].add(v));
    }
    let _ = this.groups;
    _.length === 0 && (_ = [{
      start: 0,
      count: i.length
    }]);
    for (let b = 0, D = _.length; b < D; ++b) {
      const O = _[b], Y = O.start, B = O.count;
      for (let Q = Y, j = Y + B; Q < j; Q += 3)
        g(
          i[Q + 0],
          i[Q + 1],
          i[Q + 2]
        );
    }
    const w = new M(), S = new M(), C = new M(), E = new M();
    function x(b) {
      C.fromArray(r, b * 3), E.copy(C);
      const D = c[b];
      w.copy(D), w.sub(C.multiplyScalar(C.dot(D))).normalize(), S.crossVectors(E, D);
      const Y = S.dot(h[b]) < 0 ? -1 : 1;
      l[b * 4] = w.x, l[b * 4 + 1] = w.y, l[b * 4 + 2] = w.z, l[b * 4 + 3] = Y;
    }
    for (let b = 0, D = _.length; b < D; ++b) {
      const O = _[b], Y = O.start, B = O.count;
      for (let Q = Y, j = Y + B; Q < j; Q += 3)
        x(i[Q + 0]), x(i[Q + 1]), x(i[Q + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new Je(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
      else
        for (let d = 0, p = i.count; d < p; d++)
          i.setXYZ(d, 0, 0, 0);
      const n = new M(), r = new M(), a = new M(), o = new M(), l = new M(), c = new M(), h = new M(), u = new M();
      if (e)
        for (let d = 0, p = e.count; d < p; d += 3) {
          const f = e.getX(d + 0), y = e.getX(d + 1), A = e.getX(d + 2);
          n.fromBufferAttribute(t, f), r.fromBufferAttribute(t, y), a.fromBufferAttribute(t, A), h.subVectors(a, r), u.subVectors(n, r), h.cross(u), o.fromBufferAttribute(i, f), l.fromBufferAttribute(i, y), c.fromBufferAttribute(i, A), o.add(h), l.add(h), c.add(h), i.setXYZ(f, o.x, o.y, o.z), i.setXYZ(y, l.x, l.y, l.z), i.setXYZ(A, c.x, c.y, c.z);
        }
      else
        for (let d = 0, p = t.count; d < p; d += 3)
          n.fromBufferAttribute(t, d + 0), r.fromBufferAttribute(t, d + 1), a.fromBufferAttribute(t, d + 2), h.subVectors(a, r), u.subVectors(n, r), h.cross(u), i.setXYZ(d + 0, h.x, h.y, h.z), i.setXYZ(d + 1, h.x, h.y, h.z), i.setXYZ(d + 2, h.x, h.y, h.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      rn.fromBufferAttribute(e, t), rn.normalize(), e.setXYZ(t, rn.x, rn.y, rn.z);
  }
  toNonIndexed() {
    function e(o, l) {
      const c = o.array, h = o.itemSize, u = o.normalized, d = new c.constructor(l.length * h);
      let p = 0, f = 0;
      for (let y = 0, A = l.length; y < A; y++) {
        o.isInterleavedBufferAttribute ? p = l[y] * o.data.stride + o.offset : p = l[y] * h;
        for (let m = 0; m < h; m++)
          d[f++] = c[p++];
      }
      return new Je(d, h, u);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Ze(), i = this.index.array, n = this.attributes;
    for (const o in n) {
      const l = n[o], c = e(l, i);
      t.setAttribute(o, c);
    }
    const r = this.morphAttributes;
    for (const o in r) {
      const l = [], c = r[o];
      for (let h = 0, u = c.length; h < u; h++) {
        const d = c[h], p = e(d, i);
        l.push(p);
      }
      t.morphAttributes[o] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const c = a[o];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l)
        l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const i = this.attributes;
    for (const l in i) {
      const c = i[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const n = {};
    let r = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], h = [];
      for (let u = 0, d = c.length; u < d; u++) {
        const p = c[u];
        h.push(p.toJSON(e.data));
      }
      h.length > 0 && (n[l] = h, r = !0);
    }
    r && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return o !== null && (e.data.boundingSphere = {
      center: o.center.toArray(),
      radius: o.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const n = e.attributes;
    for (const c in n) {
      const h = n[c];
      this.setAttribute(c, h.clone(t));
    }
    const r = e.morphAttributes;
    for (const c in r) {
      const h = [], u = r[c];
      for (let d = 0, p = u.length; d < p; d++)
        h.push(u[d].clone(t));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let c = 0, h = a.length; c < h; c++) {
      const u = a[c];
      this.addGroup(u.start, u.count, u.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const I0 = /* @__PURE__ */ new Ue(), Wa = /* @__PURE__ */ new wc(), Fu = /* @__PURE__ */ new ns(), D0 = /* @__PURE__ */ new M(), rl = /* @__PURE__ */ new M(), al = /* @__PURE__ */ new M(), ol = /* @__PURE__ */ new M(), Bf = /* @__PURE__ */ new M(), Ou = /* @__PURE__ */ new M(), Nu = /* @__PURE__ */ new ie(), ku = /* @__PURE__ */ new ie(), Gu = /* @__PURE__ */ new ie(), R0 = /* @__PURE__ */ new M(), B0 = /* @__PURE__ */ new M(), P0 = /* @__PURE__ */ new M(), zu = /* @__PURE__ */ new M(), Qu = /* @__PURE__ */ new M();
class Se extends ut {
  constructor(e = new Ze(), t = new $s()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.isMesh ? (e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this) : this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = n.length; r < a; r++) {
          const o = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry, n = i.attributes.position, r = i.morphAttributes.position, a = i.morphTargetsRelative;
    t.fromBufferAttribute(n, e);
    const o = this.morphTargetInfluences;
    if (r && o) {
      Ou.set(0, 0, 0);
      for (let l = 0, c = r.length; l < c; l++) {
        const h = o[l], u = r[l];
        h !== 0 && (Bf.fromBufferAttribute(u, e), a ? Ou.addScaledVector(Bf, h) : Ou.addScaledVector(Bf.sub(t), h));
      }
      t.add(Ou);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry, n = this.material, r = this.matrixWorld;
    n !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), Fu.copy(i.boundingSphere), Fu.applyMatrix4(r), Wa.copy(e.ray).recast(e.near), !(Fu.containsPoint(Wa.origin) === !1 && (Wa.intersectSphere(Fu, D0) === null || Wa.origin.distanceToSquared(D0) > (e.far - e.near) ** 2)) && (I0.copy(r).invert(), Wa.copy(e.ray).applyMatrix4(I0), !(i.boundingBox !== null && Wa.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, Wa)));
  }
  _computeIntersections(e, t, i) {
    let n;
    const r = this.geometry, a = this.material, o = r.index, l = r.attributes.position, c = r.attributes.uv, h = r.attributes.uv1, u = r.attributes.normal, d = r.groups, p = r.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let f = 0, y = d.length; f < y; f++) {
          const A = d[f], m = a[A.materialIndex], v = Math.max(A.start, p.start), g = Math.min(o.count, Math.min(A.start + A.count, p.start + p.count));
          for (let _ = v, w = g; _ < w; _ += 3) {
            const S = o.getX(_), C = o.getX(_ + 1), E = o.getX(_ + 2);
            n = Hu(this, m, e, i, c, h, u, S, C, E), n && (n.faceIndex = Math.floor(_ / 3), n.face.materialIndex = A.materialIndex, t.push(n));
          }
        }
      else {
        const f = Math.max(0, p.start), y = Math.min(o.count, p.start + p.count);
        for (let A = f, m = y; A < m; A += 3) {
          const v = o.getX(A), g = o.getX(A + 1), _ = o.getX(A + 2);
          n = Hu(this, a, e, i, c, h, u, v, g, _), n && (n.faceIndex = Math.floor(A / 3), t.push(n));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let f = 0, y = d.length; f < y; f++) {
          const A = d[f], m = a[A.materialIndex], v = Math.max(A.start, p.start), g = Math.min(l.count, Math.min(A.start + A.count, p.start + p.count));
          for (let _ = v, w = g; _ < w; _ += 3) {
            const S = _, C = _ + 1, E = _ + 2;
            n = Hu(this, m, e, i, c, h, u, S, C, E), n && (n.faceIndex = Math.floor(_ / 3), n.face.materialIndex = A.materialIndex, t.push(n));
          }
        }
      else {
        const f = Math.max(0, p.start), y = Math.min(l.count, p.start + p.count);
        for (let A = f, m = y; A < m; A += 3) {
          const v = A, g = A + 1, _ = A + 2;
          n = Hu(this, a, e, i, c, h, u, v, g, _), n && (n.faceIndex = Math.floor(A / 3), t.push(n));
        }
      }
  }
}
function TC(s, e, t, i, n, r, a, o) {
  let l;
  if (e.side === vn ? l = i.intersectTriangle(a, r, n, !0, o) : l = i.intersectTriangle(n, r, a, e.side === $n, o), l === null) return null;
  Qu.copy(o), Qu.applyMatrix4(s.matrixWorld);
  const c = t.ray.origin.distanceTo(Qu);
  return c < t.near || c > t.far ? null : {
    distance: c,
    point: Qu.clone(),
    object: s
  };
}
function Hu(s, e, t, i, n, r, a, o, l, c) {
  s.getVertexPosition(o, rl), s.getVertexPosition(l, al), s.getVertexPosition(c, ol);
  const h = TC(s, e, t, i, rl, al, ol, zu);
  if (h) {
    n && (Nu.fromBufferAttribute(n, o), ku.fromBufferAttribute(n, l), Gu.fromBufferAttribute(n, c), h.uv = hs.getInterpolation(zu, rl, al, ol, Nu, ku, Gu, new ie())), r && (Nu.fromBufferAttribute(r, o), ku.fromBufferAttribute(r, l), Gu.fromBufferAttribute(r, c), h.uv1 = hs.getInterpolation(zu, rl, al, ol, Nu, ku, Gu, new ie()), h.uv2 = h.uv1), a && (R0.fromBufferAttribute(a, o), B0.fromBufferAttribute(a, l), P0.fromBufferAttribute(a, c), h.normal = hs.getInterpolation(zu, rl, al, ol, R0, B0, P0, new M()), h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
    const u = {
      a: o,
      b: l,
      c,
      normal: new M(),
      materialIndex: 0
    };
    hs.getNormal(rl, al, ol, u.normal), h.face = u;
  }
  return h;
}
class Si extends Ze {
  constructor(e = 1, t = 1, i = 1, n = 1, r = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: i,
      widthSegments: n,
      heightSegments: r,
      depthSegments: a
    };
    const o = this;
    n = Math.floor(n), r = Math.floor(r), a = Math.floor(a);
    const l = [], c = [], h = [], u = [];
    let d = 0, p = 0;
    f("z", "y", "x", -1, -1, i, t, e, a, r, 0), f("z", "y", "x", 1, -1, i, t, -e, a, r, 1), f("x", "z", "y", 1, 1, e, i, t, n, a, 2), f("x", "z", "y", 1, -1, e, i, -t, n, a, 3), f("x", "y", "z", 1, -1, e, t, i, n, r, 4), f("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(l), this.setAttribute("position", new Te(c, 3)), this.setAttribute("normal", new Te(h, 3)), this.setAttribute("uv", new Te(u, 2));
    function f(y, A, m, v, g, _, w, S, C, E, x) {
      const b = _ / C, D = w / E, O = _ / 2, Y = w / 2, B = S / 2, Q = C + 1, j = E + 1;
      let X = 0, Z = 0;
      const ee = new M();
      for (let J = 0; J < j; J++) {
        const W = J * D - Y;
        for (let K = 0; K < Q; K++) {
          const ce = K * b - O;
          ee[y] = ce * v, ee[A] = W * g, ee[m] = B, c.push(ee.x, ee.y, ee.z), ee[y] = 0, ee[A] = 0, ee[m] = S > 0 ? 1 : -1, h.push(ee.x, ee.y, ee.z), u.push(K / C), u.push(1 - J / E), X += 1;
        }
      }
      for (let J = 0; J < E; J++)
        for (let W = 0; W < C; W++) {
          const K = d + W + Q * J, ce = d + W + Q * (J + 1), fe = d + (W + 1) + Q * (J + 1), ve = d + (W + 1) + Q * J;
          l.push(K, ce, ve), l.push(ce, fe, ve), Z += 6;
        }
      o.addGroup(p, Z, x), p += Z, d += X;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Si(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function uo(s) {
  const e = {};
  for (const t in s) {
    e[t] = {};
    for (const i in s[t]) {
      const n = s[t][i];
      n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? n.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = n.clone() : Array.isArray(n) ? e[t][i] = n.slice() : e[t][i] = n;
    }
  }
  return e;
}
function Un(s) {
  const e = {};
  for (let t = 0; t < s.length; t++) {
    const i = uo(s[t]);
    for (const n in i)
      e[n] = i[n];
  }
  return e;
}
function IC(s) {
  const e = [];
  for (let t = 0; t < s.length; t++)
    e.push(s[t].clone());
  return e;
}
function gw(s) {
  return s.getRenderTarget() === null ? s.outputColorSpace : Rt.workingColorSpace;
}
const Ec = { clone: uo, merge: Un };
var DC = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, RC = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ln extends Yi {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = DC, this.fragmentShader = RC, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1
      // set to use shader texture LOD
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = uo(e.uniforms), this.uniformsGroups = IC(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const n in this.uniforms) {
      const a = this.uniforms[n].value;
      a && a.isTexture ? t.uniforms[n] = {
        type: "t",
        value: a.toJSON(e).uuid
      } : a && a.isColor ? t.uniforms[n] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? t.uniforms[n] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? t.uniforms[n] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? t.uniforms[n] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? t.uniforms[n] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? t.uniforms[n] = {
        type: "m4",
        value: a.toArray()
      } : t.uniforms[n] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const i = {};
    for (const n in this.extensions)
      this.extensions[n] === !0 && (i[n] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class Up extends ut {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Ue(), this.projectionMatrix = new Ue(), this.projectionMatrixInverse = new Ue(), this.coordinateSystem = zr;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ki extends Up {
  constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = ec * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(ho * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return ec * 2 * Math.atan(
      Math.tan(ho * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, i, n, r, a) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(ho * 0.5 * this.fov) / this.zoom, i = 2 * t, n = this.aspect * i, r = -0.5 * n;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth, c = a.fullHeight;
      r += a.offsetX * n / l, t -= a.offsetY * i / c, n *= a.width / l, i *= a.height / c;
    }
    const o = this.filmOffset;
    o !== 0 && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const ll = -90, cl = 1;
class BC extends ut {
  constructor(e, t, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const n = new ki(ll, cl, e, t);
    n.layers = this.layers, this.add(n);
    const r = new ki(ll, cl, e, t);
    r.layers = this.layers, this.add(r);
    const a = new ki(ll, cl, e, t);
    a.layers = this.layers, this.add(a);
    const o = new ki(ll, cl, e, t);
    o.layers = this.layers, this.add(o);
    const l = new ki(ll, cl, e, t);
    l.layers = this.layers, this.add(l);
    const c = new ki(ll, cl, e, t);
    c.layers = this.layers, this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [i, n, r, a, o, l] = t;
    for (const c of t) this.remove(c);
    if (e === zr)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (e === np)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const c of t)
      this.add(c), c.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: n } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [r, a, o, l, c, h] = this.children, u = e.getRenderTarget(), d = e.getActiveCubeFace(), p = e.getActiveMipmapLevel(), f = e.xr.enabled;
    e.xr.enabled = !1;
    const y = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, n), e.render(t, r), e.setRenderTarget(i, 1, n), e.render(t, a), e.setRenderTarget(i, 2, n), e.render(t, o), e.setRenderTarget(i, 3, n), e.render(t, l), e.setRenderTarget(i, 4, n), e.render(t, c), i.texture.generateMipmaps = y, e.setRenderTarget(i, 5, n), e.render(t, h), e.setRenderTarget(u, d, p), e.xr.enabled = f, i.texture.needsPMREMUpdate = !0;
  }
}
class Fp extends Nt {
  constructor(e, t, i, n, r, a, o, l, c, h) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : qr, super(e, t, i, n, r, a, o, l, c, h), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Aw extends Zn {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const i = { width: e, height: e, depth: 1 }, n = [i, i, i, i, i, i];
    t.encoding !== void 0 && (_h("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === ga ? dt : Wt), this.texture = new Fp(n, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : tt;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, n = new Si(5, 5, 5), r = new ln({
      name: "CubemapFromEquirect",
      uniforms: uo(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: vn,
      blending: _n
    });
    r.uniforms.tEquirect.value = t;
    const a = new Se(n, r), o = t.minFilter;
    return t.minFilter === Qn && (t.minFilter = tt), new BC(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(e, t, i, n) {
    const r = e.getRenderTarget();
    for (let a = 0; a < 6; a++)
      e.setRenderTarget(this, a), e.clear(t, i, n);
    e.setRenderTarget(r);
  }
}
const Pf = /* @__PURE__ */ new M(), PC = /* @__PURE__ */ new M(), LC = /* @__PURE__ */ new yt();
class Nr {
  constructor(e = new M(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, i, n) {
    return this.normal.set(e, t, i), this.constant = n, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const n = Pf.subVectors(i, t).cross(PC.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(Pf), n = this.normal.dot(i);
    if (n === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / n;
    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(i, r);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return t < 0 && i > 0 || i < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || LC.getNormalMatrix(e), n = this.coplanarPoint(Pf).applyMatrix4(e), r = this.normal.applyMatrix3(i).normalize();
    return this.constant = -n.dot(r), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ja = /* @__PURE__ */ new ns(), Vu = /* @__PURE__ */ new M();
class uA {
  constructor(e = new Nr(), t = new Nr(), i = new Nr(), n = new Nr(), r = new Nr(), a = new Nr()) {
    this.planes = [e, t, i, n, r, a];
  }
  set(e, t, i, n, r, a) {
    const o = this.planes;
    return o[0].copy(e), o[1].copy(t), o[2].copy(i), o[3].copy(n), o[4].copy(r), o[5].copy(a), this;
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = zr) {
    const i = this.planes, n = e.elements, r = n[0], a = n[1], o = n[2], l = n[3], c = n[4], h = n[5], u = n[6], d = n[7], p = n[8], f = n[9], y = n[10], A = n[11], m = n[12], v = n[13], g = n[14], _ = n[15];
    if (i[0].setComponents(l - r, d - c, A - p, _ - m).normalize(), i[1].setComponents(l + r, d + c, A + p, _ + m).normalize(), i[2].setComponents(l + a, d + h, A + f, _ + v).normalize(), i[3].setComponents(l - a, d - h, A - f, _ - v).normalize(), i[4].setComponents(l - o, d - u, A - y, _ - g).normalize(), t === zr)
      i[5].setComponents(l + o, d + u, A + y, _ + g).normalize();
    else if (t === np)
      i[5].setComponents(o, u, y, g).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), ja.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), ja.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(ja);
  }
  intersectsSprite(e) {
    return ja.center.set(0, 0, 0), ja.radius = 0.7071067811865476, ja.applyMatrix4(e.matrixWorld), this.intersectsSphere(ja);
  }
  intersectsSphere(e) {
    const t = this.planes, i = e.center, n = -e.radius;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(i) < n)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const n = t[i];
      if (Vu.x = n.normal.x > 0 ? e.max.x : e.min.x, Vu.y = n.normal.y > 0 ? e.max.y : e.min.y, Vu.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(Vu) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      if (t[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function yw() {
  let s = null, e = !1, t = null, i = null;
  function n(r, a) {
    t(r, a), i = s.requestAnimationFrame(n);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (i = s.requestAnimationFrame(n), e = !0);
    },
    stop: function() {
      s.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function(r) {
      t = r;
    },
    setContext: function(r) {
      s = r;
    }
  };
}
function UC(s, e) {
  const t = e.isWebGL2, i = /* @__PURE__ */ new WeakMap();
  function n(c, h) {
    const u = c.array, d = c.usage, p = s.createBuffer();
    s.bindBuffer(h, p), s.bufferData(h, u, d), c.onUploadCallback();
    let f;
    if (u instanceof Float32Array)
      f = s.FLOAT;
    else if (u instanceof Uint16Array)
      if (c.isFloat16BufferAttribute)
        if (t)
          f = s.HALF_FLOAT;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        f = s.UNSIGNED_SHORT;
    else if (u instanceof Int16Array)
      f = s.SHORT;
    else if (u instanceof Uint32Array)
      f = s.UNSIGNED_INT;
    else if (u instanceof Int32Array)
      f = s.INT;
    else if (u instanceof Int8Array)
      f = s.BYTE;
    else if (u instanceof Uint8Array)
      f = s.UNSIGNED_BYTE;
    else if (u instanceof Uint8ClampedArray)
      f = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
    return {
      buffer: p,
      type: f,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: c.version
    };
  }
  function r(c, h, u) {
    const d = h.array, p = h.updateRange;
    s.bindBuffer(u, c), p.count === -1 ? s.bufferSubData(u, 0, d) : (t ? s.bufferSubData(
      u,
      p.offset * d.BYTES_PER_ELEMENT,
      d,
      p.offset,
      p.count
    ) : s.bufferSubData(
      u,
      p.offset * d.BYTES_PER_ELEMENT,
      d.subarray(p.offset, p.offset + p.count)
    ), p.count = -1), h.onUploadCallback();
  }
  function a(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), i.get(c);
  }
  function o(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const h = i.get(c);
    h && (s.deleteBuffer(h.buffer), i.delete(c));
  }
  function l(c, h) {
    if (c.isGLBufferAttribute) {
      const d = i.get(c);
      (!d || d.version < c.version) && i.set(c, {
        buffer: c.buffer,
        type: c.type,
        bytesPerElement: c.elementSize,
        version: c.version
      });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const u = i.get(c);
    u === void 0 ? i.set(c, n(c, h)) : u.version < c.version && (r(u.buffer, c, h), u.version = c.version);
  }
  return {
    get: a,
    remove: o,
    update: l
  };
}
class No extends Ze {
  constructor(e = 1, t = 1, i = 1, n = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: i,
      heightSegments: n
    };
    const r = e / 2, a = t / 2, o = Math.floor(i), l = Math.floor(n), c = o + 1, h = l + 1, u = e / o, d = t / l, p = [], f = [], y = [], A = [];
    for (let m = 0; m < h; m++) {
      const v = m * d - a;
      for (let g = 0; g < c; g++) {
        const _ = g * u - r;
        f.push(_, -v, 0), y.push(0, 0, 1), A.push(g / o), A.push(1 - m / l);
      }
    }
    for (let m = 0; m < l; m++)
      for (let v = 0; v < o; v++) {
        const g = v + c * m, _ = v + c * (m + 1), w = v + 1 + c * (m + 1), S = v + 1 + c * m;
        p.push(g, _, S), p.push(_, w, S);
      }
    this.setIndex(p), this.setAttribute("position", new Te(f, 3)), this.setAttribute("normal", new Te(y, 3)), this.setAttribute("uv", new Te(A, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new No(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var FC = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, OC = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, NC = `#ifdef USE_ALPHAMAP
	#if defined(INVERSE_ALPHAMAP) && INVERSE_ALPHAMAP >= 1
	diffuseColor.a *= 1.0-texture2D( alphaMap, vAlphaMapUv ).g;
	#else
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
	#endif
#endif`, kC = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, GC = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, zC = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, QC = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, HC = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, VC = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, WC = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, jC = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, qC = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, XC = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, YC = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, KC = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, JC = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, $C = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, ZC = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, eM = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, tM = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, iM = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, nM = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, sM = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, rM = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, aM = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, oM = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, lM = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, cM = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, hM = "gl_FragColor = linearToOutputTexel( gl_FragColor );", uM = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 RGBM16ToLinear( in vec4 value ) {
	return vec4( value.rgb * value.a * 16.0, 1.0 );
}
vec4 LinearToRGBM16( in vec4 value ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / 16.0, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * 16.0 ), M );
}`, dM = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	reflectVec = transformDirection(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, pM = `#ifdef USE_ENVMAP
	mat4 rotationMatrix(vec3 axis, float angle) {
		axis = normalize(axis);
		float s = sin(angle);
		float c = cos(angle);
		float oc = 1.0 - c;
		return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
					oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
					oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
					0.0,                                0.0,                                0.0,                                1.0);
	}
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform float envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
#endif`, fM = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, mM = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, gM = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, AM = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, yM = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, vM = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, _M = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, xM = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, wM = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, EM = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, bM = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, SM = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, CM = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, MM = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
		#if defined( FIX_ENV_DIRECTION )
			vec3 worldNormal = normal;
		#else
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#endif
			worldNormal = transformDirection(worldNormal, rotationMatrix(vec3(0,1,0), envMapRotation));
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#if !defined( FIX_ENV_DIRECTION )
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			#endif
			reflectVec = transformDirection(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, TM = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, IM = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, DM = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, RM = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, BM = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`, PM = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#if defined( USE_ANISOTROPY ) || defined( USE_ANISOTROPY_BRDF )
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, LM = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, UM = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, FM = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, OM = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, NM = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, kM = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, GM = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, zM = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, QM = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, HM = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, VM = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, WM = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, jM = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, qM = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, XM = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, YM = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, KM = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, JM = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, $M = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, ZM = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, e1 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, t1 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, i1 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, n1 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, s1 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, r1 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, a1 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, o1 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
diffuseColor.a = min(max(diffuseColor.a, 0.), 1.);
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, l1 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, c1 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, h1 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, u1 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, d1 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, p1 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, f1 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, m1 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, g1 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, A1 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, y1 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, v1 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, _1 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, x1 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, w1 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, E1 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, b1 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, S1 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, C1 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, M1 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, T1 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	#ifndef WebGL2Context
	#define textureLod texture2DLodEXT
	#define textureSize(s, lod) vec2(1024./pow(2.,float(lod)),1024./pow(2.,float(lod)))
	#define isinf(x) (x > 1e20 || x < -1e20)
	#endif
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		if(roughness == 0.0) return transmissionSamplerMapTexelToLinear( texture2D( transmissionSamplerMap, fragCoord.xy ) );
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return transmissionSamplerMapTexelToLinear( textureBicubic( transmissionSamplerMap, fragCoord.xy, lod ) );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) || attenuationDistance == 0.0) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, I1 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, D1 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, R1 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, B1 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const P1 = `#ifdef HAS_TEXTURE
varying vec2 vUv;
uniform mat3 uvTransform;
uniform bool flipX;
uniform bool flipY;
#endif
void main() {
#ifdef HAS_TEXTURE
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
    vUv = flipX ? vec2( 1.0 - vUv.x, vUv.y ) : vUv;
    vUv = flipY ? vec2( vUv.x, 1.0 - vUv.y ) : vUv;
#endif
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, L1 = `#ifdef HAS_TEXTURE
uniform sampler2D t2D;
varying vec2 vUv;
#endif
uniform float backgroundIntensity;
uniform vec3 backgroundColor;
void main() {
#ifdef HAS_TEXTURE
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
#else
	vec4 texColor = vec4( 1.0 );
#endif
	texColor.rgb *= backgroundColor * backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, U1 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, F1 = `#include <envmap_common_pars_fragment>
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
void main() {
	vec3 vReflect = vWorldDirection;
	vReflect = transformDirection(vReflect, rotationMatrix(vec3(0,1,0), envMapRotation));
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vReflect.x, vReflect.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vReflect, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	texColor.rgb *= envMapIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, O1 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, N1 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, k1 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, G1 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, z1 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, Q1 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, H1 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, V1 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, W1 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, j1 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, q1 = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, X1 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Y1 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, K1 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, J1 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, $1 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Z1 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, eT = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, tT = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, iT = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, nT = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, sT = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, rT = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, aT = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, oT = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, lT = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, cT = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, hT = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, uT = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, dT = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, ft = {
  alphahash_fragment: FC,
  alphahash_pars_fragment: OC,
  alphamap_fragment: NC,
  alphamap_pars_fragment: kC,
  alphatest_fragment: GC,
  alphatest_pars_fragment: zC,
  aomap_fragment: QC,
  aomap_pars_fragment: HC,
  begin_vertex: VC,
  beginnormal_vertex: WC,
  bsdfs: jC,
  iridescence_fragment: qC,
  bumpmap_pars_fragment: XC,
  clipping_planes_fragment: YC,
  clipping_planes_pars_fragment: KC,
  clipping_planes_pars_vertex: JC,
  clipping_planes_vertex: $C,
  color_fragment: ZC,
  color_pars_fragment: eM,
  color_pars_vertex: tM,
  color_vertex: iM,
  common: nM,
  cube_uv_reflection_fragment: sM,
  defaultnormal_vertex: rM,
  displacementmap_pars_vertex: aM,
  displacementmap_vertex: oM,
  emissivemap_fragment: lM,
  emissivemap_pars_fragment: cM,
  colorspace_fragment: hM,
  colorspace_pars_fragment: uM,
  envmap_fragment: dM,
  envmap_common_pars_fragment: pM,
  envmap_pars_fragment: fM,
  envmap_pars_vertex: mM,
  envmap_physical_pars_fragment: MM,
  envmap_vertex: gM,
  fog_vertex: AM,
  fog_pars_vertex: yM,
  fog_fragment: vM,
  fog_pars_fragment: _M,
  gradientmap_pars_fragment: xM,
  lightmap_fragment: wM,
  lightmap_pars_fragment: EM,
  lights_lambert_fragment: bM,
  lights_lambert_pars_fragment: SM,
  lights_pars_begin: CM,
  lights_toon_fragment: TM,
  lights_toon_pars_fragment: IM,
  lights_phong_fragment: DM,
  lights_phong_pars_fragment: RM,
  lights_physical_fragment: BM,
  lights_physical_pars_fragment: PM,
  lights_fragment_begin: LM,
  lights_fragment_maps: UM,
  lights_fragment_end: FM,
  logdepthbuf_fragment: OM,
  logdepthbuf_pars_fragment: NM,
  logdepthbuf_pars_vertex: kM,
  logdepthbuf_vertex: GM,
  map_fragment: zM,
  map_pars_fragment: QM,
  map_particle_fragment: HM,
  map_particle_pars_fragment: VM,
  metalnessmap_fragment: WM,
  metalnessmap_pars_fragment: jM,
  morphcolor_vertex: qM,
  morphnormal_vertex: XM,
  morphtarget_pars_vertex: YM,
  morphtarget_vertex: KM,
  normal_fragment_begin: JM,
  normal_fragment_maps: $M,
  normal_pars_fragment: ZM,
  normal_pars_vertex: e1,
  normal_vertex: t1,
  normalmap_pars_fragment: i1,
  clearcoat_normal_fragment_begin: n1,
  clearcoat_normal_fragment_maps: s1,
  clearcoat_pars_fragment: r1,
  iridescence_pars_fragment: a1,
  opaque_fragment: o1,
  packing: l1,
  premultiplied_alpha_fragment: c1,
  project_vertex: h1,
  dithering_fragment: u1,
  dithering_pars_fragment: d1,
  roughnessmap_fragment: p1,
  roughnessmap_pars_fragment: f1,
  shadowmap_pars_fragment: m1,
  shadowmap_pars_vertex: g1,
  shadowmap_vertex: A1,
  shadowmask_pars_fragment: y1,
  skinbase_vertex: v1,
  skinning_pars_vertex: _1,
  skinning_vertex: x1,
  skinnormal_vertex: w1,
  specularmap_fragment: E1,
  specularmap_pars_fragment: b1,
  tonemapping_fragment: S1,
  tonemapping_pars_fragment: C1,
  transmission_fragment: M1,
  transmission_pars_fragment: T1,
  uv_pars_fragment: I1,
  uv_pars_vertex: D1,
  uv_vertex: R1,
  worldpos_vertex: B1,
  background_vert: P1,
  background_frag: L1,
  backgroundCube_vert: U1,
  backgroundCube_frag: F1,
  cube_vert: O1,
  cube_frag: N1,
  depth_vert: k1,
  depth_frag: G1,
  distanceRGBA_vert: z1,
  distanceRGBA_frag: Q1,
  equirect_vert: H1,
  equirect_frag: V1,
  linedashed_vert: W1,
  linedashed_frag: j1,
  meshbasic_vert: q1,
  meshbasic_frag: X1,
  meshlambert_vert: Y1,
  meshlambert_frag: K1,
  meshmatcap_vert: J1,
  meshmatcap_frag: $1,
  meshnormal_vert: Z1,
  meshnormal_frag: eT,
  meshphong_vert: tT,
  meshphong_frag: iT,
  meshphysical_vert: nT,
  meshphysical_frag: sT,
  meshtoon_vert: rT,
  meshtoon_frag: aT,
  points_vert: oT,
  points_frag: lT,
  shadow_vert: cT,
  shadow_frag: hT,
  sprite_vert: uT,
  sprite_frag: dT
}, Re = {
  common: {
    diffuse: { value: /* @__PURE__ */ new se(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new yt() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new yt() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new yt() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: 0 },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new yt() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new yt() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new yt() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new yt() },
    normalScale: { value: /* @__PURE__ */ new ie(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new yt() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new yt() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new yt() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new yt() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new se(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new se(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new yt() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new yt() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new se(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new ie(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new yt() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new yt() },
    alphaTest: { value: 0 }
  }
}, Ci = {
  basic: {
    uniforms: /* @__PURE__ */ Un([
      Re.common,
      Re.specularmap,
      Re.envmap,
      Re.aomap,
      Re.lightmap,
      Re.fog
    ]),
    vertexShader: ft.meshbasic_vert,
    fragmentShader: ft.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Un([
      Re.common,
      Re.specularmap,
      Re.envmap,
      Re.aomap,
      Re.lightmap,
      Re.emissivemap,
      Re.bumpmap,
      Re.normalmap,
      Re.displacementmap,
      Re.fog,
      Re.lights,
      {
        emissive: { value: /* @__PURE__ */ new se(0) }
      }
    ]),
    vertexShader: ft.meshlambert_vert,
    fragmentShader: ft.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Un([
      Re.common,
      Re.specularmap,
      Re.envmap,
      Re.aomap,
      Re.lightmap,
      Re.emissivemap,
      Re.bumpmap,
      Re.normalmap,
      Re.displacementmap,
      Re.fog,
      Re.lights,
      {
        emissive: { value: /* @__PURE__ */ new se(0) },
        specular: { value: /* @__PURE__ */ new se(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ft.meshphong_vert,
    fragmentShader: ft.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Un([
      Re.common,
      Re.envmap,
      Re.aomap,
      Re.lightmap,
      Re.emissivemap,
      Re.bumpmap,
      Re.normalmap,
      Re.displacementmap,
      Re.roughnessmap,
      Re.metalnessmap,
      Re.fog,
      Re.lights,
      {
        emissive: { value: /* @__PURE__ */ new se(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: ft.meshphysical_vert,
    fragmentShader: ft.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Un([
      Re.common,
      Re.aomap,
      Re.lightmap,
      Re.emissivemap,
      Re.bumpmap,
      Re.normalmap,
      Re.displacementmap,
      Re.gradientmap,
      Re.fog,
      Re.lights,
      {
        emissive: { value: /* @__PURE__ */ new se(0) }
      }
    ]),
    vertexShader: ft.meshtoon_vert,
    fragmentShader: ft.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Un([
      Re.common,
      Re.bumpmap,
      Re.normalmap,
      Re.displacementmap,
      Re.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ft.meshmatcap_vert,
    fragmentShader: ft.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Un([
      Re.points,
      Re.fog
    ]),
    vertexShader: ft.points_vert,
    fragmentShader: ft.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Un([
      Re.common,
      Re.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ft.linedashed_vert,
    fragmentShader: ft.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Un([
      Re.common,
      Re.displacementmap
    ]),
    vertexShader: ft.depth_vert,
    fragmentShader: ft.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Un([
      Re.common,
      Re.bumpmap,
      Re.normalmap,
      Re.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ft.meshnormal_vert,
    fragmentShader: ft.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Un([
      Re.sprite,
      Re.fog
    ]),
    vertexShader: ft.sprite_vert,
    fragmentShader: ft.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new yt() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 },
      backgroundColor: { value: new se(16777215) },
      flipX: { value: !1 },
      flipY: { value: !1 }
    },
    vertexShader: ft.background_vert,
    fragmentShader: ft.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      envMapRotation: { value: 0 },
      envMapIntensity: { value: 1 },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ft.backgroundCube_vert,
    fragmentShader: ft.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ft.cube_vert,
    fragmentShader: ft.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ft.equirect_vert,
    fragmentShader: ft.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Un([
      Re.common,
      Re.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new M() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ft.distanceRGBA_vert,
    fragmentShader: ft.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Un([
      Re.lights,
      Re.fog,
      {
        color: { value: /* @__PURE__ */ new se(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ft.shadow_vert,
    fragmentShader: ft.shadow_frag
  }
};
Ci.physical = {
  uniforms: /* @__PURE__ */ Un([
    Ci.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new yt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new yt() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new ie(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new yt() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new yt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new yt() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new se(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new yt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new yt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new yt() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new ie() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new yt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new se(0) },
      specularColor: { value: /* @__PURE__ */ new se(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new yt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new yt() },
      anisotropyVector: { value: /* @__PURE__ */ new ie() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new yt() }
    }
  ]),
  vertexShader: ft.meshphysical_vert,
  fragmentShader: ft.meshphysical_frag
};
const Wu = { r: 0, b: 0, g: 0 };
function pT(s, e, t, i, n, r, a) {
  const o = new se(0);
  let l = r === !0 ? 0 : 1, c, h, u = null, d = 0, p = null;
  function f(A, m) {
    let v = !1, g = m.isScene === !0 ? m.background : null;
    const _ = m.isScene && m.backgroundColor !== void 0 ? m.backgroundColor : null;
    g === "environment" && (g = m.environment), g && g.isTexture && (g = (m.backgroundBlurriness > 0 ? t : e).get(g)), g === null ? y(o, l) : g && g.isColor && (y(g, 1), v = !0);
    const w = s.xr.getEnvironmentBlendMode();
    if (w === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, a) : w === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a), (s.autoClear || v) && s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil), g && (g.isCubeTexture || g.mapping === xc))
      h === void 0 && (h = new Se(
        new Si(1, 1, 1),
        new ln({
          name: "BackgroundCubeMaterial",
          uniforms: uo(Ci.backgroundCube.uniforms),
          vertexShader: Ci.backgroundCube.vertexShader,
          fragmentShader: Ci.backgroundCube.fragmentShader,
          side: vn,
          depthTest: !1,
          depthWrite: !1,
          fog: !1
        })
      ), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(S, C, E) {
        this.matrixWorld.copyPosition(E.matrixWorld);
      }, Object.defineProperty(h.material, "envMap", {
        get: function() {
          return this.uniforms.envMap.value;
        }
      }), n.update(h)), h.material.uniforms.envMap.value = g, h.material.uniforms.envMapRotation.value = g && g.rotation || 0, h.material.uniforms.envMapIntensity.value = g === m.environment && m.envMapIntensity || 1, h.material.uniforms.flipEnvMap.value = g.isCubeTexture && g.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, h.material.toneMapped = Rt.getTransfer(g.colorSpace) !== mi, (u !== g || d !== g.version || p !== s.toneMapping) && (h.material.needsUpdate = !0, u = g, d = g.version, p = s.toneMapping), h.layers.enableAll(), A.unshift(h, h.geometry, h.material, 0, 0, null);
    else if (g && g.isTexture || !g && _) {
      c === void 0 && (c = new Se(
        new No(2, 2),
        new ln({
          name: "BackgroundMaterial",
          uniforms: uo(Ci.background.uniforms),
          vertexShader: Ci.background.vertexShader,
          fragmentShader: Ci.background.fragmentShader,
          side: $n,
          depthTest: !1,
          depthWrite: !1,
          fog: !1
        })
      ), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
        get: function() {
          return this.uniforms.t2D.value;
        }
      }), n.update(c)), c.material.uniforms.backgroundColor.value.set(_ || 16777215), c.material.uniforms.t2D.value = g, c.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, g ? (c.material.toneMapped = Rt.getTransfer(g.colorSpace) !== mi, c.material.uniforms.flipX.value = g.userData.flipX || !1, c.material.uniforms.flipY.value = g.userData.flipY || !1, g.matrixAutoUpdate === !0 && g.updateMatrix(), c.material.uniforms.uvTransform.value.copy(g.matrix), c.material.defines.HAS_TEXTURE = "1") : c.material.defines.HAS_TEXTURE && delete c.material.defines.HAS_TEXTURE;
      const S = g ? g.version : -1;
      (u !== g || d !== S || p !== s.toneMapping) && (c.material.needsUpdate = !0, u = g, d = S, p = s.toneMapping), c.layers.enableAll(), A.unshift(c, c.geometry, c.material, 0, 0, null);
    }
  }
  function y(A, m) {
    A.getRGB(Wu, gw(s)), i.buffers.color.setClear(Wu.r, Wu.g, Wu.b, m, a);
  }
  return {
    getClearColor: function() {
      return o;
    },
    setClearColor: function(A, m = 1) {
      o.set(A), l = m, y(o, l);
    },
    getClearAlpha: function() {
      return l;
    },
    setClearAlpha: function(A) {
      l = A, y(o, l);
    },
    getPlaneMesh: function() {
      return c;
    },
    getBoxMesh: function() {
      return h;
    },
    getBoxMesh2: function() {
      return h === void 0 && (h = new Se(
        new Si(1, 1, 1),
        new ln({
          name: "BackgroundCubeMaterial",
          uniforms: uo(Ci.backgroundCube.uniforms),
          vertexShader: Ci.backgroundCube.vertexShader,
          fragmentShader: Ci.backgroundCube.fragmentShader,
          side: vn,
          depthTest: !1,
          depthWrite: !1,
          fog: !1
        })
      ), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(A, m, v) {
        this.matrixWorld.copyPosition(v.matrixWorld);
      }, Object.defineProperty(h.material, "envMap", {
        get: function() {
          return this.uniforms.envMap.value;
        }
      }), n.update(h)), h;
    },
    render: f
  };
}
function fT(s, e, t, i) {
  const n = s.getParameter(s.MAX_VERTEX_ATTRIBS), r = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), a = i.isWebGL2 || r !== null, o = {}, l = A(null);
  let c = l, h = !1;
  function u(B, Q, j, X, Z) {
    let ee = !1;
    if (a) {
      const J = y(X, j, Q);
      c !== J && (c = J, p(c.object)), ee = m(B, X, j, Z), ee && v(B, X, j, Z);
    } else {
      const J = Q.wireframe === !0;
      (c.geometry !== X.id || c.program !== j.id || c.wireframe !== J) && (c.geometry = X.id, c.program = j.id, c.wireframe = J, ee = !0);
    }
    Z !== null && t.update(Z, s.ELEMENT_ARRAY_BUFFER), (ee || h) && (h = !1, E(B, Q, j, X), Z !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t.get(Z).buffer));
  }
  function d() {
    return i.isWebGL2 ? s.createVertexArray() : r.createVertexArrayOES();
  }
  function p(B) {
    return i.isWebGL2 ? s.bindVertexArray(B) : r.bindVertexArrayOES(B);
  }
  function f(B) {
    return i.isWebGL2 ? s.deleteVertexArray(B) : r.deleteVertexArrayOES(B);
  }
  function y(B, Q, j) {
    const X = j.wireframe === !0;
    let Z = o[B.id];
    Z === void 0 && (Z = {}, o[B.id] = Z);
    let ee = Z[Q.id];
    ee === void 0 && (ee = {}, Z[Q.id] = ee);
    let J = ee[X];
    return J === void 0 && (J = A(d()), ee[X] = J), J;
  }
  function A(B) {
    const Q = [], j = [], X = [];
    for (let Z = 0; Z < n; Z++)
      Q[Z] = 0, j[Z] = 0, X[Z] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: Q,
      enabledAttributes: j,
      attributeDivisors: X,
      object: B,
      attributes: {},
      index: null
    };
  }
  function m(B, Q, j, X) {
    const Z = c.attributes, ee = Q.attributes;
    let J = 0;
    const W = j.getAttributes();
    for (const K in W)
      if (W[K].location >= 0) {
        const fe = Z[K];
        let ve = ee[K];
        if (ve === void 0 && (K === "instanceMatrix" && B.instanceMatrix && (ve = B.instanceMatrix), K === "instanceColor" && B.instanceColor && (ve = B.instanceColor)), fe === void 0 || fe.attribute !== ve || ve && fe.data !== ve.data) return !0;
        J++;
      }
    return c.attributesNum !== J || c.index !== X;
  }
  function v(B, Q, j, X) {
    const Z = {}, ee = Q.attributes;
    let J = 0;
    const W = j.getAttributes();
    for (const K in W)
      if (W[K].location >= 0) {
        let fe = ee[K];
        fe === void 0 && (K === "instanceMatrix" && B.instanceMatrix && (fe = B.instanceMatrix), K === "instanceColor" && B.instanceColor && (fe = B.instanceColor));
        const ve = {};
        ve.attribute = fe, fe && fe.data && (ve.data = fe.data), Z[K] = ve, J++;
      }
    c.attributes = Z, c.attributesNum = J, c.index = X;
  }
  function g() {
    const B = c.newAttributes;
    for (let Q = 0, j = B.length; Q < j; Q++)
      B[Q] = 0;
  }
  function _(B) {
    w(B, 0);
  }
  function w(B, Q) {
    const j = c.newAttributes, X = c.enabledAttributes, Z = c.attributeDivisors;
    j[B] = 1, X[B] === 0 && (s.enableVertexAttribArray(B), X[B] = 1), Z[B] !== Q && ((i.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](B, Q), Z[B] = Q);
  }
  function S() {
    const B = c.newAttributes, Q = c.enabledAttributes;
    for (let j = 0, X = Q.length; j < X; j++)
      Q[j] !== B[j] && (s.disableVertexAttribArray(j), Q[j] = 0);
  }
  function C(B, Q, j, X, Z, ee, J) {
    J === !0 ? s.vertexAttribIPointer(B, Q, j, Z, ee) : s.vertexAttribPointer(B, Q, j, X, Z, ee);
  }
  function E(B, Q, j, X) {
    if (i.isWebGL2 === !1 && (B.isInstancedMesh || X.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    g();
    const Z = X.attributes, ee = j.getAttributes(), J = Q.defaultAttributeValues;
    for (const W in ee) {
      const K = ee[W];
      if (K.location >= 0) {
        let ce = Z[W];
        if (ce === void 0 && (W === "instanceMatrix" && B.instanceMatrix && (ce = B.instanceMatrix), W === "instanceColor" && B.instanceColor && (ce = B.instanceColor)), ce !== void 0) {
          const fe = ce.normalized, ve = ce.itemSize, _e = t.get(ce);
          if (_e === void 0) continue;
          const ze = _e.buffer, Qe = _e.type, ot = _e.bytesPerElement, ht = i.isWebGL2 === !0 && (Qe === s.INT || Qe === s.UNSIGNED_INT || ce.gpuType === tA);
          if (ce.isInterleavedBufferAttribute) {
            const Xe = ce.data, G = Xe.stride, Be = ce.offset;
            if (Xe.isInstancedInterleavedBuffer) {
              for (let oe = 0; oe < K.locationSize; oe++)
                w(K.location + oe, Xe.meshPerAttribute);
              B.isInstancedMesh !== !0 && X._maxInstanceCount === void 0 && (X._maxInstanceCount = Xe.meshPerAttribute * Xe.count);
            } else
              for (let oe = 0; oe < K.locationSize; oe++)
                _(K.location + oe);
            s.bindBuffer(s.ARRAY_BUFFER, ze);
            for (let oe = 0; oe < K.locationSize; oe++)
              C(
                K.location + oe,
                ve / K.locationSize,
                Qe,
                fe,
                G * ot,
                (Be + ve / K.locationSize * oe) * ot,
                ht
              );
          } else {
            if (ce.isInstancedBufferAttribute) {
              for (let Xe = 0; Xe < K.locationSize; Xe++)
                w(K.location + Xe, ce.meshPerAttribute);
              B.isInstancedMesh !== !0 && X._maxInstanceCount === void 0 && (X._maxInstanceCount = ce.meshPerAttribute * ce.count);
            } else
              for (let Xe = 0; Xe < K.locationSize; Xe++)
                _(K.location + Xe);
            s.bindBuffer(s.ARRAY_BUFFER, ze);
            for (let Xe = 0; Xe < K.locationSize; Xe++)
              C(
                K.location + Xe,
                ve / K.locationSize,
                Qe,
                fe,
                ve * ot,
                ve / K.locationSize * Xe * ot,
                ht
              );
          }
        } else if (J !== void 0) {
          const fe = J[W];
          if (fe !== void 0)
            switch (fe.length) {
              case 2:
                s.vertexAttrib2fv(K.location, fe);
                break;
              case 3:
                s.vertexAttrib3fv(K.location, fe);
                break;
              case 4:
                s.vertexAttrib4fv(K.location, fe);
                break;
              default:
                s.vertexAttrib1fv(K.location, fe);
            }
        }
      }
    }
    S();
  }
  function x() {
    O();
    for (const B in o) {
      const Q = o[B];
      for (const j in Q) {
        const X = Q[j];
        for (const Z in X)
          f(X[Z].object), delete X[Z];
        delete Q[j];
      }
      delete o[B];
    }
  }
  function b(B) {
    if (o[B.id] === void 0) return;
    const Q = o[B.id];
    for (const j in Q) {
      const X = Q[j];
      for (const Z in X)
        f(X[Z].object), delete X[Z];
      delete Q[j];
    }
    delete o[B.id];
  }
  function D(B) {
    for (const Q in o) {
      const j = o[Q];
      if (j[B.id] === void 0) continue;
      const X = j[B.id];
      for (const Z in X)
        f(X[Z].object), delete X[Z];
      delete j[B.id];
    }
  }
  function O() {
    Y(), h = !0, c !== l && (c = l, p(c.object));
  }
  function Y() {
    l.geometry = null, l.program = null, l.wireframe = !1;
  }
  return {
    setup: u,
    reset: O,
    resetDefaultState: Y,
    dispose: x,
    releaseStatesOfGeometry: b,
    releaseStatesOfProgram: D,
    initAttributes: g,
    enableAttribute: _,
    disableUnusedAttributes: S
  };
}
function mT(s, e, t, i) {
  const n = i.isWebGL2;
  let r;
  function a(c) {
    r = c;
  }
  function o(c, h) {
    s.drawArrays(r, c, h), t.update(h, r, 1);
  }
  function l(c, h, u) {
    if (u === 0) return;
    let d, p;
    if (n)
      d = s, p = "drawArraysInstanced";
    else if (d = e.get("ANGLE_instanced_arrays"), p = "drawArraysInstancedANGLE", d === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    d[p](r, c, h, u), t.update(h, r, u);
  }
  this.setMode = a, this.render = o, this.renderInstances = l;
}
function gT(s, e, t) {
  let i;
  function n() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const C = e.get("EXT_texture_filter_anisotropic");
      i = s.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  function r(C) {
    if (C === "highp") {
      if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
        return "highp";
      C = "mediump";
    }
    return C === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  const a = typeof WebGL2RenderingContext < "u" && s.constructor.name === "WebGL2RenderingContext";
  let o = t.precision !== void 0 ? t.precision : "highp";
  const l = r(o);
  l !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", l, "instead."), o = l);
  const c = a || e.has("WEBGL_draw_buffers"), h = t.logarithmicDepthBuffer === !0, u = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), d = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), p = s.getParameter(s.MAX_TEXTURE_SIZE), f = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), y = s.getParameter(s.MAX_VERTEX_ATTRIBS), A = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), m = s.getParameter(s.MAX_VARYING_VECTORS), v = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), g = d > 0, _ = a || e.has("OES_texture_float"), w = g && _, S = a ? s.getParameter(s.MAX_SAMPLES) : 0;
  return {
    isWebGL2: a,
    drawBuffers: c,
    getMaxAnisotropy: n,
    getMaxPrecision: r,
    precision: o,
    logarithmicDepthBuffer: h,
    maxTextures: u,
    maxVertexTextures: d,
    maxTextureSize: p,
    maxCubemapSize: f,
    maxAttributes: y,
    maxVertexUniforms: A,
    maxVaryings: m,
    maxFragmentUniforms: v,
    vertexTextures: g,
    floatFragmentTextures: _,
    floatVertexTextures: w,
    maxSamples: S
  };
}
function AT(s) {
  const e = this;
  let t = null, i = 0, n = !1, r = !1;
  const a = new Nr(), o = new yt(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(u, d) {
    const p = u.length !== 0 || d || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    i !== 0 || n;
    return n = d, i = u.length, p;
  }, this.beginShadows = function() {
    r = !0, h(null);
  }, this.endShadows = function() {
    r = !1;
  }, this.setGlobalState = function(u, d) {
    t = h(u, d, 0);
  }, this.setState = function(u, d, p) {
    const f = u.clippingPlanes, y = u.clipIntersection, A = u.clipShadows, m = s.get(u);
    if (!n || f === null || f.length === 0 || r && !A)
      r ? h(null) : c();
    else {
      const v = r ? 0 : i, g = v * 4;
      let _ = m.clippingState || null;
      l.value = _, _ = h(f, d, g, p);
      for (let w = 0; w !== g; ++w)
        _[w] = t[w];
      m.clippingState = _, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += v;
    }
  };
  function c() {
    l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function h(u, d, p, f) {
    const y = u !== null ? u.length : 0;
    let A = null;
    if (y !== 0) {
      if (A = l.value, f !== !0 || A === null) {
        const m = p + y * 4, v = d.matrixWorldInverse;
        o.getNormalMatrix(v), (A === null || A.length < m) && (A = new Float32Array(m));
        for (let g = 0, _ = p; g !== y; ++g, _ += 4)
          a.copy(u[g]).applyMatrix4(v, o), a.normal.toArray(A, _), A[_ + 3] = a.constant;
      }
      l.value = A, l.needsUpdate = !0;
    }
    return e.numPlanes = y, e.numIntersection = 0, A;
  }
}
function yT(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(a, o) {
    return o === Ia ? a.mapping = qr : o === Kd && (a.mapping = go), a;
  }
  function i(a) {
    if (a && a.isTexture && a.isRenderTargetTexture === !1) {
      const o = a.mapping;
      if (o === Ia || o === Kd)
        if (e.has(a)) {
          const l = e.get(a).texture;
          return l.rotation = a.rotation, t(l, a.mapping);
        } else {
          const l = a.image;
          if (l && l.height > 0) {
            const c = new Aw(l.height / 2);
            return c.fromEquirectangularTexture(s, a), c.texture.rotation = a.rotation, e.set(a, c), a.addEventListener("dispose", n), t(c.texture, a.mapping);
          } else
            return null;
        }
    }
    return a;
  }
  function n(a) {
    const o = a.target;
    o.removeEventListener("dispose", n);
    const l = e.get(o);
    l !== void 0 && (e.delete(o), l.dispose());
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: r
  };
}
class _r extends Up {
  constructor(e = -1, t = 1, i = 1, n = -1, r = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = r, this.far = a, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, i, n, r, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
    let r = i - e, a = i + e, o = n + t, l = n - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r += c * this.view.offsetX, a = r + c * this.view.width, o -= h * this.view.offsetY, l = o - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const Tl = 4, L0 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], so = 20, Lf = /* @__PURE__ */ new _r(), U0 = /* @__PURE__ */ new se();
let Uf = null, Ff = 0, Of = 0;
const eo = (1 + Math.sqrt(5)) / 2, hl = 1 / eo, F0 = [
  /* @__PURE__ */ new M(1, 1, 1),
  /* @__PURE__ */ new M(-1, 1, 1),
  /* @__PURE__ */ new M(1, 1, -1),
  /* @__PURE__ */ new M(-1, 1, -1),
  /* @__PURE__ */ new M(0, eo, hl),
  /* @__PURE__ */ new M(0, eo, -hl),
  /* @__PURE__ */ new M(hl, 0, eo),
  /* @__PURE__ */ new M(-hl, 0, eo),
  /* @__PURE__ */ new M(eo, hl, 0),
  /* @__PURE__ */ new M(-eo, hl, 0)
];
class O0 {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, i = 0.1, n = 100) {
    Uf = this._renderer.getRenderTarget(), Ff = this._renderer.getActiveCubeFace(), Of = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const r = this._allocateTargets();
    return r.depthBuffer = !0, this._sceneToCubeUV(e, i, n, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = G0(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = k0(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Uf, Ff, Of), e.scissorTest = !1, ju(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === qr || e.mapping === go ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Uf = this._renderer.getRenderTarget(), Ff = this._renderer.getActiveCubeFace(), Of = this._renderer.getActiveMipmapLevel();
    const i = t || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = {
      magFilter: tt,
      minFilter: tt,
      generateMipmaps: !1,
      type: Qt,
      format: ei,
      colorSpace: Mt,
      depthBuffer: !1
    }, n = N0(e, t, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = N0(e, t, i);
      const { _lodMax: r } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = vT(r)), this._blurMaterial = _T(r, e, t);
    }
    return n;
  }
  _compileMaterial(e) {
    const t = new Se(this._lodPlanes[0], e);
    this._renderer.compile(t, Lf);
  }
  _sceneToCubeUV(e, t, i, n) {
    const o = new ki(90, 1, t, i), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], h = this._renderer, u = h.autoClear, d = h.toneMapping;
    h.getClearColor(U0), h.toneMapping = Vr, h.autoClear = !1;
    const p = new $s({
      name: "PMREM.Background",
      side: vn,
      depthWrite: !1,
      depthTest: !1
    }), f = new Se(new Si(), p);
    let y = !1;
    const A = e.background;
    A ? A.isColor && (p.color.copy(A), e.background = null, y = !0) : (p.color.copy(U0), y = !0);
    for (let m = 0; m < 6; m++) {
      const v = m % 3;
      v === 0 ? (o.up.set(0, l[m], 0), o.lookAt(c[m], 0, 0)) : v === 1 ? (o.up.set(0, 0, l[m]), o.lookAt(0, c[m], 0)) : (o.up.set(0, l[m], 0), o.lookAt(0, 0, c[m]));
      const g = this._cubeSize;
      ju(n, v * g, m > 2 ? g : 0, g, g), h.setRenderTarget(n), y && h.render(f, o), h.render(e, o);
    }
    f.geometry.dispose(), f.material.dispose(), h.toneMapping = d, h.autoClear = u, e.background = A;
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer, n = e.mapping === qr || e.mapping === go;
    n ? (this._cubemapMaterial === null && (this._cubemapMaterial = G0()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = k0());
    const r = n ? this._cubemapMaterial : this._equirectMaterial, a = new Se(this._lodPlanes[0], r), o = r.uniforms;
    o.envMap.value = e;
    const l = this._cubeSize;
    ju(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(a, Lf);
  }
  _applyPMREM(e) {
    const t = this._renderer, i = t.autoClear;
    t.autoClear = !1;
    for (let n = 1; n < this._lodPlanes.length; n++) {
      const r = Math.sqrt(this._sigmas[n] * this._sigmas[n] - this._sigmas[n - 1] * this._sigmas[n - 1]), a = F0[(n - 1) % F0.length];
      this._blur(e, n - 1, n, r, a);
    }
    t.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, i, n, r) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      a,
      t,
      i,
      n,
      "latitudinal",
      r
    ), this._halfBlur(
      a,
      e,
      i,
      i,
      n,
      "longitudinal",
      r
    );
  }
  _halfBlur(e, t, i, n, r, a, o) {
    const l = this._renderer, c = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const h = 3, u = new Se(this._lodPlanes[n], c), d = c.uniforms, p = this._sizeLods[i] - 1, f = isFinite(r) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * so - 1), y = r / f, A = isFinite(r) ? 1 + Math.floor(h * y) : so;
    A > so && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${A} samples when the maximum is set to ${so}`);
    const m = [];
    let v = 0;
    for (let C = 0; C < so; ++C) {
      const E = C / y, x = Math.exp(-E * E / 2);
      m.push(x), C === 0 ? v += x : C < A && (v += 2 * x);
    }
    for (let C = 0; C < m.length; C++)
      m[C] = m[C] / v;
    d.envMap.value = e.texture, d.samples.value = A, d.weights.value = m, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
    const { _lodMax: g } = this;
    d.dTheta.value = f, d.mipInt.value = g - i;
    const _ = this._sizeLods[n], w = 3 * _ * (n > g - Tl ? n - g + Tl : 0), S = 4 * (this._cubeSize - _);
    ju(t, w, S, 3 * _, 2 * _), l.setRenderTarget(t), l.render(u, Lf);
  }
}
function vT(s) {
  const e = [], t = [], i = [];
  let n = s;
  const r = s - Tl + 1 + L0.length;
  for (let a = 0; a < r; a++) {
    const o = Math.pow(2, n);
    t.push(o);
    let l = 1 / o;
    a > s - Tl ? l = L0[a - s + Tl - 1] : a === 0 && (l = 0), i.push(l);
    const c = 1 / (o - 2), h = -c, u = 1 + c, d = [h, h, u, h, u, u, h, h, u, u, h, u], p = 6, f = 6, y = 3, A = 2, m = 1, v = new Float32Array(y * f * p), g = new Float32Array(A * f * p), _ = new Float32Array(m * f * p);
    for (let S = 0; S < p; S++) {
      const C = S % 3 * 2 / 3 - 1, E = S > 2 ? 0 : -1, x = [
        C,
        E,
        0,
        C + 2 / 3,
        E,
        0,
        C + 2 / 3,
        E + 1,
        0,
        C,
        E,
        0,
        C + 2 / 3,
        E + 1,
        0,
        C,
        E + 1,
        0
      ];
      v.set(x, y * f * S), g.set(d, A * f * S);
      const b = [S, S, S, S, S, S];
      _.set(b, m * f * S);
    }
    const w = new Ze();
    w.setAttribute("position", new Je(v, y)), w.setAttribute("uv", new Je(g, A)), w.setAttribute("faceIndex", new Je(_, m)), e.push(w), n > Tl && n--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function N0(s, e, t) {
  const i = new Zn(s, e, t);
  return i.texture.mapping = xc, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i;
}
function ju(s, e, t, i, n) {
  s.viewport.set(e, t, i, n), s.scissor.set(e, t, i, n);
}
function _T(s, e, t) {
  const i = new Float32Array(so), n = new M(0, 1, 0);
  return new ln({
    name: "SphericalGaussianBlur",
    defines: {
      n: so,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${s}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: n }
    },
    vertexShader: dA(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: _n,
    depthTest: !1,
    depthWrite: !1
  });
}
function k0() {
  return new ln({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: dA(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: _n,
    depthTest: !1,
    depthWrite: !1
  });
}
function G0() {
  return new ln({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: dA(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: _n,
    depthTest: !1,
    depthWrite: !1
  });
}
function dA() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function xT(s) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function i(o) {
    if (o && o.isTexture) {
      const l = o.mapping, c = l === Ia || l === Kd, h = l === qr || l === go;
      if (c || h)
        if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
          o.needsPMREMUpdate = !1;
          let u = e.get(o);
          return t === null && (t = new O0(s)), u = c ? t.fromEquirectangular(o, u) : t.fromCubemap(o, u), e.set(o, u), u.texture;
        } else {
          if (e.has(o))
            return e.get(o).texture;
          {
            const u = o.image;
            if (c && u && u.height > 0 || h && u && n(u)) {
              t === null && (t = new O0(s));
              const d = c ? t.fromEquirectangular(o) : t.fromCubemap(o);
              return e.set(o, d), o.addEventListener("dispose", r), d.texture;
            } else
              return null;
          }
        }
    }
    return o;
  }
  function n(o) {
    let l = 0;
    const c = 6;
    for (let h = 0; h < c; h++)
      o[h] !== void 0 && l++;
    return l === c;
  }
  function r(o) {
    const l = o.target;
    l.removeEventListener("dispose", r);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: i,
    dispose: a
  };
}
function wT(s) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0)
      return e[i];
    let n;
    switch (i) {
      case "WEBGL_depth_texture":
        n = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        n = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        n = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        n = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        n = s.getExtension(i);
    }
    return e[i] = n, n;
  }
  return {
    has: function(i) {
      return t(i) !== null;
    },
    init: function(i) {
      i.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(i) {
      const n = t(i);
      return n === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), n;
    }
  };
}
function ET(s, e, t, i) {
  const n = {}, r = /* @__PURE__ */ new WeakMap();
  function a(u) {
    const d = u.target;
    d.index !== null && e.remove(d.index);
    for (const f in d.attributes)
      e.remove(d.attributes[f]);
    for (const f in d.morphAttributes) {
      const y = d.morphAttributes[f];
      for (let A = 0, m = y.length; A < m; A++)
        e.remove(y[A]);
    }
    d.removeEventListener("dispose", a), delete n[d.id];
    const p = r.get(d);
    p && (e.remove(p), r.delete(d)), i.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, t.memory.geometries--;
  }
  function o(u, d) {
    return n[d.id] === !0 || (d.addEventListener("dispose", a), n[d.id] = !0, t.memory.geometries++), d;
  }
  function l(u) {
    const d = u.attributes;
    for (const f in d)
      e.update(d[f], s.ARRAY_BUFFER);
    const p = u.morphAttributes;
    for (const f in p) {
      const y = p[f];
      for (let A = 0, m = y.length; A < m; A++)
        e.update(y[A], s.ARRAY_BUFFER);
    }
  }
  function c(u) {
    const d = [], p = u.index, f = u.attributes.position;
    let y = 0;
    if (p !== null) {
      const v = p.array;
      y = p.version;
      for (let g = 0, _ = v.length; g < _; g += 3) {
        const w = v[g + 0], S = v[g + 1], C = v[g + 2];
        d.push(w, S, S, C, C, w);
      }
    } else if (f !== void 0) {
      const v = f.array;
      y = f.version;
      for (let g = 0, _ = v.length / 3 - 1; g < _; g += 3) {
        const w = g + 0, S = g + 1, C = g + 2;
        d.push(w, S, S, C, C, w);
      }
    } else
      return;
    const A = new (dw(d) ? mw : hA)(d, 1);
    A.version = y;
    const m = r.get(u);
    m && e.remove(m), r.set(u, A);
  }
  function h(u) {
    const d = r.get(u);
    if (d) {
      const p = u.index;
      p !== null && d.version < p.version && c(u);
    } else
      c(u);
    return r.get(u);
  }
  return {
    get: o,
    update: l,
    getWireframeAttribute: h
  };
}
function bT(s, e, t, i) {
  const n = i.isWebGL2;
  let r;
  function a(d) {
    r = d;
  }
  let o, l;
  function c(d) {
    o = d.type, l = d.bytesPerElement;
  }
  function h(d, p) {
    s.drawElements(r, p, o, d * l), t.update(p, r, 1);
  }
  function u(d, p, f) {
    if (f === 0) return;
    let y, A;
    if (n)
      y = s, A = "drawElementsInstanced";
    else if (y = e.get("ANGLE_instanced_arrays"), A = "drawElementsInstancedANGLE", y === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    y[A](r, p, o, d * l, f), t.update(p, r, f);
  }
  this.setMode = a, this.setIndex = c, this.render = h, this.renderInstances = u;
}
function ST(s) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function i(r, a, o) {
    switch (t.calls++, a) {
      case s.TRIANGLES:
        t.triangles += o * (r / 3);
        break;
      case s.LINES:
        t.lines += o * (r / 2);
        break;
      case s.LINE_STRIP:
        t.lines += o * (r - 1);
        break;
      case s.LINE_LOOP:
        t.lines += o * r;
        break;
      case s.POINTS:
        t.points += o * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function n() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: n,
    update: i
  };
}
function CT(s, e) {
  return s[0] - e[0];
}
function MT(s, e) {
  return Math.abs(e[1]) - Math.abs(s[1]);
}
function TT(s, e, t) {
  const i = {}, n = new Float32Array(8), r = /* @__PURE__ */ new WeakMap(), a = new it(), o = [];
  for (let c = 0; c < 8; c++)
    o[c] = [c, 0];
  function l(c, h, u) {
    const d = c.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const p = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color, f = p !== void 0 ? p.length : 0;
      let y = r.get(h);
      if (y === void 0 || y.count !== f) {
        let B = function() {
          O.dispose(), r.delete(h), h.removeEventListener("dispose", B);
        };
        y !== void 0 && y.texture.dispose();
        const v = h.morphAttributes.position !== void 0, g = h.morphAttributes.normal !== void 0, _ = h.morphAttributes.color !== void 0, w = h.morphAttributes.position || [], S = h.morphAttributes.normal || [], C = h.morphAttributes.color || [];
        let E = 0;
        v === !0 && (E = 1), g === !0 && (E = 2), _ === !0 && (E = 3);
        let x = h.attributes.position.count * E, b = 1;
        x > e.maxTextureSize && (b = Math.ceil(x / e.maxTextureSize), x = e.maxTextureSize);
        const D = new Float32Array(x * b * 4 * f), O = new oA(D, x, b, f);
        O.type = Xt, O.needsUpdate = !0;
        const Y = E * 4;
        for (let Q = 0; Q < f; Q++) {
          const j = w[Q], X = S[Q], Z = C[Q], ee = x * b * 4 * Q;
          for (let J = 0; J < j.count; J++) {
            const W = J * Y;
            v === !0 && (a.fromBufferAttribute(j, J), D[ee + W + 0] = a.x, D[ee + W + 1] = a.y, D[ee + W + 2] = a.z, D[ee + W + 3] = 0), g === !0 && (a.fromBufferAttribute(X, J), D[ee + W + 4] = a.x, D[ee + W + 5] = a.y, D[ee + W + 6] = a.z, D[ee + W + 7] = 0), _ === !0 && (a.fromBufferAttribute(Z, J), D[ee + W + 8] = a.x, D[ee + W + 9] = a.y, D[ee + W + 10] = a.z, D[ee + W + 11] = Z.itemSize === 4 ? a.w : 1);
          }
        }
        y = {
          count: f,
          texture: O,
          size: new ie(x, b)
        }, r.set(h, y), h.addEventListener("dispose", B);
      }
      let A = 0;
      for (let v = 0; v < d.length; v++)
        A += d[v];
      const m = h.morphTargetsRelative ? 1 : 1 - A;
      u.getUniforms().setValue(s, "morphTargetBaseInfluence", m), u.getUniforms().setValue(s, "morphTargetInfluences", d), u.getUniforms().setValue(s, "morphTargetsTexture", y.texture, t), u.getUniforms().setValue(s, "morphTargetsTextureSize", y.size);
    } else {
      const p = d === void 0 ? 0 : d.length;
      let f = i[h.id];
      if (f === void 0 || f.length !== p) {
        f = [];
        for (let g = 0; g < p; g++)
          f[g] = [g, 0];
        i[h.id] = f;
      }
      for (let g = 0; g < p; g++) {
        const _ = f[g];
        _[0] = g, _[1] = d[g];
      }
      f.sort(MT);
      for (let g = 0; g < 8; g++)
        g < p && f[g][1] ? (o[g][0] = f[g][0], o[g][1] = f[g][1]) : (o[g][0] = Number.MAX_SAFE_INTEGER, o[g][1] = 0);
      o.sort(CT);
      const y = h.morphAttributes.position, A = h.morphAttributes.normal;
      let m = 0;
      for (let g = 0; g < 8; g++) {
        const _ = o[g], w = _[0], S = _[1];
        w !== Number.MAX_SAFE_INTEGER && S ? (y && h.getAttribute("morphTarget" + g) !== y[w] && h.setAttribute("morphTarget" + g, y[w]), A && h.getAttribute("morphNormal" + g) !== A[w] && h.setAttribute("morphNormal" + g, A[w]), n[g] = S, m += S) : (y && h.hasAttribute("morphTarget" + g) === !0 && h.deleteAttribute("morphTarget" + g), A && h.hasAttribute("morphNormal" + g) === !0 && h.deleteAttribute("morphNormal" + g), n[g] = 0);
      }
      const v = h.morphTargetsRelative ? 1 : 1 - m;
      u.getUniforms().setValue(s, "morphTargetBaseInfluence", v), u.getUniforms().setValue(s, "morphTargetInfluences", n);
    }
  }
  return {
    update: l
  };
}
function IT(s, e, t, i) {
  let n = /* @__PURE__ */ new WeakMap();
  function r(l) {
    const c = i.render.frame, h = l.geometry, u = e.get(l, h);
    if (n.get(u) !== c && (e.update(u), n.set(u, c)), l.isInstancedMesh && (l.hasEventListener("dispose", o) === !1 && l.addEventListener("dispose", o), n.get(l) !== c && (t.update(l.instanceMatrix, s.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, s.ARRAY_BUFFER), n.set(l, c))), l.isSkinnedMesh) {
      const d = l.skeleton;
      n.get(d) !== c && (d.update(), n.set(d, c));
    }
    return u;
  }
  function a() {
    n = /* @__PURE__ */ new WeakMap();
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return {
    update: r,
    dispose: a
  };
}
const vw = /* @__PURE__ */ new Nt(), _w = /* @__PURE__ */ new oA(), xw = /* @__PURE__ */ new lA(), ww = /* @__PURE__ */ new Fp(), z0 = [], Q0 = [], H0 = new Float32Array(16), V0 = new Float32Array(9), W0 = new Float32Array(4);
function bc(s, e, t) {
  const i = s[0];
  if (i <= 0 || i > 0) return s;
  const n = e * t;
  let r = z0[n];
  if (r === void 0 && (r = new Float32Array(n), z0[n] = r), e !== 0) {
    i.toArray(r, 0);
    for (let a = 1, o = 0; a !== e; ++a)
      o += t, s[a].toArray(r, o);
  }
  return r;
}
function tn(s, e) {
  if (s.length !== e.length) return !1;
  for (let t = 0, i = s.length; t < i; t++)
    if (s[t] !== e[t]) return !1;
  return !0;
}
function nn(s, e) {
  for (let t = 0, i = e.length; t < i; t++)
    s[t] = e[t];
}
function Op(s, e) {
  let t = Q0[e];
  t === void 0 && (t = new Int32Array(e), Q0[e] = t);
  for (let i = 0; i !== e; ++i)
    t[i] = s.allocateTextureUnit();
  return t;
}
function DT(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1f(this.addr, e), t[0] = e);
}
function RT(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (tn(t, e)) return;
    s.uniform2fv(this.addr, e), nn(t, e);
  }
}
function BT(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (tn(t, e)) return;
    s.uniform3fv(this.addr, e), nn(t, e);
  }
}
function PT(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (tn(t, e)) return;
    s.uniform4fv(this.addr, e), nn(t, e);
  }
}
function LT(s, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (tn(t, e)) return;
    s.uniformMatrix2fv(this.addr, !1, e), nn(t, e);
  } else {
    if (tn(t, i)) return;
    W0.set(i), s.uniformMatrix2fv(this.addr, !1, W0), nn(t, i);
  }
}
function UT(s, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (tn(t, e)) return;
    s.uniformMatrix3fv(this.addr, !1, e), nn(t, e);
  } else {
    if (tn(t, i)) return;
    V0.set(i), s.uniformMatrix3fv(this.addr, !1, V0), nn(t, i);
  }
}
function FT(s, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (tn(t, e)) return;
    s.uniformMatrix4fv(this.addr, !1, e), nn(t, e);
  } else {
    if (tn(t, i)) return;
    H0.set(i), s.uniformMatrix4fv(this.addr, !1, H0), nn(t, i);
  }
}
function OT(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1i(this.addr, e), t[0] = e);
}
function NT(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (tn(t, e)) return;
    s.uniform2iv(this.addr, e), nn(t, e);
  }
}
function kT(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (tn(t, e)) return;
    s.uniform3iv(this.addr, e), nn(t, e);
  }
}
function GT(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (tn(t, e)) return;
    s.uniform4iv(this.addr, e), nn(t, e);
  }
}
function zT(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1ui(this.addr, e), t[0] = e);
}
function QT(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (tn(t, e)) return;
    s.uniform2uiv(this.addr, e), nn(t, e);
  }
}
function HT(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (tn(t, e)) return;
    s.uniform3uiv(this.addr, e), nn(t, e);
  }
}
function VT(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (tn(t, e)) return;
    s.uniform4uiv(this.addr, e), nn(t, e);
  }
}
function WT(s, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), t.setTexture2D(e || vw, n);
}
function jT(s, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), t.setTexture3D(e || xw, n);
}
function qT(s, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), t.setTextureCube(e || ww, n);
}
function XT(s, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), t.setTexture2DArray(e || _w, n);
}
function YT(s) {
  switch (s) {
    case 5126:
      return DT;
    // FLOAT
    case 35664:
      return RT;
    // _VEC2
    case 35665:
      return BT;
    // _VEC3
    case 35666:
      return PT;
    // _VEC4
    case 35674:
      return LT;
    // _MAT2
    case 35675:
      return UT;
    // _MAT3
    case 35676:
      return FT;
    // _MAT4
    case 5124:
    case 35670:
      return OT;
    // INT, BOOL
    case 35667:
    case 35671:
      return NT;
    // _VEC2
    case 35668:
    case 35672:
      return kT;
    // _VEC3
    case 35669:
    case 35673:
      return GT;
    // _VEC4
    case 5125:
      return zT;
    // UINT
    case 36294:
      return QT;
    // _VEC2
    case 36295:
      return HT;
    // _VEC3
    case 36296:
      return VT;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return WT;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return jT;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return qT;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return XT;
  }
}
function KT(s, e) {
  s.uniform1fv(this.addr, e);
}
function JT(s, e) {
  const t = bc(e, this.size, 2);
  s.uniform2fv(this.addr, t);
}
function $T(s, e) {
  const t = bc(e, this.size, 3);
  s.uniform3fv(this.addr, t);
}
function ZT(s, e) {
  const t = bc(e, this.size, 4);
  s.uniform4fv(this.addr, t);
}
function eI(s, e) {
  const t = bc(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, t);
}
function tI(s, e) {
  const t = bc(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, t);
}
function iI(s, e) {
  const t = bc(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, t);
}
function nI(s, e) {
  s.uniform1iv(this.addr, e);
}
function sI(s, e) {
  s.uniform2iv(this.addr, e);
}
function rI(s, e) {
  s.uniform3iv(this.addr, e);
}
function aI(s, e) {
  s.uniform4iv(this.addr, e);
}
function oI(s, e) {
  s.uniform1uiv(this.addr, e);
}
function lI(s, e) {
  s.uniform2uiv(this.addr, e);
}
function cI(s, e) {
  s.uniform3uiv(this.addr, e);
}
function hI(s, e) {
  s.uniform4uiv(this.addr, e);
}
function uI(s, e, t) {
  const i = this.cache, n = e.length, r = Op(t, n);
  tn(i, r) || (s.uniform1iv(this.addr, r), nn(i, r));
  for (let a = 0; a !== n; ++a)
    t.setTexture2D(e[a] || vw, r[a]);
}
function dI(s, e, t) {
  const i = this.cache, n = e.length, r = Op(t, n);
  tn(i, r) || (s.uniform1iv(this.addr, r), nn(i, r));
  for (let a = 0; a !== n; ++a)
    t.setTexture3D(e[a] || xw, r[a]);
}
function pI(s, e, t) {
  const i = this.cache, n = e.length, r = Op(t, n);
  tn(i, r) || (s.uniform1iv(this.addr, r), nn(i, r));
  for (let a = 0; a !== n; ++a)
    t.setTextureCube(e[a] || ww, r[a]);
}
function fI(s, e, t) {
  const i = this.cache, n = e.length, r = Op(t, n);
  tn(i, r) || (s.uniform1iv(this.addr, r), nn(i, r));
  for (let a = 0; a !== n; ++a)
    t.setTexture2DArray(e[a] || _w, r[a]);
}
function mI(s) {
  switch (s) {
    case 5126:
      return KT;
    // FLOAT
    case 35664:
      return JT;
    // _VEC2
    case 35665:
      return $T;
    // _VEC3
    case 35666:
      return ZT;
    // _VEC4
    case 35674:
      return eI;
    // _MAT2
    case 35675:
      return tI;
    // _MAT3
    case 35676:
      return iI;
    // _MAT4
    case 5124:
    case 35670:
      return nI;
    // INT, BOOL
    case 35667:
    case 35671:
      return sI;
    // _VEC2
    case 35668:
    case 35672:
      return rI;
    // _VEC3
    case 35669:
    case 35673:
      return aI;
    // _VEC4
    case 5125:
      return oI;
    // UINT
    case 36294:
      return lI;
    // _VEC2
    case 36295:
      return cI;
    // _VEC3
    case 36296:
      return hI;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return uI;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return dI;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return pI;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return fI;
  }
}
class gI {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.setValue = YT(t.type);
  }
}
class AI {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = mI(t.type);
  }
}
class yI {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, i) {
    const n = this.seq;
    for (let r = 0, a = n.length; r !== a; ++r) {
      const o = n[r];
      o.setValue(e, t[o.id], i);
    }
  }
}
const Nf = /(\w+)(\])?(\[|\.)?/g;
function j0(s, e) {
  s.seq.push(e), s.map[e.id] = e;
}
function vI(s, e, t) {
  const i = s.name, n = i.length;
  for (Nf.lastIndex = 0; ; ) {
    const r = Nf.exec(i), a = Nf.lastIndex;
    let o = r[1];
    const l = r[2] === "]", c = r[3];
    if (l && (o = o | 0), c === void 0 || c === "[" && a + 2 === n) {
      j0(t, c === void 0 ? new gI(o, s, e) : new AI(o, s, e));
      break;
    } else {
      let u = t.map[o];
      u === void 0 && (u = new yI(o), j0(t, u)), t = u;
    }
  }
}
class Pd {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let n = 0; n < i; ++n) {
      const r = e.getActiveUniform(t, n), a = e.getUniformLocation(t, r.name);
      vI(r, a, this);
    }
  }
  setValue(e, t, i, n) {
    const r = this.map[t];
    r !== void 0 && r.setValue(e, i, n);
  }
  setOptional(e, t, i) {
    const n = t[i];
    n !== void 0 && this.setValue(e, i, n);
  }
  static upload(e, t, i, n) {
    for (let r = 0, a = t.length; r !== a; ++r) {
      const o = t[r], l = i[o.id];
      l.needsUpdate !== !1 && o.setValue(e, l.value, n);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let n = 0, r = e.length; n !== r; ++n) {
      const a = e[n];
      a.id in t && i.push(a);
    }
    return i;
  }
}
function q0(s, e, t) {
  const i = s.createShader(e);
  return s.shaderSource(i, t), s.compileShader(i), i;
}
const _I = 37297;
let xI = 0;
function wI(s, e) {
  const t = s.split(`
`), i = [], n = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
  for (let a = n; a < r; a++) {
    const o = a + 1;
    i.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
  }
  return i.join(`
`);
}
function EI(s) {
  const e = Rt.getPrimaries(Rt.workingColorSpace), t = s === Wt || s === Es ? null : Rt.getPrimaries(s);
  let i;
  switch (e === t || !t ? i = "" : e === tp && t === ep ? i = "LinearDisplayP3ToLinearSRGB" : e === ep && t === tp && (i = "LinearSRGBToLinearDisplayP3"), s) {
    case Wt:
      return ["", ""];
    case Mt:
    case ru:
      return [i, "LinearTransferOETF"];
    case dt:
    case su:
      return [i, "sRGBTransferOETF"];
    case Es:
      return ["", "LinearToRGBM16"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", s), [i, "LinearTransferOETF"];
  }
}
function X0(s, e, t) {
  const i = s.getShaderParameter(e, s.COMPILE_STATUS), n = s.getShaderInfoLog(e).trim();
  if (i && n === "") return "";
  const r = /ERROR: 0:(\d+)/.exec(n);
  if (r) {
    const a = parseInt(r[1]);
    return t.toUpperCase() + `

` + n + `

` + wI(s.getShaderSource(e), a);
  } else
    return n;
}
function bI(s, e) {
  let t;
  switch (e) {
    case Mt:
      t = "";
      break;
    case dt:
      t = "sRGBToLinear";
      break;
    case Es:
      t = "RGBM16ToLinear";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported color space:", e), t = "";
      break;
  }
  return `vec4 ${s}( vec4 value ) { return ${t} ( value ); }`;
}
function SI(s, e) {
  const t = EI(e);
  return `vec4 ${s}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function CI(s, e) {
  let t;
  switch (e) {
    case Jx:
      t = "Linear";
      break;
    case $x:
      t = "Reinhard";
      break;
    case Zx:
      t = "OptimizedCineon";
      break;
    case eA:
      t = "ACESFilmic";
      break;
    case ew:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function MI(s) {
  return [
    s.extensionDerivatives || s.envMapCubeUVHeight || s.bumpMap || s.normalMapTangentSpace || s.clearcoatNormalMap || s.flatShading || s.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (s.extensionFragDepth || s.logarithmicDepthBuffer) && s.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    s.extensionDrawBuffers && s.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (s.extensionShaderTextureLOD || s.envMap || s.transmission) && s.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(fh).join(`
`);
}
function TI(s) {
  const e = [];
  for (const t in s) {
    const i = s[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function II(s, e) {
  const t = {}, i = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let n = 0; n < i; n++) {
    const r = s.getActiveAttrib(e, n), a = r.name;
    let o = 1;
    r.type === s.FLOAT_MAT2 && (o = 2), r.type === s.FLOAT_MAT3 && (o = 3), r.type === s.FLOAT_MAT4 && (o = 4), t[a] = {
      type: r.type,
      location: s.getAttribLocation(e, a),
      locationSize: o
    };
  }
  return t;
}
function fh(s) {
  return s !== "";
}
function Y0(s, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function K0(s, e) {
  return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const DI = /^[ \t]*#include +<([\w\d./]+)>/gm;
function eg(s) {
  return s.replace(DI, BI);
}
const RI = /* @__PURE__ */ new Map([
  ["encodings_fragment", "colorspace_fragment"],
  // @deprecated, r154
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  // @deprecated, r154
  ["output_fragment", "opaque_fragment"]
  // @deprecated, r154
]);
function BI(s, e) {
  let t = ft[e];
  if (t === void 0) {
    const i = RI.get(e);
    if (i !== void 0)
      t = ft[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return eg(t);
}
const PI = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function J0(s) {
  return s.replace(PI, LI);
}
function LI(s, e, t, i) {
  let n = "";
  for (let r = parseInt(e); r < parseInt(t); r++)
    n += i.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
  return n;
}
function $0(s) {
  let e = "precision " + s.precision + ` float;
precision ` + s.precision + " int;";
  return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function UI(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return s.shadowMapType === Zg ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === BS ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === Lr && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function FI(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case qr:
      case go:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case xc:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function OI(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case go:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function NI(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case _c:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case PS:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case LS:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function kI(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: i, maxMip: t };
}
function GI(s, e, t, i) {
  const n = s.getContext(), r = t.defines;
  let a = t.vertexShader, o = t.fragmentShader;
  const l = UI(t), c = FI(t), h = OI(t), u = NI(t), d = kI(t), p = t.isWebGL2 ? "" : MI(t), f = TI(r), y = n.createProgram();
  let A, m, v = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (A = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    f
  ].filter(fh).join(`
`), A.length > 0 && (A += `
`), m = [
    p,
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    f
  ].filter(fh).join(`
`), m.length > 0 && (m += `
`)) : (A = [
    $0(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    f,
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + h : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(fh).join(`
`), m = [
    p,
    $0(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    f,
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + c : "",
    t.envMap ? "#define " + h : "",
    t.envMap ? "#define " + u : "",
    d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
    d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
    d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    // todo this might break stuff, flatShading should not be related to tangents
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== Vr ? "#define TONE_MAPPING" : "",
    t.toneMapping !== Vr ? ft.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== Vr ? CI("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    ft.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    SI("linearToOutputTexel", t.outputColorSpace),
    t.transmissionSamplerMapEncoding ? bI("transmissionSamplerMapTexelToLinear", t.transmissionSamplerMapEncoding) : "",
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(fh).join(`
`)), a = eg(a), a = Y0(a, t), a = K0(a, t), o = eg(o), o = Y0(o, t), o = K0(o, t), a = J0(a), o = J0(o), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (v = `#version 300 es
`, A = [
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + A, m = [
    "precision mediump sampler2DArray;",
    "#define varying in",
    t.glslVersion === Jm ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === Jm ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad",
    "#define WebGL2Context 1"
  ].join(`
`) + `
` + m);
  const g = v + A + a, _ = v + m + o, w = q0(n, n.VERTEX_SHADER, g), S = q0(n, n.FRAGMENT_SHADER, _);
  n.attachShader(y, w), n.attachShader(y, S), t.index0AttributeName !== void 0 ? n.bindAttribLocation(y, 0, t.index0AttributeName) : t.morphTargets === !0 && n.bindAttribLocation(y, 0, "position"), n.linkProgram(y);
  function C(D) {
    if (s.debug.checkShaderErrors) {
      const O = n.getProgramInfoLog(y).trim(), Y = n.getShaderInfoLog(w).trim(), B = n.getShaderInfoLog(S).trim();
      let Q = !0, j = !0;
      if (n.getProgramParameter(y, n.LINK_STATUS) === !1)
        if (Q = !1, typeof s.debug.onShaderError == "function")
          s.debug.onShaderError(n, y, w, S);
        else {
          const X = X0(n, w, "vertex"), Z = X0(n, S, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + n.getError() + " - VALIDATE_STATUS " + n.getProgramParameter(y, n.VALIDATE_STATUS) + `

Program Info Log: ` + O + `
` + X + `
` + Z
          );
        }
      else O !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", O) : (Y === "" || B === "") && (j = !1);
      j && (D.diagnostics = {
        runnable: Q,
        programLog: O,
        vertexShader: {
          log: Y,
          prefix: A
        },
        fragmentShader: {
          log: B,
          prefix: m
        }
      });
    }
    n.deleteShader(w), n.deleteShader(S), E = new Pd(n, y), x = II(n, y);
  }
  let E;
  this.getUniforms = function() {
    return E === void 0 && C(this), E;
  };
  let x;
  this.getAttributes = function() {
    return x === void 0 && C(this), x;
  };
  let b = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return b === !1 && (b = n.getProgramParameter(y, _I)), b;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), n.deleteProgram(y), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = xI++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = w, this.fragmentShader = S, this;
}
let zI = 0;
class QI {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, i = e.fragmentShader, n = this._getShaderStage(t), r = this._getShaderStage(i), a = this._getShaderCacheForMaterial(e);
    return a.has(n) === !1 && (a.add(n), n.usedTimes++), a.has(r) === !1 && (a.add(r), r.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && (i = new HI(e), t.set(e, i)), i;
  }
}
class HI {
  constructor(e) {
    this.id = zI++, this.code = e, this.usedTimes = 0;
  }
}
function VI(s, e, t, i, n, r, a) {
  const o = new cA(), l = new QI(), c = [], h = n.isWebGL2, u = n.logarithmicDepthBuffer, d = n.vertexTextures;
  let p = n.precision;
  const f = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function y(x) {
    return x === 0 ? "uv" : `uv${x}`;
  }
  function A(x, b, D, O, Y) {
    const B = O.fog, Q = Y.geometry, j = x.isMeshStandardMaterial ? O.environment : null, X = (x.isMeshStandardMaterial ? t : e).get(x.envMap || j), Z = X && X.mapping === xc ? X.image.height : null, ee = f[x.type];
    x.precision !== null && (p = n.getMaxPrecision(x.precision), p !== x.precision && console.warn("THREE.WebGLProgram.getParameters:", x.precision, "not supported, using", p, "instead."));
    const J = Q.morphAttributes.position || Q.morphAttributes.normal || Q.morphAttributes.color, W = J !== void 0 ? J.length : 0;
    let K = 0;
    Q.morphAttributes.position !== void 0 && (K = 1), Q.morphAttributes.normal !== void 0 && (K = 2), Q.morphAttributes.color !== void 0 && (K = 3);
    let ce, fe, ve, _e;
    if (ee) {
      const It = Ci[ee];
      ce = It.vertexShader, fe = It.fragmentShader;
    } else
      ce = x.vertexShader, fe = x.fragmentShader, l.update(x), ve = l.getVertexShaderID(x), _e = l.getFragmentShaderID(x);
    const ze = s.getRenderTarget(), Qe = s.userData && s.userData.transmissionRenderTarget, ot = ze ? Array.isArray(ze.texture) ? ze.texture[0] : ze.texture : null, ht = Y.isInstancedMesh === !0, Xe = !!x.map, G = !!x.matcap, Be = !!X, oe = !!x.aoMap, Ee = !!x.lightMap, de = !!x.bumpMap, Ke = !!x.normalMap, Ne = !!x.displacementMap, Ge = !!x.emissiveMap, nt = !!x.metalnessMap, wt = !!x.roughnessMap, di = x.anisotropy > 0, F = x.clearcoat > 0, R = x.iridescence > 0, te = x.sheen > 0, we = x.transmission > 0, Ae = di && !!x.anisotropyMap, Ce = F && !!x.clearcoatMap, We = F && !!x.clearcoatNormalMap, Me = F && !!x.clearcoatRoughnessMap, Le = R && !!x.iridescenceMap, z = R && !!x.iridescenceThicknessMap, ye = te && !!x.sheenColorMap, le = te && !!x.sheenRoughnessMap, at = !!x.specularMap, qe = !!x.specularColorMap, je = !!x.specularIntensityMap, Fe = we && !!x.transmissionMap, He = we && !!x.thicknessMap, me = !!x.gradientMap, q = !!x.alphaMap, ke = x.alphaTest > 0, xe = !!x.alphaHash, ae = !!x.extensions, De = !!Q.attributes.uv1, st = !!Q.attributes.uv2, Et = !!Q.attributes.uv3;
    let Kt = Vr;
    return x.toneMapped && (ze === null || ze.isXRRenderTarget === !0) && (Kt = s.toneMapping), {
      isWebGL2: h,
      shaderID: ee,
      shaderType: x.type,
      shaderName: x.name,
      vertexShader: ce,
      fragmentShader: fe,
      defines: x.defines,
      customVertexShaderID: ve,
      customFragmentShaderID: _e,
      isRawShaderMaterial: x.isRawShaderMaterial === !0,
      glslVersion: x.glslVersion,
      precision: p,
      instancing: ht,
      instancingColor: ht && Y.instanceColor !== null,
      supportsVertexTextures: d,
      outputColorSpace: ze === null ? s.outputColorSpace : ze.isXRRenderTarget === !0 || ot.colorSpace && ot.colorSpace !== dt ? ot.colorSpace : Mt,
      map: Xe,
      matcap: G,
      envMap: Be,
      envMapMode: Be && X.mapping,
      envMapCubeUVHeight: Z,
      aoMap: oe,
      lightMap: Ee,
      bumpMap: de,
      normalMap: Ke,
      displacementMap: d && Ne,
      emissiveMap: Ge,
      normalMapObjectSpace: Ke && x.normalMapType === hw,
      normalMapTangentSpace: Ke && x.normalMapType === Ts,
      metalnessMap: nt,
      roughnessMap: wt,
      anisotropy: di,
      anisotropyMap: Ae,
      clearcoat: F,
      clearcoatMap: Ce,
      clearcoatNormalMap: We,
      clearcoatRoughnessMap: Me,
      iridescence: R,
      iridescenceMap: Le,
      iridescenceThicknessMap: z,
      sheen: te,
      sheenColorMap: ye,
      sheenRoughnessMap: le,
      specularMap: at,
      specularColorMap: qe,
      specularIntensityMap: je,
      transmission: we,
      transmissionMap: Fe,
      thicknessMap: He,
      transmissionSamplerMapEncoding: Qe && Qe.texture.colorSpace || Mt,
      gradientMap: me,
      opaque: x.transparent === !1 && x.blending === dr && !(x.transmission > 0),
      alphaMap: q,
      alphaTest: ke,
      alphaHash: xe,
      combine: x.combine,
      //
      mapUv: Xe && y(x.map.channel),
      aoMapUv: oe && y(x.aoMap.channel),
      lightMapUv: Ee && y(x.lightMap.channel),
      bumpMapUv: de && y(x.bumpMap.channel),
      normalMapUv: Ke && y(x.normalMap.channel),
      displacementMapUv: Ne && y(x.displacementMap.channel),
      emissiveMapUv: Ge && y(x.emissiveMap.channel),
      metalnessMapUv: nt && y(x.metalnessMap.channel),
      roughnessMapUv: wt && y(x.roughnessMap.channel),
      anisotropyMapUv: Ae && y(x.anisotropyMap.channel),
      clearcoatMapUv: Ce && y(x.clearcoatMap.channel),
      clearcoatNormalMapUv: We && y(x.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Me && y(x.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Le && y(x.iridescenceMap.channel),
      iridescenceThicknessMapUv: z && y(x.iridescenceThicknessMap.channel),
      sheenColorMapUv: ye && y(x.sheenColorMap.channel),
      sheenRoughnessMapUv: le && y(x.sheenRoughnessMap.channel),
      specularMapUv: at && y(x.specularMap.channel),
      specularColorMapUv: qe && y(x.specularColorMap.channel),
      specularIntensityMapUv: je && y(x.specularIntensityMap.channel),
      transmissionMapUv: Fe && y(x.transmissionMap.channel),
      thicknessMapUv: He && y(x.thicknessMap.channel),
      alphaMapUv: q && y(x.alphaMap.channel),
      //
      vertexTangents: !!Q.attributes.tangent && (Ke || di || Q.userData.__forceUseTangent),
      vertexColors: x.vertexColors,
      vertexAlphas: x.vertexColors === !0 && !!Q.attributes.color && Q.attributes.color.itemSize === 4,
      vertexUv1s: De,
      vertexUv2s: st,
      vertexUv3s: Et,
      pointsUvs: Y.isPoints === !0 && !!Q.attributes.uv && (Xe || q),
      fog: !!B,
      useFog: x.fog === !0,
      fogExp2: B && B.isFogExp2,
      flatShading: x.flatShading === !0,
      sizeAttenuation: x.sizeAttenuation === !0,
      logarithmicDepthBuffer: u,
      skinning: Y.isSkinnedMesh === !0,
      morphTargets: Q.morphAttributes.position !== void 0,
      morphNormals: Q.morphAttributes.normal !== void 0,
      morphColors: Q.morphAttributes.color !== void 0,
      morphTargetsCount: W,
      morphTextureStride: K,
      numDirLights: b.directional.length,
      numPointLights: b.point.length,
      numSpotLights: b.spot.length,
      numSpotLightMaps: b.spotLightMap.length,
      numRectAreaLights: b.rectArea.length,
      numHemiLights: b.hemi.length,
      numDirLightShadows: b.directionalShadowMap.length,
      numPointLightShadows: b.pointShadowMap.length,
      numSpotLightShadows: b.spotShadowMap.length,
      numSpotLightShadowsWithMaps: b.numSpotLightShadowsWithMaps,
      numLightProbes: b.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: x.dithering,
      shadowMapEnabled: s.shadowMap.enabled && D.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: Kt,
      useLegacyLights: s._useLegacyLights,
      decodeVideoTexture: Xe && x.map.isVideoTexture === !0 && Rt.getTransfer(x.map.colorSpace) === mi,
      premultipliedAlpha: x.premultipliedAlpha,
      doubleSided: x.side === zi,
      flipSided: x.side === vn,
      useDepthPacking: x.depthPacking >= 0,
      depthPacking: x.depthPacking || 0,
      index0AttributeName: x.index0AttributeName,
      extensionDerivatives: ae && x.extensions.derivatives === !0,
      extensionFragDepth: ae && x.extensions.fragDepth === !0,
      extensionDrawBuffers: ae && x.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: ae && x.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
      rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: x.customProgramCacheKey()
    };
  }
  function m(x) {
    const b = [];
    if (x.shaderID ? b.push(x.shaderID) : (b.push(x.customVertexShaderID), b.push(x.customFragmentShaderID)), x.defines !== void 0)
      for (const D in x.defines)
        b.push(D), b.push(x.defines[D]);
    return x.isRawShaderMaterial === !1 && (v(b, x), g(b, x), b.push(s.outputColorSpace)), b.push(x.customProgramCacheKey), b.join();
  }
  function v(x, b) {
    x.push(b.precision), x.push(b.outputColorSpace), x.push(b.envMapMode), x.push(b.envMapCubeUVHeight), x.push(b.mapUv), x.push(b.alphaMapUv), x.push(b.lightMapUv), x.push(b.aoMapUv), x.push(b.bumpMapUv), x.push(b.normalMapUv), x.push(b.displacementMapUv), x.push(b.emissiveMapUv), x.push(b.metalnessMapUv), x.push(b.roughnessMapUv), x.push(b.anisotropyMapUv), x.push(b.clearcoatMapUv), x.push(b.clearcoatNormalMapUv), x.push(b.clearcoatRoughnessMapUv), x.push(b.iridescenceMapUv), x.push(b.iridescenceThicknessMapUv), x.push(b.sheenColorMapUv), x.push(b.sheenRoughnessMapUv), x.push(b.specularMapUv), x.push(b.specularColorMapUv), x.push(b.specularIntensityMapUv), x.push(b.transmissionMapUv), x.push(b.thicknessMapUv), x.push(b.combine), x.push(b.fogExp2), x.push(b.sizeAttenuation), x.push(b.morphTargetsCount), x.push(b.morphAttributeCount), x.push(b.numDirLights), x.push(b.numPointLights), x.push(b.numSpotLights), x.push(b.numSpotLightMaps), x.push(b.numHemiLights), x.push(b.numRectAreaLights), x.push(b.numDirLightShadows), x.push(b.numPointLightShadows), x.push(b.numSpotLightShadows), x.push(b.numSpotLightShadowsWithMaps), x.push(b.numLightProbes), x.push(b.shadowMapType), x.push(b.toneMapping), x.push(b.numClippingPlanes), x.push(b.numClipIntersection), x.push(b.depthPacking);
  }
  function g(x, b) {
    o.disableAll(), b.isWebGL2 && o.enable(0), b.supportsVertexTextures && o.enable(1), b.instancing && o.enable(2), b.instancingColor && o.enable(3), b.matcap && o.enable(4), b.envMap && o.enable(5), b.normalMapObjectSpace && o.enable(6), b.normalMapTangentSpace && o.enable(7), b.clearcoat && o.enable(8), b.iridescence && o.enable(9), b.alphaTest && o.enable(10), b.vertexColors && o.enable(11), b.vertexAlphas && o.enable(12), b.vertexUv1s && o.enable(13), b.vertexUv2s && o.enable(14), b.vertexUv3s && o.enable(15), b.vertexTangents && o.enable(16), b.anisotropy && o.enable(17), b.alphaHash && o.enable(18), x.push(o.mask), o.disableAll(), b.fog && o.enable(0), b.useFog && o.enable(1), b.flatShading && o.enable(2), b.logarithmicDepthBuffer && o.enable(3), b.skinning && o.enable(4), b.morphTargets && o.enable(5), b.morphNormals && o.enable(6), b.morphColors && o.enable(7), b.premultipliedAlpha && o.enable(8), b.shadowMapEnabled && o.enable(9), b.useLegacyLights && o.enable(10), b.doubleSided && o.enable(11), b.flipSided && o.enable(12), b.useDepthPacking && o.enable(13), b.dithering && o.enable(14), b.transmission && o.enable(15), b.sheen && o.enable(16), b.opaque && o.enable(17), b.pointsUvs && o.enable(18), b.decodeVideoTexture && o.enable(19), x.push(o.mask);
  }
  function _(x) {
    const b = f[x.type];
    let D;
    if (b) {
      const O = Ci[b];
      D = Ec.clone(O.uniforms);
    } else
      D = x.uniforms;
    return D;
  }
  function w(x, b) {
    let D;
    for (let O = 0, Y = c.length; O < Y; O++) {
      const B = c[O];
      if (B.cacheKey === b) {
        D = B, ++D.usedTimes;
        break;
      }
    }
    return D === void 0 && (D = new GI(s, b, x, r), c.push(D)), D;
  }
  function S(x) {
    if (--x.usedTimes === 0) {
      const b = c.indexOf(x);
      c[b] = c[c.length - 1], c.pop(), x.destroy();
    }
  }
  function C(x) {
    l.remove(x);
  }
  function E() {
    l.dispose();
  }
  return {
    getParameters: A,
    getProgramCacheKey: m,
    getUniforms: _,
    acquireProgram: w,
    releaseProgram: S,
    releaseShaderCache: C,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: c,
    dispose: E
  };
}
function WI() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(r) {
    let a = s.get(r);
    return a === void 0 && (a = {}, s.set(r, a)), a;
  }
  function t(r) {
    s.delete(r);
  }
  function i(r, a, o) {
    s.get(r)[a] = o;
  }
  function n() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: i,
    dispose: n
  };
}
function jI(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
}
function Z0(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
}
function ev() {
  const s = [];
  let e = 0;
  const t = [], i = [], n = [];
  function r() {
    e = 0, t.length = 0, i.length = 0, n.length = 0;
  }
  function a(u, d, p, f, y, A) {
    let m = s[e];
    return m === void 0 ? (m = {
      id: u.id,
      object: u,
      geometry: d,
      material: p,
      groupOrder: f,
      renderOrder: u.renderOrder,
      z: y,
      group: A
    }, s[e] = m) : (m.id = u.id, m.object = u, m.geometry = d, m.material = p, m.groupOrder = f, m.renderOrder = u.renderOrder, m.z = y, m.group = A), e++, m;
  }
  function o(u, d, p, f, y, A) {
    const m = a(u, d, p, f, y, A);
    p.transmission > 0 ? i.push(m) : p.transparent === !0 ? n.push(m) : t.push(m);
  }
  function l(u, d, p, f, y, A) {
    const m = a(u, d, p, f, y, A);
    p.transmission > 0 ? i.unshift(m) : p.transparent === !0 ? n.unshift(m) : t.unshift(m);
  }
  function c(u, d) {
    t.length > 1 && t.sort(u || jI), i.length > 1 && i.sort(d || Z0), n.length > 1 && n.sort(d || Z0);
  }
  function h() {
    for (let u = e, d = s.length; u < d; u++) {
      const p = s[u];
      if (p.id === null) break;
      p.id = null, p.object = null, p.geometry = null, p.material = null, p.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: n,
    init: r,
    push: o,
    unshift: l,
    finish: h,
    sort: c
  };
}
function qI() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(i, n) {
    const r = s.get(i);
    let a;
    return r === void 0 ? (a = new ev(), s.set(i, [a])) : n >= r.length ? (a = new ev(), r.push(a)) : a = r[n], a;
  }
  function t() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function XI() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new M(),
            color: new se()
          };
          break;
        case "SpotLight":
          t = {
            position: new M(),
            direction: new M(),
            color: new se(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new M(),
            color: new se(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new M(),
            skyColor: new se(),
            groundColor: new se()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new se(),
            position: new M(),
            halfWidth: new M(),
            halfHeight: new M()
          };
          break;
      }
      return s[e.id] = t, t;
    }
  };
}
function YI() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ie()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ie()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ie(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return s[e.id] = t, t;
    }
  };
}
let KI = 0;
function JI(s, e) {
  return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
}
function $I(s, e) {
  const t = new XI(), i = YI(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let h = 0; h < 9; h++) n.probe.push(new M());
  const r = new M(), a = new Ue(), o = new Ue();
  function l(h, u) {
    let d = 0, p = 0, f = 0;
    for (let O = 0; O < 9; O++) n.probe[O].set(0, 0, 0);
    let y = 0, A = 0, m = 0, v = 0, g = 0, _ = 0, w = 0, S = 0, C = 0, E = 0, x = 0;
    h.sort(JI);
    const b = u === !0 ? Math.PI : 1;
    for (let O = 0, Y = h.length; O < Y; O++) {
      const B = h[O], Q = B.color, j = B.intensity, X = B.distance, Z = B.shadow && B.shadow.map ? B.shadow.map.texture : null;
      if (B.isAmbientLight)
        d += Q.r * j * b, p += Q.g * j * b, f += Q.b * j * b;
      else if (B.isLightProbe) {
        for (let ee = 0; ee < 9; ee++)
          n.probe[ee].addScaledVector(B.sh.coefficients[ee], j);
        x++;
      } else if (B.isDirectionalLight) {
        const ee = t.get(B);
        if (ee.color.copy(B.color).multiplyScalar(B.intensity * b), B.castShadow) {
          const J = B.shadow, W = i.get(B);
          W.shadowBias = J.bias, W.shadowNormalBias = J.normalBias, W.shadowRadius = J.radius, W.shadowMapSize = J.mapSize, n.directionalShadow[y] = W, n.directionalShadowMap[y] = Z, n.directionalShadowMatrix[y] = B.shadow.matrix, _++;
        }
        n.directional[y] = ee, y++;
      } else if (B.isSpotLight) {
        const ee = t.get(B);
        ee.position.setFromMatrixPosition(B.matrixWorld), ee.color.copy(Q).multiplyScalar(j * b), ee.distance = X, ee.coneCos = Math.cos(B.angle), ee.penumbraCos = Math.cos(B.angle * (1 - B.penumbra)), ee.decay = B.decay, n.spot[m] = ee;
        const J = B.shadow;
        if (B.map && (n.spotLightMap[C] = B.map, C++, J.updateMatrices(B), B.castShadow && E++), n.spotLightMatrix[m] = J.matrix, B.castShadow) {
          const W = i.get(B);
          W.shadowBias = J.bias, W.shadowNormalBias = J.normalBias, W.shadowRadius = J.radius, W.shadowMapSize = J.mapSize, n.spotShadow[m] = W, n.spotShadowMap[m] = Z, S++;
        }
        m++;
      } else if (B.isRectAreaLight) {
        const ee = t.get(B);
        ee.color.copy(Q).multiplyScalar(j), ee.halfWidth.set(B.width * 0.5, 0, 0), ee.halfHeight.set(0, B.height * 0.5, 0), n.rectArea[v] = ee, v++;
      } else if (B.isPointLight) {
        const ee = t.get(B);
        if (ee.color.copy(B.color).multiplyScalar(B.intensity * b), ee.distance = B.distance, ee.decay = B.decay, B.castShadow) {
          const J = B.shadow, W = i.get(B);
          W.shadowBias = J.bias, W.shadowNormalBias = J.normalBias, W.shadowRadius = J.radius, W.shadowMapSize = J.mapSize, W.shadowCameraNear = J.camera.near, W.shadowCameraFar = J.camera.far, n.pointShadow[A] = W, n.pointShadowMap[A] = Z, n.pointShadowMatrix[A] = B.shadow.matrix, w++;
        }
        n.point[A] = ee, A++;
      } else if (B.isHemisphereLight) {
        const ee = t.get(B);
        ee.skyColor.copy(B.color).multiplyScalar(j * b), ee.groundColor.copy(B.groundColor).multiplyScalar(j * b), n.hemi[g] = ee, g++;
      }
    }
    v > 0 && (e.isWebGL2 || s.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = Re.LTC_FLOAT_1, n.rectAreaLTC2 = Re.LTC_FLOAT_2) : s.has("OES_texture_half_float_linear") === !0 ? (n.rectAreaLTC1 = Re.LTC_HALF_1, n.rectAreaLTC2 = Re.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), n.ambient[0] = d, n.ambient[1] = p, n.ambient[2] = f;
    const D = n.hash;
    (D.directionalLength !== y || D.pointLength !== A || D.spotLength !== m || D.rectAreaLength !== v || D.hemiLength !== g || D.numDirectionalShadows !== _ || D.numPointShadows !== w || D.numSpotShadows !== S || D.numSpotMaps !== C || D.numLightProbes !== x) && (n.directional.length = y, n.spot.length = m, n.rectArea.length = v, n.point.length = A, n.hemi.length = g, n.directionalShadow.length = _, n.directionalShadowMap.length = _, n.pointShadow.length = w, n.pointShadowMap.length = w, n.spotShadow.length = S, n.spotShadowMap.length = S, n.directionalShadowMatrix.length = _, n.pointShadowMatrix.length = w, n.spotLightMatrix.length = S + C - E, n.spotLightMap.length = C, n.numSpotLightShadowsWithMaps = E, n.numLightProbes = x, D.directionalLength = y, D.pointLength = A, D.spotLength = m, D.rectAreaLength = v, D.hemiLength = g, D.numDirectionalShadows = _, D.numPointShadows = w, D.numSpotShadows = S, D.numSpotMaps = C, D.numLightProbes = x, n.version = KI++);
  }
  function c(h, u) {
    let d = 0, p = 0, f = 0, y = 0, A = 0;
    const m = u.matrixWorldInverse;
    for (let v = 0, g = h.length; v < g; v++) {
      const _ = h[v];
      if (_.isDirectionalLight) {
        const w = n.directional[d];
        w.direction.setFromMatrixPosition(_.matrixWorld), r.setFromMatrixPosition(_.target.matrixWorld), w.direction.sub(r), w.direction.transformDirection(m), d++;
      } else if (_.isSpotLight) {
        const w = n.spot[f];
        w.position.setFromMatrixPosition(_.matrixWorld), w.position.applyMatrix4(m), w.direction.setFromMatrixPosition(_.matrixWorld), r.setFromMatrixPosition(_.target.matrixWorld), w.direction.sub(r), w.direction.transformDirection(m), f++;
      } else if (_.isRectAreaLight) {
        const w = n.rectArea[y];
        w.position.setFromMatrixPosition(_.matrixWorld), w.position.applyMatrix4(m), o.identity(), a.copy(_.matrixWorld), a.premultiply(m), o.extractRotation(a), w.halfWidth.set(_.width * 0.5, 0, 0), w.halfHeight.set(0, _.height * 0.5, 0), w.halfWidth.applyMatrix4(o), w.halfHeight.applyMatrix4(o), y++;
      } else if (_.isPointLight) {
        const w = n.point[p];
        w.position.setFromMatrixPosition(_.matrixWorld), w.position.applyMatrix4(m), p++;
      } else if (_.isHemisphereLight) {
        const w = n.hemi[A];
        w.direction.setFromMatrixPosition(_.matrixWorld), w.direction.transformDirection(m), A++;
      }
    }
  }
  return {
    setup: l,
    setupView: c,
    state: n
  };
}
function tv(s, e) {
  const t = new $I(s, e), i = [], n = [];
  function r() {
    i.length = 0, n.length = 0;
  }
  function a(u) {
    i.push(u);
  }
  function o(u) {
    n.push(u);
  }
  function l(u) {
    t.setup(i, u);
  }
  function c(u) {
    t.setupView(i, u);
  }
  return {
    init: r,
    state: {
      lightsArray: i,
      shadowsArray: n,
      lights: t
    },
    setupLights: l,
    setupLightsView: c,
    pushLight: a,
    pushShadow: o
  };
}
function ZI(s, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function i(r, a = 0) {
    const o = t.get(r);
    let l;
    return o === void 0 ? (l = new tv(s, e), t.set(r, [l])) : a >= o.length ? (l = new tv(s, e), o.push(l)) : l = o[a], l;
  }
  function n() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: n
  };
}
class Np extends Yi {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = kl, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class Ew extends Yi {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const eD = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, tD = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function iD(s, e, t) {
  let i = new uA();
  const n = new ie(), r = new ie(), a = new it(), o = new Np({ depthPacking: cw }), l = new Ew(), c = {}, h = t.maxTextureSize, u = { [$n]: vn, [vn]: $n, [zi]: zi }, d = new ln({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new ie() },
      radius: { value: 4 }
    },
    vertexShader: eD,
    fragmentShader: tD
  }), p = d.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const f = new Ze();
  f.setAttribute(
    "position",
    new Je(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const y = new Se(f, d), A = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Zg;
  let m = this.type;
  this.render = function(w, S, C) {
    if (A.enabled === !1 || A.autoUpdate === !1 && A.needsUpdate === !1 || w.length === 0) return;
    const E = s.getRenderTarget(), x = s.getActiveCubeFace(), b = s.getActiveMipmapLevel(), D = s.state;
    D.setBlending(_n), D.buffers.color.setClear(1, 1, 1, 1), D.buffers.depth.setTest(!0), D.setScissorTest(!1);
    const O = m !== Lr && this.type === Lr, Y = m === Lr && this.type !== Lr;
    for (let B = 0, Q = w.length; B < Q; B++) {
      const j = w[B], X = j.shadow;
      if (X === void 0) {
        console.warn("THREE.WebGLShadowMap:", j, "has no shadow.");
        continue;
      }
      if (X.autoUpdate === !1 && X.needsUpdate === !1) continue;
      n.copy(X.mapSize);
      const Z = X.getFrameExtents();
      if (n.multiply(Z), r.copy(X.mapSize), (n.x > h || n.y > h) && (n.x > h && (r.x = Math.floor(h / Z.x), n.x = r.x * Z.x, X.mapSize.x = r.x), n.y > h && (r.y = Math.floor(h / Z.y), n.y = r.y * Z.y, X.mapSize.y = r.y)), X.map === null || O === !0 || Y === !0) {
        const J = this.type !== Lr ? { minFilter: pi, magFilter: pi } : {};
        X.map !== null && X.map.dispose(), X.map = new Zn(n.x, n.y, J), X.map.texture.name = j.name + ".shadowMap", X.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(X.map), s.clear();
      const ee = X.getViewportCount();
      for (let J = 0; J < ee; J++) {
        const W = X.getViewport(J);
        a.set(
          r.x * W.x,
          r.y * W.y,
          r.x * W.z,
          r.y * W.w
        ), D.viewport(a), X.updateMatrices(j, J), i = X.getFrustum(), _(S, C, X.camera, j, this.type);
      }
      X.isPointLightShadow !== !0 && this.type === Lr && v(X, C), X.needsUpdate = !1;
    }
    m = this.type, A.needsUpdate = !1, s.setRenderTarget(E, x, b);
  };
  function v(w, S) {
    const C = e.update(y);
    d.defines.VSM_SAMPLES !== w.blurSamples && (d.defines.VSM_SAMPLES = w.blurSamples, p.defines.VSM_SAMPLES = w.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), w.mapPass === null && (w.mapPass = new Zn(n.x, n.y)), d.uniforms.shadow_pass.value = w.map.texture, d.uniforms.resolution.value = w.mapSize, d.uniforms.radius.value = w.radius, s.setRenderTarget(w.mapPass), s.clear(), s.renderBufferDirect(S, null, C, d, y, null), p.uniforms.shadow_pass.value = w.mapPass.texture, p.uniforms.resolution.value = w.mapSize, p.uniforms.radius.value = w.radius, s.setRenderTarget(w.map), s.clear(), s.renderBufferDirect(S, null, C, p, y, null);
  }
  function g(w, S, C, E) {
    let x = null;
    const b = C.isPointLight === !0 ? w.customDistanceMaterial : w.customDepthMaterial;
    if (b !== void 0)
      x = b;
    else if (x = C.isPointLight === !0 ? l : o, s.localClippingEnabled && S.clipShadows === !0 && Array.isArray(S.clippingPlanes) && S.clippingPlanes.length !== 0 || S.displacementMap && S.displacementScale !== 0 || S.alphaMap && S.alphaTest > 0 || S.map && S.alphaTest > 0) {
      const D = x.uuid, O = S.uuid;
      let Y = c[D];
      Y === void 0 && (Y = {}, c[D] = Y);
      let B = Y[O];
      B === void 0 && (B = x.clone(), Y[O] = B), x = B;
    }
    if (x.visible = S.visible, x.wireframe = S.wireframe, E === Lr ? x.side = S.shadowSide !== null ? S.shadowSide : S.side : x.side = S.shadowSide !== null ? S.shadowSide : u[S.side], x.alphaMap = S.alphaMap, x.alphaTest = S.alphaTest, x.map = S.map, x.clipShadows = S.clipShadows, x.clippingPlanes = S.clippingPlanes, x.clipIntersection = S.clipIntersection, x.displacementMap = S.displacementMap, x.displacementScale = S.displacementScale, x.displacementBias = S.displacementBias, x.wireframeLinewidth = S.wireframeLinewidth, x.linewidth = S.linewidth, C.isPointLight === !0 && x.isMeshDistanceMaterial === !0) {
      const D = s.properties.get(x);
      D.light = C;
    }
    return x;
  }
  function _(w, S, C, E, x) {
    if (w.visible === !1) return;
    if (w.layers.test(S.layers) && (w.isMesh || w.isLine || w.isPoints) && (w.castShadow || w.receiveShadow && x === Lr) && (!w.frustumCulled || i.intersectsObject(w))) {
      w.modelViewMatrix.multiplyMatrices(C.matrixWorldInverse, w.matrixWorld);
      const O = e.update(w), Y = w.material;
      if (Array.isArray(Y)) {
        const B = O.groups;
        for (let Q = 0, j = B.length; Q < j; Q++) {
          const X = B[Q], Z = Y[X.materialIndex];
          if (Z && Z.visible) {
            const ee = g(w, Z, E, x);
            s.renderBufferDirect(C, null, O, ee, w, X);
          }
        }
      } else if (Y.visible) {
        const B = g(w, Y, E, x);
        s.renderBufferDirect(C, null, O, B, w, null);
      }
    }
    const D = w.children;
    for (let O = 0, Y = D.length; O < Y; O++)
      _(D[O], S, C, E, x);
  }
}
function nD(s, e, t) {
  const i = t.isWebGL2;
  function n() {
    let q = !1;
    const ke = new it();
    let xe = null;
    const ae = new it(0, 0, 0, 0);
    return {
      setMask: function(De) {
        xe !== De && !q && (s.colorMask(De, De, De, De), xe = De);
      },
      setLocked: function(De) {
        q = De;
      },
      setClear: function(De, st, Et, Kt, Fi) {
        Fi === !0 && (De *= Kt, st *= Kt, Et *= Kt), ke.set(De, st, Et, Kt), ae.equals(ke) === !1 && (s.clearColor(De, st, Et, Kt), ae.copy(ke));
      },
      reset: function() {
        q = !1, xe = null, ae.set(-1, 0, 0, 0);
      }
    };
  }
  function r() {
    let q = !1, ke = null, xe = null, ae = null;
    return {
      setTest: function(De) {
        De ? ot(s.DEPTH_TEST) : ht(s.DEPTH_TEST);
      },
      setMask: function(De) {
        ke !== De && !q && (s.depthMask(De), ke = De);
      },
      setFunc: function(De) {
        if (xe !== De) {
          switch (De) {
            case Vx:
              s.depthFunc(s.NEVER);
              break;
            case Wx:
              s.depthFunc(s.ALWAYS);
              break;
            case jx:
              s.depthFunc(s.LESS);
              break;
            case Kl:
              s.depthFunc(s.LEQUAL);
              break;
            case qx:
              s.depthFunc(s.EQUAL);
              break;
            case Xx:
              s.depthFunc(s.GEQUAL);
              break;
            case Yx:
              s.depthFunc(s.GREATER);
              break;
            case Kx:
              s.depthFunc(s.NOTEQUAL);
              break;
            default:
              s.depthFunc(s.LEQUAL);
          }
          xe = De;
        }
      },
      setLocked: function(De) {
        q = De;
      },
      setClear: function(De) {
        ae !== De && (s.clearDepth(De), ae = De);
      },
      reset: function() {
        q = !1, ke = null, xe = null, ae = null;
      }
    };
  }
  function a() {
    let q = !1, ke = null, xe = null, ae = null, De = null, st = null, Et = null, Kt = null, Fi = null;
    return {
      setTest: function(It) {
        q || (It ? ot(s.STENCIL_TEST) : ht(s.STENCIL_TEST));
      },
      setMask: function(It) {
        ke !== It && !q && (s.stencilMask(It), ke = It);
      },
      setFunc: function(It, pn, ys) {
        (xe !== It || ae !== pn || De !== ys) && (s.stencilFunc(It, pn, ys), xe = It, ae = pn, De = ys);
      },
      setOp: function(It, pn, ys) {
        (st !== It || Et !== pn || Kt !== ys) && (s.stencilOp(It, pn, ys), st = It, Et = pn, Kt = ys);
      },
      setLocked: function(It) {
        q = It;
      },
      setClear: function(It) {
        Fi !== It && (s.clearStencil(It), Fi = It);
      },
      reset: function() {
        q = !1, ke = null, xe = null, ae = null, De = null, st = null, Et = null, Kt = null, Fi = null;
      }
    };
  }
  const o = new n(), l = new r(), c = new a(), h = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
  let d = {}, p = {}, f = /* @__PURE__ */ new WeakMap(), y = [], A = null, m = !1, v = null, g = null, _ = null, w = null, S = null, C = null, E = null, x = new se(0, 0, 0), b = 0, D = !1, O = null, Y = null, B = null, Q = null, j = null;
  const X = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let Z = !1, ee = 0;
  const J = s.getParameter(s.VERSION);
  J.indexOf("WebGL") !== -1 ? (ee = parseFloat(/^WebGL (\d)/.exec(J)[1]), Z = ee >= 1) : J.indexOf("OpenGL ES") !== -1 && (ee = parseFloat(/^OpenGL ES (\d)/.exec(J)[1]), Z = ee >= 2);
  let W = null, K = {};
  const ce = s.getParameter(s.SCISSOR_BOX), fe = s.getParameter(s.VIEWPORT), ve = new it().fromArray(ce), _e = new it().fromArray(fe);
  function ze(q, ke, xe, ae) {
    const De = new Uint8Array(4), st = s.createTexture();
    s.bindTexture(q, st), s.texParameteri(q, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(q, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let Et = 0; Et < xe; Et++)
      i && (q === s.TEXTURE_3D || q === s.TEXTURE_2D_ARRAY) ? s.texImage3D(ke, 0, s.RGBA, 1, 1, ae, 0, s.RGBA, s.UNSIGNED_BYTE, De) : s.texImage2D(ke + Et, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, De);
    return st;
  }
  const Qe = {};
  Qe[s.TEXTURE_2D] = ze(s.TEXTURE_2D, s.TEXTURE_2D, 1), Qe[s.TEXTURE_CUBE_MAP] = ze(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i && (Qe[s.TEXTURE_2D_ARRAY] = ze(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), Qe[s.TEXTURE_3D] = ze(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1)), o.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), ot(s.DEPTH_TEST), l.setFunc(Kl), Ne(!1), Ge(Yy), ot(s.CULL_FACE), de(_n);
  function ot(q) {
    d[q] !== !0 && (s.enable(q), d[q] = !0);
  }
  function ht(q) {
    d[q] !== !1 && (s.disable(q), d[q] = !1);
  }
  function Xe(q, ke) {
    return p[q] !== ke ? (s.bindFramebuffer(q, ke), p[q] = ke, i && (q === s.DRAW_FRAMEBUFFER && (p[s.FRAMEBUFFER] = ke), q === s.FRAMEBUFFER && (p[s.DRAW_FRAMEBUFFER] = ke)), !0) : !1;
  }
  function G(q, ke) {
    let xe = y, ae = !1;
    if (q)
      if (xe = f.get(ke), xe === void 0 && (xe = [], f.set(ke, xe)), q.isWebGLMultipleRenderTargets) {
        const De = q.texture;
        if (xe.length !== De.length || xe[0] !== s.COLOR_ATTACHMENT0) {
          for (let st = 0, Et = De.length; st < Et; st++)
            xe[st] = s.COLOR_ATTACHMENT0 + st;
          xe.length = De.length, ae = !0;
        }
      } else
        xe[0] !== s.COLOR_ATTACHMENT0 && (xe[0] = s.COLOR_ATTACHMENT0, ae = !0);
    else
      xe[0] !== s.BACK && (xe[0] = s.BACK, ae = !0);
    ae && (t.isWebGL2 ? s.drawBuffers(xe) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(xe));
  }
  function Be(q) {
    return A !== q ? (s.useProgram(q), A = q, !0) : !1;
  }
  const oe = {
    [kr]: s.FUNC_ADD,
    [zx]: s.FUNC_SUBTRACT,
    [Qx]: s.FUNC_REVERSE_SUBTRACT
  };
  if (i)
    oe[Rm] = s.MIN, oe[Bm] = s.MAX;
  else {
    const q = e.get("EXT_blend_minmax");
    q !== null && (oe[Rm] = q.MIN_EXT, oe[Bm] = q.MAX_EXT);
  }
  const Ee = {
    [Pm]: s.ZERO,
    [Lm]: s.ONE,
    [Um]: s.SRC_COLOR,
    [Xl]: s.SRC_ALPHA,
    [Hx]: s.SRC_ALPHA_SATURATE,
    [km]: s.DST_COLOR,
    [Om]: s.DST_ALPHA,
    [Fm]: s.ONE_MINUS_SRC_COLOR,
    [Yl]: s.ONE_MINUS_SRC_ALPHA,
    [Gm]: s.ONE_MINUS_DST_COLOR,
    [Nm]: s.ONE_MINUS_DST_ALPHA,
    [ch]: s.CONSTANT_COLOR,
    [hh]: s.ONE_MINUS_CONSTANT_COLOR,
    [uh]: s.CONSTANT_ALPHA,
    [dh]: s.ONE_MINUS_CONSTANT_ALPHA
  };
  function de(q, ke, xe, ae, De, st, Et, Kt, Fi, It) {
    if (q === _n) {
      m === !0 && (ht(s.BLEND), m = !1);
      return;
    }
    if (m === !1 && (ot(s.BLEND), m = !0), q !== or) {
      if (q !== v || It !== D) {
        if ((g !== kr || S !== kr) && (s.blendEquation(s.FUNC_ADD), g = kr, S = kr), It)
          switch (q) {
            case dr:
              s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case qd:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case Xd:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case Yd:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", q);
              break;
          }
        else
          switch (q) {
            case dr:
              s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case qd:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case Xd:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case Yd:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", q);
              break;
          }
        _ = null, w = null, C = null, E = null, x.set(0, 0, 0), b = 0, v = q, D = It;
      }
      return;
    }
    De = De || ke, st = st || xe, Et = Et || ae, (ke !== g || De !== S) && (s.blendEquationSeparate(oe[ke], oe[De]), g = ke, S = De), (xe !== _ || ae !== w || st !== C || Et !== E) && (s.blendFuncSeparate(Ee[xe], Ee[ae], Ee[st], Ee[Et]), _ = xe, w = ae, C = st, E = Et), (Kt.equals(x) === !1 || Fi !== b) && (s.blendColor(Kt.r, Kt.g, Kt.b, Fi), x.copy(Kt), b = Fi), v = q, D = !1;
  }
  function Ke(q, ke) {
    q.side === zi ? ht(s.CULL_FACE) : ot(s.CULL_FACE);
    let xe = q.side === vn;
    ke && (xe = !xe), Ne(xe), q.blending === dr && q.transparent === !1 ? de(_n) : de(q.blending, q.blendEquation, q.blendSrc, q.blendDst, q.blendEquationAlpha, q.blendSrcAlpha, q.blendDstAlpha, q.blendColor, q.blendAlpha, q.premultipliedAlpha), l.setFunc(q.depthFunc), l.setTest(q.depthTest), l.setMask(q.depthWrite), o.setMask(q.colorWrite);
    const ae = q.stencilWrite;
    c.setTest(ae), ae && (c.setMask(q.stencilWriteMask), c.setFunc(q.stencilFunc, q.stencilRef, q.stencilFuncMask), c.setOp(q.stencilFail, q.stencilZFail, q.stencilZPass)), wt(q.polygonOffset, q.polygonOffsetFactor, q.polygonOffsetUnits), q.alphaToCoverage === !0 ? ot(s.SAMPLE_ALPHA_TO_COVERAGE) : ht(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Ne(q) {
    O !== q && (q ? s.frontFace(s.CW) : s.frontFace(s.CCW), O = q);
  }
  function Ge(q) {
    q !== DS ? (ot(s.CULL_FACE), q !== Y && (q === Yy ? s.cullFace(s.BACK) : q === RS ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : ht(s.CULL_FACE), Y = q;
  }
  function nt(q) {
    q !== B && (Z && s.lineWidth(q), B = q);
  }
  function wt(q, ke, xe) {
    q ? (ot(s.POLYGON_OFFSET_FILL), (Q !== ke || j !== xe) && (s.polygonOffset(ke, xe), Q = ke, j = xe)) : ht(s.POLYGON_OFFSET_FILL);
  }
  function di(q) {
    q ? ot(s.SCISSOR_TEST) : ht(s.SCISSOR_TEST);
  }
  function F(q) {
    q === void 0 && (q = s.TEXTURE0 + X - 1), W !== q && (s.activeTexture(q), W = q);
  }
  function R(q, ke, xe) {
    xe === void 0 && (W === null ? xe = s.TEXTURE0 + X - 1 : xe = W);
    let ae = K[xe];
    ae === void 0 && (ae = { type: void 0, texture: void 0 }, K[xe] = ae), (ae.type !== q || ae.texture !== ke) && (W !== xe && (s.activeTexture(xe), W = xe), s.bindTexture(q, ke || Qe[q]), ae.type = q, ae.texture = ke);
  }
  function te() {
    const q = K[W];
    q !== void 0 && q.type !== void 0 && (s.bindTexture(q.type, null), q.type = void 0, q.texture = void 0);
  }
  function we() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Ae() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Ce() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function We() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Me() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Le() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function z() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function ye() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function le() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function at() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function qe(q) {
    ve.equals(q) === !1 && (s.scissor(q.x, q.y, q.z, q.w), ve.copy(q));
  }
  function je(q) {
    _e.equals(q) === !1 && (s.viewport(q.x, q.y, q.z, q.w), _e.copy(q));
  }
  function Fe(q, ke) {
    let xe = u.get(ke);
    xe === void 0 && (xe = /* @__PURE__ */ new WeakMap(), u.set(ke, xe));
    let ae = xe.get(q);
    ae === void 0 && (ae = s.getUniformBlockIndex(ke, q.name), xe.set(q, ae));
  }
  function He(q, ke) {
    const ae = u.get(ke).get(q);
    h.get(ke) !== ae && (s.uniformBlockBinding(ke, ae, q.__bindingPointIndex), h.set(ke, ae));
  }
  function me() {
    s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(!0, !0, !0, !0), s.clearColor(0, 0, 0, 0), s.depthMask(!0), s.depthFunc(s.LESS), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), i === !0 && (s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null)), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), d = {}, W = null, K = {}, p = {}, f = /* @__PURE__ */ new WeakMap(), y = [], A = null, m = !1, v = null, g = null, _ = null, w = null, S = null, C = null, E = null, x = new se(0, 0, 0), b = 0, D = !1, O = null, Y = null, B = null, Q = null, j = null, ve.set(0, 0, s.canvas.width, s.canvas.height), _e.set(0, 0, s.canvas.width, s.canvas.height), o.reset(), l.reset(), c.reset();
  }
  return {
    buffers: {
      color: o,
      depth: l,
      stencil: c
    },
    enable: ot,
    disable: ht,
    bindFramebuffer: Xe,
    drawBuffers: G,
    useProgram: Be,
    setBlending: de,
    setMaterial: Ke,
    setFlipSided: Ne,
    setCullFace: Ge,
    setLineWidth: nt,
    setPolygonOffset: wt,
    setScissorTest: di,
    activeTexture: F,
    bindTexture: R,
    unbindTexture: te,
    compressedTexImage2D: we,
    compressedTexImage3D: Ae,
    texImage2D: le,
    texImage3D: at,
    updateUBOMapping: Fe,
    uniformBlockBinding: He,
    texStorage2D: z,
    texStorage3D: ye,
    texSubImage2D: Ce,
    texSubImage3D: We,
    compressedTexSubImage2D: Me,
    compressedTexSubImage3D: Le,
    scissor: qe,
    viewport: je,
    reset: me
  };
}
function sD(s, e, t, i, n, r, a) {
  const o = n.isWebGL2, l = n.maxTextures, c = n.maxCubemapSize, h = n.maxTextureSize, u = n.maxSamples, d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, p = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), f = /* @__PURE__ */ new WeakMap();
  let y;
  const A = /* @__PURE__ */ new WeakMap();
  let m = !1;
  try {
    m = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function v(F, R) {
    return m ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(F, R)
    ) : Lh("canvas");
  }
  function g(F, R, te, we) {
    let Ae = 1;
    if ((F.width > we || F.height > we) && (Ae = we / Math.max(F.width, F.height)), Ae < 1 || R === !0)
      if (typeof HTMLImageElement < "u" && F instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && F instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && F instanceof ImageBitmap) {
        const Ce = R ? sp : Math.floor, We = Ce(Ae * F.width), Me = Ce(Ae * F.height);
        y === void 0 && (y = v(We, Me));
        const Le = te ? v(We, Me) : y;
        return Le.width = We, Le.height = Me, Le.getContext("2d").drawImage(F, 0, 0, We, Me), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + F.width + "x" + F.height + ") to (" + We + "x" + Me + ")."), Le;
      } else
        return "data" in F && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + F.width + "x" + F.height + ")."), F;
    return F;
  }
  function _(F) {
    return Zm(F.width) && Zm(F.height);
  }
  function w(F) {
    return o ? !1 : F.wrapS !== Zt || F.wrapT !== Zt || F.minFilter !== pi && F.minFilter !== tt;
  }
  function S(F, R) {
    return F.generateMipmaps && R && F.minFilter !== pi && F.minFilter !== tt;
  }
  function C(F) {
    s.generateMipmap(F);
  }
  function E(F, R, te, we, Ae = !1) {
    if (o === !1) return R;
    if (F !== null) {
      if (s[F] !== void 0) return s[F];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + F + "'");
    }
    let Ce = R;
    if (R === s.RED && (te === s.FLOAT && (Ce = s.R32F), te === s.HALF_FLOAT && (Ce = s.R16F), te === s.UNSIGNED_BYTE && (Ce = s.R8)), R === s.RED_INTEGER && (te === s.UNSIGNED_BYTE && (Ce = s.R8UI), te === s.UNSIGNED_SHORT && (Ce = s.R16UI), te === s.UNSIGNED_INT && (Ce = s.R32UI), te === s.BYTE && (Ce = s.R8I), te === s.SHORT && (Ce = s.R16I), te === s.INT && (Ce = s.R32I)), R === s.RG && (te === s.FLOAT && (Ce = s.RG32F), te === s.HALF_FLOAT && (Ce = s.RG16F), te === s.UNSIGNED_BYTE && (Ce = s.RG8)), R === s.RGBA) {
      const We = Ae ? Zd : Rt.getTransfer(we);
      te === s.FLOAT && (Ce = s.RGBA32F), te === s.HALF_FLOAT && (Ce = s.RGBA16F), te === s.UNSIGNED_BYTE && (Ce = We === mi ? s.SRGB8_ALPHA8 : s.RGBA8), te === s.UNSIGNED_SHORT_4_4_4_4 && (Ce = s.RGBA4), te === s.UNSIGNED_SHORT_5_5_5_1 && (Ce = s.RGB5_A1);
    }
    return (Ce === s.R16F || Ce === s.R32F || Ce === s.RG16F || Ce === s.RG32F || Ce === s.RGBA16F || Ce === s.RGBA32F) && e.get("EXT_color_buffer_float"), Ce;
  }
  function x(F, R, te) {
    return S(F, te) === !0 || F.isFramebufferTexture && F.minFilter !== pi && F.minFilter !== tt ? Math.log2(Math.max(R.width, R.height)) + 1 : F.mipmaps !== void 0 && F.mipmaps.length > 0 ? F.mipmaps.length : F.isCompressedTexture && Array.isArray(F.image) ? R.mipmaps.length : 1;
  }
  function b(F) {
    return F === pi || F === Jl || F === co ? s.NEAREST : s.LINEAR;
  }
  function D(F) {
    const R = F.target;
    R.removeEventListener("dispose", D), Y(R), R.isVideoTexture && f.delete(R);
  }
  function O(F) {
    const R = F.target;
    R.removeEventListener("dispose", O), Q(R);
  }
  function Y(F) {
    const R = i.get(F);
    if (R.__webglInit === void 0) return;
    const te = F.source, we = A.get(te);
    if (we) {
      const Ae = we[R.__cacheKey];
      Ae.usedTimes--, Ae.usedTimes === 0 && B(F), Object.keys(we).length === 0 && A.delete(te);
    }
    i.remove(F);
  }
  function B(F) {
    const R = i.get(F);
    s.deleteTexture(R.__webglTexture);
    const te = F.source, we = A.get(te);
    delete we[R.__cacheKey], a.memory.textures--;
  }
  function Q(F) {
    const R = F.texture, te = i.get(F), we = i.get(R);
    if (we.__webglTexture !== void 0 && (s.deleteTexture(we.__webglTexture), a.memory.textures--), F.depthTexture && F.depthTexture.dispose(), F.isWebGLCubeRenderTarget)
      for (let Ae = 0; Ae < 6; Ae++) {
        if (Array.isArray(te.__webglFramebuffer[Ae]))
          for (let Ce = 0; Ce < te.__webglFramebuffer[Ae].length; Ce++) s.deleteFramebuffer(te.__webglFramebuffer[Ae][Ce]);
        else
          s.deleteFramebuffer(te.__webglFramebuffer[Ae]);
        te.__webglDepthbuffer && s.deleteRenderbuffer(te.__webglDepthbuffer[Ae]);
      }
    else {
      if (Array.isArray(te.__webglFramebuffer))
        for (let Ae = 0; Ae < te.__webglFramebuffer.length; Ae++) s.deleteFramebuffer(te.__webglFramebuffer[Ae]);
      else
        s.deleteFramebuffer(te.__webglFramebuffer);
      if (te.__webglDepthbuffer && s.deleteRenderbuffer(te.__webglDepthbuffer), te.__webglMultisampledFramebuffer && s.deleteFramebuffer(te.__webglMultisampledFramebuffer), te.__webglColorRenderbuffer)
        for (let Ae = 0; Ae < te.__webglColorRenderbuffer.length; Ae++)
          te.__webglColorRenderbuffer[Ae] && s.deleteRenderbuffer(te.__webglColorRenderbuffer[Ae]);
      te.__webglDepthRenderbuffer && s.deleteRenderbuffer(te.__webglDepthRenderbuffer);
    }
    if (F.isWebGLMultipleRenderTargets)
      for (let Ae = 0, Ce = R.length; Ae < Ce; Ae++) {
        const We = i.get(R[Ae]);
        We.__webglTexture && (s.deleteTexture(We.__webglTexture), a.memory.textures--), i.remove(R[Ae]);
      }
    i.remove(R), i.remove(F);
  }
  let j = 0;
  function X() {
    j = 0;
  }
  function Z() {
    const F = j;
    return F >= l && console.warn("THREE.WebGLTextures: Trying to use " + F + " texture units while this GPU supports only " + l), j += 1, F;
  }
  function ee(F) {
    const R = [];
    return R.push(F.wrapS), R.push(F.wrapT), R.push(F.wrapR || 0), R.push(F.magFilter), R.push(F.minFilter), R.push(F.anisotropy), R.push(F.internalFormat), R.push(F.format), R.push(F.type), R.push(F.generateMipmaps), R.push(F.premultiplyAlpha), R.push(F.flipY), R.push(F.unpackAlignment), R.push(F.colorSpace), R.join();
  }
  function J(F, R) {
    const te = i.get(F);
    if (F.isVideoTexture && wt(F), F.isRenderTargetTexture === !1 && F.version > 0 && te.__version !== F.version) {
      const we = F.image;
      if (we === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (we.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        ot(te, F, R);
        return;
      }
    }
    t.bindTexture(s.TEXTURE_2D, te.__webglTexture, s.TEXTURE0 + R);
  }
  function W(F, R) {
    const te = i.get(F);
    if (F.version > 0 && te.__version !== F.version) {
      ot(te, F, R);
      return;
    }
    t.bindTexture(s.TEXTURE_2D_ARRAY, te.__webglTexture, s.TEXTURE0 + R);
  }
  function K(F, R) {
    const te = i.get(F);
    if (F.version > 0 && te.__version !== F.version) {
      ot(te, F, R);
      return;
    }
    t.bindTexture(s.TEXTURE_3D, te.__webglTexture, s.TEXTURE0 + R);
  }
  function ce(F, R) {
    const te = i.get(F);
    if (F.version > 0 && te.__version !== F.version) {
      ht(te, F, R);
      return;
    }
    t.bindTexture(s.TEXTURE_CUBE_MAP, te.__webglTexture, s.TEXTURE0 + R);
  }
  const fe = {
    [xn]: s.REPEAT,
    [Zt]: s.CLAMP_TO_EDGE,
    [Xr]: s.MIRRORED_REPEAT
  }, ve = {
    [pi]: s.NEAREST,
    [Jl]: s.NEAREST_MIPMAP_NEAREST,
    [co]: s.NEAREST_MIPMAP_LINEAR,
    [tt]: s.LINEAR,
    [nu]: s.LINEAR_MIPMAP_NEAREST,
    [Qn]: s.LINEAR_MIPMAP_LINEAR
  }, _e = {
    [QS]: s.NEVER,
    [YS]: s.ALWAYS,
    [HS]: s.LESS,
    [WS]: s.LEQUAL,
    [VS]: s.EQUAL,
    [XS]: s.GEQUAL,
    [jS]: s.GREATER,
    [qS]: s.NOTEQUAL
  };
  function ze(F, R, te) {
    if (te ? (s.texParameteri(F, s.TEXTURE_WRAP_S, fe[R.wrapS]), s.texParameteri(F, s.TEXTURE_WRAP_T, fe[R.wrapT]), (F === s.TEXTURE_3D || F === s.TEXTURE_2D_ARRAY) && s.texParameteri(F, s.TEXTURE_WRAP_R, fe[R.wrapR]), s.texParameteri(F, s.TEXTURE_MAG_FILTER, ve[R.magFilter]), s.texParameteri(F, s.TEXTURE_MIN_FILTER, ve[R.minFilter])) : (s.texParameteri(F, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(F, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), (F === s.TEXTURE_3D || F === s.TEXTURE_2D_ARRAY) && s.texParameteri(F, s.TEXTURE_WRAP_R, s.CLAMP_TO_EDGE), (R.wrapS !== Zt || R.wrapT !== Zt) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), s.texParameteri(F, s.TEXTURE_MAG_FILTER, b(R.magFilter)), s.texParameteri(F, s.TEXTURE_MIN_FILTER, b(R.minFilter)), R.minFilter !== pi && R.minFilter !== tt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), R.compareFunction && (s.texParameteri(F, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(F, s.TEXTURE_COMPARE_FUNC, _e[R.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      const we = e.get("EXT_texture_filter_anisotropic");
      if (R.magFilter === pi || R.minFilter !== co && R.minFilter !== Qn || R.type === Xt && e.has("OES_texture_float_linear") === !1 || o === !1 && R.type === Qt && e.has("OES_texture_half_float_linear") === !1) return;
      (R.anisotropy > 1 || i.get(R).__currentAnisotropy) && (s.texParameterf(F, we.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(R.anisotropy, n.getMaxAnisotropy())), i.get(R).__currentAnisotropy = R.anisotropy);
    }
  }
  function Qe(F, R) {
    let te = !1;
    F.__webglInit === void 0 && (F.__webglInit = !0, R.addEventListener("dispose", D));
    const we = R.source;
    let Ae = A.get(we);
    Ae === void 0 && (Ae = {}, A.set(we, Ae));
    const Ce = ee(R);
    if (Ce !== F.__cacheKey) {
      Ae[Ce] === void 0 && (Ae[Ce] = {
        texture: s.createTexture(),
        usedTimes: 0
      }, a.memory.textures++, te = !0), Ae[Ce].usedTimes++;
      const We = Ae[F.__cacheKey];
      We !== void 0 && (Ae[F.__cacheKey].usedTimes--, We.usedTimes === 0 && B(R)), F.__cacheKey = Ce, F.__webglTexture = Ae[Ce].texture;
    }
    return te;
  }
  function ot(F, R, te) {
    let we = s.TEXTURE_2D;
    (R.isDataArrayTexture || R.isCompressedArrayTexture) && (we = s.TEXTURE_2D_ARRAY), R.isData3DTexture && (we = s.TEXTURE_3D);
    const Ae = Qe(F, R), Ce = R.source;
    t.bindTexture(we, F.__webglTexture, s.TEXTURE0 + te);
    const We = i.get(Ce);
    if (Ce.version !== We.__version || Ae === !0) {
      t.activeTexture(s.TEXTURE0 + te);
      const Me = Rt.getPrimaries(Rt.workingColorSpace), Le = R.colorSpace === Wt || R.colorSpace === Es ? null : Rt.getPrimaries(R.colorSpace), z = R.colorSpace === Wt || R.colorSpace === Es || Me === Le ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, R.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, R.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, R.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, z);
      const ye = w(R) && _(R.image) === !1;
      let le = g(R.image, ye, !1, h);
      le = di(R, le);
      const at = _(le) || o, qe = r.convert(R.format, R.colorSpace);
      let je = r.convert(R.type), Fe = E(R.internalFormat, qe, je, R.colorSpace, R.isVideoTexture);
      ze(we, R, at);
      let He;
      const me = R.mipmaps, q = o && R.isVideoTexture !== !0, ke = We.__version === void 0 || Ae === !0, xe = x(R, le, at);
      if (R.isDepthTexture)
        Fe = s.DEPTH_COMPONENT, o ? R.type === Xt ? Fe = s.DEPTH_COMPONENT32F : R.type === qs ? Fe = s.DEPTH_COMPONENT24 : R.type === wa ? Fe = s.DEPTH24_STENCIL8 : Fe = s.DEPTH_COMPONENT16 : R.type === Xt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), R.format === Ea && Fe === s.DEPTH_COMPONENT && R.type !== Lp && R.type !== qs && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), R.type = qs, je = r.convert(R.type)), R.format === $l && Fe === s.DEPTH_COMPONENT && (Fe = s.DEPTH_STENCIL, R.type !== wa && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), R.type = wa, je = r.convert(R.type))), ke && (q ? t.texStorage2D(s.TEXTURE_2D, 1, Fe, le.width, le.height) : t.texImage2D(s.TEXTURE_2D, 0, Fe, le.width, le.height, 0, qe, je, null));
      else if (R.isDataTexture)
        if (me.length > 0 && at) {
          q && ke && t.texStorage2D(s.TEXTURE_2D, xe, Fe, me[0].width, me[0].height);
          for (let ae = 0, De = me.length; ae < De; ae++)
            He = me[ae], q ? t.texSubImage2D(s.TEXTURE_2D, ae, 0, 0, He.width, He.height, qe, je, He.data) : t.texImage2D(s.TEXTURE_2D, ae, Fe, He.width, He.height, 0, qe, je, He.data);
          R.generateMipmaps = !1;
        } else
          q ? (ke && t.texStorage2D(s.TEXTURE_2D, xe, Fe, le.width, le.height), t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, le.width, le.height, qe, je, le.data)) : t.texImage2D(s.TEXTURE_2D, 0, Fe, le.width, le.height, 0, qe, je, le.data);
      else if (R.isCompressedTexture)
        if (R.isCompressedArrayTexture) {
          q && ke && t.texStorage3D(s.TEXTURE_2D_ARRAY, xe, Fe, me[0].width, me[0].height, le.depth);
          for (let ae = 0, De = me.length; ae < De; ae++)
            He = me[ae], R.format !== ei ? qe !== null ? q ? t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, ae, 0, 0, 0, He.width, He.height, le.depth, qe, He.data, 0, 0) : t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, ae, Fe, He.width, He.height, le.depth, 0, He.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : q ? t.texSubImage3D(s.TEXTURE_2D_ARRAY, ae, 0, 0, 0, He.width, He.height, le.depth, qe, je, He.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, ae, Fe, He.width, He.height, le.depth, 0, qe, je, He.data);
        } else {
          q && ke && t.texStorage2D(s.TEXTURE_2D, xe, Fe, me[0].width, me[0].height);
          for (let ae = 0, De = me.length; ae < De; ae++)
            He = me[ae], R.format !== ei ? qe !== null ? q ? t.compressedTexSubImage2D(s.TEXTURE_2D, ae, 0, 0, He.width, He.height, qe, He.data) : t.compressedTexImage2D(s.TEXTURE_2D, ae, Fe, He.width, He.height, 0, He.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : q ? t.texSubImage2D(s.TEXTURE_2D, ae, 0, 0, He.width, He.height, qe, je, He.data) : t.texImage2D(s.TEXTURE_2D, ae, Fe, He.width, He.height, 0, qe, je, He.data);
        }
      else if (R.isDataArrayTexture)
        q ? (ke && t.texStorage3D(s.TEXTURE_2D_ARRAY, xe, Fe, le.width, le.height, le.depth), t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, le.width, le.height, le.depth, qe, je, le.data)) : t.texImage3D(s.TEXTURE_2D_ARRAY, 0, Fe, le.width, le.height, le.depth, 0, qe, je, le.data);
      else if (R.isData3DTexture)
        q ? (ke && t.texStorage3D(s.TEXTURE_3D, xe, Fe, le.width, le.height, le.depth), t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, le.width, le.height, le.depth, qe, je, le.data)) : t.texImage3D(s.TEXTURE_3D, 0, Fe, le.width, le.height, le.depth, 0, qe, je, le.data);
      else if (R.isFramebufferTexture) {
        if (ke)
          if (q)
            t.texStorage2D(s.TEXTURE_2D, xe, Fe, le.width, le.height);
          else {
            let ae = le.width, De = le.height;
            for (let st = 0; st < xe; st++)
              t.texImage2D(s.TEXTURE_2D, st, Fe, ae, De, 0, qe, je, null), ae >>= 1, De >>= 1;
          }
      } else if (me.length > 0 && at) {
        q && ke && t.texStorage2D(s.TEXTURE_2D, xe, Fe, me[0].width, me[0].height);
        for (let ae = 0, De = me.length; ae < De; ae++)
          He = me[ae], q ? t.texSubImage2D(s.TEXTURE_2D, ae, 0, 0, qe, je, He) : t.texImage2D(s.TEXTURE_2D, ae, Fe, qe, je, He);
        R.generateMipmaps = !1;
      } else
        q ? (ke && t.texStorage2D(s.TEXTURE_2D, xe, Fe, le.width, le.height), t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, qe, je, le)) : t.texImage2D(s.TEXTURE_2D, 0, Fe, qe, je, le);
      S(R, at) && C(we), We.__version = Ce.version, R.onUpdate && R.onUpdate(R);
    }
    F.__version = R.version;
  }
  function ht(F, R, te) {
    if (R.image.length !== 6) return;
    const we = Qe(F, R), Ae = R.source;
    t.bindTexture(s.TEXTURE_CUBE_MAP, F.__webglTexture, s.TEXTURE0 + te);
    const Ce = i.get(Ae);
    if (Ae.version !== Ce.__version || we === !0) {
      t.activeTexture(s.TEXTURE0 + te);
      const We = Rt.getPrimaries(Rt.workingColorSpace), Me = R.colorSpace === Wt || R.colorSpace === Es ? null : Rt.getPrimaries(R.colorSpace), Le = R.colorSpace === Wt || R.colorSpace === Es || We === Me ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, R.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, R.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, R.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Le);
      const z = R.isCompressedTexture || R.image[0].isCompressedTexture, ye = R.image[0] && R.image[0].isDataTexture, le = [];
      for (let ae = 0; ae < 6; ae++)
        !z && !ye ? le[ae] = g(R.image[ae], !1, !0, c) : le[ae] = ye ? R.image[ae].image : R.image[ae], le[ae] = di(R, le[ae]);
      const at = le[0], qe = _(at) || o, je = r.convert(R.format, R.colorSpace), Fe = r.convert(R.type), He = E(R.internalFormat, je, Fe, R.colorSpace), me = o && R.isVideoTexture !== !0, q = Ce.__version === void 0 || we === !0;
      let ke = x(R, at, qe);
      ze(s.TEXTURE_CUBE_MAP, R, qe);
      let xe;
      if (z) {
        me && q && t.texStorage2D(s.TEXTURE_CUBE_MAP, ke, He, at.width, at.height);
        for (let ae = 0; ae < 6; ae++) {
          xe = le[ae].mipmaps;
          for (let De = 0; De < xe.length; De++) {
            const st = xe[De];
            R.format !== ei ? je !== null ? me ? t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ae, De, 0, 0, st.width, st.height, je, st.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ae, De, He, st.width, st.height, 0, st.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : me ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ae, De, 0, 0, st.width, st.height, je, Fe, st.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ae, De, He, st.width, st.height, 0, je, Fe, st.data);
          }
        }
      } else {
        xe = R.mipmaps, me && q && (xe.length > 0 && ke++, t.texStorage2D(s.TEXTURE_CUBE_MAP, ke, He, le[0].width, le[0].height));
        for (let ae = 0; ae < 6; ae++)
          if (ye) {
            me ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ae, 0, 0, 0, le[ae].width, le[ae].height, je, Fe, le[ae].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ae, 0, He, le[ae].width, le[ae].height, 0, je, Fe, le[ae].data);
            for (let De = 0; De < xe.length; De++) {
              const Et = xe[De].image[ae].image;
              me ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ae, De + 1, 0, 0, Et.width, Et.height, je, Fe, Et.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ae, De + 1, He, Et.width, Et.height, 0, je, Fe, Et.data);
            }
          } else {
            me ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ae, 0, 0, 0, je, Fe, le[ae]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ae, 0, He, je, Fe, le[ae]);
            for (let De = 0; De < xe.length; De++) {
              const st = xe[De];
              me ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ae, De + 1, 0, 0, je, Fe, st.image[ae]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ae, De + 1, He, je, Fe, st.image[ae]);
            }
          }
      }
      S(R, qe) && C(s.TEXTURE_CUBE_MAP), Ce.__version = Ae.version, R.onUpdate && R.onUpdate(R);
    }
    F.__version = R.version;
  }
  function Xe(F, R, te, we, Ae, Ce) {
    const We = r.convert(te.format, te.colorSpace), Me = r.convert(te.type), Le = E(te.internalFormat, We, Me, te.colorSpace);
    if (!i.get(R).__hasExternalTextures) {
      const ye = Math.max(1, R.width >> Ce), le = Math.max(1, R.height >> Ce);
      Ae === s.TEXTURE_3D || Ae === s.TEXTURE_2D_ARRAY ? t.texImage3D(Ae, Ce, Le, ye, le, R.depth, 0, We, Me, null) : t.texImage2D(Ae, Ce, Le, ye, le, 0, We, Me, null);
    }
    t.bindFramebuffer(s.FRAMEBUFFER, F), nt(R) ? d.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, we, Ae, i.get(te).__webglTexture, 0, Ge(R)) : (Ae === s.TEXTURE_2D || Ae >= s.TEXTURE_CUBE_MAP_POSITIVE_X && Ae <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, we, Ae, i.get(te).__webglTexture, Ce), t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function G(F, R, te) {
    if (s.bindRenderbuffer(s.RENDERBUFFER, F), R.depthBuffer && !R.stencilBuffer) {
      let we = o === !0 ? s.DEPTH_COMPONENT24 : s.DEPTH_COMPONENT16;
      if (te || nt(R)) {
        const Ae = R.depthTexture;
        Ae && Ae.isDepthTexture && (Ae.type === Xt ? we = s.DEPTH_COMPONENT32F : Ae.type === qs && (we = s.DEPTH_COMPONENT24));
        const Ce = Ge(R);
        nt(R) ? d.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Ce, we, R.width, R.height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, Ce, we, R.width, R.height);
      } else
        s.renderbufferStorage(s.RENDERBUFFER, we, R.width, R.height);
      s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, F);
    } else if (R.depthBuffer && R.stencilBuffer) {
      const we = Ge(R);
      te && nt(R) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, we, s.DEPTH24_STENCIL8, R.width, R.height) : nt(R) ? d.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, we, s.DEPTH24_STENCIL8, R.width, R.height) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, R.width, R.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, F);
    } else {
      const we = R.isWebGLMultipleRenderTargets === !0 ? R.texture : [R.texture];
      for (let Ae = 0; Ae < we.length; Ae++) {
        const Ce = we[Ae], We = r.convert(Ce.format, Ce.colorSpace), Me = r.convert(Ce.type), Le = E(Ce.internalFormat, We, Me, Ce.colorSpace), z = Ge(R);
        te && nt(R) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, z, Le, R.width, R.height) : nt(R) ? d.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, z, Le, R.width, R.height) : s.renderbufferStorage(s.RENDERBUFFER, Le, R.width, R.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function Be(F, R) {
    if (R && R.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(s.FRAMEBUFFER, F), !(R.depthTexture && R.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!i.get(R.depthTexture).__webglTexture || R.depthTexture.image.width !== R.width || R.depthTexture.image.height !== R.height) && (R.depthTexture.image.width = R.width, R.depthTexture.image.height = R.height, R.depthTexture.needsUpdate = !0), J(R.depthTexture, 0);
    const we = i.get(R.depthTexture).__webglTexture, Ae = Ge(R);
    if (R.depthTexture.format === Ea)
      nt(R) ? d.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, we, 0, Ae) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, we, 0);
    else if (R.depthTexture.format === $l)
      nt(R) ? d.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, we, 0, Ae) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, we, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function oe(F) {
    const R = i.get(F), te = F.isWebGLCubeRenderTarget === !0;
    if (F.depthTexture && !R.__autoAllocateDepthBuffer) {
      if (te) throw new Error("target.depthTexture not supported in Cube render targets");
      Be(R.__webglFramebuffer, F);
    } else if (te) {
      R.__webglDepthbuffer = [];
      for (let we = 0; we < 6; we++)
        t.bindFramebuffer(s.FRAMEBUFFER, R.__webglFramebuffer[we]), R.__webglDepthbuffer[we] = s.createRenderbuffer(), G(R.__webglDepthbuffer[we], F, !1);
    } else
      t.bindFramebuffer(s.FRAMEBUFFER, R.__webglFramebuffer), R.__webglDepthbuffer = s.createRenderbuffer(), G(R.__webglDepthbuffer, F, !1);
    t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function Ee(F, R, te) {
    const we = i.get(F);
    R !== void 0 && Xe(we.__webglFramebuffer, F, F.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), te !== void 0 && oe(F);
  }
  function de(F) {
    const R = F.texture, te = i.get(F), we = i.get(R);
    F.addEventListener("dispose", O), F.isWebGLMultipleRenderTargets !== !0 && (we.__webglTexture === void 0 && (we.__webglTexture = s.createTexture()), we.__version = R.version, a.memory.textures++);
    const Ae = F.isWebGLCubeRenderTarget === !0, Ce = F.isWebGLMultipleRenderTargets === !0, We = _(F) || o;
    if (Ae) {
      te.__webglFramebuffer = [];
      for (let Me = 0; Me < 6; Me++)
        if (o && R.mipmaps && R.mipmaps.length > 0) {
          te.__webglFramebuffer[Me] = [];
          for (let Le = 0; Le < R.mipmaps.length; Le++)
            te.__webglFramebuffer[Me][Le] = s.createFramebuffer();
        } else
          te.__webglFramebuffer[Me] = s.createFramebuffer();
    } else {
      if (o && R.mipmaps && R.mipmaps.length > 0) {
        te.__webglFramebuffer = [];
        for (let Me = 0; Me < R.mipmaps.length; Me++)
          te.__webglFramebuffer[Me] = s.createFramebuffer();
      } else
        te.__webglFramebuffer = s.createFramebuffer();
      if (Ce)
        if (n.drawBuffers) {
          const Me = F.texture;
          for (let Le = 0, z = Me.length; Le < z; Le++) {
            const ye = i.get(Me[Le]);
            ye.__webglTexture === void 0 && (ye.__webglTexture = s.createTexture(), a.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (o && F.samples > 0 && nt(F) === !1) {
        const Me = Ce ? R : [R];
        te.__webglMultisampledFramebuffer = s.createFramebuffer(), te.__webglColorRenderbuffer = [], t.bindFramebuffer(s.FRAMEBUFFER, te.__webglMultisampledFramebuffer);
        for (let Le = 0; Le < Me.length; Le++) {
          const z = Me[Le];
          te.__webglColorRenderbuffer[Le] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, te.__webglColorRenderbuffer[Le]);
          const ye = r.convert(z.format, z.colorSpace), le = r.convert(z.type), at = E(z.internalFormat, ye, le, z.colorSpace, F.isXRRenderTarget === !0), qe = Ge(F);
          s.renderbufferStorageMultisample(s.RENDERBUFFER, qe, at, F.width, F.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Le, s.RENDERBUFFER, te.__webglColorRenderbuffer[Le]);
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null), F.depthBuffer && (te.__webglDepthRenderbuffer = s.createRenderbuffer(), G(te.__webglDepthRenderbuffer, F, !0)), t.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if (Ae) {
      t.bindTexture(s.TEXTURE_CUBE_MAP, we.__webglTexture), ze(s.TEXTURE_CUBE_MAP, R, We);
      for (let Me = 0; Me < 6; Me++)
        if (o && R.mipmaps && R.mipmaps.length > 0)
          for (let Le = 0; Le < R.mipmaps.length; Le++)
            Xe(te.__webglFramebuffer[Me][Le], F, R, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Me, Le);
        else
          Xe(te.__webglFramebuffer[Me], F, R, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Me, 0);
      S(R, We) && C(s.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Ce) {
      const Me = F.texture;
      for (let Le = 0, z = Me.length; Le < z; Le++) {
        const ye = Me[Le], le = i.get(ye);
        t.bindTexture(s.TEXTURE_2D, le.__webglTexture), ze(s.TEXTURE_2D, ye, We), Xe(te.__webglFramebuffer, F, ye, s.COLOR_ATTACHMENT0 + Le, s.TEXTURE_2D, 0), S(ye, We) && C(s.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Me = s.TEXTURE_2D;
      if ((F.isWebGL3DRenderTarget || F.isWebGLArrayRenderTarget) && (o ? Me = F.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(Me, we.__webglTexture), ze(Me, R, We), o && R.mipmaps && R.mipmaps.length > 0)
        for (let Le = 0; Le < R.mipmaps.length; Le++)
          Xe(te.__webglFramebuffer[Le], F, R, s.COLOR_ATTACHMENT0, Me, Le);
      else
        Xe(te.__webglFramebuffer, F, R, s.COLOR_ATTACHMENT0, Me, 0);
      S(R, We) && C(Me), t.unbindTexture();
    }
    F.depthBuffer && oe(F);
  }
  function Ke(F) {
    const R = _(F) || o, te = F.isWebGLMultipleRenderTargets === !0 ? F.texture : [F.texture], we = F.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D;
    for (let Ae = 0, Ce = te.length; Ae < Ce; Ae++) {
      const We = te[Ae], Me = i.get(We), Le = Me.__webglTexture;
      Me.__version !== We.version && (t.bindTexture(we, Le), ze(we, We, R), t.unbindTexture(), Me.__version = We.version), S(We, R) && (t.bindTexture(we, Le), C(we), t.unbindTexture());
    }
  }
  function Ne(F) {
    if (o && F.samples > 0 && nt(F) === !1) {
      const R = F.isWebGLMultipleRenderTargets ? F.texture : [F.texture], te = F.width, we = F.height;
      let Ae = s.COLOR_BUFFER_BIT;
      const Ce = [], We = F.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Me = i.get(F), Le = F.isWebGLMultipleRenderTargets === !0;
      if (Le)
        for (let z = 0; z < R.length; z++)
          t.bindFramebuffer(s.FRAMEBUFFER, Me.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + z, s.RENDERBUFFER, null), t.bindFramebuffer(s.FRAMEBUFFER, Me.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + z, s.TEXTURE_2D, null, 0);
      t.bindFramebuffer(s.READ_FRAMEBUFFER, Me.__webglMultisampledFramebuffer), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Me.__webglFramebuffer);
      for (let z = 0; z < R.length; z++) {
        Ce.push(s.COLOR_ATTACHMENT0 + z), F.depthBuffer && Ce.push(We);
        const ye = Me.__ignoreDepthValues !== void 0 ? Me.__ignoreDepthValues : !1;
        if (ye === !1 && (F.depthBuffer && (Ae |= s.DEPTH_BUFFER_BIT), F.stencilBuffer && (Ae |= s.STENCIL_BUFFER_BIT)), Le && s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, Me.__webglColorRenderbuffer[z]), ye === !0 && (s.invalidateFramebuffer(s.READ_FRAMEBUFFER, [We]), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [We])), Le) {
          const le = i.get(R[z]).__webglTexture;
          s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, le, 0);
        }
        s.blitFramebuffer(0, 0, te, we, 0, 0, te, we, Ae, s.NEAREST), p && s.invalidateFramebuffer(s.READ_FRAMEBUFFER, Ce);
      }
      if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), Le)
        for (let z = 0; z < R.length; z++) {
          t.bindFramebuffer(s.FRAMEBUFFER, Me.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + z, s.RENDERBUFFER, Me.__webglColorRenderbuffer[z]);
          const ye = i.get(R[z]).__webglTexture;
          t.bindFramebuffer(s.FRAMEBUFFER, Me.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + z, s.TEXTURE_2D, ye, 0);
        }
      t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Me.__webglMultisampledFramebuffer);
    }
  }
  function Ge(F) {
    return Math.min(u, F.samples);
  }
  function nt(F) {
    const R = i.get(F);
    return o && F.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && R.__useRenderToTexture !== !1;
  }
  function wt(F) {
    const R = a.render.frame;
    f.get(F) !== R && (f.set(F, R), F.update());
  }
  function di(F, R) {
    const te = F.colorSpace, we = F.format, Ae = F.type;
    return F.isCompressedTexture === !0 || F.isVideoTexture === !0 || F.format === $m || te !== Mt && te !== Wt && (Rt.getTransfer(te) === mi ? o === !1 ? e.has("EXT_sRGB") === !0 && we === ei ? (F.format = $m, F.minFilter = tt, F.generateMipmaps = !1) : R = aA.sRGBToLinear(R) : (we !== ei || Ae !== Ft) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : te === Es || console.error("THREE.WebGLTextures: Unsupported texture color space:", te)), R;
  }
  this.allocateTextureUnit = Z, this.resetTextureUnits = X, this.setTexture2D = J, this.setTexture2DArray = W, this.setTexture3D = K, this.setTextureCube = ce, this.rebindTextures = Ee, this.setupRenderTarget = de, this.updateRenderTargetMipmap = Ke, this.updateMultisampleRenderTarget = Ne, this.setupDepthRenderbuffer = oe, this.setupFrameBufferTexture = Xe, this.useMultisampledRTT = nt;
}
function rD(s, e, t) {
  const i = t.isWebGL2;
  function n(r, a = Wt) {
    let o;
    const l = Rt.getTransfer(a);
    if (r === Ft) return s.UNSIGNED_BYTE;
    if (r === iA) return s.UNSIGNED_SHORT_4_4_4_4;
    if (r === nA) return s.UNSIGNED_SHORT_5_5_5_1;
    if (r === tw) return s.BYTE;
    if (r === iw) return s.SHORT;
    if (r === Lp) return s.UNSIGNED_SHORT;
    if (r === tA) return s.INT;
    if (r === qs) return s.UNSIGNED_INT;
    if (r === Xt) return s.FLOAT;
    if (r === Qt)
      return i ? s.HALF_FLOAT : (o = e.get("OES_texture_half_float"), o !== null ? o.HALF_FLOAT_OES : null);
    if (r === FS) return s.ALPHA;
    if (r === ei) return s.RGBA;
    if (r === OS) return s.LUMINANCE;
    if (r === NS) return s.LUMINANCE_ALPHA;
    if (r === Ea) return s.DEPTH_COMPONENT;
    if (r === $l) return s.DEPTH_STENCIL;
    if (r === $m)
      return o = e.get("EXT_sRGB"), o !== null ? o.SRGB_ALPHA_EXT : null;
    if (r === ao) return s.RED;
    if (r === nw) return s.RED_INTEGER;
    if (r === bl) return s.RG;
    if (r === sw) return s.RG_INTEGER;
    if (r === rw) return s.RGBA_INTEGER;
    if (r === Dd || r === ff || r === mf || r === Rd)
      if (l === mi)
        if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
          if (r === Dd) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === ff) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === mf) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === Rd) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) {
        if (r === Dd) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === ff) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === mf) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === Rd) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (r === zm || r === $y || r === Qm || r === Zy)
      if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
        if (r === zm) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === $y) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === Qm) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === Zy) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (r === aw)
      return o = e.get("WEBGL_compressed_texture_etc1"), o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (r === Hm || r === Vm)
      if (o = e.get("WEBGL_compressed_texture_etc"), o !== null) {
        if (r === Hm) return l === mi ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (r === Vm) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (r === Wm || r === e0 || r === t0 || r === i0 || r === Jd || r === n0 || r === s0 || r === r0 || r === a0 || r === o0 || r === l0 || r === c0 || r === h0 || r === u0)
      if (o = e.get("WEBGL_compressed_texture_astc"), o !== null) {
        if (r === Wm) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === e0) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === t0) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === i0) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === Jd) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === n0) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === s0) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === r0) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === a0) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === o0) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === l0) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === c0) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === h0) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === u0) return l === mi ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (r === Bd || r === d0 || r === p0)
      if (o = e.get("EXT_texture_compression_bptc"), o !== null) {
        if (r === Bd) return l === mi ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (r === d0) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (r === p0) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (r === kS || r === f0 || r === m0 || r === g0)
      if (o = e.get("EXT_texture_compression_rgtc"), o !== null) {
        if (r === Bd) return o.COMPRESSED_RED_RGTC1_EXT;
        if (r === f0) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === m0) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === g0) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return r === wa ? i ? s.UNSIGNED_INT_24_8 : (o = e.get("WEBGL_depth_texture"), o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null) : s[r] !== void 0 ? s[r] : null;
  }
  return { convert: n };
}
class aD extends ki {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Kn extends ut {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const oD = { type: "move" };
class kf {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Kn(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Kn(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new M(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new M()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Kn(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new M(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new M()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const i of e.hand.values())
          this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, i) {
    let n = null, r = null, a = null;
    const o = this._targetRay, l = this._grip, c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        a = !0;
        for (const y of e.hand.values()) {
          const A = t.getJointPose(y, i), m = this._getHandJoint(c, y);
          A !== null && (m.matrix.fromArray(A.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.matrixWorldNeedsUpdate = !0, m.jointRadius = A.radius), m.visible = A !== null;
        }
        const h = c.joints["index-finger-tip"], u = c.joints["thumb-tip"], d = h.position.distanceTo(u.position), p = 0.02, f = 5e-3;
        c.inputState.pinching && d > p + f ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !c.inputState.pinching && d <= p - f && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, i), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
      o !== null && (n = t.getPose(e.targetRaySpace, i), n === null && r !== null && (n = r), n !== null && (o.matrix.fromArray(n.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, n.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(n.linearVelocity)) : o.hasLinearVelocity = !1, n.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(n.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(oD)));
    }
    return o !== null && (o.visible = n !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = a !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new Kn();
      i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i);
    }
    return e.joints[t.jointName];
  }
}
class bw extends Nt {
  constructor(e, t, i, n, r, a, o, l, c, h) {
    if (h = h !== void 0 ? h : Ea, h !== Ea && h !== $l)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && h === Ea && (i = qs), i === void 0 && h === $l && (i = wa), super(null, n, r, a, o, l, h, i, c), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = o !== void 0 ? o : pi, this.minFilter = l !== void 0 ? l : pi, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
class lD extends Vi {
  constructor(e, t) {
    super();
    const i = this;
    let n = null, r = 1, a = null, o = "local-floor", l = 1, c = null, h = null, u = null, d = null, p = null, f = null;
    const y = t.getContextAttributes();
    let A = null, m = null;
    const v = [], g = [], _ = new ki();
    _.layers.enable(1), _.viewport = new it();
    const w = new ki();
    w.layers.enable(2), w.viewport = new it();
    const S = [_, w], C = new aD();
    C.layers.enable(1), C.layers.enable(2);
    let E = null, x = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(W) {
      let K = v[W];
      return K === void 0 && (K = new kf(), v[W] = K), K.getTargetRaySpace();
    }, this.getControllerGrip = function(W) {
      let K = v[W];
      return K === void 0 && (K = new kf(), v[W] = K), K.getGripSpace();
    }, this.getHand = function(W) {
      let K = v[W];
      return K === void 0 && (K = new kf(), v[W] = K), K.getHandSpace();
    };
    function b(W) {
      const K = g.indexOf(W.inputSource);
      if (K === -1)
        return;
      const ce = v[K];
      ce !== void 0 && (ce.update(W.inputSource, W.frame, c || a), ce.dispatchEvent({ type: W.type, data: W.inputSource }));
    }
    function D() {
      n.removeEventListener("select", b), n.removeEventListener("selectstart", b), n.removeEventListener("selectend", b), n.removeEventListener("squeeze", b), n.removeEventListener("squeezestart", b), n.removeEventListener("squeezeend", b), n.removeEventListener("end", D), n.removeEventListener("inputsourceschange", O);
      for (let W = 0; W < v.length; W++) {
        const K = g[W];
        K !== null && (g[W] = null, v[W].disconnect(K));
      }
      E = null, x = null, e.setRenderTarget(A), p = null, d = null, u = null, n = null, m = null, J.stop(), i.isPresenting = !1, i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(W) {
      r = W, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(W) {
      o = W, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || a;
    }, this.setReferenceSpace = function(W) {
      c = W;
    }, this.getBaseLayer = function() {
      return d !== null ? d : p;
    }, this.getBinding = function() {
      return u;
    }, this.getFrame = function() {
      return f;
    }, this.getSession = function() {
      return n;
    }, this.setSession = async function(W) {
      if (n = W, n !== null) {
        if (A = e.getRenderTarget(), n.addEventListener("select", b), n.addEventListener("selectstart", b), n.addEventListener("selectend", b), n.addEventListener("squeeze", b), n.addEventListener("squeezestart", b), n.addEventListener("squeezeend", b), n.addEventListener("end", D), n.addEventListener("inputsourceschange", O), y.xrCompatible !== !0 && await t.makeXRCompatible(), n.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const K = {
            antialias: n.renderState.layers === void 0 ? y.antialias : !0,
            alpha: !0,
            depth: y.depth,
            stencil: y.stencil,
            framebufferScaleFactor: r
          };
          p = new XRWebGLLayer(n, t, K), n.updateRenderState({ baseLayer: p }), m = new Zn(
            p.framebufferWidth,
            p.framebufferHeight,
            {
              format: ei,
              type: Ft,
              colorSpace: e.outputColorSpace,
              stencilBuffer: y.stencil
            }
          );
        } else {
          let K = null, ce = null, fe = null;
          y.depth && (fe = y.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, K = y.stencil ? $l : Ea, ce = y.stencil ? wa : qs);
          const ve = {
            colorFormat: t.RGBA8,
            depthFormat: fe,
            scaleFactor: r
          };
          u = new XRWebGLBinding(n, t), d = u.createProjectionLayer(ve), n.updateRenderState({ layers: [d] }), m = new Zn(
            d.textureWidth,
            d.textureHeight,
            {
              format: ei,
              type: Ft,
              depthTexture: new bw(d.textureWidth, d.textureHeight, ce, void 0, void 0, void 0, void 0, void 0, void 0, K),
              stencilBuffer: y.stencil,
              colorSpace: e.outputColorSpace,
              samples: y.antialias ? 4 : 0
            }
          );
          const _e = e.properties.get(m);
          _e.__ignoreDepthValues = d.ignoreDepthValues;
        }
        m.isXRRenderTarget = !0, this.setFoveation(l), c = null, a = await n.requestReferenceSpace(o), J.setContext(n), J.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (n !== null)
        return n.environmentBlendMode;
    };
    function O(W) {
      for (let K = 0; K < W.removed.length; K++) {
        const ce = W.removed[K], fe = g.indexOf(ce);
        fe >= 0 && (g[fe] = null, v[fe].disconnect(ce));
      }
      for (let K = 0; K < W.added.length; K++) {
        const ce = W.added[K];
        let fe = g.indexOf(ce);
        if (fe === -1) {
          for (let _e = 0; _e < v.length; _e++)
            if (_e >= g.length) {
              g.push(ce), fe = _e;
              break;
            } else if (g[_e] === null) {
              g[_e] = ce, fe = _e;
              break;
            }
          if (fe === -1) break;
        }
        const ve = v[fe];
        ve && ve.connect(ce);
      }
    }
    const Y = new M(), B = new M();
    function Q(W, K, ce) {
      Y.setFromMatrixPosition(K.matrixWorld), B.setFromMatrixPosition(ce.matrixWorld);
      const fe = Y.distanceTo(B), ve = K.projectionMatrix.elements, _e = ce.projectionMatrix.elements, ze = ve[14] / (ve[10] - 1), Qe = ve[14] / (ve[10] + 1), ot = (ve[9] + 1) / ve[5], ht = (ve[9] - 1) / ve[5], Xe = (ve[8] - 1) / ve[0], G = (_e[8] + 1) / _e[0], Be = ze * Xe, oe = ze * G, Ee = fe / (-Xe + G), de = Ee * -Xe;
      K.matrixWorld.decompose(W.position, W.quaternion, W.scale), W.translateX(de), W.translateZ(Ee), W.matrixWorld.compose(W.position, W.quaternion, W.scale), W.matrixWorldInverse.copy(W.matrixWorld).invert();
      const Ke = ze + Ee, Ne = Qe + Ee, Ge = Be - de, nt = oe + (fe - de), wt = ot * Qe / Ne * Ke, di = ht * Qe / Ne * Ke;
      W.projectionMatrix.makePerspective(Ge, nt, wt, di, Ke, Ne), W.projectionMatrixInverse.copy(W.projectionMatrix).invert();
    }
    function j(W, K) {
      K === null ? W.matrixWorld.copy(W.matrix) : W.matrixWorld.multiplyMatrices(K.matrixWorld, W.matrix), W.matrixWorldInverse.copy(W.matrixWorld).invert();
    }
    this.updateCamera = function(W) {
      if (n === null) return;
      C.near = w.near = _.near = W.near, C.far = w.far = _.far = W.far, (E !== C.near || x !== C.far) && (n.updateRenderState({
        depthNear: C.near,
        depthFar: C.far
      }), E = C.near, x = C.far);
      const K = W.parent, ce = C.cameras;
      j(C, K);
      for (let fe = 0; fe < ce.length; fe++)
        j(ce[fe], K);
      ce.length === 2 ? Q(C, _, w) : C.projectionMatrix.copy(_.projectionMatrix), X(W, C, K);
    };
    function X(W, K, ce) {
      ce === null ? W.matrix.copy(K.matrixWorld) : (W.matrix.copy(ce.matrixWorld), W.matrix.invert(), W.matrix.multiply(K.matrixWorld)), W.matrix.decompose(W.position, W.quaternion, W.scale), W.updateMatrixWorld(!0), W.projectionMatrix.copy(K.projectionMatrix), W.projectionMatrixInverse.copy(K.projectionMatrixInverse), W.isPerspectiveCamera && (W.fov = ec * 2 * Math.atan(1 / W.projectionMatrix.elements[5]), W.zoom = 1);
    }
    this.getCamera = function() {
      return C;
    }, this.getFoveation = function() {
      if (!(d === null && p === null))
        return l;
    }, this.setFoveation = function(W) {
      l = W, d !== null && (d.fixedFoveation = W), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = W);
    };
    let Z = null;
    this.onPreAnimationFrameCallback = null;
    function ee(W, K) {
      if (i.onPreAnimationFrameCallback && i.onPreAnimationFrameCallback(W, K), h = K.getViewerPose(c || a), f = K, h !== null) {
        const ce = h.views;
        p !== null && (e.setRenderTargetFramebuffer(m, p.framebuffer), e.setRenderTarget(m));
        let fe = !1;
        ce.length !== C.cameras.length && (C.cameras.length = 0, fe = !0);
        for (let ve = 0; ve < ce.length; ve++) {
          const _e = ce[ve];
          let ze = null;
          if (p !== null)
            ze = p.getViewport(_e);
          else {
            const ot = u.getViewSubImage(d, _e);
            ze = ot.viewport, ve === 0 && (e.setRenderTargetTextures(
              m,
              ot.colorTexture,
              d.ignoreDepthValues ? void 0 : ot.depthStencilTexture
            ), e.setRenderTarget(m));
          }
          let Qe = S[ve];
          Qe === void 0 && (Qe = new ki(), Qe.layers.enable(ve), Qe.viewport = new it(), S[ve] = Qe), Qe.matrix.fromArray(_e.transform.matrix), Qe.matrix.decompose(Qe.position, Qe.quaternion, Qe.scale), Qe.projectionMatrix.fromArray(_e.projectionMatrix), Qe.projectionMatrixInverse.copy(Qe.projectionMatrix).invert(), Qe.viewport.set(ze.x, ze.y, ze.width, ze.height), ve === 0 && (C.matrix.copy(Qe.matrix), C.matrix.decompose(C.position, C.quaternion, C.scale)), fe === !0 && C.cameras.push(Qe);
        }
      }
      for (let ce = 0; ce < v.length; ce++) {
        const fe = g[ce], ve = v[ce];
        fe !== null && ve !== void 0 && ve.update(fe, K, c || a);
      }
      Z && Z(W, K), K.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: K }), f = null;
    }
    const J = new yw();
    J.setAnimationLoop(ee), this.setAnimationLoop = function(W) {
      Z = W;
    }, this.dispose = function() {
    };
  }
}
function cD(s, e) {
  function t(A, m) {
    A.matrixAutoUpdate === !0 && A.updateMatrix(), m.value.copy(A.matrix);
  }
  function i(A, m) {
    m.color.getRGB(A.fogColor.value, gw(s)), m.isFog ? (A.fogNear.value = m.near, A.fogFar.value = m.far) : m.isFogExp2 && (A.fogDensity.value = m.density);
  }
  function n(A, m, v, g, _) {
    m.isMeshBasicMaterial || m.isMeshLambertMaterial ? r(A, m) : m.isMeshToonMaterial ? (r(A, m), u(A, m)) : m.isMeshPhongMaterial ? (r(A, m), h(A, m)) : m.isMeshStandardMaterial ? (r(A, m), d(A, m), m.isMeshPhysicalMaterial && p(A, m, _)) : m.isMeshMatcapMaterial ? (r(A, m), f(A, m)) : m.isMeshDepthMaterial ? r(A, m) : m.isMeshDistanceMaterial ? (r(A, m), y(A, m)) : m.isMeshNormalMaterial ? r(A, m) : m.isLineBasicMaterial ? (a(A, m), m.isLineDashedMaterial && o(A, m)) : m.isPointsMaterial ? l(A, m, v, g) : m.isSpriteMaterial ? c(A, m) : m.isShadowMaterial ? (A.color.value.copy(m.color), A.opacity.value = m.opacity) : m.isShaderMaterial && (m.transmission !== void 0 && (A.transmission && (A.transmission.value = m.transmission), A.transmissionSamplerMap && _ && (A.transmissionSamplerMap.value = _ ? _.texture : null), A.transmissionSamplerSize && _ && A.transmissionSamplerSize.value.set(_.width, _.height)), m.uniformsNeedUpdate = !1);
  }
  function r(A, m) {
    A.opacity.value = m.opacity, m.color && A.diffuse.value.copy(m.color), m.emissive && A.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity), m.map && (A.map.value = m.map, t(m.map, A.mapTransform)), m.alphaMap && (A.alphaMap.value = m.alphaMap, t(m.alphaMap, A.alphaMapTransform)), m.bumpMap && (A.bumpMap.value = m.bumpMap, t(m.bumpMap, A.bumpMapTransform), A.bumpScale.value = m.bumpScale, m.side === vn && (A.bumpScale.value *= -1)), m.normalMap && (A.normalMap.value = m.normalMap, t(m.normalMap, A.normalMapTransform), A.normalScale.value.copy(m.normalScale), m.side === vn && A.normalScale.value.negate()), m.displacementMap && (A.displacementMap.value = m.displacementMap, t(m.displacementMap, A.displacementMapTransform), A.displacementScale.value = m.displacementScale, A.displacementBias.value = m.displacementBias), m.emissiveMap && (A.emissiveMap.value = m.emissiveMap, t(m.emissiveMap, A.emissiveMapTransform)), m.specularMap && (A.specularMap.value = m.specularMap, t(m.specularMap, A.specularMapTransform)), m.alphaTest > 0 && (A.alphaTest.value = m.alphaTest);
    const v = e.get(m).envMap;
    if (v) {
      A.envMap.value = v;
      const g = m.envMap || e.get(m).environment || v;
      A.envMapRotation.value = g ? g.rotation : 0, A.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1, A.reflectivity.value = m.reflectivity, A.ior.value = m.ior, A.refractionRatio.value = m.refractionRatio;
    }
    if (m.lightMap) {
      A.lightMap.value = m.lightMap;
      const g = s._useLegacyLights === !0 ? Math.PI : 1;
      A.lightMapIntensity.value = m.lightMapIntensity * g, t(m.lightMap, A.lightMapTransform);
    }
    m.aoMap && (A.aoMap.value = m.aoMap, A.aoMapIntensity.value = m.aoMapIntensity, t(m.aoMap, A.aoMapTransform));
  }
  function a(A, m) {
    A.diffuse.value.copy(m.color), A.opacity.value = m.opacity, m.map && (A.map.value = m.map, t(m.map, A.mapTransform));
  }
  function o(A, m) {
    A.dashSize.value = m.dashSize, A.totalSize.value = m.dashSize + m.gapSize, A.scale.value = m.scale;
  }
  function l(A, m, v, g) {
    A.diffuse.value.copy(m.color), A.opacity.value = m.opacity, A.size.value = m.size * v, A.scale.value = g * 0.5, m.map && (A.map.value = m.map, t(m.map, A.uvTransform)), m.alphaMap && (A.alphaMap.value = m.alphaMap, t(m.alphaMap, A.alphaMapTransform)), m.alphaTest > 0 && (A.alphaTest.value = m.alphaTest);
  }
  function c(A, m) {
    A.diffuse.value.copy(m.color), A.opacity.value = m.opacity, A.rotation.value = m.rotation, m.map && (A.map.value = m.map, t(m.map, A.mapTransform)), m.alphaMap && (A.alphaMap.value = m.alphaMap, t(m.alphaMap, A.alphaMapTransform)), m.alphaTest > 0 && (A.alphaTest.value = m.alphaTest);
  }
  function h(A, m) {
    A.specular.value.copy(m.specular), A.shininess.value = Math.max(m.shininess, 1e-4);
  }
  function u(A, m) {
    m.gradientMap && (A.gradientMap.value = m.gradientMap);
  }
  function d(A, m) {
    A.metalness.value = m.metalness, m.metalnessMap && (A.metalnessMap.value = m.metalnessMap, t(m.metalnessMap, A.metalnessMapTransform)), A.roughness.value = m.roughness, m.roughnessMap && (A.roughnessMap.value = m.roughnessMap, t(m.roughnessMap, A.roughnessMapTransform)), e.get(m).envMap && (A.envMapIntensity.value = m.envMapIntensity);
  }
  function p(A, m, v) {
    A.ior.value = m.ior, m.sheen > 0 && (A.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen), A.sheenRoughness.value = m.sheenRoughness, m.sheenColorMap && (A.sheenColorMap.value = m.sheenColorMap, t(m.sheenColorMap, A.sheenColorMapTransform)), m.sheenRoughnessMap && (A.sheenRoughnessMap.value = m.sheenRoughnessMap, t(m.sheenRoughnessMap, A.sheenRoughnessMapTransform))), m.clearcoat > 0 && (A.clearcoat.value = m.clearcoat, A.clearcoatRoughness.value = m.clearcoatRoughness, m.clearcoatMap && (A.clearcoatMap.value = m.clearcoatMap, t(m.clearcoatMap, A.clearcoatMapTransform)), m.clearcoatRoughnessMap && (A.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap, t(m.clearcoatRoughnessMap, A.clearcoatRoughnessMapTransform)), m.clearcoatNormalMap && (A.clearcoatNormalMap.value = m.clearcoatNormalMap, t(m.clearcoatNormalMap, A.clearcoatNormalMapTransform), A.clearcoatNormalScale.value.copy(m.clearcoatNormalScale), m.side === vn && A.clearcoatNormalScale.value.negate())), m.iridescence > 0 && (A.iridescence.value = m.iridescence, A.iridescenceIOR.value = m.iridescenceIOR, A.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0], A.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1], m.iridescenceMap && (A.iridescenceMap.value = m.iridescenceMap, t(m.iridescenceMap, A.iridescenceMapTransform)), m.iridescenceThicknessMap && (A.iridescenceThicknessMap.value = m.iridescenceThicknessMap, t(m.iridescenceThicknessMap, A.iridescenceThicknessMapTransform))), m.transmission > 0 && (A.transmission.value = m.transmission, A.transmissionSamplerMap.value = v.texture, A.transmissionSamplerSize.value.set(v.width, v.height), m.transmissionMap && (A.transmissionMap.value = m.transmissionMap, t(m.transmissionMap, A.transmissionMapTransform)), A.thickness.value = m.thickness, m.thicknessMap && (A.thicknessMap.value = m.thicknessMap, t(m.thicknessMap, A.thicknessMapTransform)), A.attenuationDistance.value = m.attenuationDistance, A.attenuationColor.value.copy(m.attenuationColor)), m.anisotropy > 0 && (A.anisotropyVector.value.set(m.anisotropy * Math.cos(m.anisotropyRotation), m.anisotropy * Math.sin(m.anisotropyRotation)), m.anisotropyMap && (A.anisotropyMap.value = m.anisotropyMap, t(m.anisotropyMap, A.anisotropyMapTransform))), A.specularIntensity.value = m.specularIntensity, A.specularColor.value.copy(m.specularColor), m.specularColorMap && (A.specularColorMap.value = m.specularColorMap, t(m.specularColorMap, A.specularColorMapTransform)), m.specularIntensityMap && (A.specularIntensityMap.value = m.specularIntensityMap, t(m.specularIntensityMap, A.specularIntensityMapTransform));
  }
  function f(A, m) {
    m.matcap && (A.matcap.value = m.matcap);
  }
  function y(A, m) {
    const v = e.get(m).light;
    A.referencePosition.value.setFromMatrixPosition(v.matrixWorld), A.nearDistance.value = v.shadow.camera.near, A.farDistance.value = v.shadow.camera.far;
  }
  return {
    refreshTransformUniform: t,
    refreshFogUniforms: i,
    refreshMaterialUniforms: n
  };
}
function hD(s, e, t, i) {
  let n = {}, r = {}, a = [];
  const o = t.isWebGL2 ? s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(v, g) {
    const _ = g.program;
    i.uniformBlockBinding(v, _);
  }
  function c(v, g) {
    let _ = n[v.id];
    _ === void 0 && (f(v), _ = h(v), n[v.id] = _, v.addEventListener("dispose", A));
    const w = g.program;
    i.updateUBOMapping(v, w);
    const S = e.render.frame;
    r[v.id] !== S && (d(v), r[v.id] = S);
  }
  function h(v) {
    const g = u();
    v.__bindingPointIndex = g;
    const _ = s.createBuffer(), w = v.__size, S = v.usage;
    return s.bindBuffer(s.UNIFORM_BUFFER, _), s.bufferData(s.UNIFORM_BUFFER, w, S), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, g, _), _;
  }
  function u() {
    for (let v = 0; v < o; v++)
      if (a.indexOf(v) === -1)
        return a.push(v), v;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function d(v) {
    const g = n[v.id], _ = v.uniforms, w = v.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, g);
    for (let S = 0, C = _.length; S < C; S++) {
      const E = _[S];
      if (p(E, S, w) === !0) {
        const x = E.__offset, b = Array.isArray(E.value) ? E.value : [E.value];
        let D = 0;
        for (let O = 0; O < b.length; O++) {
          const Y = b[O], B = y(Y);
          typeof Y == "number" ? (E.__data[0] = Y, s.bufferSubData(s.UNIFORM_BUFFER, x + D, E.__data)) : Y.isMatrix3 ? (E.__data[0] = Y.elements[0], E.__data[1] = Y.elements[1], E.__data[2] = Y.elements[2], E.__data[3] = Y.elements[0], E.__data[4] = Y.elements[3], E.__data[5] = Y.elements[4], E.__data[6] = Y.elements[5], E.__data[7] = Y.elements[0], E.__data[8] = Y.elements[6], E.__data[9] = Y.elements[7], E.__data[10] = Y.elements[8], E.__data[11] = Y.elements[0]) : (Y.toArray(E.__data, D), D += B.storage / Float32Array.BYTES_PER_ELEMENT);
        }
        s.bufferSubData(s.UNIFORM_BUFFER, x, E.__data);
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function p(v, g, _) {
    const w = v.value;
    if (_[g] === void 0) {
      if (typeof w == "number")
        _[g] = w;
      else {
        const S = Array.isArray(w) ? w : [w], C = [];
        for (let E = 0; E < S.length; E++)
          C.push(S[E].clone());
        _[g] = C;
      }
      return !0;
    } else if (typeof w == "number") {
      if (_[g] !== w)
        return _[g] = w, !0;
    } else {
      const S = Array.isArray(_[g]) ? _[g] : [_[g]], C = Array.isArray(w) ? w : [w];
      for (let E = 0; E < S.length; E++) {
        const x = S[E];
        if (x.equals(C[E]) === !1)
          return x.copy(C[E]), !0;
      }
    }
    return !1;
  }
  function f(v) {
    const g = v.uniforms;
    let _ = 0;
    const w = 16;
    let S = 0;
    for (let C = 0, E = g.length; C < E; C++) {
      const x = g[C], b = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      }, D = Array.isArray(x.value) ? x.value : [x.value];
      for (let O = 0, Y = D.length; O < Y; O++) {
        const B = D[O], Q = y(B);
        b.boundary += Q.boundary, b.storage += Q.storage;
      }
      if (x.__data = new Float32Array(b.storage / Float32Array.BYTES_PER_ELEMENT), x.__offset = _, C > 0) {
        S = _ % w;
        const O = w - S;
        S !== 0 && O - b.boundary < 0 && (_ += w - S, x.__offset = _);
      }
      _ += b.storage;
    }
    return S = _ % w, S > 0 && (_ += w - S), v.__size = _, v.__cache = {}, this;
  }
  function y(v) {
    const g = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof v == "number" ? (g.boundary = 4, g.storage = 4) : v.isVector2 ? (g.boundary = 8, g.storage = 8) : v.isVector3 || v.isColor ? (g.boundary = 16, g.storage = 12) : v.isVector4 ? (g.boundary = 16, g.storage = 16) : v.isMatrix3 ? (g.boundary = 48, g.storage = 48) : v.isMatrix4 ? (g.boundary = 64, g.storage = 64) : v.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", v), g;
  }
  function A(v) {
    const g = v.target;
    g.removeEventListener("dispose", A);
    const _ = a.indexOf(g.__bindingPointIndex);
    a.splice(_, 1), s.deleteBuffer(n[g.id]), delete n[g.id], delete r[g.id];
  }
  function m() {
    for (const v in n)
      s.deleteBuffer(n[v]);
    a = [], n = {}, r = {};
  }
  return {
    bind: l,
    update: c,
    dispose: m
  };
}
class kp {
  constructor(e = {}) {
    const {
      canvas: t = uC(),
      context: i = null,
      depth: n = !0,
      stencil: r = !0,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: u = !1
    } = e;
    this.isWebGLRenderer = !0;
    let d;
    i !== null ? d = i.getContextAttributes().alpha : d = a;
    const p = new Uint32Array(4), f = new Int32Array(4);
    let y = null, A = null;
    const m = [], v = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = dt, this._useLegacyLights = !1, this.toneMapping = Vr, this.toneMappingExposure = 1, this.userData = {}, this.onContextLost = () => {
    }, this.onContextRestore = () => {
    }, this.onContextCreationError = () => {
    };
    const g = this;
    let _ = !1, w = 0, S = 0, C = null, E = -1, x = null;
    const b = new it(), D = new it();
    let O = null;
    const Y = new se(0);
    let B = 0, Q = t.width, j = t.height, X = 1, Z = null, ee = null;
    const J = new it(0, 0, Q, j), W = new it(0, 0, Q, j);
    let K = !1;
    const ce = new uA();
    let fe = !1, ve = !1, _e = null;
    const ze = new Ue(), Qe = new ie(), ot = new M(), ht = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function Xe() {
      return C === null ? X : 1;
    }
    let G = i;
    function Be(T, L) {
      for (let U = 0; U < T.length; U++) {
        const N = T[U], H = t.getContext(N, L);
        if (H !== null) return H;
      }
      return null;
    }
    try {
      const T = {
        alpha: !0,
        depth: n,
        stencil: r,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: h,
        failIfMajorPerformanceCaveat: u
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${$g}`), t.addEventListener("webglcontextlost", me, !1), t.addEventListener("webglcontextrestored", q, !1), t.addEventListener("webglcontextcreationerror", ke, !1), G === null) {
        const L = ["webgl2", "webgl", "experimental-webgl"];
        if (g.isWebGL1Renderer === !0 && L.shift(), G = Be(L, T), G === null)
          throw Be(L) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" && G instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), G.getShaderPrecisionFormat === void 0 && (G.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (T) {
      throw console.error("THREE.WebGLRenderer: " + T.message), T;
    }
    let oe, Ee, de, Ke, Ne, Ge, nt, wt, di, F, R, te, we, Ae, Ce, We, Me, Le, z, ye, le, at, qe, je;
    function Fe() {
      oe = new wT(G), Ee = new gT(G, oe, e), oe.init(Ee), at = new rD(G, oe, Ee), de = new nD(G, oe, Ee), Ke = new ST(G), Ne = new WI(), Ge = new sD(G, oe, de, Ne, Ee, at, Ke), nt = new yT(g), wt = new xT(g), di = new UC(G, Ee), qe = new fT(G, oe, di, Ee), F = new ET(G, di, Ke, qe), R = new IT(G, F, di, Ke), z = new TT(G, Ee, Ge), We = new AT(Ne), te = new VI(g, nt, wt, oe, Ee, qe, We), we = new cD(g, Ne), Ae = new qI(), Ce = new ZI(oe, Ee), Le = new pT(g, nt, wt, de, R, d, l), Me = new iD(g, R, Ee), je = new hD(G, Ke, Ee, de), ye = new mT(G, oe, Ke, Ee), le = new bT(G, oe, Ke, Ee), Ke.programs = te.programs, g.capabilities = Ee, g.extensions = oe, g.properties = Ne, g.renderLists = Ae, g.shadowMap = Me, g.state = de, g.info = Ke, g.background = Le, g.cubemaps = nt, g.cubeuvmaps = wt, g.materials = we;
    }
    Fe();
    const He = new lD(g, G);
    this.xr = He, this.getContext = function() {
      return G;
    }, this.getContextAttributes = function() {
      return G.getContextAttributes();
    }, this.forceContextLoss = function() {
      const T = oe.get("WEBGL_lose_context");
      T && T.loseContext();
    }, this.forceContextRestore = function() {
      const T = oe.get("WEBGL_lose_context");
      T && T.restoreContext();
    }, this.getPixelRatio = function() {
      return X;
    }, this.setPixelRatio = function(T) {
      T !== void 0 && (X = T, this.setSize(Q, j, !1));
    }, this.getSize = function(T) {
      return T.set(Q, j);
    }, this.setSize = function(T, L, U = !0) {
      if (He.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      Q = T, j = L, t.width = Math.floor(T * X), t.height = Math.floor(L * X), U === !0 && (t.style.width = T + "px", t.style.height = L + "px"), this.setViewport(0, 0, T, L);
    }, this.getDrawingBufferSize = function(T) {
      return T.set(Q * X, j * X).floor();
    }, this.setDrawingBufferSize = function(T, L, U) {
      Q = T, j = L, X = U, t.width = Math.floor(T * U), t.height = Math.floor(L * U), this.setViewport(0, 0, T, L);
    }, this.getCurrentViewport = function(T) {
      return T.copy(b);
    }, this.getViewport = function(T) {
      return T.copy(J);
    }, this.setViewport = function(T, L, U, N) {
      T.isVector4 ? J.set(T.x, T.y, T.z, T.w) : J.set(T, L, U, N), de.viewport(b.copy(J).multiplyScalar(X).floor());
    }, this.getScissor = function(T) {
      return T.copy(W);
    }, this.setScissor = function(T, L, U, N) {
      T.isVector4 ? W.set(T.x, T.y, T.z, T.w) : W.set(T, L, U, N), de.scissor(D.copy(W).multiplyScalar(X).floor());
    }, this.getScissorTest = function() {
      return K;
    }, this.setScissorTest = function(T) {
      de.setScissorTest(K = T);
    }, this.setOpaqueSort = function(T) {
      Z = T;
    }, this.setTransparentSort = function(T) {
      ee = T;
    }, this.getClearColor = function(T) {
      return T.copy(Le.getClearColor());
    }, this.setClearColor = function() {
      Le.setClearColor.apply(Le, arguments);
    }, this.getClearAlpha = function() {
      return Le.getClearAlpha();
    }, this.setClearAlpha = function() {
      Le.setClearAlpha.apply(Le, arguments);
    }, this.clear = function(T = !0, L = !0, U = !0) {
      let N = 0;
      if (T) {
        let H = !1;
        if (C !== null) {
          const $ = C.texture.format;
          H = $ === rw || $ === sw || $ === nw;
        }
        if (H) {
          const $ = C.texture.type, ne = $ === Ft || $ === qs || $ === Lp || $ === wa || $ === iA || $ === nA, re = Le.getClearColor(), he = Le.getClearAlpha(), pe = re.r, be = re.g, Ie = re.b;
          ne ? (p[0] = pe, p[1] = be, p[2] = Ie, p[3] = he, G.clearBufferuiv(G.COLOR, 0, p)) : (f[0] = pe, f[1] = be, f[2] = Ie, f[3] = he, G.clearBufferiv(G.COLOR, 0, f));
        } else
          N |= G.COLOR_BUFFER_BIT;
      }
      L && (N |= G.DEPTH_BUFFER_BIT), U && (N |= G.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), G.clear(N);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", me, !1), t.removeEventListener("webglcontextrestored", q, !1), t.removeEventListener("webglcontextcreationerror", ke, !1), Ae.dispose(), Ce.dispose(), Ne.dispose(), nt.dispose(), wt.dispose(), R.dispose(), qe.dispose(), je.dispose(), te.dispose(), He.dispose(), He.removeEventListener("sessionstart", Fi), He.removeEventListener("sessionend", It), _e && (_e.dispose(), _e = null), pn.stop();
    };
    function me(T) {
      T.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _ = !0, g.onContextLost(T);
    }
    function q() {
      console.log("THREE.WebGLRenderer: Context Restored."), _ = !1;
      const T = g.info ? g.info.autoReset : void 0, L = Me.enabled, U = Me.autoUpdate, N = Me.needsUpdate, H = Me.type;
      Fe(), g.info && T !== void 0 && (g.info.autoReset = T), Me.enabled = L, Me.autoUpdate = U, Me.needsUpdate = N, Me.type = H, g.onContextRestore && g.onContextRestore();
    }
    function ke(T) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", T.statusMessage), g.onContextCreationError(T);
    }
    function xe(T) {
      const L = T.target;
      L.removeEventListener("dispose", xe), ae(L);
    }
    function ae(T) {
      De(T), Ne.remove(T);
    }
    function De(T) {
      const L = Ne.get(T).programs;
      L !== void 0 && (L.forEach(function(U) {
        te.releaseProgram(U);
      }), T.isShaderMaterial && te.releaseShaderCache(T));
    }
    this.renderBufferDirect = function(T, L, U, N, H, $) {
      L === null && (L = ht);
      const ne = H.isMesh && H.matrixWorld.determinant() < 0, re = I(T, L, U, N, H);
      de.setMaterial(N, ne);
      let he = U.index, pe = 1;
      if (N.wireframe === !0) {
        if (he = F.getWireframeAttribute(U), he === void 0) return;
        pe = 2;
      }
      const be = U.drawRange, Ie = U.attributes.position;
      let Pe = be.start * pe, Ve = (be.start + be.count) * pe;
      $ !== null && (Pe = Math.max(Pe, $.start * pe), Ve = Math.min(Ve, ($.start + $.count) * pe)), he !== null ? (Pe = Math.max(Pe, 0), Ve = Math.min(Ve, he.count)) : Ie != null && (Pe = Math.max(Pe, 0), Ve = Math.min(Ve, Ie.count));
      const $e = Ve - Pe;
      if ($e < 0 || $e === 1 / 0) return;
      qe.setup(H, N, re, U, he);
      let qt, gt = ye;
      if (he !== null && (qt = di.get(he), gt = le, gt.setIndex(qt)), H.isMesh)
        N.wireframe === !0 ? (de.setLineWidth(N.wireframeLinewidth * Xe()), gt.setMode(G.LINES)) : gt.setMode(G.TRIANGLES);
      else if (H.isLine) {
        let lt = N.linewidth;
        lt === void 0 && (lt = 1), de.setLineWidth(lt * Xe()), H.isLineSegments ? gt.setMode(G.LINES) : H.isLineLoop ? gt.setMode(G.LINE_LOOP) : gt.setMode(G.LINE_STRIP);
      } else H.isPoints ? gt.setMode(G.POINTS) : H.isSprite && gt.setMode(G.TRIANGLES);
      if (H.isInstancedMesh)
        gt.renderInstances(Pe, $e, H.count);
      else if (U.isInstancedBufferGeometry) {
        const lt = U._maxInstanceCount !== void 0 ? U._maxInstanceCount : 1 / 0, si = Math.min(U.instanceCount, lt);
        gt.renderInstances(Pe, $e, si);
      } else
        gt.render(Pe, $e);
    };
    function st(T, L, U) {
      T.transparent === !0 && T.side === zi && T.forceSinglePass === !1 ? (T.side = vn, T.needsUpdate = !0, xt(T, L, U), T.side = $n, T.needsUpdate = !0, xt(T, L, U), T.side = zi) : xt(T, L, U);
    }
    this.compile = function(T, L, U = null) {
      U === null && (U = T), A = Ce.get(U), A.init(), v.push(A), U.traverseVisible(function(H) {
        H.isLight && H.layers.test(L.layers) && (A.pushLight(H), H.castShadow && A.pushShadow(H));
      }), T !== U && T.traverseVisible(function(H) {
        H.isLight && H.layers.test(L.layers) && (A.pushLight(H), H.castShadow && A.pushShadow(H));
      }), A.setupLights(g._useLegacyLights);
      const N = /* @__PURE__ */ new Set();
      return T.traverse(function(H) {
        const $ = H.material;
        if ($)
          if (Array.isArray($))
            for (let ne = 0; ne < $.length; ne++) {
              const re = $[ne];
              st(re, U, H), N.add(re);
            }
          else
            st($, U, H), N.add($);
      }), v.pop(), A = null, N;
    }, this.compileAsync = function(T, L, U = null) {
      const N = this.compile(T, L, U);
      return new Promise((H) => {
        function $() {
          if (N.forEach(function(ne) {
            Ne.get(ne).currentProgram.isReady() && N.delete(ne);
          }), N.size === 0) {
            H(T);
            return;
          }
          setTimeout($, 10);
        }
        oe.get("KHR_parallel_shader_compile") !== null ? $() : setTimeout($, 10);
      });
    };
    let Et = null;
    function Kt(T) {
      Et && Et(T);
    }
    function Fi() {
      pn.stop();
    }
    function It() {
      pn.start();
    }
    const pn = new yw();
    pn.setAnimationLoop(Kt), typeof self < "u" && pn.setContext(self), this.setAnimationLoop = function(T) {
      Et = T, He.setAnimationLoop(T), T === null ? pn.stop() : pn.start();
    }, He.addEventListener("sessionstart", Fi), He.addEventListener("sessionend", It), this.render = function(T, L) {
      if (L !== void 0 && L.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_ !== !0) {
        if (T.matrixWorldAutoUpdate === !0 && T.updateMatrixWorld(), L.parent === null && L.matrixWorldAutoUpdate === !0 && L.updateMatrixWorld(), He.enabled === !0 && He.isPresenting === !0 && (He.cameraAutoUpdate === !0 && He.updateCamera(L), L = He.getCamera()), T.isScene === !0 && T.onBeforeRender(g, T, L, C), A = Ce.get(T, v.length), A.init(), v.push(A), ze.multiplyMatrices(L.projectionMatrix, L.matrixWorldInverse), ce.setFromProjectionMatrix(ze), ve = this.localClippingEnabled, fe = We.init(this.clippingPlanes, ve), y = Ae.get(T, m.length), y.init(), m.push(y), ys(T, L, 0, g.sortObjects), y.finish(), g.sortObjects === !0 && y.sort(Z, ee), this.info.render.frame++, g.userData.shadowMapRender !== !1) {
          fe === !0 && We.beginShadows();
          const U = A.state.shadowsArray;
          U.length > 0 && Me.render(U, T, L), fe === !0 && We.endShadows();
        }
        if (this.info.autoReset === !0 && this.info.reset(), g.userData.backgroundRender !== !1 && Le.render(y, T), g.userData.sceneRender !== !1)
          if (A.setupLights(g._useLegacyLights), L.isArrayCamera) {
            const U = L.cameras;
            for (let N = 0, H = U.length; N < H; N++) {
              const $ = U[N];
              za(y, T, $, $.viewport);
            }
          } else
            za(y, T, L);
        C !== null && (Ge.updateMultisampleRenderTarget(C), Ge.updateRenderTargetMipmap(C)), T.isScene === !0 && T.onAfterRender(g, T, L), qe.resetDefaultState(), E = -1, x = null, v.pop(), v.length > 0 ? A = v[v.length - 1] : A = null, m.pop(), m.length > 0 ? y = m[m.length - 1] : y = null;
      }
    };
    function ys(T, L, U, N) {
      if (T.visible === !1) return;
      if (T.layers.test(L.layers)) {
        if (T.isGroup)
          U = T.renderOrder;
        else if (T.isLOD)
          T.autoUpdate === !0 && T.update(L);
        else if (T.isLight)
          A.pushLight(T), T.castShadow && A.pushShadow(T);
        else if (T.isSprite) {
          if (!T.frustumCulled || ce.intersectsSprite(T)) {
            N && ot.setFromMatrixPosition(T.matrixWorld).applyMatrix4(ze);
            const ne = R.update(T), re = T.material;
            re.visible && y.push(T, ne, re, U, ot.z, null);
          }
        } else if ((T.isMesh || T.isLine || T.isPoints) && (!T.frustumCulled || ce.intersectsObject(T))) {
          const ne = R.update(T), re = T.material;
          if (N && (T.boundingSphere !== void 0 ? (T.boundingSphere === null && T.computeBoundingSphere(), ot.copy(T.boundingSphere.center)) : (ne.boundingSphere === null && ne.computeBoundingSphere(), ot.copy(ne.boundingSphere.center)), ot.applyMatrix4(T.matrixWorld).applyMatrix4(ze)), Array.isArray(re)) {
            const he = ne.groups;
            for (let pe = 0, be = he.length; pe < be; pe++) {
              const Ie = he[pe], Pe = re[Ie.materialIndex];
              Pe && Pe.visible && y.push(T, ne, Pe, U, ot.z, Ie);
            }
          } else re.visible && y.push(T, ne, re, U, ot.z, null);
        }
      }
      const $ = T.children;
      for (let ne = 0, re = $.length; ne < re; ne++)
        ys($[ne], L, U, N);
    }
    function za(T, L, U, N) {
      const H = T.opaque, $ = T.transmissive, ne = T.transparent;
      if (A.setupLightsView(U), fe === !0 && We.setGlobalState(g.clippingPlanes, U), g.userData.transmissionRender === void 0 && g.userData.renderTransmissionPass !== !1 && $.length > 0 && pf([...H, ...ne], $, L, U), N && de.viewport(b.copy(N)), g.userData.opaqueRender !== !1 && H.length > 0 && ir(H, L, U), g.userData.transparentRender !== !1 && ne.length > 0 && ir(ne, L, U), g.userData.transmissionRender !== !1 && $.length > 0) {
        _e || (_e = new Zn(1, 1));
        const re = (g.userData.transmissionRenderTarget || _e).texture, he = Ee.isWebGL2, pe = re.generateMipmaps, be = re.minFilter;
        he && g.userData.blurTransmissionTarget && g.userData.transmissionRenderTarget && (re.generateMipmaps = !0, re.minFilter = Qn, re.needsUpdate = !0, Ge.updateMultisampleRenderTarget(g.userData.transmissionRenderTarget), Ge.updateRenderTargetMipmap(g.userData.transmissionRenderTarget)), ir($, L, U), he && g.userData.blurTransmissionTarget && g.userData.transmissionRenderTarget && (re.generateMipmaps = pe, re.minFilter = be, re.needsUpdate = !0, Ge.updateMultisampleRenderTarget(g.userData.transmissionRenderTarget), Ge.updateRenderTargetMipmap(g.userData.transmissionRenderTarget));
      }
      de.buffers.depth.setTest(!0), de.buffers.depth.setMask(!0), de.buffers.color.setMask(!0), de.setPolygonOffset(!1);
    }
    function pf(T, L, U, N) {
      if (console.warn("three.js internal render transmission pass should not be called"), (U.isScene === !0 ? U.overrideMaterial : null) !== null)
        return;
      const $ = Ee.isWebGL2;
      _e === null && (_e = new Zn(1, 1, {
        generateMipmaps: !0,
        type: oe.has("EXT_color_buffer_half_float") ? Qt : Ft,
        minFilter: Qn,
        samples: $ ? 4 : 0
      })), g.getDrawingBufferSize(Qe), $ ? _e.setSize(Qe.x, Qe.y) : _e.setSize(sp(Qe.x), sp(Qe.y));
      const ne = g.getRenderTarget();
      g.setRenderTarget(_e), g.getClearColor(Y), B = g.getClearAlpha(), B < 1 && g.setClearColor(16777215, 0.5), g.clear();
      const re = g.toneMapping;
      g.toneMapping = Vr, ir(T, U, N), Ge.updateMultisampleRenderTarget(_e), Ge.updateRenderTargetMipmap(_e);
      let he = !1;
      for (let pe = 0, be = L.length; pe < be; pe++) {
        const Ie = L[pe], Pe = Ie.object, Ve = Ie.geometry, $e = Ie.material, qt = Ie.group;
        if ($e.side === zi && Pe.layers.test(N.layers)) {
          const gt = $e.side;
          $e.side = vn, $e.needsUpdate = !0, na(Pe, U, N, Ve, $e, qt), $e.side = gt, $e.needsUpdate = !0, he = !0;
        }
      }
      he === !0 && (Ge.updateMultisampleRenderTarget(_e), Ge.updateRenderTargetMipmap(_e)), g.setRenderTarget(ne), g.setClearColor(Y, B), g.toneMapping = re;
    }
    function ir(T, L, U) {
      const N = { ...g.userData };
      g.userData.opaqueRender = void 0, g.userData.transparentRender = void 0, g.userData.transmissionRender = void 0, g.userData.backgroundRender = void 0;
      const H = L.isScene === !0 ? L.overrideMaterial : null;
      for (let $ = 0, ne = T.length; $ < ne; $++) {
        const re = T[$], he = re.object, pe = re.geometry, be = H === null ? re.material : H, Ie = re.group;
        he.layers.test(U.layers) && na(he, L, U, pe, be, Ie);
      }
      Object.assign(g.userData, N);
    }
    function na(T, L, U, N, H, $) {
      T.onBeforeRender(g, L, U, N, H, $), T.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse, T.matrixWorld), T.normalMatrix.getNormalMatrix(T.modelViewMatrix), H.onBeforeRender(g, L, U, N, T, $), H.transparent === !0 && H.side === zi && H.forceSinglePass === !1 ? (H.side = vn, H.needsUpdate = !0, g.renderBufferDirect(U, L, N, H, T, $), H.side = $n, H.needsUpdate = !0, g.renderBufferDirect(U, L, N, H, T, $), H.side = zi) : g.renderBufferDirect(U, L, N, H, T, $), T.onAfterRender(g, L, U, N, H, $), H.onAfterRender(g, L, U, N, T, $);
    }
    function xt(T, L, U) {
      L.isScene !== !0 && (L = ht);
      const N = Ne.get(T), H = A.state.lights, $ = A.state.shadowsArray, ne = H.state.version, re = te.getParameters(T, H.state, $, L, U), he = te.getProgramCacheKey(re);
      let pe = N.programs;
      N.environment = T.userData && T.userData.envMapSlotKey && L.textureSlots && L.textureSlots[T.userData.envMapSlotKey] ? L.textureSlots[T.userData.envMapSlotKey] : T.isMeshStandardMaterial ? L.environment : null, N.fog = L.fog, N.envMap = (T.isMeshStandardMaterial ? wt : nt).get(T.envMap || N.environment), pe === void 0 && (T.addEventListener("dispose", xe), pe = /* @__PURE__ */ new Map(), N.programs = pe);
      let be = pe.get(he);
      if (be !== void 0) {
        if (N.currentProgram === be && N.lightsStateVersion === ne)
          return bu(T, re), be;
      } else
        re.uniforms = te.getUniforms(T), T.onBuild(U, re, g), T.onBeforeCompile(re, g), be = te.acquireProgram(re, he), pe.set(he, be), N.uniforms = re.uniforms;
      const Ie = N.uniforms;
      return (!T.isShaderMaterial && !T.isRawShaderMaterial || T.clipping === !0) && (Ie.clippingPlanes = We.uniform), bu(T, re), N.needsLights = k(T), N.lightsStateVersion = ne, N.needsLights && (Ie.ambientLightColor.value = H.state.ambient, Ie.lightProbe.value = H.state.probe, Ie.directionalLights.value = H.state.directional, Ie.directionalLightShadows.value = H.state.directionalShadow, Ie.spotLights.value = H.state.spot, Ie.spotLightShadows.value = H.state.spotShadow, Ie.rectAreaLights.value = H.state.rectArea, Ie.ltc_1.value = H.state.rectAreaLTC1, Ie.ltc_2.value = H.state.rectAreaLTC2, Ie.pointLights.value = H.state.point, Ie.pointLightShadows.value = H.state.pointShadow, Ie.hemisphereLights.value = H.state.hemi, Ie.directionalShadowMap.value = H.state.directionalShadowMap, Ie.directionalShadowMatrix.value = H.state.directionalShadowMatrix, Ie.spotShadowMap.value = H.state.spotShadowMap, Ie.spotLightMatrix.value = H.state.spotLightMatrix, Ie.spotLightMap.value = H.state.spotLightMap, Ie.pointShadowMap.value = H.state.pointShadowMap, Ie.pointShadowMatrix.value = H.state.pointShadowMatrix), N.currentProgram = be, N.uniformsList = null, be;
    }
    function Vc(T) {
      if (T.uniformsList === null) {
        const L = T.currentProgram.getUniforms();
        T.uniformsList = Pd.seqWithValue(L.seq, T.uniforms);
      }
      return T.uniformsList;
    }
    function bu(T, L) {
      const U = Ne.get(T);
      U.outputColorSpace = L.outputColorSpace, U.instancing = L.instancing, U.instancingColor = L.instancingColor, U.skinning = L.skinning, U.morphTargets = L.morphTargets, U.morphNormals = L.morphNormals, U.morphColors = L.morphColors, U.morphTargetsCount = L.morphTargetsCount, U.numClippingPlanes = L.numClippingPlanes, U.numIntersection = L.numClipIntersection, U.vertexAlphas = L.vertexAlphas, U.vertexTangents = L.vertexTangents, U.toneMapping = L.toneMapping;
    }
    function I(T, L, U, N, H) {
      L.isScene !== !0 && (L = ht), Ge.resetTextureUnits();
      const $ = L.fog, ne = N.userData && N.userData.envMapSlotKey && L.textureSlots && L.textureSlots[N.userData.envMapSlotKey] ? L.textureSlots[N.userData.envMapSlotKey] : N.isMeshStandardMaterial ? L.environment : null, re = C === null ? g.outputColorSpace : C.isXRRenderTarget === !0 || C.texture.colorSpace && C.texture.colorSpace !== dt ? C.texture.colorSpace : Mt, he = (N.isMeshStandardMaterial ? wt : nt).get(N.envMap || ne), pe = N.vertexColors === !0 && !!U.attributes.color && U.attributes.color.itemSize === 4, be = !!U.attributes.tangent && (!!N.normalMap || N.anisotropy > 0 || U.userData.__forceUseTangent), Ie = !!U.morphAttributes.position, Pe = !!U.morphAttributes.normal, Ve = !!U.morphAttributes.color;
      let $e = Vr;
      N.toneMapped && (C === null || C.isXRRenderTarget === !0) && ($e = g.toneMapping);
      const qt = U.morphAttributes.position || U.morphAttributes.normal || U.morphAttributes.color, gt = qt !== void 0 ? qt.length : 0, lt = Ne.get(N), si = A.state.lights;
      if (fe === !0 && (ve === !0 || T !== x)) {
        const ji = T === x && N.id === E;
        We.setState(N, T, ji);
      }
      let et = !1;
      N.version === lt.__version ? (lt.needsLights && lt.lightsStateVersion !== si.state.version || lt.outputColorSpace !== re || H.isInstancedMesh && lt.instancing === !1 || !H.isInstancedMesh && lt.instancing === !0 || H.isSkinnedMesh && lt.skinning === !1 || !H.isSkinnedMesh && lt.skinning === !0 || H.isInstancedMesh && lt.instancingColor === !0 && H.instanceColor === null || H.isInstancedMesh && lt.instancingColor === !1 && H.instanceColor !== null || lt.envMap !== he || N.fog === !0 && lt.fog !== $ || lt.numClippingPlanes !== void 0 && (lt.numClippingPlanes !== We.numPlanes || lt.numIntersection !== We.numIntersection) || lt.vertexAlphas !== pe || lt.vertexTangents !== be || lt.morphTargets !== Ie || lt.morphNormals !== Pe || lt.morphColors !== Ve || lt.toneMapping !== $e || Ee.isWebGL2 === !0 && lt.morphTargetsCount !== gt) && (et = !0) : (et = !0, lt.__version = N.version);
      let ci = lt.currentProgram;
      et === !0 && (ci = xt(N, L, H));
      let Rn = !1, vi = !1, Vt = !1;
      const At = ci.getUniforms(), fn = lt.uniforms;
      if (de.useProgram(ci.program) && (Rn = !0, vi = !0, Vt = !0), N.id !== E && (E = N.id, vi = !0), Rn || x !== T) {
        At.setValue(G, "projectionMatrix", T.projectionMatrix), At.setValue(G, "viewMatrix", T.matrixWorldInverse);
        const ji = At.map.cameraPosition;
        ji !== void 0 && ji.setValue(G, ot.setFromMatrixPosition(T.matrixWorld)), Ee.logarithmicDepthBuffer && At.setValue(
          G,
          "logDepthBufFC",
          2 / (Math.log(T.far + 1) / Math.LN2)
        ), (N.isMeshPhongMaterial || N.isMeshToonMaterial || N.isMeshLambertMaterial || N.isMeshBasicMaterial || N.isMeshStandardMaterial || N.isShaderMaterial) && At.setValue(G, "isOrthographic", T.isOrthographicCamera === !0), x !== T && (x = T, vi = !0, Vt = !0);
      }
      if (H.isSkinnedMesh) {
        At.setOptional(G, H, "bindMatrix"), At.setOptional(G, H, "bindMatrixInverse");
        const ji = H.skeleton;
        ji && (Ee.floatVertexTextures ? (ji.boneTexture === null && ji.computeBoneTexture(), At.setValue(G, "boneTexture", ji.boneTexture, Ge), At.setValue(G, "boneTextureSize", ji.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      const Sr = U.morphAttributes;
      (Sr.position !== void 0 || Sr.normal !== void 0 || Sr.color !== void 0 && Ee.isWebGL2 === !0) && z.update(H, U, ci), (vi || lt.receiveShadow !== H.receiveShadow) && (lt.receiveShadow = H.receiveShadow, At.setValue(G, "receiveShadow", H.receiveShadow)), N.isMeshGouraudMaterial && N.envMap !== null && (fn.envMap.value = he, fn.flipEnvMap.value = he.isCubeTexture && he.isRenderTargetTexture === !1 ? -1 : 1), vi && (At.setValue(G, "toneMappingExposure", g.toneMappingExposure), lt.needsLights && P(fn, Vt), $ && N.fog === !0 && we.refreshFogUniforms(fn, $), we.refreshMaterialUniforms(fn, N, X, j, g.userData.transmissionRenderTarget || _e), Pd.upload(G, Vc(lt), fn, Ge)), N.isShaderMaterial && N.uniformsNeedUpdate === !0 && (Pd.upload(G, Vc(lt), fn, Ge), N.uniformsNeedUpdate = !1), N.isSpriteMaterial && At.setValue(G, "center", H.center), At.setValue(G, "modelViewMatrix", H.modelViewMatrix), At.setValue(G, "normalMatrix", H.normalMatrix), At.setValue(G, "modelMatrix", H.matrixWorld);
      const rs = N.extraUniformsToUpload;
      if (rs && Object.entries(rs).forEach(([ji, Wc]) => At.setValue(G, ji, Wc.value, Ge)), N.isShaderMaterial || N.isRawShaderMaterial) {
        const ji = N.uniformsGroups;
        for (let Wc = 0, IS = ji.length; Wc < IS; Wc++)
          if (Ee.isWebGL2) {
            const Xy = ji[Wc];
            je.update(Xy, ci), je.bind(Xy, ci);
          } else
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return ci;
    }
    function P(T, L) {
      T.ambientLightColor.needsUpdate = L, T.lightProbe.needsUpdate = L, T.directionalLights.needsUpdate = L, T.directionalLightShadows.needsUpdate = L, T.pointLights.needsUpdate = L, T.pointLightShadows.needsUpdate = L, T.spotLights.needsUpdate = L, T.spotLightShadows.needsUpdate = L, T.rectAreaLights.needsUpdate = L, T.hemisphereLights.needsUpdate = L;
    }
    function k(T) {
      return T.isMeshLambertMaterial || T.isMeshToonMaterial || T.isMeshPhongMaterial || T.isMeshStandardMaterial || T.isShadowMaterial || T.isShaderMaterial && T.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return w;
    }, this.getActiveMipmapLevel = function() {
      return S;
    }, this.getRenderTarget = function() {
      return C;
    }, this.setRenderTargetTextures = function(T, L, U) {
      Ne.get(T.texture).__webglTexture = L, Ne.get(T.depthTexture).__webglTexture = U;
      const N = Ne.get(T);
      N.__hasExternalTextures = !0, N.__hasExternalTextures && (N.__autoAllocateDepthBuffer = U === void 0, N.__autoAllocateDepthBuffer || oe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), N.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function(T, L) {
      const U = Ne.get(T);
      U.__webglFramebuffer = L, U.__useDefaultFramebuffer = L === void 0;
    }, this.setRenderTarget = function(T, L = 0, U = 0) {
      C = T, w = L, S = U;
      let N = !0, H = null, $ = !1, ne = !1;
      if (T) {
        const he = Ne.get(T);
        he.__useDefaultFramebuffer !== void 0 ? (de.bindFramebuffer(G.FRAMEBUFFER, null), N = !1) : he.__webglFramebuffer === void 0 ? Ge.setupRenderTarget(T) : he.__hasExternalTextures && Ge.rebindTextures(T, Ne.get(T.texture).__webglTexture, Ne.get(T.depthTexture).__webglTexture);
        const pe = T.texture;
        (pe.isData3DTexture || pe.isDataArrayTexture || pe.isCompressedArrayTexture) && (ne = !0);
        const be = Ne.get(T).__webglFramebuffer;
        T.isWebGLCubeRenderTarget ? (Array.isArray(be[L]) ? H = be[L][U] : H = be[L], $ = !0) : Ee.isWebGL2 && T.samples > 0 && Ge.useMultisampledRTT(T) === !1 ? H = Ne.get(T).__webglMultisampledFramebuffer : Array.isArray(be) ? H = be[U] : H = be, b.copy(T.viewport), D.copy(T.scissor), O = T.scissorTest;
      } else
        b.copy(J).multiplyScalar(X).floor(), D.copy(W).multiplyScalar(X).floor(), O = K;
      if (de.bindFramebuffer(G.FRAMEBUFFER, H) && Ee.drawBuffers && N && de.drawBuffers(T, H), de.viewport(b), de.scissor(D), de.setScissorTest(O), $) {
        const he = Ne.get(T.texture);
        G.framebufferTexture2D(G.FRAMEBUFFER, G.COLOR_ATTACHMENT0, G.TEXTURE_CUBE_MAP_POSITIVE_X + L, he.__webglTexture, U);
      } else if (ne) {
        const he = Ne.get(T.texture), pe = L || 0;
        G.framebufferTextureLayer(G.FRAMEBUFFER, G.COLOR_ATTACHMENT0, he.__webglTexture, U || 0, pe);
      }
      E = -1;
    }, this.readRenderTargetPixels = function(T, L, U, N, H, $, ne, re) {
      if (!(T && T.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let he = Ne.get(T).__webglFramebuffer;
      if (T.isWebGLCubeRenderTarget && ne !== void 0 && (he = he[ne]), he) {
        de.bindFramebuffer(G.FRAMEBUFFER, he);
        try {
          const pe = Array.isArray(T.texture) ? T.texture[re || 0] : T.texture, be = pe.format, Ie = pe.type;
          if (be !== ei && at.convert(be) !== G.getParameter(G.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const Pe = Ie === Qt && (oe.has("EXT_color_buffer_half_float") || Ee.isWebGL2 && oe.has("EXT_color_buffer_float"));
          if (Ie !== Ft && at.convert(Ie) !== G.getParameter(G.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(Ie === Xt && (Ee.isWebGL2 || oe.has("OES_texture_float") || oe.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !Pe) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          L >= 0 && L <= T.width - N && U >= 0 && U <= T.height - H && (T.isWebGLMultipleRenderTargets && G.readBuffer(G.COLOR_ATTACHMENT0 + (re || 0)), G.readPixels(L, U, N, H, at.convert(be), at.convert(Ie), $));
        } finally {
          const pe = C ? Ne.get(C).__webglFramebuffer : null;
          de.bindFramebuffer(G.FRAMEBUFFER, pe);
        }
      }
    }, this.copyFramebufferToTexture = function(T, L, U = 0) {
      const N = Math.pow(2, -U), H = Math.floor(L.image.width * N), $ = Math.floor(L.image.height * N);
      Ge.setTexture2D(L, 0), G.copyTexSubImage2D(G.TEXTURE_2D, U, 0, 0, T.x, T.y, H, $), de.unbindTexture();
    }, this.copyTextureToTexture = function(T, L, U, N = 0) {
      const H = L.image.width, $ = L.image.height, ne = at.convert(U.format), re = at.convert(U.type);
      Ge.setTexture2D(U, 0), G.pixelStorei(G.UNPACK_FLIP_Y_WEBGL, U.flipY), G.pixelStorei(G.UNPACK_PREMULTIPLY_ALPHA_WEBGL, U.premultiplyAlpha), G.pixelStorei(G.UNPACK_ALIGNMENT, U.unpackAlignment), L.isDataTexture ? G.texSubImage2D(G.TEXTURE_2D, N, T.x, T.y, H, $, ne, re, L.image.data) : L.isCompressedTexture ? G.compressedTexSubImage2D(G.TEXTURE_2D, N, T.x, T.y, L.mipmaps[0].width, L.mipmaps[0].height, ne, L.mipmaps[0].data) : G.texSubImage2D(G.TEXTURE_2D, N, T.x, T.y, ne, re, L.image), N === 0 && U.generateMipmaps && G.generateMipmap(G.TEXTURE_2D), de.unbindTexture();
    }, this.copyTextureToTexture3D = function(T, L, U, N, H = 0) {
      if (g.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const $ = T.max.x - T.min.x + 1, ne = T.max.y - T.min.y + 1, re = T.max.z - T.min.z + 1, he = at.convert(N.format), pe = at.convert(N.type);
      let be;
      if (N.isData3DTexture)
        Ge.setTexture3D(N, 0), be = G.TEXTURE_3D;
      else if (N.isDataArrayTexture)
        Ge.setTexture2DArray(N, 0), be = G.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      G.pixelStorei(G.UNPACK_FLIP_Y_WEBGL, N.flipY), G.pixelStorei(G.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha), G.pixelStorei(G.UNPACK_ALIGNMENT, N.unpackAlignment);
      const Ie = G.getParameter(G.UNPACK_ROW_LENGTH), Pe = G.getParameter(G.UNPACK_IMAGE_HEIGHT), Ve = G.getParameter(G.UNPACK_SKIP_PIXELS), $e = G.getParameter(G.UNPACK_SKIP_ROWS), qt = G.getParameter(G.UNPACK_SKIP_IMAGES), gt = U.isCompressedTexture ? U.mipmaps[0] : U.image;
      G.pixelStorei(G.UNPACK_ROW_LENGTH, gt.width), G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, gt.height), G.pixelStorei(G.UNPACK_SKIP_PIXELS, T.min.x), G.pixelStorei(G.UNPACK_SKIP_ROWS, T.min.y), G.pixelStorei(G.UNPACK_SKIP_IMAGES, T.min.z), U.isDataTexture || U.isData3DTexture ? G.texSubImage3D(be, H, L.x, L.y, L.z, $, ne, re, he, pe, gt.data) : U.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), G.compressedTexSubImage3D(be, H, L.x, L.y, L.z, $, ne, re, he, gt.data)) : G.texSubImage3D(be, H, L.x, L.y, L.z, $, ne, re, he, pe, gt), G.pixelStorei(G.UNPACK_ROW_LENGTH, Ie), G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, Pe), G.pixelStorei(G.UNPACK_SKIP_PIXELS, Ve), G.pixelStorei(G.UNPACK_SKIP_ROWS, $e), G.pixelStorei(G.UNPACK_SKIP_IMAGES, qt), H === 0 && N.generateMipmaps && G.generateMipmap(be), de.unbindTexture();
    }, this.initTexture = function(T) {
      T.isCubeTexture ? Ge.setTextureCube(T, 0) : T.isData3DTexture ? Ge.setTexture3D(T, 0) : T.isDataArrayTexture || T.isCompressedArrayTexture ? Ge.setTexture2DArray(T, 0) : Ge.setTexture2D(T, 0), de.unbindTexture();
    }, this.resetState = function() {
      w = 0, S = 0, C = null, de.reset(), qe.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return zr;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === su ? "display-p3" : "srgb", t.unpackColorSpace = Rt.workingColorSpace === ru ? "display-p3" : "srgb";
  }
  get physicallyCorrectLights() {
    return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights;
  }
  set physicallyCorrectLights(e) {
    console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e;
  }
  get outputEncoding() {
    return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === dt ? ga : Ym;
  }
  set outputEncoding(e) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === ga ? dt : Mt;
  }
  get useLegacyLights() {
    return this._useLegacyLights;
  }
  set useLegacyLights(e) {
    this._useLegacyLights = e;
  }
}
class uD extends kp {
}
uD.prototype.isWebGL1Renderer = !0;
class pA {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new se(e), this.density = t;
  }
  clone() {
    return new pA(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class fA {
  constructor(e, t = 1, i = 1e3) {
    this.isFog = !0, this.name = "", this.color = new se(e), this.near = t, this.far = i;
  }
  clone() {
    return new fA(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class tc extends ut {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t;
  }
}
class au {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = ip, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = ps();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, i) {
    e *= this.stride, i *= t.stride;
    for (let n = 0, r = this.stride; n < r; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ps()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ps()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Bn = /* @__PURE__ */ new M();
class Cn {
  constructor(e, t, i, n = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = n;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      Bn.fromBufferAttribute(this, t), Bn.applyMatrix4(e), this.setXYZ(t, Bn.x, Bn.y, Bn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Bn.fromBufferAttribute(this, t), Bn.applyNormalMatrix(e), this.setXYZ(t, Bn.x, Bn.y, Bn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Bn.fromBufferAttribute(this, t), Bn.transformDirection(e), this.setXYZ(t, Bn.x, Bn.y, Bn.z);
    return this;
  }
  setX(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Yn(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Yn(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Yn(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Yn(t, this.array)), t;
  }
  setXY(e, t, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = vt(t, this.array), i = vt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = vt(t, this.array), i = vt(i, this.array), n = vt(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this;
  }
  setXYZW(e, t, i, n, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = vt(t, this.array), i = vt(i, this.array), n = vt(n, this.array), r = vt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const n = i * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[n + r]);
      }
      return new Je(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Cn(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const n = i * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[n + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class Gp extends Yi {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new se(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let ul;
const Kc = /* @__PURE__ */ new M(), dl = /* @__PURE__ */ new M(), pl = /* @__PURE__ */ new M(), fl = /* @__PURE__ */ new ie(), Jc = /* @__PURE__ */ new ie(), Sw = /* @__PURE__ */ new Ue(), qu = /* @__PURE__ */ new M(), $c = /* @__PURE__ */ new M(), Xu = /* @__PURE__ */ new M(), iv = /* @__PURE__ */ new ie(), Gf = /* @__PURE__ */ new ie(), nv = /* @__PURE__ */ new ie();
class mA extends ut {
  constructor(e = new Gp()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", ul === void 0) {
      ul = new Ze();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), i = new au(t, 5);
      ul.setIndex([0, 1, 2, 0, 2, 3]), ul.setAttribute("position", new Cn(i, 3, 0, !1)), ul.setAttribute("uv", new Cn(i, 2, 3, !1));
    }
    this.geometry = ul, this.material = e, this.center = new ie(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), dl.setFromMatrixScale(this.matrixWorld), Sw.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), pl.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && dl.multiplyScalar(-pl.z);
    const i = this.material.rotation;
    let n, r;
    i !== 0 && (r = Math.cos(i), n = Math.sin(i));
    const a = this.center;
    Yu(qu.set(-0.5, -0.5, 0), pl, a, dl, n, r), Yu($c.set(0.5, -0.5, 0), pl, a, dl, n, r), Yu(Xu.set(0.5, 0.5, 0), pl, a, dl, n, r), iv.set(0, 0), Gf.set(1, 0), nv.set(1, 1);
    let o = e.ray.intersectTriangle(qu, $c, Xu, !1, Kc);
    if (o === null && (Yu($c.set(-0.5, 0.5, 0), pl, a, dl, n, r), Gf.set(0, 1), o = e.ray.intersectTriangle(qu, Xu, $c, !1, Kc), o === null))
      return;
    const l = e.ray.origin.distanceTo(Kc);
    l < e.near || l > e.far || t.push({
      distance: l,
      point: Kc.clone(),
      uv: hs.getInterpolation(Kc, qu, $c, Xu, iv, Gf, nv, new ie()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Yu(s, e, t, i, n, r) {
  fl.subVectors(s, t).addScalar(0.5).multiply(i), n !== void 0 ? (Jc.x = r * fl.x - n * fl.y, Jc.y = n * fl.x + r * fl.y) : Jc.copy(fl), s.copy(e), s.x += Jc.x, s.y += Jc.y, s.applyMatrix4(Sw);
}
const Ku = /* @__PURE__ */ new M(), sv = /* @__PURE__ */ new M();
class dD extends ut {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      this.addLevel(r.object.clone(), r.distance, r.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const n = this.levels;
    let r;
    for (r = 0; r < n.length && !(t < n[r].distance); r++)
      ;
    return n.splice(r, 0, { distance: t, hysteresis: i, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, n;
      for (i = 1, n = t.length; i < n; i++) {
        let r = t[i].distance;
        if (t[i].object.visible && (r -= r * t[i].hysteresis), e < r)
          break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Ku.setFromMatrixPosition(this.matrixWorld);
      const n = e.ray.origin.distanceTo(Ku);
      this.getObjectForDistance(n).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Ku.setFromMatrixPosition(e.matrixWorld), sv.setFromMatrixPosition(this.matrixWorld);
      const i = Ku.distanceTo(sv) / e.zoom;
      t[0].object.visible = !0;
      let n, r;
      for (n = 1, r = t.length; n < r; n++) {
        let a = t[n].distance;
        if (t[n].object.visible && (a -= a * t[n].hysteresis), i >= a)
          t[n - 1].object.visible = !1, t[n].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = n - 1; n < r; n++)
        t[n].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const i = this.levels;
    for (let n = 0, r = i.length; n < r; n++) {
      const a = i[n];
      t.object.levels.push({
        object: a.object.uuid,
        distance: a.distance,
        hysteresis: a.hysteresis
      });
    }
    return t;
  }
}
const rv = /* @__PURE__ */ new M(), av = /* @__PURE__ */ new it(), ov = /* @__PURE__ */ new it(), pD = /* @__PURE__ */ new M(), lv = /* @__PURE__ */ new Ue(), Ju = /* @__PURE__ */ new M(), zf = /* @__PURE__ */ new ns(), cv = /* @__PURE__ */ new Ue(), Qf = /* @__PURE__ */ new wc();
class gA extends Se {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = Ky, this.bindMatrix = new Ue(), this.bindMatrixInverse = new Ue(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new is()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, Ju), this.boundingBox.expandByPoint(Ju);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new ns()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, Ju), this.boundingSphere.expandByPoint(Ju);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const i = this.material, n = this.matrixWorld;
    i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), zf.copy(this.boundingSphere), zf.applyMatrix4(n), e.ray.intersectsSphere(zf) !== !1 && (cv.copy(n).invert(), Qf.copy(e.ray).applyMatrix4(cv), !(this.boundingBox !== null && Qf.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Qf)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new it(), t = this.geometry.attributes.skinWeight;
    for (let i = 0, n = t.count; i < n; i++) {
      e.fromBufferAttribute(t, i);
      const r = 1 / e.manhattanLength();
      r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === Ky ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === US ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton, n = this.geometry;
    av.fromBufferAttribute(n.attributes.skinIndex, e), ov.fromBufferAttribute(n.attributes.skinWeight, e), rv.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const a = ov.getComponent(r);
      if (a !== 0) {
        const o = av.getComponent(r);
        lv.multiplyMatrices(i.bones[o].matrixWorld, i.boneInverses[o]), t.addScaledVector(pD.copy(rv).applyMatrix4(lv), a);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t);
  }
}
class Uh extends ut {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class Wr extends Nt {
  constructor(e = null, t = 1, i = 1, n, r, a, o, l, c = pi, h = pi, u, d) {
    super(null, a, o, l, c, h, n, r, u, d), this.isDataTexture = !0, this.image = { data: e, width: t, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const hv = /* @__PURE__ */ new Ue(), fD = /* @__PURE__ */ new Ue();
class ou {
  constructor(e = [], t = []) {
    this.uuid = ps(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let i = 0, n = this.bones.length; i < n; i++)
        this.boneInverses.push(new Ue());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new Ue();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, i = this.boneMatrices, n = this.boneTexture;
    for (let r = 0, a = e.length; r < a; r++) {
      const o = e[r] ? e[r].matrixWorld : fD;
      hv.multiplyMatrices(o, t[r]), hv.toArray(i, r * 16);
    }
    n !== null && (n.needsUpdate = !0);
  }
  clone() {
    return new ou(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = uw(e), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Wr(t, e, e, ei, Xt);
    return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this.boneTextureSize = e, this;
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const n = this.bones[t];
      if (n.name === e)
        return n;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, n = e.bones.length; i < n; i++) {
      const r = e.bones[i];
      let a = t[r];
      a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), a = new Uh()), this.bones.push(a), this.boneInverses.push(new Ue().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, i = this.boneInverses;
    for (let n = 0, r = t.length; n < r; n++) {
      const a = t[n];
      e.bones.push(a.uuid);
      const o = i[n];
      e.boneInverses.push(o.toArray());
    }
    return e;
  }
}
class Da extends Je {
  constructor(e, t, i, n = 1) {
    super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const ml = /* @__PURE__ */ new Ue(), uv = /* @__PURE__ */ new Ue(), $u = [], dv = /* @__PURE__ */ new is(), mD = /* @__PURE__ */ new Ue(), Zc = /* @__PURE__ */ new Se(), eh = /* @__PURE__ */ new ns();
class zp extends Se {
  constructor(e, t, i) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Da(new Float32Array(i * 16), 16), this.instanceColor = null, this.sourceTrs = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
    for (let n = 0; n < i; n++)
      this.setMatrixAt(n, mD);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new is()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, ml), dv.copy(e.boundingBox).applyMatrix4(ml), this.boundingBox.union(dv);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new ns()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, ml), eh.copy(e.boundingSphere).applyMatrix4(ml), this.boundingSphere.union(eh);
  }
  copy(e, t) {
    return super.copy(e, t), e.isInstancedMesh ? (this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this) : this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld, n = this.count;
    if (Zc.geometry = this.geometry, Zc.material = this.material, Zc.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), eh.copy(this.boundingSphere), eh.applyMatrix4(i), e.ray.intersectsSphere(eh) !== !1))
      for (let r = 0; r < n; r++) {
        this.getMatrixAt(r, ml), uv.multiplyMatrices(i, ml), Zc.matrixWorld = uv, Zc.raycast(e, $u);
        for (let a = 0, o = $u.length; a < o; a++) {
          const l = $u[a];
          l.instanceId = r, l.object = this, t.push(l);
        }
        $u.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new Da(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Ri extends Yi {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new se(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const pv = /* @__PURE__ */ new M(), fv = /* @__PURE__ */ new M(), mv = /* @__PURE__ */ new Ue(), Hf = /* @__PURE__ */ new wc(), Zu = /* @__PURE__ */ new ns();
class an extends ut {
  constructor(e = new Ze(), t = new Ri()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [0];
      for (let n = 1, r = t.count; n < r; n++)
        pv.fromBufferAttribute(t, n - 1), fv.fromBufferAttribute(t, n), i[n] = i[n - 1], i[n] += pv.distanceTo(fv);
      e.setAttribute("lineDistance", new Te(i, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const i = this.geometry, n = this.matrixWorld, r = e.params.Line.threshold, a = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), Zu.copy(i.boundingSphere), Zu.applyMatrix4(n), Zu.radius += r, e.ray.intersectsSphere(Zu) === !1) return;
    mv.copy(n).invert(), Hf.copy(e.ray).applyMatrix4(mv);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = new M(), h = new M(), u = new M(), d = new M(), p = this.isLineSegments ? 2 : 1, f = i.index, A = i.attributes.position;
    if (f !== null) {
      const m = Math.max(0, a.start), v = Math.min(f.count, a.start + a.count);
      for (let g = m, _ = v - 1; g < _; g += p) {
        const w = f.getX(g), S = f.getX(g + 1);
        if (c.fromBufferAttribute(A, w), h.fromBufferAttribute(A, S), Hf.distanceSqToSegment(c, h, d, u) > l) continue;
        d.applyMatrix4(this.matrixWorld);
        const E = e.ray.origin.distanceTo(d);
        E < e.near || E > e.far || t.push({
          distance: E,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: u.clone().applyMatrix4(this.matrixWorld),
          index: g,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const m = Math.max(0, a.start), v = Math.min(A.count, a.start + a.count);
      for (let g = m, _ = v - 1; g < _; g += p) {
        if (c.fromBufferAttribute(A, g), h.fromBufferAttribute(A, g + 1), Hf.distanceSqToSegment(c, h, d, u) > l) continue;
        d.applyMatrix4(this.matrixWorld);
        const S = e.ray.origin.distanceTo(d);
        S < e.near || S > e.far || t.push({
          distance: S,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: u.clone().applyMatrix4(this.matrixWorld),
          index: g,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = n.length; r < a; r++) {
          const o = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
}
const gv = /* @__PURE__ */ new M(), Av = /* @__PURE__ */ new M();
class Is extends an {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [];
      for (let n = 0, r = t.count; n < r; n += 2)
        gv.fromBufferAttribute(t, n), Av.fromBufferAttribute(t, n + 1), i[n] = n === 0 ? 0 : i[n - 1], i[n + 1] = i[n] + gv.distanceTo(Av);
      e.setAttribute("lineDistance", new Te(i, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class Cw extends an {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class Qr extends Yi {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new se(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const yv = /* @__PURE__ */ new Ue(), tg = /* @__PURE__ */ new wc(), ed = /* @__PURE__ */ new ns(), td = /* @__PURE__ */ new M();
class zl extends ut {
  constructor(e = new Ze(), t = new Qr()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const i = this.geometry, n = this.matrixWorld, r = e.params.Points.threshold, a = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), ed.copy(i.boundingSphere), ed.applyMatrix4(n), ed.radius += r, e.ray.intersectsSphere(ed) === !1) return;
    yv.copy(n).invert(), tg.copy(e.ray).applyMatrix4(yv);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = i.index, u = i.attributes.position;
    if (c !== null) {
      const d = Math.max(0, a.start), p = Math.min(c.count, a.start + a.count);
      for (let f = d, y = p; f < y; f++) {
        const A = c.getX(f);
        td.fromBufferAttribute(u, A), vv(td, A, l, n, e, t, this);
      }
    } else {
      const d = Math.max(0, a.start), p = Math.min(u.count, a.start + a.count);
      for (let f = d, y = p; f < y; f++)
        td.fromBufferAttribute(u, f), vv(td, f, l, n, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = n.length; r < a; r++) {
          const o = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
}
function vv(s, e, t, i, n, r, a) {
  const o = tg.distanceSqToPoint(s);
  if (o < t) {
    const l = new M();
    tg.closestPointToPoint(s, l), l.applyMatrix4(i);
    const c = n.ray.origin.distanceTo(l);
    if (c < n.near || c > n.far) return;
    r.push({
      distance: c,
      distanceToRay: Math.sqrt(o),
      point: l,
      index: e,
      face: null,
      object: a
    });
  }
}
class iG extends Nt {
  constructor(e, t, i, n, r, a, o, l, c) {
    super(e, t, i, n, r, a, o, l, c), this.isVideoTexture = !0, this.minFilter = a !== void 0 ? a : tt, this.magFilter = r !== void 0 ? r : tt, this.generateMipmaps = !1;
    const h = this;
    function u() {
      h.needsUpdate = !0, e.requestVideoFrameCallback(u);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(u);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class nG extends Nt {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = pi, this.minFilter = pi, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class ba extends Nt {
  constructor(e, t, i, n, r, a, o, l, c, h, u, d) {
    super(null, a, o, l, c, h, n, r, u, d), this.isCompressedTexture = !0, this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class gD extends ba {
  constructor(e, t, i, n, r, a) {
    super(e, t, i, r, a), this.isCompressedArrayTexture = !0, this.image.depth = n, this.wrapR = Zt;
  }
}
class AD extends ba {
  constructor(e, t, i) {
    super(void 0, e[0].width, e[0].height, t, i, qr), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class Qp extends Nt {
  constructor(e, t, i, n, r, a, o, l, c) {
    super(e, t, i, n, r, a, o, l, c), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class Zs {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPointAt(i / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i, n = this.getPoint(0), r = 0;
    t.push(0);
    for (let a = 1; a <= e; a++)
      i = this.getPoint(a / e), r += i.distanceTo(n), t.push(r), n = i;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let n = 0;
    const r = i.length;
    let a;
    t ? a = t : a = e * i[r - 1];
    let o = 0, l = r - 1, c;
    for (; o <= l; )
      if (n = Math.floor(o + (l - o) / 2), c = i[n] - a, c < 0)
        o = n + 1;
      else if (c > 0)
        l = n - 1;
      else {
        l = n;
        break;
      }
    if (n = l, i[n] === a)
      return n / (r - 1);
    const h = i[n], d = i[n + 1] - h, p = (a - h) / d;
    return (n + p) / (r - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let n = e - 1e-4, r = e + 1e-4;
    n < 0 && (n = 0), r > 1 && (r = 1);
    const a = this.getPoint(n), o = this.getPoint(r), l = t || (a.isVector2 ? new ie() : new M());
    return l.copy(o).sub(a).normalize(), l;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new M(), n = [], r = [], a = [], o = new M(), l = new Ue();
    for (let p = 0; p <= e; p++) {
      const f = p / e;
      n[p] = this.getTangentAt(f, new M());
    }
    r[0] = new M(), a[0] = new M();
    let c = Number.MAX_VALUE;
    const h = Math.abs(n[0].x), u = Math.abs(n[0].y), d = Math.abs(n[0].z);
    h <= c && (c = h, i.set(1, 0, 0)), u <= c && (c = u, i.set(0, 1, 0)), d <= c && i.set(0, 0, 1), o.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], o), a[0].crossVectors(n[0], r[0]);
    for (let p = 1; p <= e; p++) {
      if (r[p] = r[p - 1].clone(), a[p] = a[p - 1].clone(), o.crossVectors(n[p - 1], n[p]), o.length() > Number.EPSILON) {
        o.normalize();
        const f = Math.acos(Di(n[p - 1].dot(n[p]), -1, 1));
        r[p].applyMatrix4(l.makeRotationAxis(o, f));
      }
      a[p].crossVectors(n[p], r[p]);
    }
    if (t === !0) {
      let p = Math.acos(Di(r[0].dot(r[e]), -1, 1));
      p /= e, n[0].dot(o.crossVectors(r[0], r[e])) > 0 && (p = -p);
      for (let f = 1; f <= e; f++)
        r[f].applyMatrix4(l.makeRotationAxis(n[f], p * f)), a[f].crossVectors(n[f], r[f]);
    }
    return {
      tangents: n,
      normals: r,
      binormals: a
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class AA extends Zs {
  constructor(e = 0, t = 0, i = 1, n = 1, r = 0, a = Math.PI * 2, o = !1, l = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = a, this.aClockwise = o, this.aRotation = l;
  }
  getPoint(e, t) {
    const i = t || new ie(), n = Math.PI * 2;
    let r = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += n;
    for (; r > n; ) r -= n;
    r < Number.EPSILON && (a ? r = 0 : r = n), this.aClockwise === !0 && !a && (r === n ? r = -n : r = r - n);
    const o = this.aStartAngle + e * r;
    let l = this.aX + this.xRadius * Math.cos(o), c = this.aY + this.yRadius * Math.sin(o);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), u = Math.sin(this.aRotation), d = l - this.aX, p = c - this.aY;
      l = d * h - p * u + this.aX, c = d * u + p * h + this.aY;
    }
    return i.set(l, c);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class yD extends AA {
  constructor(e, t, i, n, r, a) {
    super(e, t, i, i, n, r, a), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function yA() {
  let s = 0, e = 0, t = 0, i = 0;
  function n(r, a, o, l) {
    s = r, e = o, t = -3 * r + 3 * a - 2 * o - l, i = 2 * r - 2 * a + o + l;
  }
  return {
    initCatmullRom: function(r, a, o, l, c) {
      n(a, o, c * (o - r), c * (l - a));
    },
    initNonuniformCatmullRom: function(r, a, o, l, c, h, u) {
      let d = (a - r) / c - (o - r) / (c + h) + (o - a) / h, p = (o - a) / h - (l - a) / (h + u) + (l - o) / u;
      d *= h, p *= h, n(a, o, d, p);
    },
    calc: function(r) {
      const a = r * r, o = a * r;
      return s + e * r + t * a + i * o;
    }
  };
}
const id = /* @__PURE__ */ new M(), Vf = /* @__PURE__ */ new yA(), Wf = /* @__PURE__ */ new yA(), jf = /* @__PURE__ */ new yA();
class vD extends Zs {
  constructor(e = [], t = !1, i = "centripetal", n = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = n;
  }
  getPoint(e, t = new M()) {
    const i = t, n = this.points, r = n.length, a = (r - (this.closed ? 0 : 1)) * e;
    let o = Math.floor(a), l = a - o;
    this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / r) + 1) * r : l === 0 && o === r - 1 && (o = r - 2, l = 1);
    let c, h;
    this.closed || o > 0 ? c = n[(o - 1) % r] : (id.subVectors(n[0], n[1]).add(n[0]), c = id);
    const u = n[o % r], d = n[(o + 1) % r];
    if (this.closed || o + 2 < r ? h = n[(o + 2) % r] : (id.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), h = id), this.curveType === "centripetal" || this.curveType === "chordal") {
      const p = this.curveType === "chordal" ? 0.5 : 0.25;
      let f = Math.pow(c.distanceToSquared(u), p), y = Math.pow(u.distanceToSquared(d), p), A = Math.pow(d.distanceToSquared(h), p);
      y < 1e-4 && (y = 1), f < 1e-4 && (f = y), A < 1e-4 && (A = y), Vf.initNonuniformCatmullRom(c.x, u.x, d.x, h.x, f, y, A), Wf.initNonuniformCatmullRom(c.y, u.y, d.y, h.y, f, y, A), jf.initNonuniformCatmullRom(c.z, u.z, d.z, h.z, f, y, A);
    } else this.curveType === "catmullrom" && (Vf.initCatmullRom(c.x, u.x, d.x, h.x, this.tension), Wf.initCatmullRom(c.y, u.y, d.y, h.y, this.tension), jf.initCatmullRom(c.z, u.z, d.z, h.z, this.tension));
    return i.set(
      Vf.calc(l),
      Wf.calc(l),
      jf.calc(l)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(new M().fromArray(n));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function _v(s, e, t, i, n) {
  const r = (i - e) * 0.5, a = (n - t) * 0.5, o = s * s, l = s * o;
  return (2 * t - 2 * i + r + a) * l + (-3 * t + 3 * i - 2 * r - a) * o + r * s + t;
}
function _D(s, e) {
  const t = 1 - s;
  return t * t * e;
}
function xD(s, e) {
  return 2 * (1 - s) * s * e;
}
function wD(s, e) {
  return s * s * e;
}
function xh(s, e, t, i) {
  return _D(s, e) + xD(s, t) + wD(s, i);
}
function ED(s, e) {
  const t = 1 - s;
  return t * t * t * e;
}
function bD(s, e) {
  const t = 1 - s;
  return 3 * t * t * s * e;
}
function SD(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function CD(s, e) {
  return s * s * s * e;
}
function wh(s, e, t, i, n) {
  return ED(s, e) + bD(s, t) + SD(s, i) + CD(s, n);
}
class Mw extends Zs {
  constructor(e = new ie(), t = new ie(), i = new ie(), n = new ie()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
  }
  getPoint(e, t = new ie()) {
    const i = t, n = this.v0, r = this.v1, a = this.v2, o = this.v3;
    return i.set(
      wh(e, n.x, r.x, a.x, o.x),
      wh(e, n.y, r.y, a.y, o.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class MD extends Zs {
  constructor(e = new M(), t = new M(), i = new M(), n = new M()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
  }
  getPoint(e, t = new M()) {
    const i = t, n = this.v0, r = this.v1, a = this.v2, o = this.v3;
    return i.set(
      wh(e, n.x, r.x, a.x, o.x),
      wh(e, n.y, r.y, a.y, o.y),
      wh(e, n.z, r.z, a.z, o.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Tw extends Zs {
  constructor(e = new ie(), t = new ie()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new ie()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new ie()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class TD extends Zs {
  constructor(e = new M(), t = new M()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new M()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new M()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Iw extends Zs {
  constructor(e = new ie(), t = new ie(), i = new ie()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new ie()) {
    const i = t, n = this.v0, r = this.v1, a = this.v2;
    return i.set(
      xh(e, n.x, r.x, a.x),
      xh(e, n.y, r.y, a.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Dw extends Zs {
  constructor(e = new M(), t = new M(), i = new M()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new M()) {
    const i = t, n = this.v0, r = this.v1, a = this.v2;
    return i.set(
      xh(e, n.x, r.x, a.x),
      xh(e, n.y, r.y, a.y),
      xh(e, n.z, r.z, a.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Rw extends Zs {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new ie()) {
    const i = t, n = this.points, r = (n.length - 1) * e, a = Math.floor(r), o = r - a, l = n[a === 0 ? a : a - 1], c = n[a], h = n[a > n.length - 2 ? n.length - 1 : a + 1], u = n[a > n.length - 3 ? n.length - 1 : a + 2];
    return i.set(
      _v(o, l.x, c.x, h.x, u.x),
      _v(o, l.y, c.y, h.y, u.y)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(new ie().fromArray(n));
    }
    return this;
  }
}
var rp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: yD,
  CatmullRomCurve3: vD,
  CubicBezierCurve: Mw,
  CubicBezierCurve3: MD,
  EllipseCurve: AA,
  LineCurve: Tw,
  LineCurve3: TD,
  QuadraticBezierCurve: Iw,
  QuadraticBezierCurve3: Dw,
  SplineCurve: Rw
});
class ID extends Zs {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new rp[i](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const i = e * this.getLength(), n = this.getCurveLengths();
    let r = 0;
    for (; r < n.length; ) {
      if (n[r] >= i) {
        const a = n[r] - i, o = this.curves[r], l = o.getLength(), c = l === 0 ? 0 : 1 - a / l;
        return o.getPointAt(c, t);
      }
      r++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, n = this.curves.length; i < n; i++)
      t += this.curves[i].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let n = 0, r = this.curves; n < r.length; n++) {
      const a = r[n], o = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, l = a.getPoints(o);
      for (let c = 0; c < l.length; c++) {
        const h = l[c];
        i && i.equals(h) || (t.push(h), i = h);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const n = e.curves[t];
      this.curves.push(n.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const n = this.curves[t];
      e.curves.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const n = e.curves[t];
      this.curves.push(new rp[n.type]().fromJSON(n));
    }
    return this;
  }
}
class ap extends ID {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new ie(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new Tw(this.currentPoint.clone(), new ie(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, n) {
    const r = new Iw(
      this.currentPoint.clone(),
      new ie(e, t),
      new ie(i, n)
    );
    return this.curves.push(r), this.currentPoint.set(i, n), this;
  }
  bezierCurveTo(e, t, i, n, r, a) {
    const o = new Mw(
      this.currentPoint.clone(),
      new ie(e, t),
      new ie(i, n),
      new ie(r, a)
    );
    return this.curves.push(o), this.currentPoint.set(r, a), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), i = new Rw(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, n, r, a) {
    const o = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(
      e + o,
      t + l,
      i,
      n,
      r,
      a
    ), this;
  }
  absarc(e, t, i, n, r, a) {
    return this.absellipse(e, t, i, i, n, r, a), this;
  }
  ellipse(e, t, i, n, r, a, o, l) {
    const c = this.currentPoint.x, h = this.currentPoint.y;
    return this.absellipse(e + c, t + h, i, n, r, a, o, l), this;
  }
  absellipse(e, t, i, n, r, a, o, l) {
    const c = new AA(e, t, i, n, r, a, o, l);
    if (this.curves.length > 0) {
      const u = c.getPoint(0);
      u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
    }
    this.curves.push(c);
    const h = c.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Hp extends Ze {
  constructor(e = [new ie(0, -0.5), new ie(0.5, 0), new ie(0, 0.5)], t = 12, i = 0, n = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: i,
      phiLength: n
    }, t = Math.floor(t), n = Di(n, 0, Math.PI * 2);
    const r = [], a = [], o = [], l = [], c = [], h = 1 / t, u = new M(), d = new ie(), p = new M(), f = new M(), y = new M();
    let A = 0, m = 0;
    for (let v = 0; v <= e.length - 1; v++)
      switch (v) {
        case 0:
          A = e[v + 1].x - e[v].x, m = e[v + 1].y - e[v].y, p.x = m * 1, p.y = -A, p.z = m * 0, y.copy(p), p.normalize(), l.push(p.x, p.y, p.z);
          break;
        case e.length - 1:
          l.push(y.x, y.y, y.z);
          break;
        default:
          A = e[v + 1].x - e[v].x, m = e[v + 1].y - e[v].y, p.x = m * 1, p.y = -A, p.z = m * 0, f.copy(p), p.x += y.x, p.y += y.y, p.z += y.z, p.normalize(), l.push(p.x, p.y, p.z), y.copy(f);
      }
    for (let v = 0; v <= t; v++) {
      const g = i + v * h * n, _ = Math.sin(g), w = Math.cos(g);
      for (let S = 0; S <= e.length - 1; S++) {
        u.x = e[S].x * _, u.y = e[S].y, u.z = e[S].x * w, a.push(u.x, u.y, u.z), d.x = v / t, d.y = S / (e.length - 1), o.push(d.x, d.y);
        const C = l[3 * S + 0] * _, E = l[3 * S + 1], x = l[3 * S + 0] * w;
        c.push(C, E, x);
      }
    }
    for (let v = 0; v < t; v++)
      for (let g = 0; g < e.length - 1; g++) {
        const _ = g + v * e.length, w = _, S = _ + e.length, C = _ + e.length + 1, E = _ + 1;
        r.push(w, S, E), r.push(C, E, S);
      }
    this.setIndex(r), this.setAttribute("position", new Te(a, 3)), this.setAttribute("uv", new Te(o, 2)), this.setAttribute("normal", new Te(c, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Hp(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class vA extends Hp {
  constructor(e = 1, t = 1, i = 4, n = 8) {
    const r = new ap();
    r.absarc(0, -t / 2, e, Math.PI * 1.5, 0), r.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(r.getPoints(i), n), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: i,
      radialSegments: n
    };
  }
  static fromJSON(e) {
    return new vA(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class _A extends Ze {
  constructor(e = 1, t = 32, i = 0, n = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: i,
      thetaLength: n
    }, t = Math.max(3, t);
    const r = [], a = [], o = [], l = [], c = new M(), h = new ie();
    a.push(0, 0, 0), o.push(0, 0, 1), l.push(0.5, 0.5);
    for (let u = 0, d = 3; u <= t; u++, d += 3) {
      const p = i + u / t * n;
      c.x = e * Math.cos(p), c.y = e * Math.sin(p), a.push(c.x, c.y, c.z), o.push(0, 0, 1), h.x = (a[d] / e + 1) / 2, h.y = (a[d + 1] / e + 1) / 2, l.push(h.x, h.y);
    }
    for (let u = 1; u <= t; u++)
      r.push(u, u + 1, 0);
    this.setIndex(r), this.setAttribute("position", new Te(a, 3)), this.setAttribute("normal", new Te(o, 3)), this.setAttribute("uv", new Te(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new _A(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class yn extends Ze {
  constructor(e = 1, t = 1, i = 1, n = 32, r = 1, a = !1, o = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: i,
      radialSegments: n,
      heightSegments: r,
      openEnded: a,
      thetaStart: o,
      thetaLength: l
    };
    const c = this;
    n = Math.floor(n), r = Math.floor(r);
    const h = [], u = [], d = [], p = [];
    let f = 0;
    const y = [], A = i / 2;
    let m = 0;
    v(), a === !1 && (e > 0 && g(!0), t > 0 && g(!1)), this.setIndex(h), this.setAttribute("position", new Te(u, 3)), this.setAttribute("normal", new Te(d, 3)), this.setAttribute("uv", new Te(p, 2));
    function v() {
      const _ = new M(), w = new M();
      let S = 0;
      const C = (t - e) / i;
      for (let E = 0; E <= r; E++) {
        const x = [], b = E / r, D = b * (t - e) + e;
        for (let O = 0; O <= n; O++) {
          const Y = O / n, B = Y * l + o, Q = Math.sin(B), j = Math.cos(B);
          w.x = D * Q, w.y = -b * i + A, w.z = D * j, u.push(w.x, w.y, w.z), _.set(Q, C, j).normalize(), d.push(_.x, _.y, _.z), p.push(Y, 1 - b), x.push(f++);
        }
        y.push(x);
      }
      for (let E = 0; E < n; E++)
        for (let x = 0; x < r; x++) {
          const b = y[x][E], D = y[x + 1][E], O = y[x + 1][E + 1], Y = y[x][E + 1];
          h.push(b, D, Y), h.push(D, O, Y), S += 6;
        }
      c.addGroup(m, S, 0), m += S;
    }
    function g(_) {
      const w = f, S = new ie(), C = new M();
      let E = 0;
      const x = _ === !0 ? e : t, b = _ === !0 ? 1 : -1;
      for (let O = 1; O <= n; O++)
        u.push(0, A * b, 0), d.push(0, b, 0), p.push(0.5, 0.5), f++;
      const D = f;
      for (let O = 0; O <= n; O++) {
        const B = O / n * l + o, Q = Math.cos(B), j = Math.sin(B);
        C.x = x * j, C.y = A * b, C.z = x * Q, u.push(C.x, C.y, C.z), d.push(0, b, 0), S.x = Q * 0.5 + 0.5, S.y = j * 0.5 * b + 0.5, p.push(S.x, S.y), f++;
      }
      for (let O = 0; O < n; O++) {
        const Y = w + O, B = D + O;
        _ === !0 ? h.push(B, B + 1, Y) : h.push(B + 1, B, Y), E += 3;
      }
      c.addGroup(m, E, _ === !0 ? 1 : 2), m += E;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new yn(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class xA extends yn {
  constructor(e = 1, t = 1, i = 32, n = 1, r = !1, a = 0, o = Math.PI * 2) {
    super(0, e, t, i, n, r, a, o), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: i,
      heightSegments: n,
      openEnded: r,
      thetaStart: a,
      thetaLength: o
    };
  }
  static fromJSON(e) {
    return new xA(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class ko extends Ze {
  constructor(e = [], t = [], i = 1, n = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: i,
      detail: n
    };
    const r = [], a = [];
    o(n), c(i), h(), this.setAttribute("position", new Te(r, 3)), this.setAttribute("normal", new Te(r.slice(), 3)), this.setAttribute("uv", new Te(a, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function o(v) {
      const g = new M(), _ = new M(), w = new M();
      for (let S = 0; S < t.length; S += 3)
        p(t[S + 0], g), p(t[S + 1], _), p(t[S + 2], w), l(g, _, w, v);
    }
    function l(v, g, _, w) {
      const S = w + 1, C = [];
      for (let E = 0; E <= S; E++) {
        C[E] = [];
        const x = v.clone().lerp(_, E / S), b = g.clone().lerp(_, E / S), D = S - E;
        for (let O = 0; O <= D; O++)
          O === 0 && E === S ? C[E][O] = x : C[E][O] = x.clone().lerp(b, O / D);
      }
      for (let E = 0; E < S; E++)
        for (let x = 0; x < 2 * (S - E) - 1; x++) {
          const b = Math.floor(x / 2);
          x % 2 === 0 ? (d(C[E][b + 1]), d(C[E + 1][b]), d(C[E][b])) : (d(C[E][b + 1]), d(C[E + 1][b + 1]), d(C[E + 1][b]));
        }
    }
    function c(v) {
      const g = new M();
      for (let _ = 0; _ < r.length; _ += 3)
        g.x = r[_ + 0], g.y = r[_ + 1], g.z = r[_ + 2], g.normalize().multiplyScalar(v), r[_ + 0] = g.x, r[_ + 1] = g.y, r[_ + 2] = g.z;
    }
    function h() {
      const v = new M();
      for (let g = 0; g < r.length; g += 3) {
        v.x = r[g + 0], v.y = r[g + 1], v.z = r[g + 2];
        const _ = A(v) / 2 / Math.PI + 0.5, w = m(v) / Math.PI + 0.5;
        a.push(_, 1 - w);
      }
      f(), u();
    }
    function u() {
      for (let v = 0; v < a.length; v += 6) {
        const g = a[v + 0], _ = a[v + 2], w = a[v + 4], S = Math.max(g, _, w), C = Math.min(g, _, w);
        S > 0.9 && C < 0.1 && (g < 0.2 && (a[v + 0] += 1), _ < 0.2 && (a[v + 2] += 1), w < 0.2 && (a[v + 4] += 1));
      }
    }
    function d(v) {
      r.push(v.x, v.y, v.z);
    }
    function p(v, g) {
      const _ = v * 3;
      g.x = e[_ + 0], g.y = e[_ + 1], g.z = e[_ + 2];
    }
    function f() {
      const v = new M(), g = new M(), _ = new M(), w = new M(), S = new ie(), C = new ie(), E = new ie();
      for (let x = 0, b = 0; x < r.length; x += 9, b += 6) {
        v.set(r[x + 0], r[x + 1], r[x + 2]), g.set(r[x + 3], r[x + 4], r[x + 5]), _.set(r[x + 6], r[x + 7], r[x + 8]), S.set(a[b + 0], a[b + 1]), C.set(a[b + 2], a[b + 3]), E.set(a[b + 4], a[b + 5]), w.copy(v).add(g).add(_).divideScalar(3);
        const D = A(w);
        y(S, b + 0, v, D), y(C, b + 2, g, D), y(E, b + 4, _, D);
      }
    }
    function y(v, g, _, w) {
      w < 0 && v.x === 1 && (a[g] = v.x - 1), _.x === 0 && _.z === 0 && (a[g] = w / 2 / Math.PI + 0.5);
    }
    function A(v) {
      return Math.atan2(v.z, -v.x);
    }
    function m(v) {
      return Math.atan2(-v.y, Math.sqrt(v.x * v.x + v.z * v.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new ko(e.vertices, e.indices, e.radius, e.details);
  }
}
class wA extends ko {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, n = 1 / i, r = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -n,
      -i,
      0,
      -n,
      i,
      0,
      n,
      -i,
      0,
      n,
      i,
      // (±1/φ, ±φ, 0)
      -n,
      -i,
      0,
      -n,
      i,
      0,
      n,
      -i,
      0,
      n,
      i,
      0,
      // (±φ, 0, ±1/φ)
      -i,
      0,
      -n,
      i,
      0,
      -n,
      -i,
      0,
      n,
      i,
      0,
      n
    ], a = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(r, a, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new wA(e.radius, e.detail);
  }
}
const nd = /* @__PURE__ */ new M(), sd = /* @__PURE__ */ new M(), qf = /* @__PURE__ */ new M(), rd = /* @__PURE__ */ new hs();
class DD extends Ze {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const n = Math.pow(10, 4), r = Math.cos(ho * t), a = e.getIndex(), o = e.getAttribute("position"), l = a ? a.count : o.count, c = [0, 0, 0], h = ["a", "b", "c"], u = new Array(3), d = {}, p = [];
      for (let f = 0; f < l; f += 3) {
        a ? (c[0] = a.getX(f), c[1] = a.getX(f + 1), c[2] = a.getX(f + 2)) : (c[0] = f, c[1] = f + 1, c[2] = f + 2);
        const { a: y, b: A, c: m } = rd;
        if (y.fromBufferAttribute(o, c[0]), A.fromBufferAttribute(o, c[1]), m.fromBufferAttribute(o, c[2]), rd.getNormal(qf), u[0] = `${Math.round(y.x * n)},${Math.round(y.y * n)},${Math.round(y.z * n)}`, u[1] = `${Math.round(A.x * n)},${Math.round(A.y * n)},${Math.round(A.z * n)}`, u[2] = `${Math.round(m.x * n)},${Math.round(m.y * n)},${Math.round(m.z * n)}`, !(u[0] === u[1] || u[1] === u[2] || u[2] === u[0]))
          for (let v = 0; v < 3; v++) {
            const g = (v + 1) % 3, _ = u[v], w = u[g], S = rd[h[v]], C = rd[h[g]], E = `${_}_${w}`, x = `${w}_${_}`;
            x in d && d[x] ? (qf.dot(d[x].normal) <= r && (p.push(S.x, S.y, S.z), p.push(C.x, C.y, C.z)), d[x] = null) : E in d || (d[E] = {
              index0: c[v],
              index1: c[g],
              normal: qf.clone()
            });
          }
      }
      for (const f in d)
        if (d[f]) {
          const { index0: y, index1: A } = d[f];
          nd.fromBufferAttribute(o, y), sd.fromBufferAttribute(o, A), p.push(nd.x, nd.y, nd.z), p.push(sd.x, sd.y, sd.z);
        }
      this.setAttribute("position", new Te(p, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class Ql extends ap {
  constructor(e) {
    super(e), this.uuid = ps(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, n = this.holes.length; i < n; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const n = e.holes[t];
      this.holes.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const n = this.holes[t];
      e.holes.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const n = e.holes[t];
      this.holes.push(new ap().fromJSON(n));
    }
    return this;
  }
}
const RD = {
  triangulate: function(s, e, t = 2) {
    const i = e && e.length, n = i ? e[0] * t : s.length;
    let r = Bw(s, 0, n, t, !0);
    const a = [];
    if (!r || r.next === r.prev) return a;
    let o, l, c, h, u, d, p;
    if (i && (r = FD(s, e, r, t)), s.length > 80 * t) {
      o = c = s[0], l = h = s[1];
      for (let f = t; f < n; f += t)
        u = s[f], d = s[f + 1], u < o && (o = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
      p = Math.max(c - o, h - l), p = p !== 0 ? 32767 / p : 0;
    }
    return Fh(r, a, t, o, l, p, 0), a;
  }
};
function Bw(s, e, t, i, n) {
  let r, a;
  if (n === qD(s, e, t, i) > 0)
    for (r = e; r < t; r += i) a = xv(r, s[r], s[r + 1], a);
  else
    for (r = t - i; r >= e; r -= i) a = xv(r, s[r], s[r + 1], a);
  return a && Vp(a, a.next) && (Nh(a), a = a.next), a;
}
function yo(s, e) {
  if (!s) return s;
  e || (e = s);
  let t = s, i;
  do
    if (i = !1, !t.steiner && (Vp(t, t.next) || Mi(t.prev, t, t.next) === 0)) {
      if (Nh(t), t = e = t.prev, t === t.next) break;
      i = !0;
    } else
      t = t.next;
  while (i || t !== e);
  return e;
}
function Fh(s, e, t, i, n, r, a) {
  if (!s) return;
  !a && r && zD(s, i, n, r);
  let o = s, l, c;
  for (; s.prev !== s.next; ) {
    if (l = s.prev, c = s.next, r ? PD(s, i, n, r) : BD(s)) {
      e.push(l.i / t | 0), e.push(s.i / t | 0), e.push(c.i / t | 0), Nh(s), s = c.next, o = c.next;
      continue;
    }
    if (s = c, s === o) {
      a ? a === 1 ? (s = LD(yo(s), e, t), Fh(s, e, t, i, n, r, 2)) : a === 2 && UD(s, e, t, i, n, r) : Fh(yo(s), e, t, i, n, r, 1);
      break;
    }
  }
}
function BD(s) {
  const e = s.prev, t = s, i = s.next;
  if (Mi(e, t, i) >= 0) return !1;
  const n = e.x, r = t.x, a = i.x, o = e.y, l = t.y, c = i.y, h = n < r ? n < a ? n : a : r < a ? r : a, u = o < l ? o < c ? o : c : l < c ? l : c, d = n > r ? n > a ? n : a : r > a ? r : a, p = o > l ? o > c ? o : c : l > c ? l : c;
  let f = i.next;
  for (; f !== e; ) {
    if (f.x >= h && f.x <= d && f.y >= u && f.y <= p && Il(n, o, r, l, a, c, f.x, f.y) && Mi(f.prev, f, f.next) >= 0) return !1;
    f = f.next;
  }
  return !0;
}
function PD(s, e, t, i) {
  const n = s.prev, r = s, a = s.next;
  if (Mi(n, r, a) >= 0) return !1;
  const o = n.x, l = r.x, c = a.x, h = n.y, u = r.y, d = a.y, p = o < l ? o < c ? o : c : l < c ? l : c, f = h < u ? h < d ? h : d : u < d ? u : d, y = o > l ? o > c ? o : c : l > c ? l : c, A = h > u ? h > d ? h : d : u > d ? u : d, m = ig(p, f, e, t, i), v = ig(y, A, e, t, i);
  let g = s.prevZ, _ = s.nextZ;
  for (; g && g.z >= m && _ && _.z <= v; ) {
    if (g.x >= p && g.x <= y && g.y >= f && g.y <= A && g !== n && g !== a && Il(o, h, l, u, c, d, g.x, g.y) && Mi(g.prev, g, g.next) >= 0 || (g = g.prevZ, _.x >= p && _.x <= y && _.y >= f && _.y <= A && _ !== n && _ !== a && Il(o, h, l, u, c, d, _.x, _.y) && Mi(_.prev, _, _.next) >= 0)) return !1;
    _ = _.nextZ;
  }
  for (; g && g.z >= m; ) {
    if (g.x >= p && g.x <= y && g.y >= f && g.y <= A && g !== n && g !== a && Il(o, h, l, u, c, d, g.x, g.y) && Mi(g.prev, g, g.next) >= 0) return !1;
    g = g.prevZ;
  }
  for (; _ && _.z <= v; ) {
    if (_.x >= p && _.x <= y && _.y >= f && _.y <= A && _ !== n && _ !== a && Il(o, h, l, u, c, d, _.x, _.y) && Mi(_.prev, _, _.next) >= 0) return !1;
    _ = _.nextZ;
  }
  return !0;
}
function LD(s, e, t) {
  let i = s;
  do {
    const n = i.prev, r = i.next.next;
    !Vp(n, r) && Pw(n, i, i.next, r) && Oh(n, r) && Oh(r, n) && (e.push(n.i / t | 0), e.push(i.i / t | 0), e.push(r.i / t | 0), Nh(i), Nh(i.next), i = s = r), i = i.next;
  } while (i !== s);
  return yo(i);
}
function UD(s, e, t, i, n, r) {
  let a = s;
  do {
    let o = a.next.next;
    for (; o !== a.prev; ) {
      if (a.i !== o.i && VD(a, o)) {
        let l = Lw(a, o);
        a = yo(a, a.next), l = yo(l, l.next), Fh(a, e, t, i, n, r, 0), Fh(l, e, t, i, n, r, 0);
        return;
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== s);
}
function FD(s, e, t, i) {
  const n = [];
  let r, a, o, l, c;
  for (r = 0, a = e.length; r < a; r++)
    o = e[r] * i, l = r < a - 1 ? e[r + 1] * i : s.length, c = Bw(s, o, l, i, !1), c === c.next && (c.steiner = !0), n.push(HD(c));
  for (n.sort(OD), r = 0; r < n.length; r++)
    t = ND(n[r], t);
  return t;
}
function OD(s, e) {
  return s.x - e.x;
}
function ND(s, e) {
  const t = kD(s, e);
  if (!t)
    return e;
  const i = Lw(t, s);
  return yo(i, i.next), yo(t, t.next);
}
function kD(s, e) {
  let t = e, i = -1 / 0, n;
  const r = s.x, a = s.y;
  do {
    if (a <= t.y && a >= t.next.y && t.next.y !== t.y) {
      const d = t.x + (a - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (d <= r && d > i && (i = d, n = t.x < t.next.x ? t : t.next, d === r))
        return n;
    }
    t = t.next;
  } while (t !== e);
  if (!n) return null;
  const o = n, l = n.x, c = n.y;
  let h = 1 / 0, u;
  t = n;
  do
    r >= t.x && t.x >= l && r !== t.x && Il(a < c ? r : i, a, l, c, a < c ? i : r, a, t.x, t.y) && (u = Math.abs(a - t.y) / (r - t.x), Oh(t, s) && (u < h || u === h && (t.x > n.x || t.x === n.x && GD(n, t))) && (n = t, h = u)), t = t.next;
  while (t !== o);
  return n;
}
function GD(s, e) {
  return Mi(s.prev, s, e.prev) < 0 && Mi(e.next, s, s.next) < 0;
}
function zD(s, e, t, i) {
  let n = s;
  do
    n.z === 0 && (n.z = ig(n.x, n.y, e, t, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== s);
  n.prevZ.nextZ = null, n.prevZ = null, QD(n);
}
function QD(s) {
  let e, t, i, n, r, a, o, l, c = 1;
  do {
    for (t = s, s = null, r = null, a = 0; t; ) {
      for (a++, i = t, o = 0, e = 0; e < c && (o++, i = i.nextZ, !!i); e++)
        ;
      for (l = c; o > 0 || l > 0 && i; )
        o !== 0 && (l === 0 || !i || t.z <= i.z) ? (n = t, t = t.nextZ, o--) : (n = i, i = i.nextZ, l--), r ? r.nextZ = n : s = n, n.prevZ = r, r = n;
      t = i;
    }
    r.nextZ = null, c *= 2;
  } while (a > 1);
  return s;
}
function ig(s, e, t, i, n) {
  return s = (s - t) * n | 0, e = (e - i) * n | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function HD(s) {
  let e = s, t = s;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== s);
  return t;
}
function Il(s, e, t, i, n, r, a, o) {
  return (n - a) * (e - o) >= (s - a) * (r - o) && (s - a) * (i - o) >= (t - a) * (e - o) && (t - a) * (r - o) >= (n - a) * (i - o);
}
function VD(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !WD(s, e) && // dones't intersect other edges
  (Oh(s, e) && Oh(e, s) && jD(s, e) && // locally visible
  (Mi(s.prev, s, e.prev) || Mi(s, e.prev, e)) || // does not create opposite-facing sectors
  Vp(s, e) && Mi(s.prev, s, s.next) > 0 && Mi(e.prev, e, e.next) > 0);
}
function Mi(s, e, t) {
  return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
}
function Vp(s, e) {
  return s.x === e.x && s.y === e.y;
}
function Pw(s, e, t, i) {
  const n = od(Mi(s, e, t)), r = od(Mi(s, e, i)), a = od(Mi(t, i, s)), o = od(Mi(t, i, e));
  return !!(n !== r && a !== o || n === 0 && ad(s, t, e) || r === 0 && ad(s, i, e) || a === 0 && ad(t, s, i) || o === 0 && ad(t, e, i));
}
function ad(s, e, t) {
  return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
}
function od(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function WD(s, e) {
  let t = s;
  do {
    if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && Pw(t, t.next, s, e)) return !0;
    t = t.next;
  } while (t !== s);
  return !1;
}
function Oh(s, e) {
  return Mi(s.prev, s, s.next) < 0 ? Mi(s, e, s.next) >= 0 && Mi(s, s.prev, e) >= 0 : Mi(s, e, s.prev) < 0 || Mi(s, s.next, e) < 0;
}
function jD(s, e) {
  let t = s, i = !1;
  const n = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
  do
    t.y > r != t.next.y > r && t.next.y !== t.y && n < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
  while (t !== s);
  return i;
}
function Lw(s, e) {
  const t = new ng(s.i, s.x, s.y), i = new ng(e.i, e.x, e.y), n = s.next, r = e.prev;
  return s.next = e, e.prev = s, t.next = n, n.prev = t, i.next = t, t.prev = i, r.next = i, i.prev = r, i;
}
function xv(s, e, t, i) {
  const n = new ng(s, e, t);
  return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
}
function Nh(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function ng(s, e, t) {
  this.i = s, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function qD(s, e, t, i) {
  let n = 0;
  for (let r = e, a = t - i; r < t; r += i)
    n += (s[a] - s[r]) * (s[r + 1] + s[a + 1]), a = r;
  return n;
}
class jr {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let n = t - 1, r = 0; r < t; n = r++)
      i += e[n].x * e[r].y - e[r].x * e[n].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return jr.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [], n = [], r = [];
    wv(e), Ev(i, e);
    let a = e.length;
    t.forEach(wv);
    for (let l = 0; l < t.length; l++)
      n.push(a), a += t[l].length, Ev(i, t[l]);
    const o = RD.triangulate(i, n);
    for (let l = 0; l < o.length; l += 3)
      r.push(o.slice(l, l + 3));
    return r;
  }
}
function wv(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function Ev(s, e) {
  for (let t = 0; t < e.length; t++)
    s.push(e[t].x), s.push(e[t].y);
}
class EA extends Ze {
  constructor(e = new Ql([new ie(0.5, 0.5), new ie(-0.5, 0.5), new ie(-0.5, -0.5), new ie(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const i = this, n = [], r = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o];
      a(c);
    }
    this.setAttribute("position", new Te(n, 3)), this.setAttribute("uv", new Te(r, 2)), this.computeVertexNormals();
    function a(o) {
      const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, h = t.steps !== void 0 ? t.steps : 1, u = t.depth !== void 0 ? t.depth : 1;
      let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, p = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, f = t.bevelSize !== void 0 ? t.bevelSize : p - 0.1, y = t.bevelOffset !== void 0 ? t.bevelOffset : 0, A = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const m = t.extrudePath, v = t.UVGenerator !== void 0 ? t.UVGenerator : XD;
      let g, _ = !1, w, S, C, E;
      m && (g = m.getSpacedPoints(h), _ = !0, d = !1, w = m.computeFrenetFrames(h, !1), S = new M(), C = new M(), E = new M()), d || (A = 0, p = 0, f = 0, y = 0);
      const x = o.extractPoints(c);
      let b = x.shape;
      const D = x.holes;
      if (!jr.isClockWise(b)) {
        b = b.reverse();
        for (let G = 0, Be = D.length; G < Be; G++) {
          const oe = D[G];
          jr.isClockWise(oe) && (D[G] = oe.reverse());
        }
      }
      const Y = jr.triangulateShape(b, D), B = b;
      for (let G = 0, Be = D.length; G < Be; G++) {
        const oe = D[G];
        b = b.concat(oe);
      }
      function Q(G, Be, oe) {
        return Be || console.error("THREE.ExtrudeGeometry: vec does not exist"), G.clone().addScaledVector(Be, oe);
      }
      const j = b.length, X = Y.length;
      function Z(G, Be, oe) {
        let Ee, de, Ke;
        const Ne = G.x - Be.x, Ge = G.y - Be.y, nt = oe.x - G.x, wt = oe.y - G.y, di = Ne * Ne + Ge * Ge, F = Ne * wt - Ge * nt;
        if (Math.abs(F) > Number.EPSILON) {
          const R = Math.sqrt(di), te = Math.sqrt(nt * nt + wt * wt), we = Be.x - Ge / R, Ae = Be.y + Ne / R, Ce = oe.x - wt / te, We = oe.y + nt / te, Me = ((Ce - we) * wt - (We - Ae) * nt) / (Ne * wt - Ge * nt);
          Ee = we + Ne * Me - G.x, de = Ae + Ge * Me - G.y;
          const Le = Ee * Ee + de * de;
          if (Le <= 2)
            return new ie(Ee, de);
          Ke = Math.sqrt(Le / 2);
        } else {
          let R = !1;
          Ne > Number.EPSILON ? nt > Number.EPSILON && (R = !0) : Ne < -Number.EPSILON ? nt < -Number.EPSILON && (R = !0) : Math.sign(Ge) === Math.sign(wt) && (R = !0), R ? (Ee = -Ge, de = Ne, Ke = Math.sqrt(di)) : (Ee = Ne, de = Ge, Ke = Math.sqrt(di / 2));
        }
        return new ie(Ee / Ke, de / Ke);
      }
      const ee = [];
      for (let G = 0, Be = B.length, oe = Be - 1, Ee = G + 1; G < Be; G++, oe++, Ee++)
        oe === Be && (oe = 0), Ee === Be && (Ee = 0), ee[G] = Z(B[G], B[oe], B[Ee]);
      const J = [];
      let W, K = ee.concat();
      for (let G = 0, Be = D.length; G < Be; G++) {
        const oe = D[G];
        W = [];
        for (let Ee = 0, de = oe.length, Ke = de - 1, Ne = Ee + 1; Ee < de; Ee++, Ke++, Ne++)
          Ke === de && (Ke = 0), Ne === de && (Ne = 0), W[Ee] = Z(oe[Ee], oe[Ke], oe[Ne]);
        J.push(W), K = K.concat(W);
      }
      for (let G = 0; G < A; G++) {
        const Be = G / A, oe = p * Math.cos(Be * Math.PI / 2), Ee = f * Math.sin(Be * Math.PI / 2) + y;
        for (let de = 0, Ke = B.length; de < Ke; de++) {
          const Ne = Q(B[de], ee[de], Ee);
          ze(Ne.x, Ne.y, -oe);
        }
        for (let de = 0, Ke = D.length; de < Ke; de++) {
          const Ne = D[de];
          W = J[de];
          for (let Ge = 0, nt = Ne.length; Ge < nt; Ge++) {
            const wt = Q(Ne[Ge], W[Ge], Ee);
            ze(wt.x, wt.y, -oe);
          }
        }
      }
      const ce = f + y;
      for (let G = 0; G < j; G++) {
        const Be = d ? Q(b[G], K[G], ce) : b[G];
        _ ? (C.copy(w.normals[0]).multiplyScalar(Be.x), S.copy(w.binormals[0]).multiplyScalar(Be.y), E.copy(g[0]).add(C).add(S), ze(E.x, E.y, E.z)) : ze(Be.x, Be.y, 0);
      }
      for (let G = 1; G <= h; G++)
        for (let Be = 0; Be < j; Be++) {
          const oe = d ? Q(b[Be], K[Be], ce) : b[Be];
          _ ? (C.copy(w.normals[G]).multiplyScalar(oe.x), S.copy(w.binormals[G]).multiplyScalar(oe.y), E.copy(g[G]).add(C).add(S), ze(E.x, E.y, E.z)) : ze(oe.x, oe.y, u / h * G);
        }
      for (let G = A - 1; G >= 0; G--) {
        const Be = G / A, oe = p * Math.cos(Be * Math.PI / 2), Ee = f * Math.sin(Be * Math.PI / 2) + y;
        for (let de = 0, Ke = B.length; de < Ke; de++) {
          const Ne = Q(B[de], ee[de], Ee);
          ze(Ne.x, Ne.y, u + oe);
        }
        for (let de = 0, Ke = D.length; de < Ke; de++) {
          const Ne = D[de];
          W = J[de];
          for (let Ge = 0, nt = Ne.length; Ge < nt; Ge++) {
            const wt = Q(Ne[Ge], W[Ge], Ee);
            _ ? ze(wt.x, wt.y + g[h - 1].y, g[h - 1].x + oe) : ze(wt.x, wt.y, u + oe);
          }
        }
      }
      fe(), ve();
      function fe() {
        const G = n.length / 3;
        if (d) {
          let Be = 0, oe = j * Be;
          for (let Ee = 0; Ee < X; Ee++) {
            const de = Y[Ee];
            Qe(de[2] + oe, de[1] + oe, de[0] + oe);
          }
          Be = h + A * 2, oe = j * Be;
          for (let Ee = 0; Ee < X; Ee++) {
            const de = Y[Ee];
            Qe(de[0] + oe, de[1] + oe, de[2] + oe);
          }
        } else {
          for (let Be = 0; Be < X; Be++) {
            const oe = Y[Be];
            Qe(oe[2], oe[1], oe[0]);
          }
          for (let Be = 0; Be < X; Be++) {
            const oe = Y[Be];
            Qe(oe[0] + j * h, oe[1] + j * h, oe[2] + j * h);
          }
        }
        i.addGroup(G, n.length / 3 - G, 0);
      }
      function ve() {
        const G = n.length / 3;
        let Be = 0;
        _e(B, Be), Be += B.length;
        for (let oe = 0, Ee = D.length; oe < Ee; oe++) {
          const de = D[oe];
          _e(de, Be), Be += de.length;
        }
        i.addGroup(G, n.length / 3 - G, 1);
      }
      function _e(G, Be) {
        let oe = G.length;
        for (; --oe >= 0; ) {
          const Ee = oe;
          let de = oe - 1;
          de < 0 && (de = G.length - 1);
          for (let Ke = 0, Ne = h + A * 2; Ke < Ne; Ke++) {
            const Ge = j * Ke, nt = j * (Ke + 1), wt = Be + Ee + Ge, di = Be + de + Ge, F = Be + de + nt, R = Be + Ee + nt;
            ot(wt, di, F, R);
          }
        }
      }
      function ze(G, Be, oe) {
        l.push(G), l.push(Be), l.push(oe);
      }
      function Qe(G, Be, oe) {
        ht(G), ht(Be), ht(oe);
        const Ee = n.length / 3, de = v.generateTopUV(i, n, Ee - 3, Ee - 2, Ee - 1);
        Xe(de[0]), Xe(de[1]), Xe(de[2]);
      }
      function ot(G, Be, oe, Ee) {
        ht(G), ht(Be), ht(Ee), ht(Be), ht(oe), ht(Ee);
        const de = n.length / 3, Ke = v.generateSideWallUV(i, n, de - 6, de - 3, de - 2, de - 1);
        Xe(Ke[0]), Xe(Ke[1]), Xe(Ke[3]), Xe(Ke[1]), Xe(Ke[2]), Xe(Ke[3]);
      }
      function ht(G) {
        n.push(l[G * 3 + 0]), n.push(l[G * 3 + 1]), n.push(l[G * 3 + 2]);
      }
      function Xe(G) {
        r.push(G.x), r.push(G.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, i = this.parameters.options;
    return YD(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, a = e.shapes.length; r < a; r++) {
      const o = t[e.shapes[r]];
      i.push(o);
    }
    const n = e.options.extrudePath;
    return n !== void 0 && (e.options.extrudePath = new rp[n.type]().fromJSON(n)), new EA(i, e.options);
  }
}
const XD = {
  generateTopUV: function(s, e, t, i, n) {
    const r = e[t * 3], a = e[t * 3 + 1], o = e[i * 3], l = e[i * 3 + 1], c = e[n * 3], h = e[n * 3 + 1];
    return [
      new ie(r, a),
      new ie(o, l),
      new ie(c, h)
    ];
  },
  generateSideWallUV: function(s, e, t, i, n, r) {
    const a = e[t * 3], o = e[t * 3 + 1], l = e[t * 3 + 2], c = e[i * 3], h = e[i * 3 + 1], u = e[i * 3 + 2], d = e[n * 3], p = e[n * 3 + 1], f = e[n * 3 + 2], y = e[r * 3], A = e[r * 3 + 1], m = e[r * 3 + 2];
    return Math.abs(o - h) < Math.abs(a - c) ? [
      new ie(a, 1 - l),
      new ie(c, 1 - u),
      new ie(d, 1 - f),
      new ie(y, 1 - m)
    ] : [
      new ie(o, 1 - l),
      new ie(h, 1 - u),
      new ie(p, 1 - f),
      new ie(A, 1 - m)
    ];
  }
};
function YD(s, e, t) {
  if (t.shapes = [], Array.isArray(s))
    for (let i = 0, n = s.length; i < n; i++) {
      const r = s[i];
      t.shapes.push(r.uuid);
    }
  else
    t.shapes.push(s.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class bA extends ko {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, n = [
      -1,
      i,
      0,
      1,
      i,
      0,
      -1,
      -i,
      0,
      1,
      -i,
      0,
      0,
      -1,
      i,
      0,
      1,
      i,
      0,
      -1,
      -i,
      0,
      1,
      -i,
      i,
      0,
      -1,
      i,
      0,
      1,
      -i,
      0,
      -1,
      -i,
      0,
      1
    ], r = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(n, r, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new bA(e.radius, e.detail);
  }
}
class ya extends ko {
  constructor(e = 1, t = 0) {
    const i = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], n = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(i, n, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new ya(e.radius, e.detail);
  }
}
class SA extends Ze {
  constructor(e = 0.5, t = 1, i = 32, n = 1, r = 0, a = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: i,
      phiSegments: n,
      thetaStart: r,
      thetaLength: a
    }, i = Math.max(3, i), n = Math.max(1, n);
    const o = [], l = [], c = [], h = [];
    let u = e;
    const d = (t - e) / n, p = new M(), f = new ie();
    for (let y = 0; y <= n; y++) {
      for (let A = 0; A <= i; A++) {
        const m = r + A / i * a;
        p.x = u * Math.cos(m), p.y = u * Math.sin(m), l.push(p.x, p.y, p.z), c.push(0, 0, 1), f.x = (p.x / t + 1) / 2, f.y = (p.y / t + 1) / 2, h.push(f.x, f.y);
      }
      u += d;
    }
    for (let y = 0; y < n; y++) {
      const A = y * (i + 1);
      for (let m = 0; m < i; m++) {
        const v = m + A, g = v, _ = v + i + 1, w = v + i + 2, S = v + 1;
        o.push(g, _, S), o.push(_, w, S);
      }
    }
    this.setIndex(o), this.setAttribute("position", new Te(l, 3)), this.setAttribute("normal", new Te(c, 3)), this.setAttribute("uv", new Te(h, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new SA(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class CA extends Ze {
  constructor(e = new Ql([new ie(0, 0.5), new ie(-0.5, -0.5), new ie(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const i = [], n = [], r = [], a = [];
    let o = 0, l = 0;
    if (Array.isArray(e) === !1)
      c(e);
    else
      for (let h = 0; h < e.length; h++)
        c(e[h]), this.addGroup(o, l, h), o += l, l = 0;
    this.setIndex(i), this.setAttribute("position", new Te(n, 3)), this.setAttribute("normal", new Te(r, 3)), this.setAttribute("uv", new Te(a, 2));
    function c(h) {
      const u = n.length / 3, d = h.extractPoints(t);
      let p = d.shape;
      const f = d.holes;
      jr.isClockWise(p) === !1 && (p = p.reverse());
      for (let A = 0, m = f.length; A < m; A++) {
        const v = f[A];
        jr.isClockWise(v) === !0 && (f[A] = v.reverse());
      }
      const y = jr.triangulateShape(p, f);
      for (let A = 0, m = f.length; A < m; A++) {
        const v = f[A];
        p = p.concat(v);
      }
      for (let A = 0, m = p.length; A < m; A++) {
        const v = p[A];
        n.push(v.x, v.y, 0), r.push(0, 0, 1), a.push(v.x, v.y);
      }
      for (let A = 0, m = y.length; A < m; A++) {
        const v = y[A], g = v[0] + u, _ = v[1] + u, w = v[2] + u;
        i.push(g, _, w), l += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return KD(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let n = 0, r = e.shapes.length; n < r; n++) {
      const a = t[e.shapes[n]];
      i.push(a);
    }
    return new CA(i, e.curveSegments);
  }
}
function KD(s, e) {
  if (e.shapes = [], Array.isArray(s))
    for (let t = 0, i = s.length; t < i; t++) {
      const n = s[t];
      e.shapes.push(n.uuid);
    }
  else
    e.shapes.push(s.uuid);
  return e;
}
class fr extends Ze {
  constructor(e = 1, t = 32, i = 16, n = 0, r = Math.PI * 2, a = 0, o = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: i,
      phiStart: n,
      phiLength: r,
      thetaStart: a,
      thetaLength: o
    }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
    const l = Math.min(a + o, Math.PI);
    let c = 0;
    const h = [], u = new M(), d = new M(), p = [], f = [], y = [], A = [];
    for (let m = 0; m <= i; m++) {
      const v = [], g = m / i;
      let _ = 0;
      m === 0 && a === 0 ? _ = 0.5 / t : m === i && l === Math.PI && (_ = -0.5 / t);
      for (let w = 0; w <= t; w++) {
        const S = w / t;
        u.x = -e * Math.cos(n + S * r) * Math.sin(a + g * o), u.y = e * Math.cos(a + g * o), u.z = e * Math.sin(n + S * r) * Math.sin(a + g * o), f.push(u.x, u.y, u.z), d.copy(u).normalize(), y.push(d.x, d.y, d.z), A.push(S + _, 1 - g), v.push(c++);
      }
      h.push(v);
    }
    for (let m = 0; m < i; m++)
      for (let v = 0; v < t; v++) {
        const g = h[m][v + 1], _ = h[m][v], w = h[m + 1][v], S = h[m + 1][v + 1];
        (m !== 0 || a > 0) && p.push(g, _, S), (m !== i - 1 || l < Math.PI) && p.push(_, w, S);
      }
    this.setIndex(p), this.setAttribute("position", new Te(f, 3)), this.setAttribute("normal", new Te(y, 3)), this.setAttribute("uv", new Te(A, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new fr(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class MA extends ko {
  constructor(e = 1, t = 0) {
    const i = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], n = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(i, n, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new MA(e.radius, e.detail);
  }
}
class kh extends Ze {
  constructor(e = 1, t = 0.4, i = 12, n = 48, r = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: i,
      tubularSegments: n,
      arc: r
    }, i = Math.floor(i), n = Math.floor(n);
    const a = [], o = [], l = [], c = [], h = new M(), u = new M(), d = new M();
    for (let p = 0; p <= i; p++)
      for (let f = 0; f <= n; f++) {
        const y = f / n * r, A = p / i * Math.PI * 2;
        u.x = (e + t * Math.cos(A)) * Math.cos(y), u.y = (e + t * Math.cos(A)) * Math.sin(y), u.z = t * Math.sin(A), o.push(u.x, u.y, u.z), h.x = e * Math.cos(y), h.y = e * Math.sin(y), d.subVectors(u, h).normalize(), l.push(d.x, d.y, d.z), c.push(f / n), c.push(p / i);
      }
    for (let p = 1; p <= i; p++)
      for (let f = 1; f <= n; f++) {
        const y = (n + 1) * p + f - 1, A = (n + 1) * (p - 1) + f - 1, m = (n + 1) * (p - 1) + f, v = (n + 1) * p + f;
        a.push(y, A, v), a.push(A, m, v);
      }
    this.setIndex(a), this.setAttribute("position", new Te(o, 3)), this.setAttribute("normal", new Te(l, 3)), this.setAttribute("uv", new Te(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new kh(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class TA extends Ze {
  constructor(e = 1, t = 0.4, i = 64, n = 8, r = 2, a = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: i,
      radialSegments: n,
      p: r,
      q: a
    }, i = Math.floor(i), n = Math.floor(n);
    const o = [], l = [], c = [], h = [], u = new M(), d = new M(), p = new M(), f = new M(), y = new M(), A = new M(), m = new M();
    for (let g = 0; g <= i; ++g) {
      const _ = g / i * r * Math.PI * 2;
      v(_, r, a, e, p), v(_ + 0.01, r, a, e, f), A.subVectors(f, p), m.addVectors(f, p), y.crossVectors(A, m), m.crossVectors(y, A), y.normalize(), m.normalize();
      for (let w = 0; w <= n; ++w) {
        const S = w / n * Math.PI * 2, C = -t * Math.cos(S), E = t * Math.sin(S);
        u.x = p.x + (C * m.x + E * y.x), u.y = p.y + (C * m.y + E * y.y), u.z = p.z + (C * m.z + E * y.z), l.push(u.x, u.y, u.z), d.subVectors(u, p).normalize(), c.push(d.x, d.y, d.z), h.push(g / i), h.push(w / n);
      }
    }
    for (let g = 1; g <= i; g++)
      for (let _ = 1; _ <= n; _++) {
        const w = (n + 1) * (g - 1) + (_ - 1), S = (n + 1) * g + (_ - 1), C = (n + 1) * g + _, E = (n + 1) * (g - 1) + _;
        o.push(w, S, E), o.push(S, C, E);
      }
    this.setIndex(o), this.setAttribute("position", new Te(l, 3)), this.setAttribute("normal", new Te(c, 3)), this.setAttribute("uv", new Te(h, 2));
    function v(g, _, w, S, C) {
      const E = Math.cos(g), x = Math.sin(g), b = w / _ * g, D = Math.cos(b);
      C.x = S * (2 + D) * 0.5 * E, C.y = S * (2 + D) * x * 0.5, C.z = S * Math.sin(b) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new TA(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class IA extends Ze {
  constructor(e = new Dw(new M(-1, -1, 0), new M(-1, 1, 0), new M(1, 1, 0)), t = 64, i = 1, n = 8, r = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: i,
      radialSegments: n,
      closed: r
    };
    const a = e.computeFrenetFrames(t, r);
    this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
    const o = new M(), l = new M(), c = new ie();
    let h = new M();
    const u = [], d = [], p = [], f = [];
    y(), this.setIndex(f), this.setAttribute("position", new Te(u, 3)), this.setAttribute("normal", new Te(d, 3)), this.setAttribute("uv", new Te(p, 2));
    function y() {
      for (let g = 0; g < t; g++)
        A(g);
      A(r === !1 ? t : 0), v(), m();
    }
    function A(g) {
      h = e.getPointAt(g / t, h);
      const _ = a.normals[g], w = a.binormals[g];
      for (let S = 0; S <= n; S++) {
        const C = S / n * Math.PI * 2, E = Math.sin(C), x = -Math.cos(C);
        l.x = x * _.x + E * w.x, l.y = x * _.y + E * w.y, l.z = x * _.z + E * w.z, l.normalize(), d.push(l.x, l.y, l.z), o.x = h.x + i * l.x, o.y = h.y + i * l.y, o.z = h.z + i * l.z, u.push(o.x, o.y, o.z);
      }
    }
    function m() {
      for (let g = 1; g <= t; g++)
        for (let _ = 1; _ <= n; _++) {
          const w = (n + 1) * (g - 1) + (_ - 1), S = (n + 1) * g + (_ - 1), C = (n + 1) * g + _, E = (n + 1) * (g - 1) + _;
          f.push(w, S, E), f.push(S, C, E);
        }
    }
    function v() {
      for (let g = 0; g <= t; g++)
        for (let _ = 0; _ <= n; _++)
          c.x = g / t, c.y = _ / n, p.push(c.x, c.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new IA(
      new rp[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class DA extends Ze {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], i = /* @__PURE__ */ new Set(), n = new M(), r = new M();
      if (e.index !== null) {
        const a = e.attributes.position, o = e.index;
        let l = e.groups;
        l.length === 0 && (l = [{ start: 0, count: o.count, materialIndex: 0 }]);
        for (let c = 0, h = l.length; c < h; ++c) {
          const u = l[c], d = u.start, p = u.count;
          for (let f = d, y = d + p; f < y; f += 3)
            for (let A = 0; A < 3; A++) {
              const m = o.getX(f + A), v = o.getX(f + (A + 1) % 3);
              n.fromBufferAttribute(a, m), r.fromBufferAttribute(a, v), bv(n, r, i) === !0 && (t.push(n.x, n.y, n.z), t.push(r.x, r.y, r.z));
            }
        }
      } else {
        const a = e.attributes.position;
        for (let o = 0, l = a.count / 3; o < l; o++)
          for (let c = 0; c < 3; c++) {
            const h = 3 * o + c, u = 3 * o + (c + 1) % 3;
            n.fromBufferAttribute(a, h), r.fromBufferAttribute(a, u), bv(n, r, i) === !0 && (t.push(n.x, n.y, n.z), t.push(r.x, r.y, r.z));
          }
      }
      this.setAttribute("position", new Te(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function bv(s, e, t) {
  const i = `${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`, n = `${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;
  return t.has(i) === !0 || t.has(n) === !0 ? !1 : (t.add(i), t.add(n), !0);
}
var Sv = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: Si,
  CapsuleGeometry: vA,
  CircleGeometry: _A,
  ConeGeometry: xA,
  CylinderGeometry: yn,
  DodecahedronGeometry: wA,
  EdgesGeometry: DD,
  ExtrudeGeometry: EA,
  IcosahedronGeometry: bA,
  LatheGeometry: Hp,
  OctahedronGeometry: ya,
  PlaneGeometry: No,
  PolyhedronGeometry: ko,
  RingGeometry: SA,
  ShapeGeometry: CA,
  SphereGeometry: fr,
  TetrahedronGeometry: MA,
  TorusGeometry: kh,
  TorusKnotGeometry: TA,
  TubeGeometry: IA,
  WireframeGeometry: DA
});
class JD extends Yi {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new se(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class $D extends ln {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class Go extends Yi {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new se(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new se(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ts, this.normalScale = new ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Sc extends Go {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ie(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Di(2.5 * (this.ior - 1) / (this.ior + 1), 0, 2.5);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new se(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new se(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new se(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class Hl extends Yi {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new se(16777215), this.specular = new se(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new se(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ts, this.normalScale = new ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = _c, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class ZD extends Yi {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new se(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new se(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ts, this.normalScale = new ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class Uw extends Yi {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ts, this.normalScale = new ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class Fw extends Yi {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new se(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new se(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ts, this.normalScale = new ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = _c, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class eR extends Yi {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new se(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ts, this.normalScale = new ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class tR extends Ri {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function oo(s, e, t) {
  return !s || // let 'undefined' and 'null' pass
  !t && s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s);
}
function Ow(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function Nw(s) {
  function e(n, r) {
    return s[n] - s[r];
  }
  const t = s.length, i = new Array(t);
  for (let n = 0; n !== t; ++n) i[n] = n;
  return i.sort(e), i;
}
function sg(s, e, t) {
  const i = s.length, n = new s.constructor(i);
  for (let r = 0, a = 0; a !== i; ++r) {
    const o = t[r] * e;
    for (let l = 0; l !== e; ++l)
      n[a++] = s[o + l];
  }
  return n;
}
function RA(s, e, t, i) {
  let n = 1, r = s[0];
  for (; r !== void 0 && r[i] === void 0; )
    r = s[n++];
  if (r === void 0) return;
  let a = r[i];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        a = r[i], a !== void 0 && (e.push(r.time), t.push.apply(t, a)), r = s[n++];
      while (r !== void 0);
    else if (a.toArray !== void 0)
      do
        a = r[i], a !== void 0 && (e.push(r.time), a.toArray(t, t.length)), r = s[n++];
      while (r !== void 0);
    else
      do
        a = r[i], a !== void 0 && (e.push(r.time), t.push(a)), r = s[n++];
      while (r !== void 0);
}
function iR(s, e, t, i, n = 30) {
  const r = s.clone();
  r.name = e;
  const a = [];
  for (let l = 0; l < r.tracks.length; ++l) {
    const c = r.tracks[l], h = c.getValueSize(), u = [], d = [];
    for (let p = 0; p < c.times.length; ++p) {
      const f = c.times[p] * n;
      if (!(f < t || f >= i)) {
        u.push(c.times[p]);
        for (let y = 0; y < h; ++y)
          d.push(c.values[p * h + y]);
      }
    }
    u.length !== 0 && (c.times = oo(u, c.times.constructor), c.values = oo(d, c.values.constructor), a.push(c));
  }
  r.tracks = a;
  let o = 1 / 0;
  for (let l = 0; l < r.tracks.length; ++l)
    o > r.tracks[l].times[0] && (o = r.tracks[l].times[0]);
  for (let l = 0; l < r.tracks.length; ++l)
    r.tracks[l].shift(-1 * o);
  return r.resetDuration(), r;
}
function nR(s, e = 0, t = s, i = 30) {
  i <= 0 && (i = 30);
  const n = t.tracks.length, r = e / i;
  for (let a = 0; a < n; ++a) {
    const o = t.tracks[a], l = o.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const c = s.tracks.find(function(m) {
      return m.name === o.name && m.ValueTypeName === l;
    });
    if (c === void 0) continue;
    let h = 0;
    const u = o.getValueSize();
    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = u / 3);
    let d = 0;
    const p = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = p / 3);
    const f = o.times.length - 1;
    let y;
    if (r <= o.times[0]) {
      const m = h, v = u - h;
      y = o.values.slice(m, v);
    } else if (r >= o.times[f]) {
      const m = f * u + h, v = m + u - h;
      y = o.values.slice(m, v);
    } else {
      const m = o.createInterpolant(), v = h, g = u - h;
      m.evaluate(r), y = m.resultBuffer.slice(v, g);
    }
    l === "quaternion" && new rt().fromArray(y).normalize().conjugate().toArray(y);
    const A = c.times.length;
    for (let m = 0; m < A; ++m) {
      const v = m * p + d;
      if (l === "quaternion")
        rt.multiplyQuaternionsFlat(
          c.values,
          v,
          y,
          0,
          c.values,
          v
        );
      else {
        const g = p - d * 2;
        for (let _ = 0; _ < g; ++_)
          c.values[v + _] -= y[_];
      }
    }
  }
  return s.blendMode = ow, s;
}
const sG = {
  convertArray: oo,
  isTypedArray: Ow,
  getKeyframeOrder: Nw,
  sortedArray: sg,
  flattenJSON: RA,
  subclip: iR,
  makeClipAdditive: nR
};
class lu {
  constructor(e, t, i, n) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex, n = t[i], r = t[i - 1];
    e: {
      t: {
        let a;
        i: {
          n: if (!(e < n)) {
            for (let o = i + 2; ; ) {
              if (n === void 0) {
                if (e < r) break n;
                return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
              }
              if (i === o) break;
              if (r = n, n = t[++i], e < n)
                break t;
            }
            a = t.length;
            break i;
          }
          if (!(e >= r)) {
            const o = t[1];
            e < o && (i = 2, r = o);
            for (let l = i - 2; ; ) {
              if (r === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (i === l) break;
              if (n = r, r = t[--i - 1], e >= r)
                break t;
            }
            a = i, i = 0;
            break i;
          }
          break e;
        }
        for (; i < a; ) {
          const o = i + a >>> 1;
          e < t[o] ? a = o : i = o + 1;
        }
        if (n = t[i], r = t[i - 1], r === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (n === void 0)
          return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
      }
      this._cachedIndex = i, this.intervalChanged_(i, r, n);
    }
    return this.interpolate_(i, r, e, n);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n;
    for (let a = 0; a !== n; ++a)
      t[a] = i[r + a];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class sR extends lu {
  constructor(e, t, i, n) {
    super(e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: Sl,
      endingEnd: Sl
    };
  }
  intervalChanged_(e, t, i) {
    const n = this.parameterPositions;
    let r = e - 2, a = e + 1, o = n[r], l = n[a];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case Cl:
          r = e, o = 2 * t - i;
          break;
        case $d:
          r = n.length - 2, o = t + n[r] - n[r + 1];
          break;
        default:
          r = e, o = i;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case Cl:
          a = e, l = 2 * i - t;
          break;
        case $d:
          a = 1, l = i + n[1] - n[0];
          break;
        default:
          a = e - 1, l = t;
      }
    const c = (i - t) * 0.5, h = this.valueSize;
    this._weightPrev = c / (t - o), this._weightNext = c / (l - i), this._offsetPrev = r * h, this._offsetNext = a * h;
  }
  interpolate_(e, t, i, n) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, h = this._offsetPrev, u = this._offsetNext, d = this._weightPrev, p = this._weightNext, f = (i - t) / (n - t), y = f * f, A = y * f, m = -d * A + 2 * d * y - d * f, v = (1 + d) * A + (-1.5 - 2 * d) * y + (-0.5 + d) * f + 1, g = (-1 - p) * A + (1.5 + p) * y + 0.5 * f, _ = p * A - p * y;
    for (let w = 0; w !== o; ++w)
      r[w] = m * a[h + w] + v * a[c + w] + g * a[l + w] + _ * a[u + w];
    return r;
  }
}
class kw extends lu {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, h = (i - t) / (n - t), u = 1 - h;
    for (let d = 0; d !== o; ++d)
      r[d] = a[c + d] * u + a[l + d] * h;
    return r;
  }
}
class rR extends lu {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class xr {
  constructor(e, t, i, n) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = oo(t, this.TimeBufferType), this.values = oo(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON)
      i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: oo(e.times, Array),
        values: oo(e.values, Array)
      };
      const n = e.getInterpolation();
      n !== e.DefaultInterpolation && (i.interpolation = n);
    }
    return i.type = e.ValueTypeName, i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new rR(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new kw(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new sR(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Zl:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Ao:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case gf:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Zl;
      case this.InterpolantFactoryMethodLinear:
        return Ao;
      case this.InterpolantFactoryMethodSmooth:
        return gf;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i)
        t[i] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i)
        t[i] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const i = this.times, n = i.length;
    let r = 0, a = n - 1;
    for (; r !== n && i[r] < e; )
      ++r;
    for (; a !== -1 && i[a] > t; )
      --a;
    if (++a, r !== 0 || a !== n) {
      r >= a && (a = Math.max(a, 1), r = a - 1);
      const o = this.getValueSize();
      this.times = i.slice(r, a), this.values = this.values.slice(r * o, a * o);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const i = this.times, n = this.values, r = i.length;
    r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let a = null;
    for (let o = 0; o !== r; o++) {
      const l = i[o];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, l), e = !1;
        break;
      }
      if (a !== null && a > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a), e = !1;
        break;
      }
      a = l;
    }
    if (n !== void 0 && Ow(n))
      for (let o = 0, l = n.length; o !== l; ++o) {
        const c = n[o];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), i = this.getValueSize(), n = this.getInterpolation() === gf, r = e.length - 1;
    let a = 1;
    for (let o = 1; o < r; ++o) {
      let l = !1;
      const c = e[o], h = e[o + 1];
      if (c !== h && (o !== 1 || c !== e[0]))
        if (n)
          l = !0;
        else {
          const u = o * i, d = u - i, p = u + i;
          for (let f = 0; f !== i; ++f) {
            const y = t[u + f];
            if (y !== t[d + f] || y !== t[p + f]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (o !== a) {
          e[a] = e[o];
          const u = o * i, d = a * i;
          for (let p = 0; p !== i; ++p)
            t[d + p] = t[u + p];
        }
        ++a;
      }
    }
    if (r > 0) {
      e[a] = e[r];
      for (let o = r * i, l = a * i, c = 0; c !== i; ++c)
        t[l + c] = t[o + c];
      ++a;
    }
    return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * i)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), i = this.constructor, n = new i(this.name, e, t);
    return n.createInterpolant = this.createInterpolant, n;
  }
}
xr.prototype.TimeBufferType = Float32Array;
xr.prototype.ValueBufferType = Float32Array;
xr.prototype.DefaultInterpolation = Ao;
class Cc extends xr {
}
Cc.prototype.ValueTypeName = "bool";
Cc.prototype.ValueBufferType = Array;
Cc.prototype.DefaultInterpolation = Zl;
Cc.prototype.InterpolantFactoryMethodLinear = void 0;
Cc.prototype.InterpolantFactoryMethodSmooth = void 0;
class Gw extends xr {
}
Gw.prototype.ValueTypeName = "color";
class vo extends xr {
}
vo.prototype.ValueTypeName = "number";
class aR extends lu {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = (i - t) / (n - t);
    let c = e * o;
    for (let h = c + o; c !== h; c += 4)
      rt.slerpFlat(r, 0, a, c - o, a, c, l);
    return r;
  }
}
class Ra extends xr {
  InterpolantFactoryMethodLinear(e) {
    return new aR(this.times, this.values, this.getValueSize(), e);
  }
}
Ra.prototype.ValueTypeName = "quaternion";
Ra.prototype.DefaultInterpolation = Ao;
Ra.prototype.InterpolantFactoryMethodSmooth = void 0;
class Mc extends xr {
}
Mc.prototype.ValueTypeName = "string";
Mc.prototype.ValueBufferType = Array;
Mc.prototype.DefaultInterpolation = Zl;
Mc.prototype.InterpolantFactoryMethodLinear = void 0;
Mc.prototype.InterpolantFactoryMethodSmooth = void 0;
class _o extends xr {
}
_o.prototype.ValueTypeName = "vector";
class ic {
  constructor(e, t = -1, i, n = sA) {
    this.name = e, this.tracks = i, this.duration = t, this.blendMode = n, this.uuid = ps(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], i = e.tracks, n = 1 / (e.fps || 1);
    for (let a = 0, o = i.length; a !== o; ++a)
      t.push(lR(i[a]).scale(n));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return r.uuid = e.uuid, r;
  }
  static toJSON(e) {
    const t = [], i = e.tracks, n = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let r = 0, a = i.length; r !== a; ++r)
      t.push(xr.toJSON(i[r]));
    return n;
  }
  static CreateFromMorphTargetSequence(e, t, i, n) {
    const r = t.length, a = [];
    for (let o = 0; o < r; o++) {
      let l = [], c = [];
      l.push(
        (o + r - 1) % r,
        o,
        (o + 1) % r
      ), c.push(0, 1, 0);
      const h = Nw(l);
      l = sg(l, 1, h), c = sg(c, 1, h), !n && l[0] === 0 && (l.push(r), c.push(c[0])), a.push(
        new vo(
          ".morphTargetInfluences[" + t[o].name + "]",
          l,
          c
        ).scale(1 / i)
      );
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const n = e;
      i = n.geometry && n.geometry.animations || n.animations;
    }
    for (let n = 0; n < i.length; n++)
      if (i[n].name === t)
        return i[n];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const n = {}, r = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o], h = c.name.match(r);
      if (h && h.length > 1) {
        const u = h[1];
        let d = n[u];
        d || (n[u] = d = []), d.push(c);
      }
    }
    const a = [];
    for (const o in n)
      a.push(this.CreateFromMorphTargetSequence(o, n[o], t, i));
    return a;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const i = function(u, d, p, f, y) {
      if (p.length !== 0) {
        const A = [], m = [];
        RA(p, A, m, f), A.length !== 0 && y.push(new u(d, A, m));
      }
    }, n = [], r = e.name || "default", a = e.fps || 30, o = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let u = 0; u < c.length; u++) {
      const d = c[u].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const p = {};
          let f;
          for (f = 0; f < d.length; f++)
            if (d[f].morphTargets)
              for (let y = 0; y < d[f].morphTargets.length; y++)
                p[d[f].morphTargets[y]] = -1;
          for (const y in p) {
            const A = [], m = [];
            for (let v = 0; v !== d[f].morphTargets.length; ++v) {
              const g = d[f];
              A.push(g.time), m.push(g.morphTarget === y ? 1 : 0);
            }
            n.push(new vo(".morphTargetInfluence[" + y + "]", A, m));
          }
          l = p.length * a;
        } else {
          const p = ".bones[" + t[u].name + "]";
          i(
            _o,
            p + ".position",
            d,
            "pos",
            n
          ), i(
            Ra,
            p + ".quaternion",
            d,
            "rot",
            n
          ), i(
            _o,
            p + ".scale",
            d,
            "scl",
            n
          );
        }
    }
    return n.length === 0 ? null : new this(r, l, n, o);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, n = e.length; i !== n; ++i) {
      const r = this.tracks[i];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function oR(s) {
  switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return vo;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return _o;
    case "color":
      return Gw;
    case "quaternion":
      return Ra;
    case "bool":
    case "boolean":
      return Cc;
    case "string":
      return Mc;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
}
function lR(s) {
  if (s.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = oR(s.type);
  if (s.times === void 0) {
    const t = [], i = [];
    RA(s.keys, t, i, "value"), s.times = t, s.values = i;
  }
  return e.parse !== void 0 ? e.parse(s) : new e(s.name, s.times, s.values, s.interpolation);
}
const us = {
  enabled: !1,
  files: {},
  add: function(s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function(s, e) {
    return this.enabled === !1 ? e ? Promise.resolve() : void 0 : e ? Promise.resolve(this.files[s]) : this.files[s];
  },
  remove: function(s) {
    delete this.files[s];
  },
  clear: function() {
    this.files = {};
  }
};
class BA {
  constructor(e, t, i) {
    const n = this;
    let r = !1, a = 0, o = 0, l;
    const c = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(h) {
      o++, r === !1 && n.onStart !== void 0 && n.onStart(h, a, o), r = !0;
    }, this.itemEnd = function(h) {
      a++, n.onProgress !== void 0 && n.onProgress(h, a, o), a === o && (r = !1, n.onLoad !== void 0 && n.onLoad());
    }, this.itemError = function(h) {
      n.onError !== void 0 && n.onError(h);
    }, this.resolveURL = function(h) {
      return l ? l(h) : h;
    }, this.setURLModifier = function(h) {
      return l = h, this;
    }, this.addHandler = function(h, u) {
      return c.push(h, u), this;
    }, this.removeHandler = function(h) {
      const u = c.indexOf(h);
      return u !== -1 && c.splice(u, 2), this;
    }, this.getHandler = function(h) {
      for (let u = 0, d = c.length; u < d; u += 2) {
        const p = c[u], f = c[u + 1];
        if (p.global && (p.lastIndex = 0), p.test(h))
          return f;
      }
      return null;
    };
  }
}
const zw = /* @__PURE__ */ new BA();
class ui {
  constructor(e) {
    this.manager = e !== void 0 ? e : zw, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const i = this;
    return new Promise(function(n, r) {
      i.load(e, n, t, r);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
ui.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Rr = {};
class cR extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class ti extends ui {
  constructor(e) {
    super(e), this.responseType = "text", this.useCache = !0;
  }
  load(e, t, i, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e), (this.useCache ? us.get(e, this.responseType, this.mimeType) : Promise.resolve(void 0)).then((r) => {
      if (r !== void 0)
        return this.manager.itemStart(e), setTimeout(() => {
          t && t(r), this.manager.itemEnd(e);
        }, 0), r;
      if (Rr[e] !== void 0) {
        Rr[e].push({
          onLoad: t,
          onProgress: i,
          onError: n
        });
        return;
      }
      Rr[e] = [], Rr[e].push({
        onLoad: t,
        onProgress: i,
        onError: n
      });
      const a = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin"
        // An abort controller could be added within a future PR
      }), o = this.mimeType, l = this.responseType;
      fetch(a).then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
            return c;
          const h = Rr[e], u = c.body.getReader(), d = c.headers.get("Content-Length") || c.headers.get("X-File-Size"), p = d ? parseInt(d) : 0, f = p !== 0;
          let y = 0;
          const A = new ReadableStream({
            start(m) {
              v();
              function v() {
                u.read().then(({ done: g, value: _ }) => {
                  if (g)
                    m.close();
                  else {
                    y += _.byteLength;
                    const w = new ProgressEvent("progress", { lengthComputable: f, loaded: y, total: p });
                    for (let S = 0, C = h.length; S < C; S++) {
                      const E = h[S];
                      E.onProgress && E.onProgress(w);
                    }
                    m.enqueue(_), v();
                  }
                });
              }
            }
          });
          return new Response(A);
        } else
          throw new cR(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
      }).then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((h) => new DOMParser().parseFromString(h, o));
          case "json":
            return c.json();
          default:
            if (o === void 0)
              return c.text();
            {
              const u = /charset="?([^;"\s]*)"?/i.exec(o), d = u && u[1] ? u[1].toLowerCase() : void 0, p = new TextDecoder(d);
              return c.arrayBuffer().then((f) => p.decode(f));
            }
        }
      }).then((c) => {
        this.useCache && us.add(e, c, this.responseType);
        const h = Rr[e];
        delete Rr[e];
        for (let u = 0, d = h.length; u < d; u++) {
          const p = h[u];
          p.onLoad && p.onLoad(c);
        }
      }).catch((c) => {
        const h = Rr[e];
        if (h === void 0)
          throw this.manager.itemError(e), c;
        delete Rr[e];
        for (let u = 0, d = h.length; u < d; u++) {
          const p = h[u];
          p.onError && p.onError(c);
        }
        this.manager.itemError(e);
      }).finally(() => {
        this.useCache && this.manager.itemEnd(e);
      }), this.useCache && this.manager.itemStart(e);
    });
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class rG extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, a = new ti(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(JSON.parse(o)));
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const n = ic.parse(e[i]);
      t.push(n);
    }
    return t;
  }
}
class hR extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, a = [], o = new ba(), l = new ti(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(r.withCredentials);
    let c = 0;
    function h(u) {
      l.load(e[u], function(d) {
        const p = r.parse(d, !0);
        a[u] = {
          width: p.width,
          height: p.height,
          format: p.format,
          mipmaps: p.mipmaps
        }, c += 1, c === 6 && (p.mipmapCount === 1 && (o.minFilter = tt), o.image = a, o.format = p.format, o.needsUpdate = !0, t && t(o));
      }, i, n);
    }
    if (Array.isArray(e))
      for (let u = 0, d = e.length; u < d; ++u)
        h(u);
    else
      l.load(e, function(u) {
        const d = r.parse(u, !0);
        if (d.isCubemap) {
          const p = d.mipmaps.length / d.mipmapCount;
          for (let f = 0; f < p; f++) {
            a[f] = { mipmaps: [] };
            for (let y = 0; y < d.mipmapCount; y++)
              a[f].mipmaps.push(d.mipmaps[f * d.mipmapCount + y]), a[f].format = d.format, a[f].width = d.width, a[f].height = d.height;
          }
          o.image = a;
        } else
          o.image.width = d.width, o.image.height = d.height, o.mipmaps = d.mipmaps;
        d.mipmapCount === 1 && (o.minFilter = tt), o.format = d.format, o.needsUpdate = !0, t && t(o);
      }, i, n);
    return o;
  }
}
class Gh extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = e;
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const a = this, o = us.get(e);
    if (o !== void 0)
      return a.manager.itemStart(e), setTimeout(function() {
        t && t(o), a.manager.itemEnd(e);
      }, 0), o;
    const l = Lh("img");
    function c() {
      u(), us.add(e, this), t && t(this), a.manager.itemEnd(e);
    }
    function h(d) {
      u(), n && n(d), a.manager.itemError(e), a.manager.itemEnd(e);
    }
    function u() {
      l.removeEventListener("load", c, !1), l.removeEventListener("error", h, !1);
    }
    return l.addEventListener("load", c, !1), l.addEventListener("error", h, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin), a.manager.itemStart(e), us.get(e, "blob").then((d) => {
      if (d !== void 0 && !d.type.startsWith("text/plain")) {
        d.type || (e.endsWith(".svg") || e.startsWith("data:image/svg")) && (d = new Blob([d], { type: "image/svg+xml" })), l.src = URL.createObjectURL(d);
        return;
      }
      const p = new ti(this.manager);
      p.useCache = !1, p.setPath(this.path), p.setCrossOrigin(this.crossOrigin), p.setResponseType("blob"), p.load(r, function(f) {
        f.type || (e.endsWith(".svg") || e.startsWith("data:image/svg")) && (f = new Blob([f], { type: "image/svg+xml" })), us.add(e, f, "blob"), l.src = URL.createObjectURL(f);
      }, i, (f) => {
        u(), n && n(f);
      });
    }), l;
  }
}
class aG extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = new Fp();
    r.colorSpace = dt;
    const a = new Gh(this.manager);
    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
    let o = 0;
    function l(c) {
      a.load(e[c], function(h) {
        r.images[c] = h, o++, o === 6 && (r.needsUpdate = !0, t && t(r));
      }, void 0, n);
    }
    for (let c = 0; c < e.length; ++c)
      l(c);
    return r;
  }
}
class Qw extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, a = new Wr(), o = new ti(this.manager);
    return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(r.withCredentials), o.load(e, function(l) {
      let c;
      try {
        c = r.parse(l);
      } catch (h) {
        if (n !== void 0)
          n(h);
        else {
          console.error(h);
          return;
        }
      }
      c.image !== void 0 ? a.image = c.image : c.data !== void 0 && (a.image.width = c.width, a.image.height = c.height, a.image.data = c.data, a.image.complete = !0), a.wrapS = c.wrapS !== void 0 ? c.wrapS : Zt, a.wrapT = c.wrapT !== void 0 ? c.wrapT : Zt, a.magFilter = c.magFilter !== void 0 ? c.magFilter : tt, a.minFilter = c.minFilter !== void 0 ? c.minFilter : tt, a.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.colorSpace !== void 0 ? a.colorSpace = c.colorSpace : c.encoding !== void 0 && (a.encoding = c.encoding), c.flipY !== void 0 && (a.flipY = c.flipY), c.format !== void 0 && (a.format = c.format), c.type !== void 0 && (a.type = c.type), c.mipmaps !== void 0 && (a.mipmaps = c.mipmaps, a.minFilter = Qn), c.mipmapCount === 1 && (a.minFilter = tt), c.generateMipmaps !== void 0 && (a.generateMipmaps = c.generateMipmaps), a.needsUpdate = !0, t && t(a, c);
    }, i, n), a;
  }
}
class xo extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = new Nt(), a = new Gh(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
      r.image = o, r.needsUpdate = !0, t !== void 0 && t(r);
    }, i, function(o) {
      r.image instanceof ImageData && (r.needsUpdate = !0), n !== void 0 && n(o);
    }), r;
  }
}
class zo extends ut {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new se(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class PA extends zo {
  constructor(e, t, i) {
    super(e, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(ut.DEFAULT_UP), this.updateMatrix(), this.groundColor = new se(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const Xf = /* @__PURE__ */ new Ue(), Cv = /* @__PURE__ */ new M(), Mv = /* @__PURE__ */ new M();
class LA {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ie(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ue(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new uA(), this._frameExtents = new ie(1, 1), this._viewportCount = 1, this._viewports = [
      new it(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, i = this.matrix;
    Cv.setFromMatrixPosition(e.matrixWorld), t.position.copy(Cv), Mv.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Mv), t.updateMatrixWorld(), Xf.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Xf), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(Xf);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.normalBias = e.normalBias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class uR extends LA {
  constructor() {
    super(new ki(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, i = ec * 2 * e.angle * this.focus, n = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
    (i !== t.fov || n !== t.aspect || r !== t.far) && (t.fov = i, t.aspect = n, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class cu extends zo {
  constructor(e, t, i = 0, n = Math.PI / 3, r = 0, a = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(ut.DEFAULT_UP), this.updateMatrix(), this.target = new ut(), this.distance = i, this.angle = n, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new uR();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const Tv = /* @__PURE__ */ new Ue(), th = /* @__PURE__ */ new M(), Yf = /* @__PURE__ */ new M();
class dR extends LA {
  constructor() {
    super(new ki(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new ie(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new it(2, 1, 1, 1),
      // negative X
      new it(0, 1, 1, 1),
      // positive Z
      new it(3, 1, 1, 1),
      // negative Z
      new it(1, 1, 1, 1),
      // positive Y
      new it(3, 0, 1, 1),
      // negative Y
      new it(1, 0, 1, 1)
    ], this._cubeDirections = [
      new M(1, 0, 0),
      new M(-1, 0, 0),
      new M(0, 0, 1),
      new M(0, 0, -1),
      new M(0, 1, 0),
      new M(0, -1, 0)
    ], this._cubeUps = [
      new M(0, 1, 0),
      new M(0, 1, 0),
      new M(0, 1, 0),
      new M(0, 1, 0),
      new M(0, 0, 1),
      new M(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const i = this.camera, n = this.matrix, r = e.distance || i.far;
    r !== i.far && (i.far = r, i.updateProjectionMatrix()), th.setFromMatrixPosition(e.matrixWorld), i.position.copy(th), Yf.copy(i.position), Yf.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(Yf), i.updateMatrixWorld(), n.makeTranslation(-th.x, -th.y, -th.z), Tv.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Tv);
  }
}
class nc extends zo {
  constructor(e, t, i = 0, n = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new dR();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class pR extends LA {
  constructor() {
    super(new _r(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class hu extends zo {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(ut.DEFAULT_UP), this.updateMatrix(), this.target = new ut(), this.shadow = new pR();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class UA extends zo {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class FA extends zo {
  constructor(e, t, i = 10, n = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = n;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class fR {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new M());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const i = e.x, n = e.y, r = e.z, a = this.coefficients;
    return t.copy(a[0]).multiplyScalar(0.282095), t.addScaledVector(a[1], 0.488603 * n), t.addScaledVector(a[2], 0.488603 * r), t.addScaledVector(a[3], 0.488603 * i), t.addScaledVector(a[4], 1.092548 * (i * n)), t.addScaledVector(a[5], 1.092548 * (n * r)), t.addScaledVector(a[6], 0.315392 * (3 * r * r - 1)), t.addScaledVector(a[7], 1.092548 * (i * r)), t.addScaledVector(a[8], 0.546274 * (i * i - n * n)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const i = e.x, n = e.y, r = e.z, a = this.coefficients;
    return t.copy(a[0]).multiplyScalar(0.886227), t.addScaledVector(a[1], 2 * 0.511664 * n), t.addScaledVector(a[2], 2 * 0.511664 * r), t.addScaledVector(a[3], 2 * 0.511664 * i), t.addScaledVector(a[4], 2 * 0.429043 * i * n), t.addScaledVector(a[5], 2 * 0.429043 * n * r), t.addScaledVector(a[6], 0.743125 * r * r - 0.247708), t.addScaledVector(a[7], 2 * 0.429043 * i * r), t.addScaledVector(a[8], 0.429043 * (i * i - n * n)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let n = 0; n < 9; n++)
      i[n].fromArray(e, t + n * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let n = 0; n < 9; n++)
      i[n].toArray(e, t + n * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const i = e.x, n = e.y, r = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * n, t[2] = 0.488603 * r, t[3] = 0.488603 * i, t[4] = 1.092548 * i * n, t[5] = 1.092548 * n * r, t[6] = 0.315392 * (3 * r * r - 1), t[7] = 1.092548 * i * r, t[8] = 0.546274 * (i * i - n * n);
  }
}
class mR extends zo {
  constructor(e = new fR(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class Wp extends ui {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, i, n) {
    const r = this, a = new ti(r.manager);
    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(JSON.parse(o)));
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e) {
    const t = this.textures;
    function i(a) {
      return t[a] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", a), t[a];
    }
    const n = e.metadata && e.metadata.version <= 4.5 ? Mt : void 0, r = Wp.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color, n), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new se().setHex(e.sheenColor, n)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive, n), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular, n), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor, n), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor, n), e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc), e.blendDst !== void 0 && (r.blendDst = e.blendDst), e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== void 0 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const a in e.uniforms) {
        const o = e.uniforms[a];
        switch (r.uniforms[a] = {}, o.type) {
          case "t":
            r.uniforms[a].value = i(o.value);
            break;
          case "c":
            r.uniforms[a].value = new se().setHex(o.value, n);
            break;
          case "v2":
            r.uniforms[a].value = new ie().fromArray(o.value);
            break;
          case "v3":
            r.uniforms[a].value = new M().fromArray(o.value);
            break;
          case "v4":
            r.uniforms[a].value = new it().fromArray(o.value);
            break;
          case "m3":
            r.uniforms[a].value = new yt().fromArray(o.value);
            break;
          case "m4":
            r.uniforms[a].value = new Ue().fromArray(o.value);
            break;
          default:
            r.uniforms[a].value = o.value;
        }
      }
    if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const a in e.extensions)
        r.extensions[a] = e.extensions[a];
    if (e.lights !== void 0 && (r.lights = e.lights), e.clipping !== void 0 && (r.clipping = e.clipping), e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = i(e.map)), e.matcap !== void 0 && (r.matcap = i(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let a = e.normalScale;
      Array.isArray(a) === !1 && (a = [a, a]), r.normalScale = new ie().fromArray(a);
    }
    return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = i(e.envMap)), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new ie().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)), e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)), r;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: JD,
      SpriteMaterial: Gp,
      RawShaderMaterial: $D,
      ShaderMaterial: ln,
      PointsMaterial: Qr,
      MeshPhysicalMaterial: Sc,
      MeshStandardMaterial: Go,
      MeshPhongMaterial: Hl,
      MeshToonMaterial: ZD,
      MeshNormalMaterial: Uw,
      MeshLambertMaterial: Fw,
      MeshDepthMaterial: Np,
      MeshDistanceMaterial: Ew,
      MeshBasicMaterial: $s,
      MeshMatcapMaterial: eR,
      LineDashedMaterial: tR,
      LineBasicMaterial: Ri,
      Material: Yi
    };
    return new t[e]();
  }
}
class hr {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, n = e.length; i < n; i++)
      t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class Hw extends Ze {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class Vw extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, a = new ti(r.manager);
    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(JSON.parse(o)));
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e) {
    const t = {}, i = {};
    function n(p, f) {
      if (t[f] !== void 0) return t[f];
      const A = p.interleavedBuffers[f], m = r(p, A.buffer), v = Ml(A.type, m), g = new au(v, A.stride);
      return g.uuid = A.uuid, t[f] = g, g;
    }
    function r(p, f) {
      if (i[f] !== void 0) return i[f];
      const A = p.arrayBuffers[f], m = new Uint32Array(A).buffer;
      return i[f] = m, m;
    }
    const a = e.isInstancedBufferGeometry ? new Hw() : new Ze(), o = e.data.index;
    if (o !== void 0) {
      const p = Ml(o.type, o.array);
      a.setIndex(new Je(p, 1));
    }
    const l = e.data.attributes;
    for (const p in l) {
      const f = l[p];
      let y;
      if (f.isInterleavedBufferAttribute) {
        const A = n(e.data, f.data);
        y = new Cn(A, f.itemSize, f.offset, f.normalized);
      } else {
        const A = Ml(f.type, f.array), m = f.isInstancedBufferAttribute ? Da : Je;
        y = new m(A, f.itemSize, f.normalized);
      }
      f.name !== void 0 && (y.name = f.name), f.usage !== void 0 && y.setUsage(f.usage), f.updateRange !== void 0 && (y.updateRange.offset = f.updateRange.offset, y.updateRange.count = f.updateRange.count), a.setAttribute(p, y);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const p in c) {
        const f = c[p], y = [];
        for (let A = 0, m = f.length; A < m; A++) {
          const v = f[A];
          let g;
          if (v.isInterleavedBufferAttribute) {
            const _ = n(e.data, v.data);
            g = new Cn(_, v.itemSize, v.offset, v.normalized);
          } else {
            const _ = Ml(v.type, v.array);
            g = new Je(_, v.itemSize, v.normalized);
          }
          v.name !== void 0 && (g.name = v.name), y.push(g);
        }
        a.morphAttributes[p] = y;
      }
    e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
    const u = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (u !== void 0)
      for (let p = 0, f = u.length; p !== f; ++p) {
        const y = u[p];
        a.addGroup(y.start, y.count, y.materialIndex);
      }
    const d = e.data.boundingSphere;
    if (d !== void 0) {
      const p = new M();
      d.center !== void 0 && p.fromArray(d.center), a.boundingSphere = new ns(p, d.radius);
    }
    return e.name && (a.name = e.name), e.userData && (a.userData = e.userData), a;
  }
}
class OA extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, a = this.path === "" ? hr.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || a;
    const o = new ti(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
      let c = null;
      try {
        c = JSON.parse(l);
      } catch (u) {
        n !== void 0 && n(u), console.error("THREE:ObjectLoader: Can't parse " + e + ".", u.message);
        return;
      }
      const h = c.metadata;
      if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
        n !== void 0 && n(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      r.parse(c, t);
    }, i, n);
  }
  async loadAsync(e, t) {
    const i = this, n = this.path === "" ? hr.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || n;
    const r = new ti(this.manager);
    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
    const a = await r.loadAsync(e, t), o = JSON.parse(a), l = o.metadata;
    if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(o);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, n), a = this.parseImages(e.images, function() {
      t !== void 0 && t(c);
    }), o = this.parseTextures(e.textures, a), l = this.parseMaterials(e.materials, o), c = this.parseObject(e.object, r, l, o, i), h = this.parseSkeletons(e.skeletons, c);
    if (this.bindSkeletons(c, h), t !== void 0) {
      let u = !1;
      for (const d in a)
        if (a[d].data instanceof HTMLImageElement) {
          u = !0;
          break;
        }
      u === !1 && t(c);
    }
    return c;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), n = this.parseGeometries(e.geometries, i), r = await this.parseImagesAsync(e.images), a = this.parseTextures(e.textures, r), o = this.parseMaterials(e.materials, a), l = this.parseObject(e.object, n, o, a, t), c = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, c), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0, n = e.length; i < n; i++) {
        const r = new Ql().fromJSON(e[i]);
        t[r.uuid] = r;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {}, n = {};
    if (t.traverse(function(r) {
      r.isBone && (n[r.uuid] = r);
    }), e !== void 0)
      for (let r = 0, a = e.length; r < a; r++) {
        const o = new ou().fromJSON(e[r], n);
        i[o.uuid] = o;
      }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const n = new Vw();
      for (let r = 0, a = e.length; r < a; r++) {
        let o;
        const l = e[r];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            o = n.parse(l);
            break;
          default:
            l.type in Sv ? o = Sv[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        o.uuid = l.uuid, l.name !== void 0 && (o.name = l.name), l.userData !== void 0 && (o.userData = l.userData), i[l.uuid] = o;
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {}, n = {};
    if (e !== void 0) {
      const r = new Wp();
      r.setTextures(t);
      for (let a = 0, o = e.length; a < o; a++) {
        const l = e[a];
        i[l.uuid] === void 0 && (i[l.uuid] = r.parse(l)), n[l.uuid] = i[l.uuid];
      }
    }
    return n;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const n = e[i], r = ic.parse(n);
        t[r.uuid] = r;
      }
    return t;
  }
  parseImages(e, t) {
    const i = this, n = {};
    let r;
    function a(l) {
      return i.manager.itemStart(l), r.load(l, function() {
        i.manager.itemEnd(l);
      }, void 0, function() {
        i.manager.itemError(l), i.manager.itemEnd(l);
      });
    }
    function o(l) {
      if (typeof l == "string") {
        const c = l, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : i.resourcePath + c;
        return a(h);
      } else
        return l.data ? {
          data: Ml(l.type, l.data),
          width: l.width,
          height: l.height,
          complete: !0
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new BA(t);
      r = new Gh(l), r.setCrossOrigin(this.crossOrigin);
      for (let c = 0, h = e.length; c < h; c++) {
        const u = e[c], d = u.url;
        if (Array.isArray(d)) {
          const p = [];
          for (let f = 0, y = d.length; f < y; f++) {
            const A = d[f], m = o(A);
            m !== null && (m instanceof HTMLImageElement ? p.push(m) : p.push(new Wr(m.data, m.width, m.height)));
          }
          n[u.uuid] = new Aa(p);
        } else {
          const p = o(u.url);
          n[u.uuid] = new Aa(p);
        }
      }
    }
    return n;
  }
  async parseImagesAsync(e) {
    const t = this, i = {};
    let n;
    async function r(a) {
      if (typeof a == "string") {
        const o = a, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(o) ? o : t.resourcePath + o;
        return await n.loadAsync(l);
      } else
        return a.data ? {
          data: Ml(a.type, a.data),
          width: a.width,
          height: a.height,
          complete: !0
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      n = new Gh(this.manager), n.setCrossOrigin(this.crossOrigin);
      for (let a = 0, o = e.length; a < o; a++) {
        const l = e[a], c = l.url;
        if (Array.isArray(c)) {
          const h = [];
          for (let u = 0, d = c.length; u < d; u++) {
            const p = c[u], f = await r(p);
            f !== null && (f instanceof HTMLImageElement ? h.push(f) : h.push(new Wr(f.data, f.width, f.height)));
          }
          i[l.uuid] = new Aa(h);
        } else {
          const h = await r(l.url);
          i[l.uuid] = new Aa(h);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(r, a) {
      return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), a[r]);
    }
    const n = {};
    if (e !== void 0)
      for (let r = 0, a = e.length; r < a; r++) {
        const o = e[r];
        o.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), t[o.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", o.image);
        const l = t[o.image], c = l ? l.data : void 0;
        let h;
        Array.isArray(c) ? (h = new Fp(), c.length === 6 && (h.needsUpdate = !0)) : (c && c.data ? h = new Wr() : h = new Nt(), c && c.complete && (h.needsUpdate = !0)), h.source = l, h.uuid = o.uuid, o.name !== void 0 && (h.name = o.name), o.mapping !== void 0 && (h.mapping = i(o.mapping, gR)), o.channel !== void 0 && (h.channel = o.channel), o.offset !== void 0 && h.offset.fromArray(o.offset), o.repeat !== void 0 && h.repeat.fromArray(o.repeat), o.center !== void 0 && h.center.fromArray(o.center), o.rotation !== void 0 && (h.rotation = o.rotation), o.wrap !== void 0 && (h.wrapS = i(o.wrap[0], Iv), h.wrapT = i(o.wrap[1], Iv)), o.format !== void 0 && (h.format = o.format), o.internalFormat !== void 0 && (h.internalFormat = o.internalFormat), o.type !== void 0 && (h.type = o.type), o.colorSpace !== void 0 ? h.colorSpace = o.colorSpace : o.encoding !== void 0 && (h.encoding = o.encoding), o.minFilter !== void 0 && (h.minFilter = i(o.minFilter, Dv)), o.magFilter !== void 0 && (h.magFilter = i(o.magFilter, Dv)), o.anisotropy !== void 0 && (h.anisotropy = o.anisotropy), o.flipY !== void 0 && (h.flipY = o.flipY), o.generateMipmaps !== void 0 && (h.generateMipmaps = o.generateMipmaps), o.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = o.premultiplyAlpha), o.unpackAlignment !== void 0 && (h.unpackAlignment = o.unpackAlignment), o.compareFunction !== void 0 && (h.compareFunction = o.compareFunction), o.userData !== void 0 && (h.userData = o.userData), n[o.uuid] = h;
      }
    return n;
  }
  parseObject(e, t, i, n, r) {
    let a;
    const o = e.metadata && e.metadata.version <= 4.5 ? Mt : void 0;
    function l(p) {
      return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), t[p];
    }
    function c(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const f = [];
          for (let y = 0, A = p.length; y < A; y++) {
            const m = p[y];
            i[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", m), f.push(i[m]);
          }
          return f;
        }
        return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), i[p];
      }
    }
    function h(p) {
      return n[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p), n[p];
    }
    let u, d;
    switch (e.type) {
      case "Scene":
        a = new tc(), e.background !== void 0 && (Number.isInteger(e.background) ? a.background = new se().setHex(e.background, o) : a.background = h(e.background)), e.environment !== void 0 && (a.environment = h(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? a.fog = new fA(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (a.fog = new pA(e.fog.color, e.fog.density)), e.fog.name !== "" && (a.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (a.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (a.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        a = new ki(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (a.focus = e.focus), e.zoom !== void 0 && (a.zoom = e.zoom), e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset), e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        a = new _r(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (a.zoom = e.zoom), e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        a = new UA(e.color, e.intensity);
        break;
      case "DirectionalLight":
        a = new hu(e.color, e.intensity);
        break;
      case "PointLight":
        a = new nc(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        a = new FA(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        a = new cu(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        a = new PA(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        a = new mR().fromJSON(e);
        break;
      case "SkinnedMesh":
        u = l(e.geometry), d = c(e.material), a = new gA(u, d), e.bindMode !== void 0 && (a.bindMode = e.bindMode), e.bindMatrix !== void 0 && a.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (a.skeleton = e.skeleton);
        break;
      case "Mesh":
        u = l(e.geometry), d = c(e.material), a = new Se(u, d);
        break;
      case "InstancedMesh":
        u = l(e.geometry), d = c(e.material);
        const p = e.count, f = e.instanceMatrix, y = e.instanceColor;
        a = new zp(u, d, p), a.instanceMatrix = new Da(new Float32Array(f.array), 16), y !== void 0 && (a.instanceColor = new Da(new Float32Array(y.array), y.itemSize));
        break;
      case "LOD":
        a = new dD();
        break;
      case "Line":
        a = new an(l(e.geometry), c(e.material));
        break;
      case "LineLoop":
        a = new Cw(l(e.geometry), c(e.material));
        break;
      case "LineSegments":
        a = new Is(l(e.geometry), c(e.material));
        break;
      case "PointCloud":
      case "Points":
        a = new zl(l(e.geometry), c(e.material));
        break;
      case "Sprite":
        a = new mA(c(e.material));
        break;
      case "Group":
        a = new Kn();
        break;
      case "Bone":
        a = new Uh();
        break;
      default:
        a = new ut();
    }
    if (a.uuid = e.uuid, e.name !== void 0 && (a.name = e.name), e.matrix !== void 0 ? (a.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (a.matrixAutoUpdate = e.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (e.position !== void 0 && a.position.fromArray(e.position), e.rotation !== void 0 && a.rotation.fromArray(e.rotation), e.quaternion !== void 0 && a.quaternion.fromArray(e.quaternion), e.scale !== void 0 && a.scale.fromArray(e.scale)), e.up !== void 0 && a.up.fromArray(e.up), e.castShadow !== void 0 && (a.castShadow = e.castShadow), e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (a.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (a.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && a.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (a.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (a.visible = e.visible), e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder), e.userData !== void 0 && (a.userData = e.userData), e.layers !== void 0 && (a.layers.mask = e.layers), e.children !== void 0) {
      const p = e.children;
      for (let f = 0; f < p.length; f++)
        a.add(this.parseObject(p[f], t, i, n, r));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let f = 0; f < p.length; f++) {
        const y = p[f];
        a.animations.push(r[y]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let f = 0; f < p.length; f++) {
        const y = p[f], A = a.getObjectByProperty("uuid", y.object);
        A !== void 0 && a.addLevel(A, y.distance, y.hysteresis);
      }
    }
    return a;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(i) {
      if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
        const n = t[i.skeleton];
        n === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(n, i.bindMatrix);
      }
    });
  }
}
const gR = {
  UVMapping: iu,
  CubeReflectionMapping: qr,
  CubeRefractionMapping: go,
  EquirectangularReflectionMapping: Ia,
  EquirectangularRefractionMapping: Kd,
  CubeUVReflectionMapping: xc
}, Iv = {
  RepeatWrapping: xn,
  ClampToEdgeWrapping: Zt,
  MirroredRepeatWrapping: Xr
}, Dv = {
  NearestFilter: pi,
  NearestMipmapNearestFilter: Jl,
  NearestMipmapLinearFilter: co,
  LinearFilter: tt,
  LinearMipmapNearestFilter: nu,
  LinearMipmapLinearFilter: Qn
};
class AR extends ui {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, i, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this;
    us.get(e, "blob").then((a) => {
      if (a !== void 0) {
        r.manager.itemStart(e), createImageBitmap(a, Object.assign(r.options, { colorSpaceConversion: "none" })).then(function(l) {
          t && t(l), r.manager.itemEnd(e);
        }).catch(function(l) {
          n && n(l), r.manager.itemError(e), r.manager.itemEnd(e);
        });
        return;
      }
      const o = {};
      o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader, fetch(e, o).then(function(l) {
        return l.blob();
      }).then(function(l) {
        return us.add(e, l, "blob"), createImageBitmap(l, Object.assign(r.options, { colorSpaceConversion: "none" }));
      }).then(function(l) {
        t && t(l), r.manager.itemEnd(e);
      }).catch(function(l) {
        n && n(l), r.manager.itemError(e), r.manager.itemEnd(e);
      }), r.manager.itemStart(e);
    });
  }
}
let ld;
class Ww {
  static getContext() {
    return ld === void 0 && (ld = new (window.AudioContext || window.webkitAudioContext)()), ld;
  }
  static setContext(e) {
    ld = e;
  }
}
class oG extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, a = new ti(this.manager);
    a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
      try {
        const c = l.slice(0);
        Ww.getContext().decodeAudioData(c, function(u) {
          t(u);
        }, o);
      } catch (c) {
        o(c);
      }
    }, i, n);
    function o(l) {
      n ? n(l) : console.error(l), r.manager.itemError(e);
    }
  }
}
const Rv = /* @__PURE__ */ new Ue(), Bv = /* @__PURE__ */ new Ue(), qa = /* @__PURE__ */ new Ue();
class lG {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new ki(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ki(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, qa.copy(e.projectionMatrix);
      const n = t.eyeSep / 2, r = n * t.near / t.focus, a = t.near * Math.tan(ho * t.fov * 0.5) / t.zoom;
      let o, l;
      Bv.elements[12] = -n, Rv.elements[12] = n, o = -a * t.aspect + r, l = a * t.aspect + r, qa.elements[0] = 2 * t.near / (l - o), qa.elements[8] = (l + o) / (l - o), this.cameraL.projectionMatrix.copy(qa), o = -a * t.aspect - r, l = a * t.aspect - r, qa.elements[0] = 2 * t.near / (l - o), qa.elements[8] = (l + o) / (l - o), this.cameraR.projectionMatrix.copy(qa);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Bv), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Rv);
  }
}
class NA {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = Pv(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = Pv();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function Pv() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Xa = /* @__PURE__ */ new M(), Lv = /* @__PURE__ */ new rt(), yR = /* @__PURE__ */ new M(), Ya = /* @__PURE__ */ new M();
class cG extends ut {
  constructor() {
    super(), this.type = "AudioListener", this.context = Ww.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new NA();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, i = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Xa, Lv, yR), Ya.set(0, 0, -1).applyQuaternion(Lv), t.positionX) {
      const n = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Xa.x, n), t.positionY.linearRampToValueAtTime(Xa.y, n), t.positionZ.linearRampToValueAtTime(Xa.z, n), t.forwardX.linearRampToValueAtTime(Ya.x, n), t.forwardY.linearRampToValueAtTime(Ya.y, n), t.forwardZ.linearRampToValueAtTime(Ya.z, n), t.upX.linearRampToValueAtTime(i.x, n), t.upY.linearRampToValueAtTime(i.y, n), t.upZ.linearRampToValueAtTime(i.z, n);
    } else
      t.setPosition(Xa.x, Xa.y, Xa.z), t.setOrientation(Ya.x, Ya.y, Ya.z, i.x, i.y, i.z);
  }
}
class vR extends ut {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const Ka = /* @__PURE__ */ new M(), Uv = /* @__PURE__ */ new rt(), _R = /* @__PURE__ */ new M(), Ja = /* @__PURE__ */ new M();
class hG extends vR {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, i) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(Ka, Uv, _R), Ja.set(0, 0, 1).applyQuaternion(Uv);
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Ka.x, i), t.positionY.linearRampToValueAtTime(Ka.y, i), t.positionZ.linearRampToValueAtTime(Ka.z, i), t.orientationX.linearRampToValueAtTime(Ja.x, i), t.orientationY.linearRampToValueAtTime(Ja.y, i), t.orientationZ.linearRampToValueAtTime(Ja.z, i);
    } else
      t.setPosition(Ka.x, Ka.y, Ka.z), t.setOrientation(Ja.x, Ja.y, Ja.z);
  }
}
class uG {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t.length; i++)
      e += t[i];
    return e / t.length;
  }
}
class xR {
  constructor(e, t, i) {
    this.binding = e, this.valueSize = i;
    let n, r, a;
    switch (t) {
      case "quaternion":
        n = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        n = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
        break;
      default:
        n = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5);
    }
    this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const i = this.buffer, n = this.valueSize, r = e * n + n;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let o = 0; o !== n; ++o)
        i[r + o] = i[o];
      a = t;
    } else {
      a += t;
      const o = t / a;
      this._mixBufferRegion(i, r, 0, o, n);
    }
    this.cumulativeWeight = a;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, i = this.valueSize, n = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, n, 0, e, i), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, i = this.buffer, n = e * t + t, r = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
      const l = t * this._origIndex;
      this._mixBufferRegion(
        i,
        n,
        l,
        1 - r,
        t
      );
    }
    a > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (i[l] !== i[l + t]) {
        o.setValue(i, n);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, i = this.valueSize, n = i * this._origIndex;
    e.getValue(t, n);
    for (let r = i, a = n; r !== a; ++r)
      t[r] = t[n + r % i];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let i = e; i < t; i++)
      this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  // mix functions
  _select(e, t, i, n, r) {
    if (n >= 0.5)
      for (let a = 0; a !== r; ++a)
        e[t + a] = e[i + a];
  }
  _slerp(e, t, i, n) {
    rt.slerpFlat(e, t, e, t, e, i, n);
  }
  _slerpAdditive(e, t, i, n, r) {
    const a = this._workIndex * r;
    rt.multiplyQuaternionsFlat(e, a, e, t, e, i), rt.slerpFlat(e, t, e, t, e, a, n);
  }
  _lerp(e, t, i, n, r) {
    const a = 1 - n;
    for (let o = 0; o !== r; ++o) {
      const l = t + o;
      e[l] = e[l] * a + e[i + o] * n;
    }
  }
  _lerpAdditive(e, t, i, n, r) {
    for (let a = 0; a !== r; ++a) {
      const o = t + a;
      e[o] = e[o] + e[i + a] * n;
    }
  }
}
const kA = "\\[\\]\\.:\\/", wR = new RegExp("[" + kA + "]", "g"), GA = "[^" + kA + "]", ER = "[^" + kA.replace("\\.", "") + "]", bR = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", GA), SR = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", ER), CR = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", GA), MR = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", GA), TR = new RegExp(
  "^" + bR + SR + CR + MR + "$"
), IR = ["material", "materials", "bones", "map"];
class DR {
  constructor(e, t, i) {
    const n = i || _t.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, n);
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_, n = this._bindings[i];
    n !== void 0 && n.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
      i[n].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class _t {
  constructor(e, t, i) {
    this.path = t, this.parsedPath = i || _t.parseTrackName(t), this.node = _t.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup ? new _t.Composite(e, t, i) : new _t(e, t, i);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(wR, "");
  }
  static parseTrackName(e) {
    const t = TR.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, n = i.nodeName && i.nodeName.lastIndexOf(".");
    if (n !== void 0 && n !== -1) {
      const r = i.nodeName.substring(n + 1);
      IR.indexOf(r) !== -1 && (i.nodeName = i.nodeName.substring(0, n), i.objectName = r);
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return i;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0)
        return i;
    }
    if (e.children) {
      const i = function(r) {
        for (let a = 0; a < r.length; a++) {
          const o = r[a];
          if (o.name === t || o.uuid === t)
            return o;
          const l = i(o.children);
          if (l) return l;
        }
        return null;
      }, n = i(e.children);
      if (n)
        return n;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n)
      e[t++] = i[n];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n)
      i[n] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n)
      i[n] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n)
      i[n] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, i = t.objectName, n = t.propertyName;
    let r = t.propertyIndex;
    if (e || (e = _t.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (i) {
      let c = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === c) {
              c = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[i];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[c];
      }
    }
    const a = e[n];
    if (a === void 0) {
      const c = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + n + " but it wasn't found.", e);
      return;
    }
    let o = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? o = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (r !== void 0) {
      if (n === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r;
    } else a.fromArray !== void 0 && a.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = n;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
_t.Composite = DR;
_t.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
_t.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
_t.prototype.GetterByBindingType = [
  _t.prototype._getValue_direct,
  _t.prototype._getValue_array,
  _t.prototype._getValue_arrayElement,
  _t.prototype._getValue_toArray
];
_t.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    _t.prototype._setValue_direct,
    _t.prototype._setValue_direct_setNeedsUpdate,
    _t.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    _t.prototype._setValue_array,
    _t.prototype._setValue_array_setNeedsUpdate,
    _t.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    _t.prototype._setValue_arrayElement,
    _t.prototype._setValue_arrayElement_setNeedsUpdate,
    _t.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    _t.prototype._setValue_fromArray,
    _t.prototype._setValue_fromArray_setNeedsUpdate,
    _t.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class dG {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = ps(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, n = arguments.length; i !== n; ++i)
      e[arguments[i].uuid] = i;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, i = this._paths, n = this._parsedPaths, r = this._bindings, a = r.length;
    let o, l = e.length, c = this.nCachedObjects_;
    for (let h = 0, u = arguments.length; h !== u; ++h) {
      const d = arguments[h], p = d.uuid;
      let f = t[p];
      if (f === void 0) {
        f = l++, t[p] = f, e.push(d);
        for (let y = 0, A = a; y !== A; ++y)
          r[y].push(new _t(d, i[y], n[y]));
      } else if (f < c) {
        o = e[f];
        const y = --c, A = e[y];
        t[A.uuid] = f, e[f] = A, t[p] = y, e[y] = d;
        for (let m = 0, v = a; m !== v; ++m) {
          const g = r[m], _ = g[y];
          let w = g[f];
          g[f] = _, w === void 0 && (w = new _t(d, i[m], n[m])), g[y] = w;
        }
      } else e[f] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = c;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, i = this._bindings, n = i.length;
    let r = this.nCachedObjects_;
    for (let a = 0, o = arguments.length; a !== o; ++a) {
      const l = arguments[a], c = l.uuid, h = t[c];
      if (h !== void 0 && h >= r) {
        const u = r++, d = e[u];
        t[d.uuid] = h, e[h] = d, t[c] = u, e[u] = l;
        for (let p = 0, f = n; p !== f; ++p) {
          const y = i[p], A = y[u], m = y[h];
          y[h] = A, y[u] = m;
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, i = this._bindings, n = i.length;
    let r = this.nCachedObjects_, a = e.length;
    for (let o = 0, l = arguments.length; o !== l; ++o) {
      const c = arguments[o], h = c.uuid, u = t[h];
      if (u !== void 0)
        if (delete t[h], u < r) {
          const d = --r, p = e[d], f = --a, y = e[f];
          t[p.uuid] = u, e[u] = p, t[y.uuid] = d, e[d] = y, e.pop();
          for (let A = 0, m = n; A !== m; ++A) {
            const v = i[A], g = v[d], _ = v[f];
            v[u] = g, v[d] = _, v.pop();
          }
        } else {
          const d = --a, p = e[d];
          d > 0 && (t[p.uuid] = u), e[u] = p, e.pop();
          for (let f = 0, y = n; f !== y; ++f) {
            const A = i[f];
            A[u] = A[d], A.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath;
    let n = i[e];
    const r = this._bindings;
    if (n !== void 0) return r[n];
    const a = this._paths, o = this._parsedPaths, l = this._objects, c = l.length, h = this.nCachedObjects_, u = new Array(c);
    n = r.length, i[e] = n, a.push(e), o.push(t), r.push(u);
    for (let d = h, p = l.length; d !== p; ++d) {
      const f = l[d];
      u[d] = new _t(f, e, t);
    }
    return u;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, i = t[e];
    if (i !== void 0) {
      const n = this._paths, r = this._parsedPaths, a = this._bindings, o = a.length - 1, l = a[o], c = e[o];
      t[c] = i, a[i] = l, a.pop(), r[i] = r[o], r.pop(), n[i] = n[o], n.pop();
    }
  }
}
class RR {
  constructor(e, t, i = null, n = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = n;
    const r = t.tracks, a = r.length, o = new Array(a), l = {
      endingStart: Sl,
      endingEnd: Sl
    };
    for (let c = 0; c !== a; ++c) {
      const h = r[c].createInterpolant(null);
      o[c] = h, h.settings = l;
    }
    this._interpolantSettings = l, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = qm, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if (e.fadeOut(t), this.fadeIn(t), i) {
      const n = this._clip.duration, r = e._clip.duration, a = r / n, o = n / r;
      e.warp(1, a, t), this.warp(o, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const n = this._mixer, r = n.time, a = this.timeScale;
    let o = this._timeScaleInterpolant;
    o === null && (o = n._lendControlInterpolant(), this._timeScaleInterpolant = o);
    const l = o.parameterPositions, c = o.sampleValues;
    return l[0] = r, l[1] = r + i, c[0] = e / a, c[1] = t / a, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, i, n) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const r = this._startTime;
    if (r !== null) {
      const l = (e - r) * i;
      l < 0 || i === 0 ? t = 0 : (this._startTime = null, t = i * l);
    }
    t *= this._updateTimeScale(e);
    const a = this._updateTime(t), o = this._updateWeight(e);
    if (o > 0) {
      const l = this._interpolants, c = this._propertyBindings;
      switch (this.blendMode) {
        case ow:
          for (let h = 0, u = l.length; h !== u; ++h)
            l[h].evaluate(a), c[h].accumulateAdditive(o);
          break;
        case sA:
        default:
          for (let h = 0, u = l.length; h !== u; ++h)
            l[h].evaluate(a), c[h].accumulate(n, o);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const n = i.evaluate(e)[0];
        t *= n, e > i.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const n = i.evaluate(e)[0];
        t *= n, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, i = this.loop;
    let n = this.time + e, r = this._loopCount;
    const a = i === GS;
    if (e === 0)
      return r === -1 ? n : a && (r & 1) === 1 ? t - n : n;
    if (i === jm) {
      r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (n >= t)
          n = t;
        else if (n < 0)
          n = 0;
        else {
          this.time = n;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = n, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), n >= t || n < 0) {
        const o = Math.floor(n / t);
        n -= t * o, r += Math.abs(o);
        const l = this.repetitions - r;
        if (l <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = e > 0 ? t : 0, this.time = n, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, a);
          } else
            this._setEndings(!1, !1, a);
          this._loopCount = r, this.time = n, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: o
          });
        }
      } else
        this.time = n;
      if (a && (r & 1) === 1)
        return t - n;
    }
    return n;
  }
  _setEndings(e, t, i) {
    const n = this._interpolantSettings;
    i ? (n.endingStart = Cl, n.endingEnd = Cl) : (e ? n.endingStart = this.zeroSlopeAtStart ? Cl : Sl : n.endingStart = $d, t ? n.endingEnd = this.zeroSlopeAtEnd ? Cl : Sl : n.endingEnd = $d);
  }
  _scheduleFading(e, t, i) {
    const n = this._mixer, r = n.time;
    let a = this._weightInterpolant;
    a === null && (a = n._lendControlInterpolant(), this._weightInterpolant = a);
    const o = a.parameterPositions, l = a.sampleValues;
    return o[0] = r, l[0] = t, o[1] = r + e, l[1] = i, this;
  }
}
const BR = new Float32Array(1);
class PR extends Vi {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root, n = e._clip.tracks, r = n.length, a = e._propertyBindings, o = e._interpolants, l = i.uuid, c = this._bindingsByRootAndName;
    let h = c[l];
    h === void 0 && (h = {}, c[l] = h);
    for (let u = 0; u !== r; ++u) {
      const d = n[u], p = d.name;
      let f = h[p];
      if (f !== void 0)
        ++f.referenceCount, a[u] = f;
      else {
        if (f = a[u], f !== void 0) {
          f._cacheIndex === null && (++f.referenceCount, this._addInactiveBinding(f, l, p));
          continue;
        }
        const y = t && t._propertyBindings[u].binding.parsedPath;
        f = new xR(
          _t.create(i, p, y),
          d.ValueTypeName,
          d.getValueSize()
        ), ++f.referenceCount, this._addInactiveBinding(f, l, p), a[u] = f;
      }
      o[u].resultBuffer = f.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid, n = e._clip.uuid, r = this._actionsByClip[n];
        this._bindAction(
          e,
          r && r.knownActions[0]
        ), this._addInactiveAction(e, n, i);
      }
      const t = e._propertyBindings;
      for (let i = 0, n = t.length; i !== n; ++i) {
        const r = t[i];
        r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, n = t.length; i !== n; ++i) {
        const r = t[i];
        --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const n = this._actions, r = this._actionsByClip;
    let a = r[t];
    if (a === void 0)
      a = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, r[t] = a;
    else {
      const o = a.knownActions;
      e._byClipCacheIndex = o.length, o.push(e);
    }
    e._cacheIndex = n.length, n.push(e), a.actionByRoot[i] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, i = t[t.length - 1], n = e._cacheIndex;
    i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null;
    const r = e._clip.uuid, a = this._actionsByClip, o = a[r], l = o.knownActions, c = l[l.length - 1], h = e._byClipCacheIndex;
    c._byClipCacheIndex = h, l[h] = c, l.pop(), e._byClipCacheIndex = null;
    const u = o.actionByRoot, d = (e._localRoot || this._root).uuid;
    delete u[d], l.length === 0 && delete a[r], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, n = t.length; i !== n; ++i) {
      const r = t[i];
      --r.referenceCount === 0 && this._removeInactiveBinding(r);
    }
  }
  _lendAction(e) {
    const t = this._actions, i = e._cacheIndex, n = this._nActiveActions++, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  }
  _takeBackAction(e) {
    const t = this._actions, i = e._cacheIndex, n = --this._nActiveActions, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, i) {
    const n = this._bindingsByRootAndName, r = this._bindings;
    let a = n[t];
    a === void 0 && (a = {}, n[t] = a), a[i] = e, e._cacheIndex = r.length, r.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, i = e.binding, n = i.rootNode.uuid, r = i.path, a = this._bindingsByRootAndName, o = a[n], l = t[t.length - 1], c = e._cacheIndex;
    l._cacheIndex = c, t[c] = l, t.pop(), delete o[r], Object.keys(o).length === 0 && delete a[n];
  }
  _lendBinding(e) {
    const t = this._bindings, i = e._cacheIndex, n = this._nActiveBindings++, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  }
  _takeBackBinding(e) {
    const t = this._bindings, i = e._cacheIndex, n = --this._nActiveBindings, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let i = e[t];
    return i === void 0 && (i = new kw(
      new Float32Array(2),
      new Float32Array(2),
      1,
      BR
    ), i.__cacheIndex = t, e[t] = i), i;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, i = e.__cacheIndex, n = --this._nActiveControlInterpolants, r = t[n];
    e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, i) {
    const n = t || this._root, r = n.uuid;
    let a = typeof e == "string" ? ic.findByName(n, e) : e;
    const o = a !== null ? a.uuid : e, l = this._actionsByClip[o];
    let c = null;
    if (i === void 0 && (a !== null ? i = a.blendMode : i = sA), l !== void 0) {
      const u = l.actionByRoot[r];
      if (u !== void 0 && u.blendMode === i)
        return u;
      c = l.knownActions[0], a === null && (a = c._clip);
    }
    if (a === null) return null;
    const h = new RR(this, a, t, i);
    return this._bindAction(h, c), this._addInactiveAction(h, o, r), h;
  }
  // get an existing action
  existingAction(e, t) {
    const i = t || this._root, n = i.uuid, r = typeof e == "string" ? ic.findByName(i, e) : e, a = r ? r.uuid : e, o = this._actionsByClip[a];
    return o !== void 0 && o.actionByRoot[n] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i)
      e[i].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1;
    for (let c = 0; c !== i; ++c)
      t[c]._update(n, e, r, a);
    const o = this._bindings, l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c)
      o[c].apply(a);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, i = e.uuid, n = this._actionsByClip, r = n[i];
    if (r !== void 0) {
      const a = r.knownActions;
      for (let o = 0, l = a.length; o !== l; ++o) {
        const c = a[o];
        this._deactivateAction(c);
        const h = c._cacheIndex, u = t[t.length - 1];
        c._cacheIndex = null, c._byClipCacheIndex = null, u._cacheIndex = h, t[h] = u, t.pop(), this._removeInactiveBindingsForAction(c);
      }
      delete n[i];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, i = this._actionsByClip;
    for (const a in i) {
      const o = i[a].actionByRoot, l = o[t];
      l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const n = this._bindingsByRootAndName, r = n[t];
    if (r !== void 0)
      for (const a in r) {
        const o = r[a];
        o.restoreOriginalState(), this._removeInactiveBinding(o);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class zA {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new zA(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let LR = 0;
class pG extends Vi {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: LR++ }), this.name = "", this.usage = ip, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, n = t.length; i < n; i++)
      this.uniforms.push(t[i].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class op extends au {
  constructor(e, t, i = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class fG {
  constructor(e, t, i, n, r) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = i, this.elementSize = n, this.count = r, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class QA {
  constructor(e, t, i = 0, n = 1 / 0) {
    this.ray = new wc(e, t), this.near = i, this.far = n, this.camera = null, this.layers = new cA(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, i = []) {
    return rg(e, this, i, t), i.sort(Fv), i;
  }
  intersectObjects(e, t = !0, i = []) {
    for (let n = 0, r = e.length; n < r; n++)
      rg(e[n], this, i, t);
    return i.sort(Fv), i;
  }
}
function Fv(s, e) {
  return s.distance - e.distance;
}
function rg(s, e, t, i) {
  if (s.layers.test(e.layers) && s.raycast(e, t), i === !0) {
    const n = s.children;
    for (let r = 0, a = n.length; r < a; r++)
      rg(n[r], e, t, !0);
  }
}
class sc {
  constructor(e = 1, t = 0, i = 0) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  set(e, t, i) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(Di(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class mG {
  constructor(e = 1, t = 0, i = 0) {
    return this.radius = e, this.theta = t, this.y = i, this;
  }
  set(e, t, i) {
    return this.radius = e, this.theta = t, this.y = i, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ov = /* @__PURE__ */ new ie();
class jw {
  constructor(e = new ie(1 / 0, 1 / 0), t = new ie(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = Ov.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Ov).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Nv = /* @__PURE__ */ new M(), cd = /* @__PURE__ */ new M();
class UR {
  constructor(e = new M(), t = new M()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    Nv.subVectors(e, this.start), cd.subVectors(this.end, this.start);
    const i = cd.dot(cd);
    let r = cd.dot(Nv) / i;
    return t && (r = Di(r, 0, 1)), r;
  }
  closestPointToPoint(e, t, i) {
    const n = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(n).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const kv = /* @__PURE__ */ new M();
class gG extends ut {
  constructor(e, t) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const i = new Ze(), n = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let a = 0, o = 1, l = 32; a < l; a++, o++) {
      const c = a / l * Math.PI * 2, h = o / l * Math.PI * 2;
      n.push(
        Math.cos(c),
        Math.sin(c),
        1,
        Math.cos(h),
        Math.sin(h),
        1
      );
    }
    i.setAttribute("position", new Te(n, 3));
    const r = new Ri({ fog: !1, toneMapped: !1 });
    this.cone = new Is(i, r), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), kv.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(kv), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const ca = /* @__PURE__ */ new M(), hd = /* @__PURE__ */ new Ue(), Kf = /* @__PURE__ */ new Ue();
class AG extends Is {
  constructor(e) {
    const t = qw(e), i = new Ze(), n = [], r = [], a = new se(0, 0, 1), o = new se(0, 1, 0);
    for (let c = 0; c < t.length; c++) {
      const h = t[c];
      h.parent && h.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b));
    }
    i.setAttribute("position", new Te(n, 3)), i.setAttribute("color", new Te(r, 3));
    const l = new Ri({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(i, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, i = this.geometry, n = i.getAttribute("position");
    Kf.copy(this.root.matrixWorld).invert();
    for (let r = 0, a = 0; r < t.length; r++) {
      const o = t[r];
      o.parent && o.parent.isBone && (hd.multiplyMatrices(Kf, o.matrixWorld), ca.setFromMatrixPosition(hd), n.setXYZ(a, ca.x, ca.y, ca.z), hd.multiplyMatrices(Kf, o.parent.matrixWorld), ca.setFromMatrixPosition(hd), n.setXYZ(a + 1, ca.x, ca.y, ca.z), a += 2);
    }
    i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function qw(s) {
  const e = [];
  s.isBone === !0 && e.push(s);
  for (let t = 0; t < s.children.length; t++)
    e.push.apply(e, qw(s.children[t]));
  return e;
}
class yG extends Se {
  constructor(e, t, i) {
    const n = new fr(t, 4, 2), r = new $s({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(n, r), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const FR = /* @__PURE__ */ new M(), Gv = /* @__PURE__ */ new se(), zv = /* @__PURE__ */ new se();
class vG extends ut {
  constructor(e, t, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "HemisphereLightHelper";
    const n = new ya(t);
    n.rotateY(Math.PI * 0.5), this.material = new $s({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const r = n.getAttribute("position"), a = new Float32Array(r.count * 3);
    n.setAttribute("color", new Je(a, 3)), this.add(new Se(n, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      Gv.copy(this.light.color), zv.copy(this.light.groundColor);
      for (let i = 0, n = t.count; i < n; i++) {
        const r = i < n / 2 ? Gv : zv;
        t.setXYZ(i, r.r, r.g, r.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(FR.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class _G extends Is {
  constructor(e = 10, t = 10, i = 4473924, n = 8947848) {
    i = new se(i), n = new se(n);
    const r = t / 2, a = e / t, o = e / 2, l = [], c = [];
    for (let d = 0, p = 0, f = -o; d <= t; d++, f += a) {
      l.push(-o, 0, f, o, 0, f), l.push(f, 0, -o, f, 0, o);
      const y = d === r ? i : n;
      y.toArray(c, p), p += 3, y.toArray(c, p), p += 3, y.toArray(c, p), p += 3, y.toArray(c, p), p += 3;
    }
    const h = new Ze();
    h.setAttribute("position", new Te(l, 3)), h.setAttribute("color", new Te(c, 3));
    const u = new Ri({ vertexColors: !0, toneMapped: !1 });
    super(h, u), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class xG extends Is {
  constructor(e = 10, t = 16, i = 8, n = 64, r = 4473924, a = 8947848) {
    r = new se(r), a = new se(a);
    const o = [], l = [];
    if (t > 1)
      for (let u = 0; u < t; u++) {
        const d = u / t * (Math.PI * 2), p = Math.sin(d) * e, f = Math.cos(d) * e;
        o.push(0, 0, 0), o.push(p, 0, f);
        const y = u & 1 ? r : a;
        l.push(y.r, y.g, y.b), l.push(y.r, y.g, y.b);
      }
    for (let u = 0; u < i; u++) {
      const d = u & 1 ? r : a, p = e - e / i * u;
      for (let f = 0; f < n; f++) {
        let y = f / n * (Math.PI * 2), A = Math.sin(y) * p, m = Math.cos(y) * p;
        o.push(A, 0, m), l.push(d.r, d.g, d.b), y = (f + 1) / n * (Math.PI * 2), A = Math.sin(y) * p, m = Math.cos(y) * p, o.push(A, 0, m), l.push(d.r, d.g, d.b);
      }
    }
    const c = new Ze();
    c.setAttribute("position", new Te(o, 3)), c.setAttribute("color", new Te(l, 3));
    const h = new Ri({ vertexColors: !0, toneMapped: !1 });
    super(c, h), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const Qv = /* @__PURE__ */ new M(), ud = /* @__PURE__ */ new M(), Hv = /* @__PURE__ */ new M();
class wG extends ut {
  constructor(e, t, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let n = new Ze();
    n.setAttribute("position", new Te([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const r = new Ri({ fog: !1, toneMapped: !1 });
    this.lightPlane = new an(n, r), this.add(this.lightPlane), n = new Ze(), n.setAttribute("position", new Te([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new an(n, r), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), Qv.setFromMatrixPosition(this.light.matrixWorld), ud.setFromMatrixPosition(this.light.target.matrixWorld), Hv.subVectors(ud, Qv), this.lightPlane.lookAt(ud), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(ud), this.targetLine.scale.z = Hv.length();
  }
}
const dd = /* @__PURE__ */ new M(), Ti = /* @__PURE__ */ new Up();
class EG extends Is {
  constructor(e) {
    const t = new Ze(), i = new Ri({ color: 16777215, vertexColors: !0, toneMapped: !1 }), n = [], r = [], a = {};
    o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", "cn2"), o("cn3", "cn4"), o("cf1", "cf2"), o("cf3", "cf4");
    function o(f, y) {
      l(f), l(y);
    }
    function l(f) {
      n.push(0, 0, 0), r.push(0, 0, 0), a[f] === void 0 && (a[f] = []), a[f].push(n.length / 3 - 1);
    }
    t.setAttribute("position", new Te(n, 3)), t.setAttribute("color", new Te(r, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update();
    const c = new se(16755200), h = new se(16711680), u = new se(43775), d = new se(16777215), p = new se(3355443);
    this.setColors(c, h, u, d, p);
  }
  setColors(e, t, i, n, r) {
    const o = this.geometry.getAttribute("color");
    o.setXYZ(0, e.r, e.g, e.b), o.setXYZ(1, e.r, e.g, e.b), o.setXYZ(2, e.r, e.g, e.b), o.setXYZ(3, e.r, e.g, e.b), o.setXYZ(4, e.r, e.g, e.b), o.setXYZ(5, e.r, e.g, e.b), o.setXYZ(6, e.r, e.g, e.b), o.setXYZ(7, e.r, e.g, e.b), o.setXYZ(8, e.r, e.g, e.b), o.setXYZ(9, e.r, e.g, e.b), o.setXYZ(10, e.r, e.g, e.b), o.setXYZ(11, e.r, e.g, e.b), o.setXYZ(12, e.r, e.g, e.b), o.setXYZ(13, e.r, e.g, e.b), o.setXYZ(14, e.r, e.g, e.b), o.setXYZ(15, e.r, e.g, e.b), o.setXYZ(16, e.r, e.g, e.b), o.setXYZ(17, e.r, e.g, e.b), o.setXYZ(18, e.r, e.g, e.b), o.setXYZ(19, e.r, e.g, e.b), o.setXYZ(20, e.r, e.g, e.b), o.setXYZ(21, e.r, e.g, e.b), o.setXYZ(22, e.r, e.g, e.b), o.setXYZ(23, e.r, e.g, e.b), o.setXYZ(24, t.r, t.g, t.b), o.setXYZ(25, t.r, t.g, t.b), o.setXYZ(26, t.r, t.g, t.b), o.setXYZ(27, t.r, t.g, t.b), o.setXYZ(28, t.r, t.g, t.b), o.setXYZ(29, t.r, t.g, t.b), o.setXYZ(30, t.r, t.g, t.b), o.setXYZ(31, t.r, t.g, t.b), o.setXYZ(32, i.r, i.g, i.b), o.setXYZ(33, i.r, i.g, i.b), o.setXYZ(34, i.r, i.g, i.b), o.setXYZ(35, i.r, i.g, i.b), o.setXYZ(36, i.r, i.g, i.b), o.setXYZ(37, i.r, i.g, i.b), o.setXYZ(38, n.r, n.g, n.b), o.setXYZ(39, n.r, n.g, n.b), o.setXYZ(40, r.r, r.g, r.b), o.setXYZ(41, r.r, r.g, r.b), o.setXYZ(42, r.r, r.g, r.b), o.setXYZ(43, r.r, r.g, r.b), o.setXYZ(44, r.r, r.g, r.b), o.setXYZ(45, r.r, r.g, r.b), o.setXYZ(46, r.r, r.g, r.b), o.setXYZ(47, r.r, r.g, r.b), o.setXYZ(48, r.r, r.g, r.b), o.setXYZ(49, r.r, r.g, r.b), o.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, i = 1, n = 1;
    Ti.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Oi("c", t, e, Ti, 0, 0, -1), Oi("t", t, e, Ti, 0, 0, 1), Oi("n1", t, e, Ti, -1, -1, -1), Oi("n2", t, e, Ti, i, -1, -1), Oi("n3", t, e, Ti, -1, n, -1), Oi("n4", t, e, Ti, i, n, -1), Oi("f1", t, e, Ti, -1, -1, 1), Oi("f2", t, e, Ti, i, -1, 1), Oi("f3", t, e, Ti, -1, n, 1), Oi("f4", t, e, Ti, i, n, 1), Oi("u1", t, e, Ti, i * 0.7, n * 1.1, -1), Oi("u2", t, e, Ti, -1 * 0.7, n * 1.1, -1), Oi("u3", t, e, Ti, 0, n * 2, -1), Oi("cf1", t, e, Ti, -1, 0, 1), Oi("cf2", t, e, Ti, i, 0, 1), Oi("cf3", t, e, Ti, 0, -1, 1), Oi("cf4", t, e, Ti, 0, n, 1), Oi("cn1", t, e, Ti, -1, 0, -1), Oi("cn2", t, e, Ti, i, 0, -1), Oi("cn3", t, e, Ti, 0, -1, -1), Oi("cn4", t, e, Ti, 0, n, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Oi(s, e, t, i, n, r, a) {
  dd.set(n, r, a).unproject(i);
  const o = e[s];
  if (o !== void 0) {
    const l = t.getAttribute("position");
    for (let c = 0, h = o.length; c < h; c++)
      l.setXYZ(o[c], dd.x, dd.y, dd.z);
  }
}
const pd = /* @__PURE__ */ new is();
class bG extends Is {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new Float32Array(8 * 3), r = new Ze();
    r.setIndex(new Je(i, 1)), r.setAttribute("position", new Je(n, 3)), super(r, new Ri({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && pd.setFromObject(this.object), pd.isEmpty()) return;
    const t = pd.min, i = pd.max, n = this.geometry.attributes.position, r = n.array;
    r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = t.x, r[4] = i.y, r[5] = i.z, r[6] = t.x, r[7] = t.y, r[8] = i.z, r[9] = i.x, r[10] = t.y, r[11] = i.z, r[12] = i.x, r[13] = i.y, r[14] = t.z, r[15] = t.x, r[16] = i.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = i.x, r[22] = t.y, r[23] = t.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class SG extends Is {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], r = new Ze();
    r.setIndex(new Je(i, 1)), r.setAttribute("position", new Te(n, 3)), super(r, new Ri({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class CG extends an {
  constructor(e, t = 1, i = 16776960) {
    const n = i, r = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], a = new Ze();
    a.setAttribute("position", new Te(r, 3)), a.computeBoundingSphere(), super(a, new Ri({ color: n, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new Ze();
    l.setAttribute("position", new Te(o, 3)), l.computeBoundingSphere(), this.add(new Se(l, new $s({ color: n, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const Vv = /* @__PURE__ */ new M();
let fd, Jf;
class MG extends ut {
  // dir is assumed to be normalized
  constructor(e = new M(0, 0, 1), t = new M(0, 0, 0), i = 1, n = 16776960, r = i * 0.2, a = r * 0.2) {
    super(), this.type = "ArrowHelper", fd === void 0 && (fd = new Ze(), fd.setAttribute("position", new Te([0, 0, 0, 0, 1, 0], 3)), Jf = new yn(0, 0.5, 1, 5, 1), Jf.translate(0, -0.5, 0)), this.position.copy(t), this.line = new an(fd, new Ri({ color: n, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Se(Jf, new $s({ color: n, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, r, a);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      Vv.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(Vv, t);
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class TG extends Is {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], i = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], n = new Ze();
    n.setAttribute("position", new Te(t, 3)), n.setAttribute("color", new Te(i, 3));
    const r = new Ri({ vertexColors: !0, toneMapped: !1 });
    super(n, r), this.type = "AxesHelper";
  }
  setColors(e, t, i) {
    const n = new se(), r = this.geometry.attributes.color.array;
    return n.set(e), n.toArray(r, 0), n.toArray(r, 3), n.set(t), n.toArray(r, 6), n.toArray(r, 9), n.set(i), n.toArray(r, 12), n.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class IG {
  constructor() {
    this.type = "ShapePath", this.color = new se(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new ap(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, i, n) {
    return this.currentPath.quadraticCurveTo(e, t, i, n), this;
  }
  bezierCurveTo(e, t, i, n, r, a) {
    return this.currentPath.bezierCurveTo(e, t, i, n, r, a), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(m) {
      const v = [];
      for (let g = 0, _ = m.length; g < _; g++) {
        const w = m[g], S = new Ql();
        S.curves = w.curves, v.push(S);
      }
      return v;
    }
    function i(m, v) {
      const g = v.length;
      let _ = !1;
      for (let w = g - 1, S = 0; S < g; w = S++) {
        let C = v[w], E = v[S], x = E.x - C.x, b = E.y - C.y;
        if (Math.abs(b) > Number.EPSILON) {
          if (b < 0 && (C = v[S], x = -x, E = v[w], b = -b), m.y < C.y || m.y > E.y) continue;
          if (m.y === C.y) {
            if (m.x === C.x) return !0;
          } else {
            const D = b * (m.x - C.x) - x * (m.y - C.y);
            if (D === 0) return !0;
            if (D < 0) continue;
            _ = !_;
          }
        } else {
          if (m.y !== C.y) continue;
          if (E.x <= m.x && m.x <= C.x || C.x <= m.x && m.x <= E.x) return !0;
        }
      }
      return _;
    }
    const n = jr.isClockWise, r = this.subPaths;
    if (r.length === 0) return [];
    let a, o, l;
    const c = [];
    if (r.length === 1)
      return o = r[0], l = new Ql(), l.curves = o.curves, c.push(l), c;
    let h = !n(r[0].getPoints());
    h = e ? !h : h;
    const u = [], d = [];
    let p = [], f = 0, y;
    d[f] = void 0, p[f] = [];
    for (let m = 0, v = r.length; m < v; m++)
      o = r[m], y = o.getPoints(), a = n(y), a = e ? !a : a, a ? (!h && d[f] && f++, d[f] = { s: new Ql(), p: y }, d[f].s.curves = o.curves, h && f++, p[f] = []) : p[f].push({ h: o, p: y[0] });
    if (!d[0]) return t(r);
    if (d.length > 1) {
      let m = !1, v = 0;
      for (let g = 0, _ = d.length; g < _; g++)
        u[g] = [];
      for (let g = 0, _ = d.length; g < _; g++) {
        const w = p[g];
        for (let S = 0; S < w.length; S++) {
          const C = w[S];
          let E = !0;
          for (let x = 0; x < d.length; x++)
            i(C.p, d[x].p) && (g !== x && v++, E ? (E = !1, u[x].push(C)) : m = !0);
          E && u[g].push(C);
        }
      }
      v > 0 && m === !1 && (p = u);
    }
    let A;
    for (let m = 0, v = d.length; m < v; m++) {
      l = d[m].s, c.push(l), A = p[m];
      for (let g = 0, _ = A.length; g < _; g++)
        l.holes.push(A[g].h);
    }
    return c;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: $g
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = $g);
/**
 * @license
 * ts-browser-helpers v0.16.2
 * Copyright 2022-2025 repalash <palash@shaders.app>
 * MIT License
 * See ./dependencies.txt for bundled third-party dependencies and licenses.
 */
let Xw = class {
  constructor() {
    this._eventListeners = {}, this.dispatchEvent = this.dispatchEvent.bind(this), this.addEventListener = this.addEventListener.bind(this), this.removeEventListener = this.removeEventListener.bind(this), this.hasEventListener = this.hasEventListener.bind(this);
  }
  addEventListener(e, t) {
    const i = this._eventListeners;
    i[e] === void 0 && (i[e] = []), i[e].includes(t) || i[e].push(t);
  }
  hasEventListener(e, t) {
    const i = this._eventListeners;
    return i[e] !== void 0 && i[e].includes(t);
  }
  removeEventListener(e, t) {
    const i = this._eventListeners[e];
    if (i !== void 0) {
      const n = i.indexOf(t);
      n !== -1 && i.splice(n, 1);
    }
  }
  dispatchEvent(e) {
    const t = this._eventListeners[e.type];
    if (t !== void 0) {
      e.target = this;
      const i = t.slice(0);
      for (let n = 0, r = i.length; n < r; n++) i[n].call(this, e);
    }
  }
};
async function bs(s) {
  return new Promise((e) => setTimeout(e, Math.max(0, s)));
}
function zn() {
  return (typeof performance > "u" ? Date : performance).now();
}
class OR extends Xw {
  constructor() {
    super(...arguments), this._onPointerDown = (e) => {
      if (e.button !== 0 || !this._element) return;
      this._pointerUp = void 0;
      const t = e.clientX / this._element.clientWidth * 2 - 1, i = -(e.clientY / this._element.clientHeight) * 2 + 1, n = zn();
      this._pointerDown = { x: t, y: i, time: n }, this._pointer = this._pointerDown, this.dispatchEvent({ type: "dragStart", pointer: this._pointerDown });
    }, this._onPointerMove = (e) => {
      if (!this._pointerDown || !this._pointer || !this._element) return;
      const t = e.clientX / this._element.clientWidth * 2 - 1, i = -(e.clientY / this._element.clientHeight) * 2 + 1, n = zn();
      this.dispatchEvent({
        type: "drag",
        pointer: this._pointer,
        drag: { x: t - this._pointerDown.x, y: i - this._pointerDown.y, time: n - this._pointerDown.time },
        delta: { x: t - this._pointer.x, y: i - this._pointer.y, time: n - this._pointer.time }
      }), this._pointer = { x: t, y: i, time: zn() }, e.buttons % 2 === 0 && this._onPointerUp(e);
    }, this._onPointerUp = (e) => {
      if (e.button !== 0 || !this._pointerDown || !this._element) return;
      const t = e.clientX / this._element.clientWidth * 2 - 1, i = -(e.clientY / this._element.clientHeight) * 2 + 1, n = zn();
      this._pointerUp = { x: t, y: i, time: n }, this.dispatchEvent({
        type: "dragEnd",
        pointer: this._pointerUp,
        drag: {
          x: this._pointerUp.x - this._pointerDown.x,
          y: this._pointerUp.y - this._pointerDown.y,
          time: this._pointerUp.time - this._pointerDown.time
        }
      }), this._pointerDown = void 0, this._pointer = void 0;
    };
  }
  get element() {
    return this._element;
  }
  set element(e) {
    this._element !== e && (this._element && this._removeElement(), this._element = e, this._element && this._addElement());
  }
  _removeElement() {
    var e, t, i, n, r;
    (e = this._element) == null || e.removeEventListener("pointerdown", this._onPointerDown), (t = this._element) == null || t.removeEventListener("pointermove", this._onPointerMove), (i = this._element) == null || i.removeEventListener("pointerup", this._onPointerUp), (n = this._element) == null || n.removeEventListener("pointercancel", this._onPointerUp), (r = this._element) == null || r.removeEventListener("pointerout", this._onPointerUp);
  }
  _addElement() {
    var e, t, i, n, r;
    (e = this._element) == null || e.addEventListener("pointerdown", this._onPointerDown), (t = this._element) == null || t.addEventListener("pointermove", this._onPointerMove), (i = this._element) == null || i.addEventListener("pointerup", this._onPointerUp), (n = this._element) == null || n.addEventListener("pointercancel", this._onPointerUp), (r = this._element) == null || r.addEventListener("pointerout", this._onPointerUp);
  }
  dispose() {
    this.element = void 0;
  }
}
/*!
 * Fork Of -
 * JavaScript Undo Manager 1.0.0
 * Simple JavaScript undo/redo command manager supporting transactions with no dependencies.
 *
 * Copyright: Alexey Grinko, 2017
 * Git repository: https://github.com/agrinko/js-undo-manager.git
 *
 * @license MIT - https://opensource.org/licenses/MIT
 *
 * Changes -
 * 1. Added presets commands
 * 2. Port to TypeScript
 * 3. Remove transactions
 */
let NR = class {
  constructor(e) {
    this.options = {
      limit: 500,
      // maximum commands stack size
      debug: !1,
      // whether to emit execution status in console
      bindHotKeys: !1
      // whether to bind "undo" and "redo" commands to "Ctrl+Z", "Ctrl+Y" & "Ctrl+Shift+Z" hot keys
      // useTransactions: true   // whether to initialize transactions manager
    }, this.enabled = !0, this.presets = {}, this._keyDown = (t) => {
      if (!this.enabled) return;
      const i = t.ctrlKey || t.metaKey;
      t.code === "KeyZ" && i && !t.shiftKey ? this.undo() : (t.code === "KeyZ" && i && t.shiftKey || t.code === "KeyY" && t.ctrlKey) && this.redo();
    }, Object.assign(this.options, e), this.limit = e.limit, this.options = e, this.reset(), e.bindHotKeys && this.bindHotKeys(), this.log(`Initialized with stack limit of ${this.limit} commands`);
  }
  /**
   * Bind 'undo' and 'redo' actions to 'Ctrl/Cmd+Z', 'Ctrl+Y' & 'Ctrl/Cmd+Shift+Z' hot keys.
   * It is a basic implementation for quick testing and should be replaced with custom event handlers
   * for more flexible processing.
   * @returns {JSUndoManager}
   */
  bindHotKeys() {
    return this.log("Bound 'undo' and 'redo' actions to 'Ctrl/Cmd+Z', 'Ctrl+Y' & 'Ctrl/Cmd+Shift+Z' hot keys"), (this.options.hotKeyRoot ?? document).addEventListener("keydown", this._keyDown), this;
  }
  dispose() {
    return (this.options.hotKeyRoot ?? document).removeEventListener("keydown", this._keyDown), this.reset();
  }
  /**
   * Remember executed command containing "redo" and "undo" functions
   * @param {Object|Function} command - either an object with "redo" and "undo" functions
   * @returns {JSUndoManager}
   */
  record(e) {
    return this.enabled ? (this._record(e), this) : this;
  }
  replaceLast(e) {
    const t = this.peek();
    if (t)
      return this.log("replace", t, "with", e), this.stack[this.sp] = e, this;
  }
  /**
   * Execute function and record it with its opposite "undo" function
   * @param {Object|Function} command - either an object with "redo" and "undo" functions
   * @param {Function} [undo] - "undo" function, used if the first argument is also a function
   * @returns {JSUndoManager}
   */
  execute(e) {
    if (!this.enabled) return;
    let t = this._rc(e), i = t.redo;
    return this.record.apply(this, t), this.log("Executing function..."), i.apply(e), this;
  }
  _rc(e) {
    if (e.type) {
      const t = this.presets[e.type];
      if (typeof t == "function")
        return t(e);
      throw console.error(e, t, this.presets), new Error("Preset command not found");
    } else
      return e;
  }
  _record(e) {
    this.enabled && (this.log("Recording command", e), this._rebase(), this.stack.push(e), this.sp++, this._keepLimit());
  }
  //forget "future" commands if stack pointer is not at the end
  _rebase() {
    this.canRedo() && (this.stack.length = this.sp + 1);
  }
  //sustain limited size of stack; cut extra commands starting with the latest ones
  _keepLimit() {
    if (this.stack.length <= this.limit)
      return;
    let e = this.stack.length - this.limit;
    this.log("Stack size reached its limit: ${this.limit} commands. Cutting off most old commands..."), e === 1 ? this.stack.shift() : this.stack.splice(0, e), this.sp -= e;
  }
  /**
   * Undo previous command if possible
   * @returns {JSUndoManager}
   */
  undo() {
    if (!this.canUndo())
      return this;
    let e = this.stack[this.sp];
    return this.log("undo"), this.sp--, this._rc(e).undo(), this;
  }
  /**
   * Check whether undoing previous command is possible
   * @returns {boolean}
   */
  canUndo() {
    return this.sp >= 0 && this.enabled;
  }
  /**
   * Get the last command that was done
   */
  peek() {
    return this.canUndo() ? this.stack[this.sp] : null;
  }
  /**
   * Redo the command which was previously undone
   * @returns {JSUndoManager}
   */
  redo() {
    if (!this.canRedo())
      return this;
    let e = this.stack[this.sp + 1];
    return this.log("redo"), this.sp++, this._rc(e).redo(), this;
  }
  /**
   * Check whether redoing command is possible
   * @returns {boolean}
   */
  canRedo() {
    return this.sp < this.stack.length - 1 && this.enabled;
  }
  /**
   * Gets the last command that was undone
   */
  peekForward() {
    return this.canRedo() ? this.stack[this.sp + 1] : null;
  }
  /**
   * Change stack size limit initially defined in the constructor options
   * @param {number} limit
   */
  setLimit(e) {
    let t = this.stack.length - this.sp - 1;
    if (e < 1 || typeof e != "number")
      throw new TypeError(`JSUndoManager.setLimit(): unexpected argument limit=${e}. Should be a positive number`);
    return e < t ? console.warn(`JSUndoManager.setLimit(): cannot set stack limit (${e}) less than the number of 'redoable' commands (${t})`) : (this.limit = Math.floor(e), this._keepLimit()), this;
  }
  /**
   * Reset all commands from memory
   */
  reset() {
    return this.log("reset"), this.stack = [], this.sp = -1, this;
  }
  /**
   * Check whether the commands stack is empty
   * @returns {boolean}
   */
  isEmpty() {
    return !this.stack.length;
  }
  /**
   * Check whether the commands stack size reaches its limit
   * @returns {boolean}
   */
  isFull() {
    return this.stack.length === this.limit;
  }
  /**
   * Get number of commands in memory stack
   * @returns {Number}
   */
  getSize() {
    return this.stack.length;
  }
  log(e, ...t) {
    this.options.debug && console.log(`Command Manager: ${e}`, ...t);
  }
};
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ld = class ag {
  constructor(e = ag.DECAY_MILLISECONDS) {
    this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(e);
  }
  setDecayTime(e) {
    this.naturalFrequency = 1 / Math.max(ag.MIN_DECAY_MILLISECONDS, e);
  }
  update(e, t, i, n) {
    const r = 2e-4 * this.naturalFrequency;
    if (e == null || n === 0 || e === t && this.velocity === 0)
      return t;
    if (i < 0)
      return e;
    const a = e - t, o = this.velocity + this.naturalFrequency * a, l = a + i * o, c = Math.exp(-this.naturalFrequency * i), h = (o - this.naturalFrequency * l) * c, u = -this.naturalFrequency * (h + o * c);
    return Math.abs(h) < r * Math.abs(n) && u * a >= 0 ? (this.velocity = 0, t) : (this.velocity = h, t + l * c);
  }
};
Ld.SETTLING_TIME = 1e4, Ld.MIN_DECAY_MILLISECONDS = 1e-3, Ld.DECAY_MILLISECONDS = 50;
let BG = Ld;
function kR() {
  const s = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  return s.style.display = "block", s;
}
function po({ innerHTML: s = "", id: e, classList: t, addToBody: i = !0, elementTag: n = "div" }) {
  const r = document.createElement(n);
  return e && (r.id = e), r.innerHTML = s, t && r.classList.add(...t), i && document.body.appendChild(r), r;
}
async function GR(s) {
  return new Promise((e, t) => {
    const i = new Image();
    i.onload = () => e(i), i.onerror = t, i.crossOrigin = "anonymous", i.decoding = "sync", i.src = s;
  });
}
function zh(s, e = document.head) {
  const t = document.createElement("style");
  return t.type = "text/css", t.innerText = s, e == null || e.appendChild(t), t;
}
async function PG(s, e = document.head) {
  return new Promise((t, i) => {
    const n = document.createElement("script");
    n.setAttribute("src", s), n.addEventListener("load", () => t(n)), n.addEventListener("error", i), e.appendChild(n);
  });
}
async function LG(s, e) {
  var t;
  s.innerHTML = e;
  const i = s.getElementsByTagName("script");
  for (let n = 0; n < i.length; n++) {
    const r = i[n], a = zR(r);
    let o = !1;
    await new Promise((l) => {
      a.onload = l, a.onerror = () => {
        o = !0, l(void 0);
      };
    }), !o && ((t = r.parentNode) == null || t.replaceChild(a, r));
  }
}
function zR(s, e) {
  e = e ?? document.createElement("script"), e.type = s.type || "text/javascript", e.text = s.text;
  for (let t = 0; t < s.attributes.length; t++) {
    const i = s.attributes[t];
    e.setAttribute(i.name, i.value);
  }
  return e;
}
function $f(s) {
  if (!window)
    return console.warn("window is required"), "";
  let e = "";
  const t = new Uint8Array(s), i = t.byteLength;
  for (let n = 0; n < i; n++)
    e += String.fromCharCode(t[n]);
  return window.btoa(e);
}
function Yw(s) {
  if (!window)
    return console.warn("window is required"), new Uint8Array(0);
  const e = window.atob(s), t = e.length, i = new Uint8Array(t);
  for (let n = 0; n < t; n++)
    i[n] = e.charCodeAt(n);
  return i.buffer;
}
const QR = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function HR(s, e) {
  return new QR[s](e);
}
function UG(s) {
  return s.replace(
    /\w\S*/g,
    function(e) {
      return e.charAt(0).toUpperCase() + e.substr(1).toLowerCase();
    }
  );
}
function FG(s) {
  return s.replace(
    /([-_][a-z])/ig,
    (e) => e.toUpperCase().replace("-", "").replace("_", "")
  );
}
function og(s) {
  if (!s || s === "" || s.match(/__MACOSX\/.*\._/)) return "";
  s = s.replace(/\?.*$/, "");
  const e = s.split(/[\\/]/).pop() ?? "", t = e.lastIndexOf(".");
  return e === "" || t < 1 ? "" : e.slice(t + 1);
}
function OG(s) {
  return s.substring(s.lastIndexOf("/") + 1);
}
function VR(s) {
  return s.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
}
function Pn(s, e, t) {
  return s.replace(new RegExp(VR(e), "g"), t);
}
function NG(s, e, t, {
  replaceAll: i = !1,
  prepend: n = !1,
  append: r = !1,
  notFoundCallback: a = () => {
  }
} = {}) {
  if (a && !s.includes(e))
    return a(), s;
  let o = t;
  return n ? o = t + e : r && (o = e + t), i ? s.replaceAll(e, o) : s.replace(e, o);
}
function kG(s) {
  return s.sort(), s[0].split("").map((e, t) => s[s.length - 1][t] === e ? e : "\0").join("").split("\0").at(0) || "";
}
const Oa = (s, ...e) => String.raw({ raw: s }, ...e), WR = (s, ...e) => String.raw({ raw: s }, ...e), GG = (s, ...e) => String.raw({ raw: s }, ...e), jR = (s, ...e) => {
  let t = String.raw({ raw: s }, ...e);
  return t = Pn(t, "%", "%25"), t = Pn(t, "> <", "><"), t = Pn(t, "; }", ";}"), t = Pn(t, "<", "%3c"), t = Pn(t, ">", "%3e"), t = Pn(t, '"', "'"), t = Pn(t, "#", "%23"), t = Pn(t, "{", "%7b"), t = Pn(t, "}", "%7d"), t = Pn(t, "|", "%7c"), t = Pn(t, "^", "%5e"), t = Pn(t, "`", "%60"), t = Pn(t, "@", "%40"), t = Pn(t, "&", "&amp;"), t = Pn(t, `
`, "%0A"), "data:image/svg+xml;charset=UTF-8," + t;
};
function zG(s = document.head) {
  return zh(WR`
      ::-webkit-scrollbar
      {
        width: 8px;  /* for vertical scrollbars */
        height: 8px; /* for horizontal scrollbars */
      }
      ::-webkit-scrollbar-track
      {
        background: rgba(64, 64, 64, 0.4);
        border-radius: 6px;
      }
      ::-webkit-scrollbar-thumb
      {
        background: rgba(128, 128, 128, 0.2);
        border-radius: 6px;
      }
      ::-webkit-scrollbar-corner {background: rgba(0,0,0,0.5);}
    `, s);
}
function jp(s, e) {
  const t = window.URL.createObjectURL(s), i = document.createElement("a");
  i.style.display = "none", i.href = t, i.download = e, document.body.appendChild(i), i.click(), setTimeout(() => {
    document.body.removeChild(i), window.URL.revokeObjectURL(t);
  }, 1e3);
}
async function Kw(s) {
  return new Promise((e, t) => {
    const i = new FileReader();
    i.onload = (n) => e(i.result), i.onerror = (n) => t(i.error), i.onabort = (n) => t(new Error("Read aborted")), i.readAsDataURL(s);
  });
}
function qR(s, e) {
  return jp(s, e ?? s.name);
}
async function XR(s = !1, e = !1, t) {
  const i = document.createElement("input");
  i.type = "file", i.multiple = s, i.accept = t || "*", i.webkitdirectory = e, i.style.display = "none", document.body.appendChild(i), i.click();
  const n = await new Promise((r) => {
    i.onchange = (a) => {
      r(Array.from(i.files || []));
    };
  });
  return document.body.removeChild(i), n;
}
function QG() {
  let s = !1;
  return function(e) {
    (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0, 4))) && (s = !0);
  }(navigator.userAgent || navigator.vendor || window.opera), s;
}
function HG(s) {
  return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function YR(s) {
  return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
function VG(s, e = 1, t = 1) {
  const i = document.createElement("canvas");
  i.width = e, i.height = t;
  const n = i.getContext("2d");
  n.fillStyle = "#" + s, n.fillRect(0, 0, e, t);
  const r = i.toDataURL();
  return i.remove(), r;
}
function KR(s, e) {
  let t;
  do
    t = Object.getOwnPropertyDescriptor(s, e);
  while (!t && (s = Object.getPrototypeOf(s)));
  return t;
}
function JR(s, e, t = !0, i = !1) {
  const n = KR(s, e);
  return !!(n != null && n.set) || t && (n == null ? void 0 : n.writable) !== !1 && (n == null ? void 0 : n.get) === void 0 || i && !n;
}
function wo(s, e, t, i = !0, n = !1) {
  return s && JR(s, e, i, n) ? (s[e] = t, !0) : !1;
}
function gi(s, ...e) {
  return typeof s == "function" && (s = s(...e)), s;
}
function $R(s, e, t) {
  for (const i of t) {
    const n = s[i];
    n !== void 0 && wo(e, i, n, !0);
  }
  return e;
}
function ZR(s, e) {
  for (const t of e)
    if (!s.includes(t)) return !1;
  return !0;
}
function eB(s, e) {
  for (let t = s.length - 1; t >= 0; t--)
    if (e(s[t])) return t;
  return -1;
}
function WG(s, e) {
  return function(...t) {
    return s(), e && e.call(this, ...t);
  };
}
function tB(s, e) {
  return function(...t) {
    return s(...t), e && e.call(this, ...t);
  };
}
function jG(s, e, t = !1) {
  for (typeof s == "string" && (s = s.split(".")); s.length > 0; ) {
    if (!e) return e;
    const i = s.splice(0, 1)[0];
    if (!(i.length < 1))
      if (Array.isArray(e))
        e = e[parseInt(i)];
      else if (typeof e == "object" && i in e)
        e = e[i];
      else {
        if (t)
          throw new Error("invalid access, check " + i + " in " + e);
        return;
      }
  }
  return e;
}
function qG(s, e) {
  return Object.keys(s).find((t) => s[t] === e);
}
function Jn(s, e) {
  return Object.hasOwn ? Object.hasOwn(s, e) : s.hasOwnProperty(e);
}
function iB(s, e, t = !0) {
  const i = t ? s : {}, n = Object.keys(s);
  for (const r of n) i[r] = e(s[r], r);
  return i;
}
function Wv(s, e) {
  return Object.fromEntries(Object.entries(s).map((t) => e(t)));
}
const lg = {
  // object
  priority: 1 / 0,
  serialize: (s, e) => Wv(s, ([t, i]) => [t, Sn.Serialize(i, e, !1)]),
  deserialize: (s, e, t) => Object.assign(e || {}, Wv(s, ([i, n]) => [i, Sn.Deserialize(n, e == null ? void 0 : e[i], t, !1)])),
  isType: (s) => (s.constructor || Object) === Object
}, to = class qn {
  static GetSerializer(e) {
    return qn.Serializers.find((t) => t.isType(e));
  }
  static RegisterSerializer(...e) {
    for (const t of e) {
      const i = t.priority ?? 1e10, n = eB(qn.Serializers, (r) => r.priority !== void 0 && r.priority < i);
      n >= 0 ? qn.Serializers.splice(n + 1, 0, t) : qn.Serializers.push(t);
    }
  }
  static UnregisterSerializer(...e) {
    for (const t of e) {
      const i = qn.Serializers.indexOf(t);
      i >= 0 && qn.Serializers.splice(i, 1);
    }
  }
  /**
   * Serialize an object
   * @param obj - object to serialize
   * @param meta - Optional object to store common meta-data/resources across the serialization process of multiple objects
   * @param isThis - true if called from inside the serialization function, like custom {@link IJSONSerializable.toJSON}.
   */
  static Serialize(e, t, i = !1) {
    if (typeof e == "function") return;
    if (!i) {
      const a = qn.GetSerializer(e);
      if (a) return a.serialize(e, t);
      if (typeof e.toJSON == "function") {
        const o = e.toJSON(t);
        return e.serializableClassId && o && (o.serializableClassId = e.serializableClassId), o;
      }
    }
    let n = e.constructor ?? Object;
    const r = {};
    for (; n && n !== Object; ) {
      const a = qn.TypeMap.get(n) ?? [];
      for (const [o, l] of a)
        r[o] = qn.Serialize(e[l], t, !1);
      n = Object.getPrototypeOf(n);
    }
    return e.serializableClassId && (r.serializableClassId = e.serializableClassId), r;
  }
  /**
   * Deserialize an object
   * @param data - data to deserialize
   * @param obj - current object that's set. If of the same class/type the data is deserialized into that instead of creating new objects.
   * @param meta - Optional object to retrieve common meta-data/resources across the deserialization process of multiple objects. Objects in meta must be class instances, not js objects. (like Material, Texture, Object3D etc)
   * @param isThis - true if called from inside the deserialization function, like custom {@link IJSONSerializable.fromJSON}
   */
  static Deserialize(e, t, i, n = !1) {
    if (e === void 0 || t === e) return t;
    if (e && typeof e == "object" && (e.constructor || Object) === Object && e.resource && typeof e.resource == "string" && e.uuid) {
      const a = i == null ? void 0 : i[e.resource];
      if (a) {
        if (e = a[e.uuid], typeof e == "object" && (e.__useCount = e.__useCount ? e.__useCount + 1 : 1), e || console.warn(`Resource ${e.resource} with uuid ${e.uuid} not found`), t === e) return t;
        if (e && typeof e == "object") {
          if ((e.constructor || Object) !== Object)
            return t && console.warn("replacing object", t, "with deserialized object from meta", e), e;
          console.error("Deserialize; meta should only have class instances, not js objects", e, t, i);
        }
      } else
        return console.warn(`Resource ${e.resource} not found`), t;
    }
    if (e && typeof e == "object" && (e.constructor || Object) !== Object && !Array.isArray(e) && !e.serializableClassId) {
      if (e instanceof Blob) return e;
      console.warn("Data might already be deserialized. It will be cloned, or copied to source", e, "source", t, e.constructor, e.constructor !== Object);
    }
    if (e && typeof e == "object")
      if (e.serializableClassId && (!t || t.serializableClassId !== e.serializableClassId)) {
        const a = qn.SerializableClasses.get(e.serializableClassId);
        a && (a.DataInConstructor ? t = new a(e) : t = new a());
      } else (e.constructor || Object) === Object && !t ? t = {} : Array.isArray(e) && !t && (t = []);
    if (typeof t == "function")
      return console.error("cannot deserialize a function", t, e), t;
    if (!n) {
      const a = qn.GetSerializer(e);
      if (a && a !== lg) return a.deserialize(e, t, i);
    }
    if (!e || t === void 0 || t === null || typeof t != "object")
      return e;
    if (!n && typeof (t == null ? void 0 : t.fromJSON) == "function")
      return t.fromJSON(e, i), t;
    let r = t.constructor ?? Object;
    if (r === Object) return lg.deserialize(e, t, i);
    for (; r && r !== Object; ) {
      const a = qn.TypeMap.get(r) ?? [];
      for (const [o, l] of a) {
        const c = t[l], h = qn.Deserialize(e[o], c, i, !1);
        h !== c && wo(t, l, h, !0);
      }
      r = Object.getPrototypeOf(r);
    }
    return t;
  }
};
to.TypeMap = /* @__PURE__ */ new Map(), to.SerializableClasses = /* @__PURE__ */ new Map(), to.Serializers = [
  {
    // arrays
    priority: 0,
    isType: (s) => Array.isArray(s),
    serialize: (s, e) => s.map((t) => to.Serialize(t, e, !1)),
    deserialize: (s, e, t) => {
      const i = s.length;
      Array.isArray(e) || (e = []);
      for (let n = 0; n < i; n++) {
        const r = s[n], a = e.length > n ? to.Deserialize(r, e[n], t, !1) : to.Deserialize(r, void 0, t, !1);
        e.length <= n ? e.push(a) : e[n] = a;
      }
      return e;
    }
  },
  {
    // primitives
    priority: 0,
    isType: (s) => !s || typeof s != "object",
    serialize: (s) => {
      if (s && typeof s == "number") {
        if (s === 1 / 0) return "Infinity";
        if (s === -1 / 0) return "-Infinity";
        if (isNaN(s)) return "NaN";
      }
      return s;
    },
    deserialize: (s, e) => {
      if (typeof e == "number") {
        if (s === "Infinity") return 1 / 0;
        if (s === "-Infinity") return -1 / 0;
        if (s === "NaN") return NaN;
        if (typeof s == "number" || !s) return s;
      }
      return s;
    }
  },
  lg
];
let Sn = to;
const Jw = class Ud {
  static callFunction(e, t, i = []) {
    if (!t) return e(...i);
    if (e.name && t[e.name] === e) return e.call(t, ...i);
    Ud.methodMap.has(t) || Ud.methodMap.set(t, /* @__PURE__ */ new WeakMap());
    const n = Ud.methodMap.get(t);
    if (!n.has(e)) {
      let r = t;
      for (; r; ) {
        const a = Object.values(Object.getOwnPropertyDescriptors(r));
        for (let o of a)
          if (o.value === e)
            return n.set(e, !0), e.call(t, ...i);
        r = Object.getPrototypeOf(r);
      }
      n.set(e, !1);
    }
    return n.get(e) ? e.call(t, ...i) : e(...i);
  }
};
Jw.methodMap = /* @__PURE__ */ new WeakMap();
let qp = Jw;
function Oe(s, e = "param") {
  if (!s) throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
  return (t, i, n) => {
    const r = {
      get() {
        return this[`_oc_${i}`];
      },
      set(a) {
        var o;
        const l = this[`_oc_${i}`];
        if (l === a) return;
        this[`_oc_${i}`] = a;
        const c = e === "param" ? [i, a, l, this] : e === "object" ? [{ key: i, value: a, oldValue: l, target: this }] : [];
        typeof s == "string" ? (o = this[s]) == null || o.call(this, ...c) : typeof s == "function" && qp.callFunction(s, this, c);
      }
    };
    if (n)
      return Jn(n, "value") && delete n.value, Jn(n, "writable") && delete n.writable, Jn(n, "initializer") && delete n.initializer, Object.assign(n, r);
    Object.defineProperty(t, i, r);
  };
}
function Pi(s, e = "void") {
  if (!s) throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
  return Oe(s, e);
}
function bt(s, e = "object") {
  if (!s) throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
  return Oe(s, e);
}
function nB(s) {
  return Oe((e, t, i, n) => {
    if (!n.dispatchEvent) throw new Error("onChangeDispatchEvent: target does not have dispatchEvent");
    n.dispatchEvent({ type: s || `${e}-changed`, detail: { key: e, value: t, oldValue: i } });
  }, "param");
}
function V(s) {
  return (e, t) => {
    const i = e.constructor;
    if (i === Object) throw new Error("All properties in an object are serialized by default");
    Sn.TypeMap.has(i) || Sn.TypeMap.set(i, []), Sn.TypeMap.get(i).push([s || t, t]);
  };
}
function $w(s) {
  return (e) => (e = class extends e {
    constructor() {
      super(...arguments), this.serializableClassId = s;
    }
    // static DataInConstructor = false // if constructor is equivalent to fromJSON, see LUTCubeTextureWrapper.
  }, Sn.SerializableClasses.set(s, e), e);
}
async function sB(s, e, t) {
  const i = typeof e == "string" ? new TextEncoder().encode(e) : e, n = await crypto.subtle.digest("SHA-256", i), r = crypto.getRandomValues(new Uint8Array(12)), a = Array.from(r).map((A) => String.fromCharCode(A)).join(""), o = { name: "AES-GCM", iv: r }, l = await crypto.subtle.importKey("raw", n, o, !1, ["encrypt"]), c = typeof s == "string" ? new TextEncoder().encode(s) : s, h = await crypto.subtle.encrypt(o, l, c), u = new Uint8Array(h), d = Array.from(u), p = d.map((A) => String.fromCharCode(A)).join(""), f = t ? typeof t == "string" ? t : new TextDecoder().decode(t) : "", y = t ? typeof t == "string" ? new TextEncoder().encode(t) : Array.from(t) : [];
  return typeof s == "string" ? f + a + p : new Uint8Array([...y, ...r, ...d]);
}
async function rB(s, e) {
  const t = typeof e == "string" ? new TextEncoder().encode(e) : e, i = await crypto.subtle.digest("SHA-256", t), n = s.slice(0, 12), r = { name: "AES-GCM", iv: typeof n == "string" ? new Uint8Array(Array.from(n).map((c) => c.charCodeAt(0))) : n }, a = await crypto.subtle.importKey("raw", i, r, !1, ["decrypt"]), o = s.slice(12), l = typeof o == "string" ? new Uint8Array(Array.from(o).map((c) => c.charCodeAt(0))) : o;
  try {
    const c = await crypto.subtle.decrypt(r, a, l);
    return typeof s == "string" ? new TextDecoder().decode(c) : new Uint8Array(c);
  } catch {
    throw new Error("Decrypt failed");
  }
}
async function XG() {
  return "showOpenFilePicker" in window ? window.showOpenFilePicker().then((s) => s[0]) : window.chooseFileSystemEntries();
}
function YG() {
  if ("showSaveFilePicker" in window) {
    const e = {
      types: [{
        description: "Text file",
        accept: { "text/plain": [".txt"] }
      }]
    };
    return window.showSaveFilePicker(e);
  }
  const s = {
    type: "save-file",
    accepts: [{
      description: "Text file",
      extensions: ["txt"],
      mimeTypes: ["text/plain"]
    }]
  };
  return window.chooseFileSystemEntries(s);
}
function KG(s) {
  return s.text ? s.text() : aB(s);
}
function aB(s) {
  return new Promise((e) => {
    const t = new FileReader();
    t.addEventListener("loadend", (i) => {
      const n = (i.srcElement || i.target).result;
      e(n);
    }), t.readAsText(s);
  });
}
async function JG(s, e) {
  if (s.createWriter) {
    const i = await s.createWriter();
    await i.write(0, e), await i.close();
    return;
  }
  const t = await s.createWritable();
  await t.write(e), await t.close();
}
async function $G(s, e) {
  const t = {};
  return e && (t.writable = !0, t.mode = "readwrite"), await s.queryPermission(t) === "granted" || await s.requestPermission(t) === "granted";
}
function Zw(s, e = 8192, t = !1) {
  var i;
  if (!s.width || !s.height) throw new Error("Invalid bitmap");
  const n = document.createElement("canvas");
  n.width = Math.min(e, s.width), n.height = Math.floor(1 + n.width * s.height / s.width);
  const r = s instanceof ImageBitmap, a = r && t && Math.abs(n.width - s.width) < 0.5 ? n.getContext("bitmaprenderer") : void 0;
  return a ? a.transferFromImageBitmap(s) : (i = n.getContext("2d")) == null || i.drawImage(s, 0, 0, n.width, n.height), r && t && s.close(), n;
}
function oB(s, e = 8192, t = !1, i = "image/png") {
  if (!s.width || !s.height) return "";
  const n = Zw(s, e, !1), r = n.toDataURL(i);
  return n.remove(), t && s instanceof ImageBitmap && s.close(), r;
}
async function ZG(s, e = 8192, t = !1, i = "image/png") {
  if (!s.width || !s.height) return Promise.reject("Invalid bitmap");
  const n = Zw(s, e, !1);
  return new Promise((r, a) => {
    n.toBlob((o) => {
      o ? r(o) : a("Could not get blob"), n.remove(), t && s instanceof ImageBitmap && s.close();
    }, i);
  });
}
async function lB(s) {
  return new Promise((e, t) => {
    const i = new Image();
    i.addEventListener("load", () => {
      const n = document.createElement("canvas");
      n.width = i.width, n.height = i.height;
      const r = n.getContext("2d");
      if (!r) {
        t(new Error("Could not get 2d context"));
        return;
      }
      r.drawImage(i, 0, 0, n.width, n.height);
      const a = r.getImageData(0, 0, n.width, n.height);
      e(a), n.remove(), i.remove();
    }, !1), i.addEventListener("error", (n) => {
      i.remove(), t(n);
    }, !1), i.src = s;
  });
}
function cB(s, {
  backgroundColor: e = "",
  scale: t = 1,
  width: i = 512,
  height: n = 512
}) {
  const r = document.createElement("canvas"), a = r.getContext("2d"), o = t, l = i, c = n;
  return r.width = l * o, r.height = c * o, r.style.width = `${l}`, r.style.height = `${c}`, (e == null ? void 0 : e.length) > 0 && (a.fillStyle = e, a.fillRect(0, 0, r.width, r.height)), a.drawImage(s, 0, 0, r.width, r.height), r;
}
function ez(s) {
  const e = document.createElement("canvas");
  return e.width = s.width, e.height = s.height, e.getContext("2d").putImageData(s, 0, 0), e;
}
function tz() {
  const s = document.createElement("canvas");
  return s.getContext && s.getContext("2d") ? s.toDataURL("image/webp").startsWith("data:image/webp") : !1;
}
function eE(s) {
  const e = document.createElement("canvas");
  e.width = s.width, e.height = s.height;
  const t = e.getContext("2d");
  if (!t) throw new Error("Unable to get 2d context");
  return t.translate(0, s.height), t.scale(1, -1), t.drawImage(s, 0, 0), e;
}
function iz(s) {
  return new Promise((e, t) => {
    const i = new Image(), n = URL.createObjectURL(s);
    i.onload = () => {
      URL.revokeObjectURL(n), e(i);
    }, i.onerror = (r) => {
      URL.revokeObjectURL(n), t(r);
    }, i.src = n;
  });
}
const nz = (s) => `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='16' height='16' fill='%23${s}'/%3E%3C/svg%3E%0A`, hB = (s) => `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='8' cy='8' r='7' fill='%23${s}'/%3E%3C/svg%3E%0A`, sz = (s) => `data:image/svg+xml,%3Csvg viewBox='0 0 80 14' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext style='font: 8px "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace; fill: white;' x='9' y='9'%3E${s}%3C/text%3E%3C/svg%3E%0A`, tE = async (s, e) => {
  const t = await GR(s);
  return cB(t, e);
}, uB = async (s, e) => await tE(s, e).then((t) => t.toDataURL("image/png")), dB = async (s) => Kw(await (await fetch(s)).blob());
async function rz(s, e = dB) {
  const t = s.match(/(((ftp|https?):\/\/)[\-\w@:%_\+.~#?,&\/\/=]+)/g);
  if (t)
    for (const i of t) {
      const n = await e(i);
      s = s.replace(i, n);
    }
  return s;
}
function iE(s, e, { width: t, height: i }, n = !0) {
  const r = `
<svg viewBox="0 0 ${t} ${i}" xmlns="http://www.w3.org/2000/svg">
    <style>
    ${e}
    </style>
    <foreignObject x="0" y="0" width="100%" height="100%">
        <div xmlns="http://www.w3.org/1999/xhtml" style="height: 100%; width: 100%; position: absolute: top:0; left:0">
            ${s}
        </div>
    </foreignObject>
</svg>
    `;
  return n ? jR(r) : r;
}
async function az(s, e, t) {
  const i = iE(s, e, t);
  return await tE(i, t);
}
async function oz(s, e, t) {
  const i = iE(s, e, t);
  return await uB(i, t);
}
function pB(s, e) {
  return Math.abs(s) > Math.abs(e) ? s : e;
}
function nE(s, e, t) {
  const i = t ? 1 : 0, n = ~(1 << e);
  return s & n | i << e;
}
function lz(s, e) {
  const t = ~(1 << e);
  return s & t;
}
function cz() {
  const s = (i, n) => i.toString(16).padStart(n, "0"), e = crypto.getRandomValues(new Uint8Array(16));
  e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
  const t = new DataView(e.buffer);
  return `${s(t.getUint32(0), 8)}-${s(t.getUint16(4), 4)}-${s(t.getUint16(6), 4)}-${s(t.getUint16(8), 4)}-${s(t.getUint32(10), 8)}${s(t.getUint16(14), 4)}`;
}
function HA(s, e = null) {
  return new URL(window.location.href).searchParams.get(s) ?? e;
}
function hz(s, e, t = !1) {
  const i = new URLSearchParams(location.search);
  e == null ? i.has(s) && i.delete(s) : i.set(s, e), t ? window.location.search = i.toString() : window.history.replaceState({}, "", "?" + i.toString());
}
function uz(s, e = "/") {
  return s.join(e);
}
function dz(s, e) {
  const t = (e ? `var Module = { locateFile: function(s) { return "${e}"; } }; 
` : "") + `importScripts( "${s}" );`;
  return URL.createObjectURL(new Blob([t], { type: "text/javascript" }));
}
const fB = `#ifndef SIMPLE_CAMERA_HELPERS
#define SIMPLE_CAMERA_HELPERS
#ifndef USE_TRANSMISSION
uniform mat4 projectionMatrix;
#endif
vec3 viewToScreen(const in vec3 pos){vec4 projected=projectionMatrix*vec4(pos,1.0);return vec3(0.5+0.5*projected.xy/projected.w,projected.w);}vec3 screenToView(const in vec2 uv,const in float viewZ){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projectionMatrix[2][0])*viewZ/projectionMatrix[0][0];float ye=-(uv_.y+projectionMatrix[2][1])*viewZ/projectionMatrix[1][1];return vec3(xe,ye,viewZ);}
#endif
`, mB = `#ifndef BASIC_CAMERA_HELPERS
#define BASIC_CAMERA_HELPERS
uniform mat4 projection;uniform vec2 cameraNearFar;uniform vec3 cameraPositionWorld;
#ifndef THREE_PACKING_INCLUDED
#define THREE_PACKING_INCLUDED
#include <packing>
#endif
float linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.0,1.0);}float depthToViewZ(const in float depth){return(depth>0.999)?-cameraNearFar.y*1000.0 :-mix(cameraNearFar.x,cameraNearFar.y,depth);}float viewZToDepth(const in float viewZ){return linstep(-cameraNearFar.x,-cameraNearFar.y,viewZ);}vec4 viewToScreen3(const in vec3 pos){vec4 projected=projection*vec4(pos,1.0);projected.z=pos.z;projected.w=1./projected.w;projected.xyz*=projected.w;projected.xy=0.5+0.5*projected.xy;return projected;}vec3 screenToView3(const in vec2 uv,const in float viewZ){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewZ/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewZ/projection[1][1];return vec3(xe,ye,viewZ);}float viewZFromNDCZ(const in float depth){
#if PERSPECTIVE_CAMERA == 1
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}
#endif
`, gB = `#ifndef BASIC_RANDOM_HELPERS
#define BASIC_RANDOM_HELPERS
float random(float n){return fract(sin(n)*43758.5453123);}float random2(vec2 n,float x){n+=x;return fract(sin(dot(n.xy,vec2(12.9898,78.233)))*43758.5453);}float random3(vec3 v){v=fract(v*443.8975);v+=dot(v,v.yzx+19.19);return fract((v.x+v.y)*v.z);}float interleavedGradientNoise(const in vec2 fragCoord,const in float seed){vec3 magic=vec3(0.06711056,0.00583715,52.9829189);return fract(magic.z*fract(dot(fragCoord.xy+seed*vec2(2.083,4.867),magic.xy)));}vec3 hash3(vec2 p){vec3 q=vec3(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)),dot(p,vec2(419.2,371.9)));return fract(sin(q)*43758.5453);}
#endif
`, AB = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}", yB = "varying vec2 vUv;void main(){gl_FragColor=vec4(vUv,0.0,1.0);}", vB = `#ifndef VORONOI_HELPER
#define VORONOI_HELPER
float voronoi_distance(vec2 a,vec2 b,float metric){return distance(a,b);}float voronoi_f1_2d(in vec2 coord,in float randomness,in float flakeClamp,in float flakeRadius,inout vec3 outColor){vec2 cellPosition=floor(coord);vec2 localPosition=coord-cellPosition;float minDistance=8.0;vec2 targetOffset,targetPosition;for(int j=-1;j<=1;j++){for(int i=-1;i<=1;i++){vec2 cellOffset=vec2(i,j);vec2 pointPosition=cellOffset+hash3(cellPosition+cellOffset).xy*randomness;float distanceToPoint=voronoi_distance(pointPosition,localPosition,1.);if(distanceToPoint<minDistance){targetOffset=cellOffset;minDistance=distanceToPoint;targetPosition=pointPosition;}}}float outDistance=minDistance;float dist=step(flakeRadius,outDistance);outColor=hash3(cellPosition+hash3(cellPosition+targetOffset).xy*randomness+targetOffset);vec3 outColor1=minDistance<flakeRadius ? outColor : vec3(0.5,0.5,1.);outDistance=mix(dist,minDistance,flakeClamp);outColor=mix(outColor1,outColor,flakeClamp);return outDistance;}
#endif
`, lp = {
  simpleCameraHelpers: fB,
  cameraHelpers: mB,
  randomHelpers: gB,
  defaultVertex: AB,
  defaultFragment: yB,
  voronoiNoise: vB
}, _B = {
  alert: async (s) => window.alert(s),
  prompt: async (s, e, t) => window.prompt(s, e),
  confirm: async (s) => window.confirm(s),
  confirmSync: (s) => window.confirm(s)
};
function xB(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var Fd = { exports: {} }, wB = Fd.exports, jv;
function EB() {
  return jv || (jv = 1, function(s, e) {
    (function(t, i) {
      s.exports = i();
    })(wB, function() {
      var t = function() {
        function i(p) {
          return a.appendChild(p.dom), p;
        }
        function n(p) {
          for (var f = 0; f < a.children.length; f++) a.children[f].style.display = f === p ? "block" : "none";
          r = p;
        }
        var r = 0, a = document.createElement("div");
        a.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", a.addEventListener("click", function(p) {
          p.preventDefault(), n(++r % a.children.length);
        }, !1);
        var o = (performance || Date).now(), l = o, c = 0, h = i(new t.Panel("FPS", "#0ff", "#002")), u = i(new t.Panel("MS", "#0f0", "#020"));
        if (self.performance && self.performance.memory) var d = i(new t.Panel("MB", "#f08", "#201"));
        return n(0), { REVISION: 16, dom: a, addPanel: i, showPanel: n, begin: function() {
          o = (performance || Date).now();
        }, end: function() {
          c++;
          var p = (performance || Date).now();
          if (u.update(p - o, 200), p > l + 1e3 && (h.update(1e3 * c / (p - l), 100), l = p, c = 0, d)) {
            var f = performance.memory;
            d.update(f.usedJSHeapSize / 1048576, f.jsHeapSizeLimit / 1048576);
          }
          return p;
        }, update: function() {
          o = this.end();
        }, domElement: a, setMode: n };
      };
      return t.Panel = function(i, n, r) {
        var a = 1 / 0, o = 0, l = Math.round, c = l(window.devicePixelRatio || 1), h = 80 * c, u = 48 * c, d = 3 * c, p = 2 * c, f = 3 * c, y = 15 * c, A = 74 * c, m = 30 * c, v = document.createElement("canvas");
        v.width = h, v.height = u, v.style.cssText = "width:80px;height:48px";
        var g = v.getContext("2d");
        return g.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif", g.textBaseline = "top", g.fillStyle = r, g.fillRect(0, 0, h, u), g.fillStyle = n, g.fillText(i, d, p), g.fillRect(f, y, A, m), g.fillStyle = r, g.globalAlpha = 0.9, g.fillRect(f, y, A, m), { dom: v, update: function(_, w) {
          a = Math.min(a, _), o = Math.max(o, _), g.fillStyle = r, g.globalAlpha = 1, g.fillRect(0, 0, h, y), g.fillStyle = n, g.fillText(l(_) + " " + i + " (" + l(a) + "-" + l(o) + ")", d, p), g.drawImage(v, f + c, y, A - c, m, f, y, A - c, m), g.fillRect(f + A - c, y, c, m), g.fillStyle = r, g.globalAlpha = 0.9, g.fillRect(f + A - c, y, c, l((1 - _ / w) * m));
        } };
      }, t;
    });
  }(Fd)), Fd.exports;
}
var bB = EB();
const SB = /* @__PURE__ */ xB(bB);
class CB {
  constructor(e) {
    this._stats = new SB(), this._container = e, this._stats.dom.id = "stats-js", this._stats.dom.style.position = "absolute", this._stats.dom.style.left = "unset", this._stats.dom.style.right = "0";
  }
  show() {
    this._container.appendChild(this._stats.dom), this._stats.showPanel(0);
  }
  hide() {
    this._container.removeChild(this._stats.dom);
  }
  begin() {
    this._stats.begin();
  }
  end() {
    this._stats.end();
  }
}
const MB = ".CustomContextMenu{position:absolute;background:#333e;min-width:8rem;color:#fff;font-size:.8rem;overflow:hidden;border-radius:8px;box-shadow:2px 2px 10px #6666;z-index:100000}.CustomContextMenu div{cursor:pointer;padding:6px 10px;transition:background-color .25s ease-in-out}.CustomContextMenu div:hover{background:#1a1a1c}#customContextMenu{background:#333e;-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);border:.5px solid rgba(20,20,20,.3);width:auto;height:auto;position:absolute;display:flex;flex-direction:column;z-index:9999;padding:.4rem .25rem;border-radius:.375rem;min-width:8rem;pointer-events:auto;box-shadow:0 2px 10px #0c0c0c33}.customContextMenuItems{color:#fff;font-size:.8rem;font-family:monospace;background-color:transparent;cursor:pointer;padding:4px 8px;border-radius:.25rem;line-height:1rem;font-weight:500;transition:background-color .25s ease-in-out}.customContextMenuItems:hover{color:#fff;background-color:#017aff}", Rp = class Rp {
  /**
   * Initializes the context menu by adding event listeners.
   * This method should be called before creating a context menu.
   */
  static _initialize() {
    this._inited = !0, document.addEventListener("pointerdown", (e) => {
      this.Element && !this.Element.contains(e.target) && e.button === 0 && this.Remove();
    });
  }
  /**
   * Creates a custom context menu with specified items and options.
   *
   * @param items - An object containing menu item labels and corresponding callback functions.
   * @param x - The horizontal position of the context menu.
   * @param y - The vertical position of the context menu.
   * @param show - Indicates whether the context menu should be displayed immediately.
   * @param removeOnSelect - Indicates whether the context menu should be removed after an item is selected.
   * @returns The HTML element representing the created context menu.
   */
  static Create(e, t, i, n = !0, r = !0) {
    this._inited || this._initialize(), this.Element && this.Remove();
    const a = document.createElement("div");
    a.id = "customContextMenu", a.style.top = i + "px", a.style.left = t + "px", a.innerHTML = "<style>" + MB + "</style>";
    for (const [o, l] of Object.entries(e)) {
      const c = document.createElement("div");
      c.classList.add("customContextMenuItems"), c.innerHTML = o, a.appendChild(c), c.onclick = async () => {
        await l(), r && this.Remove();
      };
    }
    return this.Element = a, n && document.body.appendChild(a), a;
  }
  /**
   * Removes the context menu from the DOM.
   */
  static Remove() {
    var e;
    (e = this.Element) == null || e.remove(), this.Element = void 0;
  }
};
Rp.Element = void 0, Rp._inited = !1;
let cp = Rp;
const Bp = class Bp {
  get inputEl() {
    return this._inputEl;
  }
  get el() {
    return this._el;
  }
  constructor(e, t, i) {
    this._el = e, this._inputEl = t, this._listeners = {
      drop: [],
      dropstart: [],
      droperror: []
    }, this._onDragover = this._onDragover.bind(this), this._onDrop = this._onDrop.bind(this), this._onSelect = this._onSelect.bind(this), e == null || e.addEventListener("dragover", this._onDragover, !1), e == null || e.addEventListener("drop", this._onDrop, !1), t == null || t.addEventListener("change", this._onSelect), i && Object.entries(i).forEach(([n, r]) => r && this.on(n, r));
  }
  on(e, t) {
    return this._listeners[e].push(t), this;
  }
  _emit(e, t) {
    return this._listeners[e].forEach((i) => i(t)), this;
  }
  /**
   * Destroys the instance.
   */
  destroy() {
    const e = this._el, t = this._inputEl;
    e == null || e.removeEventListener("dragover", this._onDragover), e == null || e.removeEventListener("drop", this._onDrop), t == null || t.removeEventListener("change", this._onSelect);
  }
  /**
   * References (and horror):
   * - https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/items
   * - https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/files
   * - https://code.flickr.net/2012/12/10/drag-n-drop/
   * - https://stackoverflow.com/q/44842247/1314762
   *
   */
  _onDrop(e) {
    var n, r;
    e.stopPropagation(), e.preventDefault(), this._emit("dropstart");
    const t = Array.from(((n = e.dataTransfer) == null ? void 0 : n.files) || []), i = Array.from(((r = e.dataTransfer) == null ? void 0 : r.items) || []);
    if (t.length === 0 && i.length === 0) {
      this._fail("Required drag-and-drop APIs are not supported in this browser.");
      return;
    }
    if (Bp.USE_DATA_TRANSFER_ITEMS && i.length > 0) {
      const a = i.map((o) => o.webkitGetAsEntry());
      this._loadNextEntry(/* @__PURE__ */ new Map(), a, e);
      return;
    }
    this._emit("drop", {
      nativeEvent: e,
      files: new Map(t.map((a) => (a.filePath = a.name, [a.filePath, a])))
    });
  }
  /**
   * @param  {Event} e
   */
  _onDragover(e) {
    e.stopPropagation(), e.preventDefault(), e.dataTransfer && (e.dataTransfer.dropEffect = "copy");
  }
  _onSelect(e) {
    if (!this._inputEl) {
      console.warn("Invalid Dropzone event ", e);
      return;
    }
    this._emit("dropstart");
    const t = [].slice.call(this._inputEl.files ?? new FileList()), i = /* @__PURE__ */ new Map();
    t.forEach((n) => {
      n.filePath = n.webkitRelativePath || n.name, i.set(n.filePath, n);
    }), this._emit("drop", { files: i, nativeEvent: e });
  }
  /**
   * Iterates through a list of FileSystemEntry objects, creates the fileMap
   * tree, and emits the result.
   * @param fileMap
   * @param  {Array<FileSystemEntry>} entries
   * @param e
   */
  _loadNextEntry(e, t, i) {
    const n = t.pop();
    if (!n) {
      this._emit("drop", { files: e, nativeEvent: i });
      return;
    }
    if (n.isFile)
      n.file((r) => {
        r.filePath = n.fullPath, e.set(n.fullPath, r), this._loadNextEntry(e, t, i);
      }, (r) => console.error("Could not load file: %s", n.fullPath, r, "Try setting Dropzone.USE_DATA_TRANSFER_ITEMS to false."));
    else if (n.isDirectory) {
      const r = n.createReader(), a = (o) => {
        o.length ? (t = t.concat(o), r.readEntries(a)) : this._loadNextEntry(e, t, i);
      };
      r.readEntries(a);
    } else
      console.warn("Unknown asset type: " + n.fullPath), this._loadNextEntry(e, t, i);
  }
  // /**
  //  * Inflates a File in .ZIP format, creates the fileMap tree, and emits the
  //  * result.
  //  * @param  {File} file
  //  */
  // _loadZip(file) {
  //     const pending = []
  //     const fileMap = new Map()
  //     const archive = new fs.FS()
  //
  //     const traverse = (node) => {
  //         if (node.directory) {
  //             node.children.forEach(traverse)
  //         } else if (node.name[0] !== '.') {
  //             pending.push(new Promise((resolve) => {
  //                 node.getData(new zip.BlobWriter(), (blob) => {
  //                     blob.name = node.name
  //                     fileMap.set(node.getFullname(), blob)
  //                     resolve()
  //                 })
  //             }))
  //         }
  //     }
  //
  //     archive.importBlob(file, () => {
  //         traverse(archive.root)
  //         Promise.all(pending).then(() => {
  //             this._emit('drop', {files: fileMap, archive: file})
  //         })
  //     })
  // }
  // /**
  //  * @param  {File} file
  //  * @return {Boolean}
  //  */
  // _isZip(file) {
  //     return file.type === 'application/zip' || file.name.match(/\.zip$/)
  // }
  /**
   * @throws
   */
  _fail(e) {
    this._emit("droperror", { message: e });
  }
};
Bp.USE_DATA_TRANSFER_ITEMS = !0;
let cg = Bp;
function qv(s) {
  if (!s) return Ft;
  const e = s.extensions.has("EXT_color_buffer_half_float") || s.capabilities.isWebGL2 && s.extensions.has("EXT_color_buffer_float"), t = s.capabilities.isWebGL2 || s.extensions.has("OES_texture_float") || s.extensions.has("WEBGL_color_buffer_float");
  return e ? Qt : t ? Xt : Ft;
}
function sE(s, e, t) {
  const i = (t == null ? void 0 : t.data) ?? new Uint8ClampedArray(s.height * s.width * 4), n = s.data instanceof Float32Array, r = s.data instanceof Uint16Array;
  for (let a = 0; a < i.length; a++)
    n ? i[a] = s.data[a] * 255 : r ? i[a] = Gn.fromHalfFloat(s.data[a]) * 255 : i[a] = s.data[a], e === Mt && (i[a] = YR(i[a] / 255) * 255);
  return t ?? new ImageData(i, s.width, s.height);
}
function VA(s, e, t = !1) {
  let i;
  return s.isDataTexture ? i = sE(s.image, s.colorSpace) : i = s.image, TB(i, e, t);
}
function TB(s, e, t = !1) {
  let i, n;
  window.VideoFrame || (window.VideoFrame = HTMLVideoElement), s instanceof window.VideoFrame ? (i = s.displayWidth, n = s.displayHeight) : (i = s.width, n = s.height), window.VideoFrame === HTMLVideoElement && delete window.VideoFrame;
  const r = document.createElement("canvas");
  r.width = Math.min(e, i), r.height = Math.floor(1 + r.width * n / i);
  const a = r.getContext("2d");
  if (!a)
    return console.error("textureToDataUrl: could not get canvas context"), r;
  t === !0 && (a.translate(0, r.height), a.scale(1, -1));
  let o = !1;
  if (s.data !== void 0) {
    const l = s;
    if (i !== r.width || n !== r.height) {
      const c = document.createElement("canvas");
      c.width = i, c.height = n;
      const h = c.getContext("2d");
      h ? (h.putImageData(l, 0, 0), a.drawImage(c, 0, 0, r.width, r.height)) : (console.error("textureToDataUrl: could not get temp canvas context"), a.putImageData(l, 0, 0));
    } else
      a.putImageData(l, 0, 0), t && (o = !0);
  } else
    a.drawImage(s, 0, 0, r.width, r.height);
  return o ? eE(r) : r;
}
function pz(s, e, t, i, n) {
  return VA(s, e, t).toDataURL(i, n);
}
async function fz(s, e, t, i, n) {
  const r = VA(s, e, t);
  return new Promise((a, o) => {
    r.toBlob((l) => {
      l ? a(l) : o(new Error("Failed to create blob"));
    }, i, n);
  });
}
const IB = (s) => (e, t) => {
  var i;
  return ((i = t == null ? void 0 : t.copy) == null ? void 0 : i.call(t, e)) ?? new s().copy(e);
}, Rh = class Rh {
};
(() => {
  const e = [
    [ie, "isVector2", ["x", "y"]],
    [M, "isVector3", ["x", "y", "z"]],
    [it, "isVector4", ["x", "y", "z", "w"]],
    [rt, "isQuaternion", ["x", "y", "z", "w"]],
    [se, "isColor", ["r", "g", "b"]],
    [yt, "isMatrix3", ["elements"]],
    [Ue, "isMatrix4", ["elements"]]
  ];
  Sn.RegisterSerializer(...e.map((t) => ({
    priority: 1,
    isType: (i) => i[t[1]],
    serialize: (i) => {
      const n = { [t[1]]: !0 };
      for (const r of t[2]) n[r] = i[r];
      return n;
    },
    deserialize: IB(t[0])
  }))), Sn.RegisterSerializer({
    priority: 2,
    isType: (t) => {
      var i;
      return t.isTexture || ((i = t.metadata) == null ? void 0 : i.type) === "Texture";
    },
    serialize: (t, i) => {
      if (!(t != null && t.isTexture)) throw new Error("Expected a texture");
      if (t.isRenderTargetTexture) return;
      if (i != null && i.textures[t.uuid]) return { uuid: t.uuid, resource: "textures" };
      const n = t.source.data, r = !t.isRenderTargetTexture && t.userData.rootPath;
      let a = {};
      const o = t.userData;
      try {
        r && t.source.data && (t.userData.embedUrlImagePreviews ? t.source.data = VA(t, 16, t.flipY) : t.source.data = null), t.userData = {};
        const l = { images: {} };
        a = t.toJSON(i || l), !i && a.image && (a.image = r && !t.userData.embedUrlImagePreviews ? void 0 : l.images[a.image]), a.userData = Sn.Serialize(rE({}, o), i, !1);
      } catch (l) {
        console.error("Threepipe Serialization: Unable to serialize texture"), console.error(l);
      }
      return t.userData = o, r && (i && !t.userData.embedUrlImagePreviews && delete i.images[t.source.uuid], t.source.data = n), i != null && i.textures && a && !a.resource && (i.textures[a.uuid] || (i.textures[a.uuid] = a), a = { uuid: a.uuid, resource: "textures" }), a;
    },
    deserialize: (t, i, n) => {
      var u, d;
      if (t.isTexture) return t;
      if (t.resource === "textures" && ((u = n == null ? void 0 : n.textures) != null && u[t.uuid])) return n.textures[t.uuid];
      console.warn("Cannot deserialize texture into object like primitive, since textures need to be loaded asynchronously. Trying with ObjectLoader. Load events might not work properly.", t, i);
      const r = (n == null ? void 0 : n._context.objectLoader) ?? new OA((d = n == null ? void 0 : n._context.assetImporter) == null ? void 0 : d.loadingManager), a = { ...t };
      if (typeof a.image == "string" && (n != null && n.images ? a.image = n.images[a.image] : console.error("Cannot deserialize texture with image url without meta.images", a)), !a.image || typeof a.image == "string" || !a.image.isSource && !a.image.url)
        return console.error("Cannot deserialize texture", a), i;
      let o;
      n && !a.image.isSource && (n._context.imagePromises || (n._context.imagePromises = []), n._context.imagePromises.push(new Promise((p) => {
        o = p;
      })));
      const l = a.image.isSource ? { [a.image.uuid]: a.image } : r.parseImages([a.image], o);
      a.image = Object.keys(l)[0], n != null && n.images && (n.images[a.image] = l[a.image]), a.userData && (a.userData = Rh.Deserialize(a.userData, {}, n));
      const c = r.parseTextures([a], l), h = Object.keys(c)[0];
      return !h || !c[h] ? (console.error("Cannot deserialize texture", a), i) : (n != null && n.textures && (n.textures[h] = c[h]), c[h]);
    }
  }), Sn.RegisterSerializer({
    priority: 2,
    isType: (t) => {
      var i;
      return t.isMaterial || ((i = t.metadata) == null ? void 0 : i.type) === "Material";
    },
    serialize: (t, i) => {
      var h;
      if (!(t != null && t.isMaterial)) throw new Error("Expected a material");
      if ((h = i == null ? void 0 : i.materials) != null && h[t.uuid]) return { uuid: t.uuid, resource: "materials" };
      t.userData.rootPath && console.error("TODO: handle material with root path with material inheritance/hierarchy");
      const n = i ?? { textures: {}, images: {} }, r = {}, a = {}, o = Object.keys(t.constructor.MaterialProperties || t);
      for (const u of o) {
        if (u.startsWith("__")) continue;
        const d = t[u];
        if (d != null && d.isTexture) {
          const p = Sn.Serialize(d, n);
          r[u] = p, a[u] = d, t[u] = p ? { isTexture: !0, toJSON: () => p } : null;
        }
      }
      const l = t.userData;
      t.userData = {};
      let c = {};
      try {
        c = t.toJSON(i || n, !0), DB(c, l, i), c.userData.uuid = l.uuid, t.constructor.TYPE && (c.type = t.constructor.TYPE);
        for (const u of Object.keys(c)) c[u] === void 0 && delete c[u];
      } catch (u) {
        console.error("Threepipe Serialization: Unable to serialize material"), console.error(u);
      }
      t.userData = l;
      for (const [u, d] of Object.entries(a))
        t[u] = d, delete a[u];
      if (c)
        if (i) {
          for (const [u, d] of Object.entries(r))
            d && (c[u] = d);
          i.materials && (i.materials[c.uuid] || (i.materials[c.uuid] = c), c = { uuid: c.uuid, resource: "materials" });
        } else {
          for (const [u, d] of Object.entries(r))
            d && (c[u] = d.uuid);
          c.textures = Object.values(n.textures), c.images = Object.values(n.images);
        }
      return c;
    },
    deserialize: (t, i, n) => {
      var f, y, A, m, v;
      function r(g) {
        if (g.isMaterial)
          return i != null && i.isMaterial && i.uuid === g.uuid ? (i !== g && typeof i.setValues == "function" && (console.warn("material uuid already exists, copying values to old material"), i.setValues(g)), i) : g;
      }
      let a = r(t);
      if (a !== void 0) return a;
      if (t.resource === "materials" && ((f = n == null ? void 0 : n.materials) != null && f[t.uuid])) {
        if (a = r(n.materials[t.uuid]), a !== void 0) return a;
        console.error("cannot find material in meta", t, a);
      }
      const o = t.type;
      if (!o)
        return console.error("Cannot deserialize material without type", t), i;
      const l = { ...t };
      l.userData && (l.userData = Sn.Deserialize(l.userData, void 0, n, !1));
      const c = {};
      for (const [g, _] of Object.entries(l)) {
        if (typeof _ == "string" && ((y = n == null ? void 0 : n.textures) != null && y[_]) && (l[g] = n.textures[_], c[g] = n.textures[_]), !_ || !_.resource || typeof _.resource != "string") continue;
        const w = (A = n == null ? void 0 : n[_.resource]) == null ? void 0 : A[_.uuid];
        l[g] = w || null, _.resource === "textures" && (w != null && w.isTexture) && (c[g] = w);
      }
      if ((!i || !i.isMaterial || i.type !== o && ((m = i.constructor) == null ? void 0 : m.TYPE) !== o) && (i && Object.keys(i).length && console.warn("Material type mismatch during deserialize, creating a new material", i, l, o, (v = i.constructor) == null ? void 0 : v.type), i = null), i && (!l.uuid || i.uuid === l.uuid))
        return i.fromJSON ? i.fromJSON(l, n, !0) : i.setValues ? i.setValues(l) : console.error("Cannot deserialize material, no fromJSON or setValues method", i, l), i;
      const h = n == null ? void 0 : n._context.materialManager;
      if (h) {
        const g = h.create(o);
        if (g)
          return g.fromJSON ? g.fromJSON(l, n, !0) : g.setValues ? g.setValues(l) : console.error("Cannot deserialize material, no fromJSON or setValues method", g, l), g;
      }
      console.warn("Legacy three.js material deserialization");
      const u = new Wp();
      for (const [g, _] of Object.entries(c))
        l[g] = _.uuid;
      const d = { ...u.textures };
      u.setTextures(c);
      const p = u.parse(l);
      if (u.setTextures(d), a = r(p), a !== void 0) return a;
      console.error("cannot deserialize material", t, a, p);
    }
  }), Sn.RegisterSerializer({
    priority: 2,
    isType: (t) => {
      var i;
      return t.isWebGLRenderTarget || ((i = t.metadata) == null ? void 0 : i.type) === "RenderTarget";
    },
    serialize: (t, i) => {
      var a;
      if (!(t != null && t.isWebGLRenderTarget) || !t.uuid) throw new Error("Expected a IRenderTarget");
      if (i != null && i.extras[t.uuid]) return { uuid: t.uuid, resource: "extras" };
      const n = Array.isArray(t.texture) ? t.texture[0] : t.texture;
      let r = {
        metadata: { type: "RenderTarget" },
        uuid: t.uuid,
        width: t.width,
        height: t.height,
        depth: t.depth,
        sizeMultiplier: t.sizeMultiplier,
        count: Array.isArray(t.texture) ? t.texture.length : void 0,
        isCubeRenderTarget: t.isWebGLCubeRenderTarget || void 0,
        isTemporary: t.isTemporary,
        textureName: Array.isArray(t.texture) ? t.texture.map((o) => o.name) : (a = t.texture) == null ? void 0 : a.name,
        options: {
          wrapS: n == null ? void 0 : n.wrapS,
          wrapT: n == null ? void 0 : n.wrapT,
          magFilter: n == null ? void 0 : n.magFilter,
          minFilter: n == null ? void 0 : n.minFilter,
          format: n == null ? void 0 : n.format,
          type: n == null ? void 0 : n.type,
          anisotropy: n == null ? void 0 : n.anisotropy,
          depthBuffer: !!t.depthBuffer,
          stencilBuffer: !!t.stencilBuffer,
          generateMipmaps: n == null ? void 0 : n.generateMipmaps,
          depthTexture: !!t.depthTexture,
          colorSpace: n == null ? void 0 : n.colorSpace,
          samples: t.samples
        }
      };
      return i != null && i.extras && (i.extras[r.uuid] || (i.extras[r.uuid] = r), r = { uuid: r.uuid, resource: "extras" }), r;
    },
    deserialize: (t, i, n) => {
      if ((i == null ? void 0 : i.uuid) === t.uuid) return i;
      if (t.isWebGLRenderTarget) return t;
      const r = n == null ? void 0 : n._context.renderManager;
      if (!r)
        return console.error("Cannot deserialize render target without render manager", t), i;
      if (t.isWebGLCubeRenderTarget || t.isTemporary)
        return console.warn("Cannot deserialize WebGLCubeRenderTarget or temporary render target yet", t), i;
      const a = r.createTarget({
        sizeMultiplier: t.sizeMultiplier || void 0,
        size: t.sizeMultiplier ? void 0 : { width: t.width, height: t.height },
        textureCount: t.count,
        ...t.options
      });
      if (t.textureName)
        if (Array.isArray(t.textureName) && Array.isArray(a.texture))
          for (let o = 0; o < t.textureName.length; o++)
            a.texture[o].name = t.textureName[o];
        else Array.isArray(a.texture) || (a.texture.name = Array.isArray(t.textureName) ? t.textureName[0] : t.textureName);
      return a && (a.uuid = t.uuid, n != null && n.extras && (n.extras[t.uuid] = a), a);
    }
  });
})(), Rh.Serialize = Sn.Serialize, Rh.Deserialize = Sn.Deserialize;
let mt = Rh;
function Xp(s, e, t = [], i = !0) {
  if (!e) return s;
  for (const n of Object.keys(e)) {
    if (i && t.includes(n) || n.startsWith("__")) continue;
    const r = e[n];
    if (typeof s[n] == "function" || typeof r == "function") continue;
    const a = !r || r.isTexture || r.isObject3D || r.isMaterial;
    !a && typeof r.clone == "function" ? s[n] = r.clone() : !a && (r.constructor === Object || Array.isArray(r)) ? s[n] = Xp(Array.isArray(r) ? [] : {}, r, t, !1) : s[n] = r;
  }
  return s;
}
function rE(s, e, t = ["uuid"], i = !0) {
  return Xp(s, e, t, i);
}
function aE(s, e, t = ["uuid"], i = !0) {
  return Xp(s, e, t, i);
}
function hg(s, e, t = ["uuid"], i = !0) {
  return Xp(s, e, t, i);
}
function DB(s, e, t) {
  var n, r;
  s.userData = {}, aE(s.userData, e);
  const i = t || {
    // Make meta object for the Serializer from the data. This requires changing from Array to Object for textures and images
    textures: Object.fromEntries(((n = s.textures) == null ? void 0 : n.map((a) => [a.uuid, a])) || []),
    images: Object.fromEntries(((r = s.images) == null ? void 0 : r.map((a) => [a.uuid, a])) || [])
  };
  s.userData = Sn.Serialize(s.userData, i), t || (Object.keys(i.textures).length > 0 && (s.textures = Object.values(i.textures)), Object.keys(i.images).length > 0 && (s.images = Object.values(i.images)));
}
function Xv(s) {
  Object.values(s).forEach((e) => {
    e && Object.values(e).forEach((t) => {
      t.url && (!(t.url.data instanceof ArrayBuffer) && !Array.isArray(t.url.data) || (t.url.type === "Uint16Array" ? (t.url.data instanceof Uint16Array || (t.url.data = new Uint16Array(t.url.data)), t.url.data = "data:application/octet-stream;base64," + $f(t.url.data.buffer)) : t.url.type === "Uint8Array" ? (t.url.data instanceof Uint8Array || (t.url.data = new Uint8Array(t.url.data)), t.url.data = "data:application/octet-stream;base64," + $f(t.url.data.buffer)) : t.url.data instanceof ArrayBuffer ? t.url.data = "data:application/octet-stream;base64," + $f(t.url.data.buffer) : console.warn("Unsupported buffer type", t.url.type)));
    });
  });
}
function RB(s) {
  Object.values(s).forEach((e) => {
    e && Object.values(e).forEach((t) => {
      if (!t || !t.url || typeof t.url.data != "string") return;
      const i = t.url.data.match(/^data:.*;base64,(.*)$/);
      i != null && i[1] ? t.url.data = Yw(i == null ? void 0 : i[1]) : (t.url.type !== "Uint8Array" && console.error("Unsupported buffer type string for ", t.url.type, "use base64"), t.url.data = new TextEncoder().encode(t.url.data).buffer);
    });
  });
}
function Sa(s) {
  return {
    // see Object3D.js toJSON for more details
    geometries: { ...s == null ? void 0 : s.geometries },
    materials: { ...s == null ? void 0 : s.materials },
    textures: { ...s == null ? void 0 : s.textures },
    images: { ...s == null ? void 0 : s.images },
    shapes: { ...s == null ? void 0 : s.shapes },
    skeletons: { ...s == null ? void 0 : s.skeletons },
    animations: { ...s == null ? void 0 : s.animations },
    extras: { ...s == null ? void 0 : s.extras },
    _context: {}
  };
}
class WA {
  /**
   * @param json
   * @param objLoader
   * @param extraResources - preloaded resources in the format of viewer config resources.
   */
  static async ImportMeta(e, t) {
    var c;
    if (e.__isLoadedResources) return e;
    const i = oE();
    i._context = e._context, RB(e);
    const n = e._context.assetImporter;
    if (!n) throw new Error("assetImporter not found in meta context, which is required for import meta.");
    const r = e._context.objectLoader || new OA(n.loadingManager);
    i.animations = e.animations ? r.parseAnimations(Object.values(e.animations)) : {}, t && t.animations && (i.animations = { ...i.animations, ...t.animations }), i.shapes = e.shapes ? r.parseShapes(Object.values(e.shapes)) : {}, t && t.shapes && (i.shapes = { ...i.shapes, ...t.shapes }), i.geometries = e.geometries ? r.parseGeometries(Object.values(e.geometries), i.shapes) : {}, t && t.geometries && (i.geometries = { ...i.geometries, ...t.geometries }), i.images = e.images ? await r.parseImagesAsync(Object.values(e.images)) : {}, t && t.images && (i.images = { ...i.images, ...t.images }), Array.isArray(e.textures) && (console.error("TODO: check file format"), e.textures = e.textures.reduce((h, u) => (u && (h[u.uuid] = u), h))), await WA.LoadRootPathTextures({ textures: e.textures, images: i.images }, n);
    const a = [];
    for (const h of Object.values(e.textures)) {
      const u = { ...h };
      u.userData && (u.userData = mt.Deserialize(u.userData, {}, i)), a.push(u);
    }
    i.textures = e.textures ? r.parseTextures(a, i.images) : {};
    const o = { ...i.textures };
    for (const h of Object.values(e.textures))
      (c = h.rootPathPromise) == null || c.then((u) => {
        if (!u) return;
        const d = o[h.uuid];
        d.dispose(), d.source = u, d.source.needsUpdate = !0, d.needsUpdate = !0;
      });
    for (const h of Object.entries(i.textures))
      h[1] = await n.processRawSingle(h[1], {}), h[1] ? i.textures[h[0]] = h[1] : delete i.textures[h[0]];
    t && t.textures && (i.textures = { ...i.textures, ...t.textures });
    const l = e.materials ? Object.values(e.materials) : [];
    i.materials = {};
    for (const h of l)
      h != null && h.uuid && (i.materials[h.uuid] = mt.Deserialize(h, void 0, i));
    if (t && t.materials && (i.materials = { ...i.materials, ...t.materials }), e.object && (i.object = r.parseObject(e.object, i.geometries, i.materials, i.textures, i.animations), e.skeletons && (i.skeletons = r.parseSkeletons(Object.values(e.skeletons), i.object), r.bindSkeletons(i.object, i.skeletons))), e.extras) {
      i.extras = e.extras;
      for (const h of Object.values(e.extras))
        if (h.uuid) {
          if (!h.url) {
            i.extras[h.uuid] = mt.Deserialize(h, void 0, i);
            continue;
          }
          if (typeof h.url == "string") {
            const u = await n.importPath(h.url);
            (u == null ? void 0 : u.length) > 0 && (i.extras[h.uuid] = u[0]);
          } else if (h.url.data) {
            const u = new File([HR(h.url.type, h.url.data)], h.url.path), d = await n.importAsset({ path: u.name, file: u });
            (d == null ? void 0 : d.length) > 0 && (i.extras[h.uuid] = d[0]);
          } else
            console.warn("invalid URL type while loading extra resource");
        }
    }
    return t && t.extras && (i.extras = { ...i.extras, ...t.extras }), i.__isLoadedResources = !0, i;
  }
  static async LoadRootPathTextures({ textures: e, images: t }, i, n = !0) {
    var a;
    const r = [];
    for (const o of Array.isArray(e) ? e : Object.values(e ?? {})) {
      const l = (a = o == null ? void 0 : o.userData) == null ? void 0 : a.rootPath, c = n && o.image && t[o.image];
      if (!l) continue;
      const h = i.importSingle(l, { processRaw: !1 }).then((u) => {
        const d = u == null ? void 0 : u.source;
        if (!u || !d) return null;
        const p = new Aa(d.data);
        return o.image && (p.uuid = o.image), o.image = p.uuid, c || (t[p.uuid] = p), u.dispose(), p;
      }).catch((u) => (console.error(u), delete o.userData.rootPath, null));
      c ? o.rootPathPromise = h : r.push(h);
    }
    await Promise.allSettled(r);
  }
}
function Zf(s) {
  if (!s) return {};
  const e = { ...s };
  return e._context && delete e._context, e;
}
function oE(s, e) {
  return {
    ...s,
    ...Sa(s),
    _context: {
      assetManager: e == null ? void 0 : e.assetManager,
      assetImporter: e == null ? void 0 : e.assetManager.importer,
      materialManager: e == null ? void 0 : e.assetManager.materials,
      renderManager: e == null ? void 0 : e.renderManager
    }
    // clear context even if its present in resources
  };
}
function Yv(s) {
  const e = new Blob([JSON.stringify(s)], { type: "application/json" });
  return e.ext = "json", e;
}
function BB(s, e, t, i) {
  var a, o, l;
  if (e != null && e.extras[s.uuid]) return { uuid: s.uuid, resource: "extras" };
  let n = "";
  if ((a = s.source) != null && a._sourceImgBuffer || s.__sourceBuffer) {
    const c = new Uint8Array(((o = s.source) == null ? void 0 : o._sourceImgBuffer) || s.__sourceBuffer), h = i || s.userData.mimeType || "";
    n = {
      data: Array.from(c),
      // texture need to be a normal array, not a typed array.
      type: c.constructor.name,
      path: ((l = s.userData.__sourceBlob) == null ? void 0 : l.name) || s.userData.rootPath || "file." + h.split("/")[1]
    }, h && (n.mimeType = h);
  } else s.userData.rootPath ? n = s.userData.rootPath : console.error("Unable to serialize LUT texture, not loaded through asset manager.");
  const r = {
    uuid: s.uuid,
    url: n,
    userData: rE({}, s.userData),
    type: s.type,
    name: t || s.name
  };
  return e != null && e.extras ? (e.extras[s.uuid] = r, { uuid: s.uuid, resource: "extras" }) : r;
}
const Kv = "shaderReplaceString: str must be passed if str is a RegExp and append/prepend is true";
function Ct(s, e, t, {
  replaceAll: i = !1,
  prepend: n = !1,
  append: r = !1,
  str: a = void 0
} = {}) {
  const o = typeof e == "string";
  if (o ? !s.includes(e) : !e.test(s))
    return console.error(`${e} not found in shader`), s;
  let l = t;
  if (a = a ?? (o ? e : void 0), n) {
    if (typeof a != "string") throw new Error(Kv);
    l = t + a;
  } else if (r) {
    if (typeof a != "string") throw new Error(Kv);
    l = a + t;
  }
  return i ? s.replaceAll(e, l) : s.replace(e, l);
}
function Jv(s, e = 0) {
  const t = PB(s.byteLength);
  if (t !== s.byteLength) {
    const i = new Uint8Array(t);
    if (i.set(new Uint8Array(s)), e !== 0)
      for (let n = s.byteLength; n < t; n++)
        i[n] = e;
    return i.buffer;
  }
  return s.buffer;
}
function PB(s) {
  return Math.ceil(s / 4) * 4;
}
const $v = 12, LB = 1179937895, UB = 2, Zv = 8, FB = 1313821514, OB = 5130562;
function NB(s, e) {
  const t = Jv(s), i = new DataView(new ArrayBuffer(Zv));
  i.setUint32(0, t.byteLength, !0), i.setUint32(4, OB, !0);
  const n = new TextEncoder().encode(JSON.stringify(e || {})), r = Jv(n, 32), a = new DataView(new ArrayBuffer(Zv));
  a.setUint32(0, r.byteLength, !0), a.setUint32(4, FB, !0);
  const o = new ArrayBuffer($v), l = new DataView(o);
  l.setUint32(0, LB, !0), l.setUint32(4, UB, !0);
  const c = $v + a.byteLength + r.byteLength + i.byteLength + t.byteLength;
  l.setUint32(8, c, !0);
  const h = new Blob([
    o,
    a,
    r,
    i,
    t
  ], { type: "model/gltf+binary" });
  return h.ext = "glb", h;
}
function e_(s, e) {
  let t, i;
  if (Array.isArray(s))
    for (const r of s) {
      const a = e_(r, e);
      t === void 0 || i === void 0 ? (t = a.min.clone(), i = a.max.clone()) : (t.min(a.min), i.max(a.max));
    }
  const n = s;
  if (n.geometry !== void 0) {
    const r = n.geometry.vertices;
    if (r === void 0 && n.geometry.attributes !== void 0 && "position" in n.geometry.attributes) {
      const a = new M(), o = n.geometry.attributes.position;
      for (let l = 0; l < o.count * o.itemSize; l += o.itemSize) {
        a.set(o.array[l], o.array[l + 1], o.array[3]);
        const h = a.applyMatrix4(s.matrixWorld).project(e), u = new ie(h.x, h.y);
        t === void 0 || i === void 0 ? (t = u.clone(), i = u.clone()) : (t.min(u), i.max(u));
      }
    } else
      for (const a of r) {
        const l = a.clone().applyMatrix4(s.matrixWorld).project(e), c = new ie(l.x, l.y);
        t === void 0 || i === void 0 ? (t = c.clone(), i = c.clone()) : (t.min(c), i.max(c));
      }
  }
  if (s.children !== void 0)
    for (const r of s.children) {
      const a = e_(r, e);
      t === void 0 || i === void 0 ? (t = a.min.clone(), i = a.max.clone()) : (t.min(a.min), i.max(a.max));
    }
  return new jw(t, i);
}
function kB(s) {
  const e = { ...us };
  us.get = (t, i, n) => i ? t.startsWith("data:") || t.startsWith("blob") || t.startsWith("chrome-extension") ? Promise.resolve(void 0) : s.match(t).then((r) => {
    if (r)
      switch (i) {
        case "arraybuffer":
          return r.arrayBuffer();
        case "blob":
          return r.blob();
        case "document":
          return r.text().then((a) => new DOMParser().parseFromString(a, n ?? "text/html"));
        case "json":
          return r.json();
        default:
          if (n === void 0)
            return r.text();
          {
            const o = /charset="?([^;"\s]*)"?/i.exec(n), l = o && o[1] ? o[1].toLowerCase() : void 0, c = new TextDecoder(l);
            return r.arrayBuffer().then((h) => c.decode(h));
          }
      }
  }) : e.get(t), us.add = async (t, i, n) => {
    if (!n) return e.add(t, i);
    t.startsWith("data:") || t.startsWith("blob") || t.startsWith("chrome-extension") || (await s.match(t) && await s.delete(t), await s.put(t, new Response(i, { status: 200 })));
  }, us.remove = (t, i) => {
    if (!i) return e.remove(t);
    s.delete(t);
  };
}
function mz(s) {
  const e = new Wr(new Uint8Array([Math.floor(s.r * 255), Math.floor(s.g * 255), Math.floor(s.b * 255), 255]), 1, 1, ei, Ft);
  return e.needsUpdate = !0, e.colorSpace = Mt, e;
}
function gz(s) {
  const e = new Wr(new Uint8Array([Math.floor(s.x * 255), Math.floor(s.y * 255), Math.floor(s.z * 255), Math.floor(s.w * 255)]), 1, 1, ei, Ft);
  return e.needsUpdate = !0, e;
}
function GB(s, e = 3, t) {
  let i, n, r, a, o;
  const l = s.byteLength / (e * 2) | 0;
  t = t || new Uint8ClampedArray(l * 4);
  for (let c = 0; c < l; c++) {
    i = Gn.fromHalfFloat(s[c * e]) * 65504, n = Gn.fromHalfFloat(s[c * e + 1]) * 65504, r = Gn.fromHalfFloat(s[c * e + 2]) * 65504, a = Math.max(Math.max(i, n), r);
    const h = Math.ceil(Math.log2(a));
    o = Math.pow(2, h - 8), t[c * 4] = i / o | 0, t[c * 4 + 1] = n / o | 0, t[c * 4 + 2] = r / o | 0, t[c * 4 + 3] = h + 128;
  }
  return t;
}
function Qo({ uniforms: s, propKey: e, thisTarget: t = !1, onChange: i } = {}) {
  const n = !!s, r = !!e, a = t;
  return (o, l, c) => {
    const h = (d) => {
      const p = a ? d : n ? s : d.uniforms || d._uniforms || d.extraUniforms;
      let f = r ? e : l;
      a && (f = "_" + f);
      let y = p[f];
      return y || (y = { value: null }, p[f] = y), y;
    }, u = {
      get() {
        return h(this).value;
      },
      set(d) {
        const p = h(this);
        p.value !== d && (p.value = d, wo(this, "uniformsNeedUpdate", !0, !0), i && qp.callFunction(i, this, [l, d]));
      }
      // configurable: true,
      // enumerable: true,
    };
    if (c)
      return Jn(c, "value") && delete c.value, Jn(c, "writable") && delete c.writable, Jn(c, "initializer") && delete c.initializer, Object.assign(c, u);
    Object.defineProperty(o, l, u);
  };
}
function jA(s, e, t = !1, i, n, r) {
  const a = !!e, o = !!s;
  return (l, c, h) => {
    const u = (p) => ({ t: a ? e : p.defines || p._defines || p.extraDefines, p: o ? s : c }), d = {
      get() {
        const { t: p, p: f } = u(t ? this : this.material);
        let y = p[f];
        return r && (y = r(y)), y;
      },
      set(p) {
        const { t: f, p: y } = u(t ? this : this.material);
        n && (p = n(p)), wo(f, y, p, !0), p === void 0 && delete f[y], i && typeof i == "function" ? qp.callFunction(i, this, [y, p]) : wo(t ? this : this.material, "needsUpdate", !0, !0);
      }
      // configurable: true,
      // enumerable: true,
    };
    if (h)
      return Jn(h, "value") && delete h.value, Jn(h, "writable") && delete h.writable, Jn(h, "initializer") && delete h.initializer, Object.assign(h, d);
    Object.defineProperty(l, c, d);
  };
}
function Yp(s, e, t = !1, i, n = !1) {
  return jA(s, e, t, i, (r) => r ? "1" : n ? void 0 : "0", (r) => !!(r && r !== "0"));
}
function Ht({ obj: s, key: e, processVal: t, invProcessVal: i, onChange: n, onChangeParams: r = !0 }) {
  const a = !!e;
  return (o, l, c) => {
    const h = (d) => {
      let p = gi(s) || d;
      typeof p == "string" && (p = d[p]);
      let f = a && gi(e) || l, y;
      if (Array.isArray(f)) {
        for (; f.length > 1 && p && typeof p == "object"; )
          p = p[f[0]], f = f.slice(1);
        y = f.length ? f[0] : l;
      } else y = f;
      return { t: p, p: y };
    }, u = {
      get() {
        const { t: d, p } = h(this);
        if (!d || typeof d != "object") return;
        let f = d[p];
        return i && (f = i(f)), f;
      },
      set(d) {
        const { t: p, p: f } = h(this);
        if (!p || typeof p != "object") return;
        t && (d = t(d)), wo(p, f, d, !0), d === void 0 && delete p[f];
        let y = n;
        y && (typeof y == "string" || typeof y == "symbol") && (y = this[y]), y && typeof y == "function" && qp.callFunction(y, this, r ? [f, d] : []);
      }
      // configurable: true,
      // enumerable: true,
    };
    if (c)
      return Jn(c, "value") && delete c.value, Jn(c, "writable") && delete c.writable, Jn(c, "initializer") && delete c.initializer, Object.assign(c, u);
    Object.defineProperty(o, l, u);
  };
}
function zB(s, e) {
  let t;
  switch (e) {
    case Wt:
    case Mt:
      t = "";
      break;
    case dt:
      t = "";
      break;
    case Es:
      t = "RGBM16ToLinear";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported color space:", e), t = "";
      break;
  }
  return `#define ${s}( value ) ${t} ( value )`;
}
function lE(s, e) {
  return zB(s + "TexelToLinear", e ?? Mt) + `
`;
}
function Az(s, e, t = !0) {
  if (!e || !e.isReady)
    throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");
  if (!s.hasAttribute("position") || !s.hasAttribute("normal") || !s.hasAttribute("uv"))
    throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');
  function i(a) {
    if (a.normalized || a.isInterleavedBufferAttribute) {
      const o = new Float32Array(a.count * a.itemSize);
      for (let l = 0, c = 0; l < a.count; l++)
        o[c++] = a.getX(l), o[c++] = a.getY(l), a.itemSize > 2 && (o[c++] = a.getZ(l));
      return o;
    }
    return a.array instanceof Float32Array ? a.array : new Float32Array(a.array);
  }
  const n = s.index ? s.toNonIndexed() : s, r = e.generateTangents(
    i(n.attributes.position),
    i(n.attributes.normal),
    i(n.attributes.uv)
  );
  if (t)
    for (let a = 3; a < r.length; a += 4)
      r[a] *= -1;
  return n.setAttribute("tangent", new Je(r, 4)), s !== n && s.copy(n), s;
}
function QB(s, e = !1) {
  const t = s[0].index !== null, i = new Set(Object.keys(s[0].attributes)), n = new Set(Object.keys(s[0].morphAttributes)), r = {}, a = {}, o = s[0].morphTargetsRelative, l = new Ze();
  let c = 0;
  for (let h = 0; h < s.length; ++h) {
    const u = s[h];
    let d = 0;
    if (t !== (u.index !== null))
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
    for (const p in u.attributes) {
      if (!i.has(p))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + '. All geometries must have compatible attributes; make sure "' + p + '" attribute exists among all geometries, or in none of them.'), null;
      r[p] === void 0 && (r[p] = []), r[p].push(u.attributes[p]), d++;
    }
    if (d !== i.size)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". Make sure all geometries have the same number of attributes."), null;
    if (o !== u.morphTargetsRelative)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
    for (const p in u.morphAttributes) {
      if (!n.has(p))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ".  .morphAttributes must be consistent throughout all geometries."), null;
      a[p] === void 0 && (a[p] = []), a[p].push(u.morphAttributes[p]);
    }
    if (e) {
      let p;
      if (t)
        p = u.index.count;
      else if (u.attributes.position !== void 0)
        p = u.attributes.position.count;
      else
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". The geometry must have either an index or a position attribute"), null;
      l.addGroup(c, p, h), c += p;
    }
  }
  if (t) {
    let h = 0;
    const u = [];
    for (let d = 0; d < s.length; ++d) {
      const p = s[d].index;
      for (let f = 0; f < p.count; ++f)
        u.push(p.getX(f) + h);
      h += s[d].attributes.position.count;
    }
    l.setIndex(u);
  }
  for (const h in r) {
    const u = ug(r[h]);
    if (!u)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + h + " attribute."), null;
    l.setAttribute(h, u);
  }
  for (const h in a) {
    const u = a[h][0].length;
    if (u === 0) break;
    l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[h] = [];
    for (let d = 0; d < u; ++d) {
      const p = [];
      for (let y = 0; y < a[h].length; ++y)
        p.push(a[h][y][d]);
      const f = ug(p);
      if (!f)
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + h + " morphAttribute."), null;
      l.morphAttributes[h].push(f);
    }
  }
  return l;
}
function ug(s) {
  let e, t, i, n = -1, r = 0;
  for (let c = 0; c < s.length; ++c) {
    const h = s[c];
    if (h.isInterleavedBufferAttribute)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."), null;
    if (e === void 0 && (e = h.array.constructor), e !== h.array.constructor)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
    if (t === void 0 && (t = h.itemSize), t !== h.itemSize)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
    if (i === void 0 && (i = h.normalized), i !== h.normalized)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
    if (n === -1 && (n = h.gpuType), n !== h.gpuType)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
    r += h.array.length;
  }
  const a = new e(r);
  let o = 0;
  for (let c = 0; c < s.length; ++c)
    a.set(s[c].array, o), o += s[c].array.length;
  const l = new Je(a, t, i);
  return n !== void 0 && (l.gpuType = n), l;
}
function yz(s) {
  return s.isInstancedInterleavedBufferAttribute || s.isInterleavedBufferAttribute ? dg(s) : s.isInstancedBufferAttribute ? new Da().copy(s) : new Je().copy(s);
}
function vz(s) {
  let e, t = 0, i = 0;
  for (let c = 0, h = s.length; c < h; ++c) {
    const u = s[c];
    if (e === void 0 && (e = u.array.constructor), e !== u.array.constructor)
      return console.error("AttributeBuffers of different types cannot be interleaved"), null;
    t += u.array.length, i += u.itemSize;
  }
  const n = new au(new e(t), i);
  let r = 0;
  const a = [], o = ["getX", "getY", "getZ", "getW"], l = ["setX", "setY", "setZ", "setW"];
  for (let c = 0, h = s.length; c < h; c++) {
    const u = s[c], d = u.itemSize, p = u.count, f = new Cn(n, d, r, u.normalized);
    a.push(f), r += d;
    for (let y = 0; y < p; y++)
      for (let A = 0; A < d; A++)
        f[l[A]](y, u[o[A]](y));
  }
  return a;
}
function dg(s) {
  const e = s.data.array.constructor, t = s.count, i = s.itemSize, n = s.normalized, r = new e(t * i);
  let a;
  s.isInstancedInterleavedBufferAttribute ? a = new Da(r, i, n, s.meshPerAttribute) : a = new Je(r, i, n);
  for (let o = 0; o < t; o++)
    a.setX(o, s.getX(o)), i >= 2 && a.setY(o, s.getY(o)), i >= 3 && a.setZ(o, s.getZ(o)), i >= 4 && a.setW(o, s.getW(o));
  return a;
}
function _z(s) {
  const e = s.attributes, t = s.morphTargets, i = /* @__PURE__ */ new Map();
  for (const n in e) {
    const r = e[n];
    r.isInterleavedBufferAttribute && (i.has(r) || i.set(r, dg(r)), e[n] = i.get(r));
  }
  for (const n in t) {
    const r = t[n];
    r.isInterleavedBufferAttribute && (i.has(r) || i.set(r, dg(r)), t[n] = i.get(r));
  }
}
function xz(s) {
  let e = 0;
  for (const i in s.attributes) {
    const n = s.getAttribute(i);
    e += n.count * n.itemSize * n.array.BYTES_PER_ELEMENT;
  }
  const t = s.getIndex();
  return e += t ? t.count * t.itemSize * t.array.BYTES_PER_ELEMENT : 0, e;
}
function HB(s, e = 1e-4) {
  const t = e > 0;
  e = Math.max(e, Number.EPSILON);
  const i = {}, n = s.getIndex(), r = s.getAttribute("position"), a = n ? n.count : r.count;
  let o = 0;
  const l = Object.keys(s.attributes), c = {}, h = {}, u = [], d = ["getX", "getY", "getZ", "getW"], p = ["setX", "setY", "setZ", "setW"];
  for (let g = 0, _ = l.length; g < _; g++) {
    const w = l[g], S = s.attributes[w];
    c[w] = new Je(
      new S.array.constructor(S.count * S.itemSize),
      S.itemSize,
      S.normalized
    );
    const C = s.morphAttributes[w];
    C && (h[w] = new Je(
      new C.array.constructor(C.count * C.itemSize),
      C.itemSize,
      C.normalized
    ));
  }
  const f = e * 0.5, y = Math.log10(1 / e), A = Math.pow(10, y), m = f * A;
  for (let g = 0; g < a; g++) {
    const _ = n ? n.getX(g) : g;
    let w = "";
    for (let S = 0, C = l.length; S < C && t; S++) {
      const E = l[S], x = s.getAttribute(E), b = x.itemSize;
      for (let D = 0; D < b; D++)
        w += `${~~(x[d[D]](_) * A + m)},`;
    }
    if (t && w in i)
      u.push(i[w]);
    else {
      for (let S = 0, C = l.length; S < C; S++) {
        const E = l[S], x = s.getAttribute(E), b = s.morphAttributes[E], D = x.itemSize, O = c[E], Y = h[E];
        for (let B = 0; B < D; B++) {
          const Q = d[B], j = p[B];
          if (O[j](o, x[Q](_)), b)
            for (let X = 0, Z = b.length; X < Z; X++)
              Y[X][j](o, b[X][Q](_));
        }
      }
      t && (i[w] = o), u.push(o), o++;
    }
  }
  const v = s.clone();
  for (const g in s.attributes) {
    const _ = c[g];
    if (v.setAttribute(g, new Je(
      _.array.slice(0, o * _.itemSize),
      _.itemSize,
      _.normalized
    )), g in h)
      for (let w = 0; w < h[g].length; w++) {
        const S = h[g][w];
        v.morphAttributes[g][w] = new Je(
          S.array.slice(0, o * S.itemSize),
          S.itemSize,
          S.normalized
        );
      }
  }
  return v.setIndex(u), v;
}
function t_(s, e) {
  if (e === zS)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), s;
  if (e === Xm || e === lw) {
    let t = s.getIndex();
    if (t === null) {
      const a = [], o = s.getAttribute("position");
      if (o !== void 0) {
        for (let l = 0; l < o.count; l++)
          a.push(l);
        s.setIndex(a), t = s.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), s;
    }
    const i = t.count - 2, n = [];
    if (e === Xm)
      for (let a = 1; a <= i; a++)
        n.push(t.getX(0)), n.push(t.getX(a)), n.push(t.getX(a + 1));
    else
      for (let a = 0; a < i; a++)
        a % 2 === 0 ? (n.push(t.getX(a)), n.push(t.getX(a + 1)), n.push(t.getX(a + 2))) : (n.push(t.getX(a + 2)), n.push(t.getX(a + 1)), n.push(t.getX(a)));
    n.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const r = s.clone();
    return r.setIndex(n), r.clearGroups(), r;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), s;
}
function wz(s) {
  const e = new M(), t = new M(), i = new M(), n = new M(), r = new M(), a = new M(), o = new M(), l = new M(), c = new M();
  function h(ee, J, W, K, ce, fe, ve, _e) {
    e.fromBufferAttribute(J, ce), t.fromBufferAttribute(J, fe), i.fromBufferAttribute(J, ve);
    const ze = ee.morphTargetInfluences;
    if (W && ze) {
      o.set(0, 0, 0), l.set(0, 0, 0), c.set(0, 0, 0);
      for (let Qe = 0, ot = W.length; Qe < ot; Qe++) {
        const ht = ze[Qe], Xe = W[Qe];
        ht !== 0 && (n.fromBufferAttribute(Xe, ce), r.fromBufferAttribute(Xe, fe), a.fromBufferAttribute(Xe, ve), K ? (o.addScaledVector(n, ht), l.addScaledVector(r, ht), c.addScaledVector(a, ht)) : (o.addScaledVector(n.sub(e), ht), l.addScaledVector(r.sub(t), ht), c.addScaledVector(a.sub(i), ht)));
      }
      e.add(o), t.add(l), i.add(c);
    }
    ee.isSkinnedMesh && (ee.applyBoneTransform(ce, e), ee.applyBoneTransform(fe, t), ee.applyBoneTransform(ve, i)), _e[ce * 3 + 0] = e.x, _e[ce * 3 + 1] = e.y, _e[ce * 3 + 2] = e.z, _e[fe * 3 + 0] = t.x, _e[fe * 3 + 1] = t.y, _e[fe * 3 + 2] = t.z, _e[ve * 3 + 0] = i.x, _e[ve * 3 + 1] = i.y, _e[ve * 3 + 2] = i.z;
  }
  const u = s.geometry, d = s.material;
  let p, f, y;
  const A = u.index, m = u.attributes.position, v = u.morphAttributes.position, g = u.morphTargetsRelative, _ = u.attributes.normal, w = u.morphAttributes.position, S = u.groups, C = u.drawRange;
  let E, x, b, D, O, Y, B;
  const Q = new Float32Array(m.count * m.itemSize), j = new Float32Array(_.count * _.itemSize);
  if (A !== null)
    if (Array.isArray(d))
      for (E = 0, b = S.length; E < b; E++)
        for (O = S[E], Y = Math.max(O.start, C.start), B = Math.min(O.start + O.count, C.start + C.count), x = Y, D = B; x < D; x += 3)
          p = A.getX(x), f = A.getX(x + 1), y = A.getX(x + 2), h(
            s,
            m,
            v,
            g,
            p,
            f,
            y,
            Q
          ), h(
            s,
            _,
            w,
            g,
            p,
            f,
            y,
            j
          );
    else
      for (Y = Math.max(0, C.start), B = Math.min(A.count, C.start + C.count), E = Y, b = B; E < b; E += 3)
        p = A.getX(E), f = A.getX(E + 1), y = A.getX(E + 2), h(
          s,
          m,
          v,
          g,
          p,
          f,
          y,
          Q
        ), h(
          s,
          _,
          w,
          g,
          p,
          f,
          y,
          j
        );
  else if (Array.isArray(d))
    for (E = 0, b = S.length; E < b; E++)
      for (O = S[E], Y = Math.max(O.start, C.start), B = Math.min(O.start + O.count, C.start + C.count), x = Y, D = B; x < D; x += 3)
        p = x, f = x + 1, y = x + 2, h(
          s,
          m,
          v,
          g,
          p,
          f,
          y,
          Q
        ), h(
          s,
          _,
          w,
          g,
          p,
          f,
          y,
          j
        );
  else
    for (Y = Math.max(0, C.start), B = Math.min(m.count, C.start + C.count), E = Y, b = B; E < b; E += 3)
      p = E, f = E + 1, y = E + 2, h(
        s,
        m,
        v,
        g,
        p,
        f,
        y,
        Q
      ), h(
        s,
        _,
        w,
        g,
        p,
        f,
        y,
        j
      );
  const X = new Te(Q, 3), Z = new Te(j, 3);
  return {
    positionAttribute: m,
    normalAttribute: _,
    morphedPositionAttribute: X,
    morphedNormalAttribute: Z
  };
}
function Ez(s) {
  if (s.groups.length === 0)
    return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."), s;
  let e = s.groups;
  if (e = e.sort((a, o) => a.materialIndex !== o.materialIndex ? a.materialIndex - o.materialIndex : a.start - o.start), s.getIndex() === null) {
    const a = s.getAttribute("position"), o = [];
    for (let l = 0; l < a.count; l += 3)
      o.push(l, l + 1, l + 2);
    s.setIndex(o);
  }
  const t = s.getIndex(), i = [];
  for (let a = 0; a < e.length; a++) {
    const o = e[a], l = o.start, c = l + o.count;
    for (let h = l; h < c; h++)
      i.push(t.getX(h));
  }
  s.dispose(), s.setIndex(i);
  let n = 0;
  for (let a = 0; a < e.length; a++) {
    const o = e[a];
    o.start = n, n += o.count;
  }
  let r = e[0];
  s.groups = [r];
  for (let a = 1; a < e.length; a++) {
    const o = e[a];
    r.materialIndex === o.materialIndex ? r.count += o.count : (r = o, s.groups.push(r));
  }
  return s;
}
function bz(s, e = Math.PI / 3) {
  const t = Math.cos(e), i = (1 + 1e-10) * 100, n = [new M(), new M(), new M()], r = new M(), a = new M(), o = new M(), l = new M();
  function c(y) {
    const A = ~~(y.x * i), m = ~~(y.y * i), v = ~~(y.z * i);
    return `${A},${m},${v}`;
  }
  const h = s.index ? s.toNonIndexed() : s, u = h.attributes.position, d = {};
  for (let y = 0, A = u.count / 3; y < A; y++) {
    const m = 3 * y, v = n[0].fromBufferAttribute(u, m + 0), g = n[1].fromBufferAttribute(u, m + 1), _ = n[2].fromBufferAttribute(u, m + 2);
    r.subVectors(_, g), a.subVectors(v, g);
    const w = new M().crossVectors(r, a).normalize();
    for (let S = 0; S < 3; S++) {
      const C = n[S], E = c(C);
      E in d || (d[E] = []), d[E].push(w);
    }
  }
  const p = new Float32Array(u.count * 3), f = new Je(p, 3, !1);
  for (let y = 0, A = u.count / 3; y < A; y++) {
    const m = 3 * y, v = n[0].fromBufferAttribute(u, m + 0), g = n[1].fromBufferAttribute(u, m + 1), _ = n[2].fromBufferAttribute(u, m + 2);
    r.subVectors(_, g), a.subVectors(v, g), o.crossVectors(r, a).normalize();
    for (let w = 0; w < 3; w++) {
      const S = n[w], C = c(S), E = d[C];
      l.set(0, 0, 0);
      for (let x = 0, b = E.length; x < b; x++) {
        const D = E[x];
        o.dot(D) > t && l.add(D);
      }
      l.normalize(), f.setXYZ(m + w, l.x, l.y, l.z);
    }
  }
  return h.setAttribute("normal", f), h;
}
function Sz(s, e = !1) {
  return console.warn("THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries()."), QB(s, e);
}
function Cz(s) {
  return console.warn("THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes()."), ug(s);
}
function cE(s, e = -1) {
  return HB(s, e);
}
function Ss() {
  return ri.generateUUID();
}
function Qh(...s) {
  if (s.length > 1) return s.some((i) => Qh(i));
  const e = s[0];
  if (e.isTexture) return Array.from(e._appliedMaterials || []).some((i) => Qh(i)) ?? !1;
  const t = e.isObject3D ? [e] : e.appliedMeshes;
  for (const i of t) {
    let n = !1;
    if (i.traverseAncestors((r) => r.isScene && (n = !0)), n) return !0;
  }
  return !1;
}
function VB(s, e, t = new rt()) {
  return e.premultiply(s.getWorldQuaternion(t).invert());
}
function Mz(s, e, t = new rt()) {
  return e.premultiply(s.getWorldQuaternion(t));
}
const WB = {
  None: _n,
  Normal: dr,
  Additive: qd,
  Subtractive: Xd,
  Multiply: Yd,
  Custom: or
}, jB = {
  UV: iu,
  Cube: qr,
  // CubeRefraction: CubeRefractionMapping,
  CubeUV: xc,
  Equirectangular: Ia
  // EquirectangularRefraction: EquirectangularRefractionMapping,
}, qB = {
  None: "",
  SRGB: dt,
  LinearSRGB: Mt,
  RGBM16: Es,
  DisplayP3: su
}, XB = {
  UnsignedByte: Ft,
  Byte: tw,
  Short: iw,
  UnsignedShort: Lp,
  Int: tA,
  UnsignedInt: qs,
  Float: Xt,
  HalfFloat: Qt,
  UnsignedShort4444: iA,
  UnsignedShort5551: nA,
  UnsignedInt248: wa
}, YB = {
  Basic: kl,
  RGBADepthPacking: cw
};
function ih(s) {
  return {
    map: s,
    inv: Object.fromEntries(Object.entries(s).map(([e, t]) => [t, e])),
    uiConfig: Object.entries(s).map(([e, t]) => ({ label: e, value: t }))
  };
}
const hE = {
  Blending: ih(WB),
  AnyMapping: ih(jB),
  ColorSpace: ih(qB),
  TextureDataType: ih(XB),
  DepthPackingStrategies: ih(YB)
}, Bl = class Bl extends Vi {
  constructor(e, t, i, n) {
    super(), this.hoverEnabled = !1, this._mouseDownPos = new ie(), this._onPointerMove = (r) => {
      var a;
      r.isPrimary !== !1 && (this.updateMouseFromEvent(r), this.hoverEnabled && (this.hoverObject = ((a = this.checkIntersection()) == null ? void 0 : a.intersects[0].object) ?? null));
    }, this._onPointerLeave = (r) => {
      r.isPrimary !== !1 && (this.domElement.style.cursor = this.cursorStyles.default, (this.hoverEnabled || this.hoverObject) && (this.hoverObject = null));
    }, this._onPointerEnter = (r) => {
    }, this._onPointerCancel = (r) => {
    }, this._onPointerDown = (r) => {
      r.isPrimary !== !1 && (this.domElement.style.cursor = this.cursorStyles.down, this._mouseDownTime = this.time, this._mouseDownPos.copy(this.mouse));
    }, this._onPointerUp = (r) => {
      if (r.isPrimary === !1) return;
      this.domElement.style.cursor = this.cursorStyles.default, this._mouseUpTime = this.time;
      const a = this.mouseDownDeltaTime, o = this._mouseDownPos.distanceTo(this.mouse);
      a < Bl.PointerClickMaxTime && o < Bl.PointerClickMaxDistance && this._onPointerClick(r);
    }, this._onPointerClick = (r) => {
      if (r.isPrimary === !1) return;
      this.updateMouseFromEvent(r);
      const a = this.checkIntersection();
      a ? this.dispatchEvent({ type: "hitObject", time: this._mouseUpTime, intersects: a }) : this.dispatchEvent({ type: "hitObject", time: this._mouseUpTime, intersects: { selectedObject: null, intersect: null, intersects: [] } }), this.selectedObject = (a == null ? void 0 : a.selectedObject) || null;
    }, this._root = e, this._camera = i, this.domElement = t, this._time = this.time, this._mouseDownTime = 0, this._mouseUpTime = 1, this.selectionCondition = n ?? ((r) => r.userData.userSelectable !== !1 && r.userData.bboxVisible !== !1 && r.material != null && r.material.type !== "ShadowMaterial"), this.raycaster = new QA(), this.mouse = new ie(), this._selected = [], this._hovering = [], this.cursorStyles = {
      default: "grab",
      down: "grabbing"
    }, this.domElement.style.touchAction = "none", this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerleave", this._onPointerLeave), this.domElement.addEventListener("pointerout", this._onPointerLeave), this.domElement.addEventListener("pointercancel", this._onPointerCancel), this.domElement.addEventListener("pointerenter", this._onPointerEnter), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  dispose() {
    this.selectedObject = null, this.hoverObject = null, this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerleave", this._onPointerLeave), this.domElement.removeEventListener("pointerout", this._onPointerLeave), this.domElement.removeEventListener("pointercancel", this._onPointerCancel), this.domElement.removeEventListener("pointerenter", this._onPointerEnter), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointerup", this._onPointerUp);
  }
  get camera() {
    return this._camera;
  }
  set camera(e) {
    this._camera = e;
  }
  get selectedObject() {
    return this._selected.length > 0 ? this._selected[0] : null;
  }
  set selectedObject(e) {
    this.setSelected(e);
  }
  setSelected(e, t = !0) {
    var n;
    if (!this._selected.length && !e || this._selected.length === 1 && this._selected[0] === e) return;
    const i = [...this._selected];
    this._selected = e ? Array.isArray(e) ? [...e] : [e] : [], this.dispatchEvent({ type: "selectedObjectChanged", object: this.selectedObject }), t && ((n = this.undoManager) == null || n.record({
      undo: () => this.setSelected(i.length ? i[0] : null, !1),
      redo: () => this.setSelected(e, !1)
    }));
  }
  get hoverObject() {
    return this._hovering.length > 0 ? this._hovering[0] : null;
  }
  set hoverObject(e) {
    !this._hovering.length && !e || this._hovering.length === 1 && this._hovering[0] === e || (this._hovering = e ? Array.isArray(e) ? [...e] : [e] : [], this.dispatchEvent({ type: "hoverObjectChanged", object: this.hoverObject }));
  }
  get time() {
    return this._time = zn(), this._time;
  }
  get isMouseDown() {
    return this.mouseDownDeltaTime < 0;
  }
  get mouseDownDeltaTime() {
    return this._mouseUpTime - this._mouseDownTime;
  }
  updateMouseFromEvent(e) {
    const t = this.domElement.getBoundingClientRect();
    this.mouse.x = (e.clientX - t.x) / t.width * 2 - 1, this.mouse.y = -((e.clientY - t.y) / t.height) * 2 + 1;
  }
  checkIntersection() {
    const e = this._camera;
    if (!e) return null;
    this.raycaster.setFromCamera(this.mouse, e);
    let t = this.raycaster.intersectObject(this._root, !0);
    const i = [];
    t = t.filter((l) => i.includes(l.object.id) ? !1 : (i.push(l.object.id), !0));
    let r = null, a;
    const o = [];
    for (const l of t) {
      for (r = l.object, a = l; r != null && (!r.visible || !this.selectionCondition(r)); )
        r = r.parent;
      r != null && o.push(l);
    }
    if (t = o, t.length > 0) {
      if (r = t[0].object, a = t[0], this._firstHit && r.id !== this._firstHit.id)
        r = a.object;
      else
        for (let l = 0; l < t.length; l++)
          if (this.selectedObject && this.selectedObject.id === t[l].object.id) {
            const c = l + 1;
            if (c < t.length)
              a = t[c], r = a.object;
            else
              return null;
          }
      this._firstHit = t[0].object;
    }
    return r && a && r ? { selectedObject: r, intersect: a, intersects: t, mouse: this.mouse.toArray() } : null;
  }
  isHovering() {
    return this.hoverObject != null;
  }
  isSelected() {
    return this.selectedObject != null;
  }
};
Bl.PointerClickMaxTime = 200, Bl.PointerClickMaxDistance = 0.1;
let pg = Bl;
function uE(s) {
  if (!s.isMaterial && !s.isBufferGeometry) return;
  const e = Array.from(s.appliedMeshes).filter(
    (r) => !r.isInstancedMesh && !!r.parent && r.children.length === 0 && !Array.isArray(r.material)
  );
  if (e.length < 2) return;
  const t = (r) => {
    var a, o;
    return r.parent.uuid + "_" + ((a = r.geometry) == null ? void 0 : a.uuid) + "_" + ((o = r.material) == null ? void 0 : o.uuid);
  }, i = /* @__PURE__ */ new Map();
  for (const r of e) {
    const a = t(r);
    i.has(a) || i.set(a, []), i.get(a).push(r), r.updateMatrix();
  }
  const n = i.keys();
  for (const r of n) {
    const a = i.get(r), o = a[0];
    if (!o || a.length < 2) continue;
    const l = new zp(o.geometry, o.material, a.length), c = o.userData;
    o.userData = {}, l.copy(o), hg(l.userData, c);
    const h = o.parent;
    l.position.set(0, 0, 0), l.rotation.set(0, 0, 0), l.scale.set(1, 1, 1), l.updateMatrix();
    const u = new Float32Array(l.count * 3), d = new Float32Array(l.count * 4), p = new Float32Array(l.count * 3);
    for (let f = 0; f < a.length; f++) {
      const y = a[f], A = y.matrix;
      A.determinant() < 0 && (A.elements[0] *= -1, A.elements[1] *= -1, A.elements[2] *= -1), l.setMatrixAt(f, A), y.position.toArray(u, f * 3), y.quaternion.toArray(d, f * 4), y.scale.toArray(p, f * 3), y.removeFromParent(), y.material = void 0, y.geometry = void 0;
    }
    l.sourceTrs = {
      TRANSLATION: new Je(u, 3),
      ROTATION: new Je(d, 4),
      SCALE: new Je(p, 3)
    }, l.instanceMatrix.needsUpdate = !0, h.add(l), h.setDirty();
  }
}
const KB = {
  name: "HorizontalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
}, JB = {
  name: "VerticalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};
class $B {
  constructor(e) {
    this._viewer = e, this.horizontalBlurMaterial = new ln(KB), this.verticalBlurMaterial = new ln(JB), this.horizontalBlurMaterial.depthTest = !1, this.verticalBlurMaterial.depthTest = !1;
  }
  blur(e, t, i, n = 1) {
    this.horizontalBlurMaterial.uniforms.h.value = n, this.verticalBlurMaterial.uniforms.v.value = n, this._viewer.renderManager.blit(i, {
      material: this.horizontalBlurMaterial,
      clear: !0,
      source: e
      // this._depthPass.target.texture,
    }), this._viewer.renderManager.blit(t, {
      material: this.verticalBlurMaterial,
      clear: !0,
      source: i.texture
    });
  }
  dispose() {
    this.horizontalBlurMaterial.dispose(), this.verticalBlurMaterial.dispose();
  }
}
const ls = class ls extends is {
  constructor() {
    super(...arguments), this._vector = new M();
  }
  expandByObject(e, t = !1, i = !1, n) {
    var o;
    if (((o = e.userData) == null ? void 0 : o.bboxVisible) === !1) return this;
    if (!e.visible && i) return this;
    if (n && n(e)) return this;
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0) {
      const l = r.getAttribute("position");
      if (t === !0 && l !== void 0 && Object.getPrototypeOf(r).computeBoundingBox === Ze.prototype.computeBoundingBox)
        for (let c = 0, h = l.count; c < h; c++)
          e.isMesh === !0 ? e.getVertexPosition(c, this._vector) : this._vector.fromBufferAttribute(l, c), this._vector.applyMatrix4(e.matrixWorld), this.expandByPoint(this._vector);
      else
        e.boundingBox !== void 0 ? ((t || e.boundingBox === null) && typeof e.computeBoundingBox == "function" && e.computeBoundingBox(), e.boundingBox !== null ? (ls._box.copy(e.boundingBox), ls._box.applyMatrix4(e.matrixWorld), this.union(ls._box)) : console.warn("Box3B - Unable to compute bounds for", e)) : (r.boundingBox === null && r.computeBoundingBox(), r.boundingBox ? (ls._box.copy(r.boundingBox), ls._box.applyMatrix4(e.matrixWorld), this.union(ls._box)) : console.warn("Box3B - Unable to compute bounds for", e, r));
    } else e.boundingBox !== void 0 && ((t || e.boundingBox === null) && typeof e.computeBoundingBox == "function" && e.computeBoundingBox(), e.boundingBox !== null ? (ls._box.copy(e.boundingBox), ls._box.applyMatrix4(e.matrixWorld), this.union(ls._box)) : console.warn("Box3B - Unable to compute bounds for", e));
    const a = e.children;
    for (let l = 0, c = a.length; l < c; l++)
      this.expandByObject(a[l], t, i);
    return this;
  }
  expandByObjects(e, t = !1, i = !1) {
    for (let n = 0, r = e.length; n < r; n++) this.expandByObject(e[n], t, i);
    return this;
  }
  /**
   * Get corner points.
   */
  getPoints() {
    return [
      new M(this.min.x, this.min.y, this.min.z),
      // 000
      new M(this.min.x, this.min.y, this.max.z),
      // 001
      new M(this.min.x, this.max.y, this.min.z),
      // 010
      new M(this.min.x, this.max.y, this.max.z),
      // 011
      new M(this.max.x, this.min.y, this.min.z),
      // 100
      new M(this.max.x, this.min.y, this.max.z),
      // 101
      new M(this.max.x, this.max.y, this.min.z),
      // 110
      new M(this.max.x, this.max.y, this.max.z)
      // 111
    ];
  }
  getScreenSpaceBounds(e) {
    const t = this.getPoints(), i = new jw();
    for (const n of t) {
      const r = n.project(e);
      i.min.min(r), i.max.max(r);
    }
    return i;
  }
};
ls._box = new ls();
let Nn = ls;
function dE(s, e, t, i = 7, n = new M(0, 0, 1.5), r = new ki(45, 1, 0.1, 1e3)) {
  const a = e.visible;
  e.visible = !0;
  const o = new Nn().expandByObject(e, !0, !0), l = o.getCenter(new M()), c = o.getSize(new M());
  r.position.copy(l).add(n.clone().multiplyScalar(Math.max(c.x, c.y, c.z))), r.lookAt(l), e && e.traverseVisible((u) => {
    u.layers.enable(i);
  }), i > 0 ? r.layers.set(i) : r.layers.enableAll(), s.setRenderTarget(null), s.clear(), typeof s.renderWithModes == "function" ? s.renderWithModes({
    backgroundRender: !1
    // mainRenderPass: false,
    // screenSpaceRendering: false,
    // shadowMapRender: false,
  }, () => {
    s.render(t ?? e, r);
  }) : s.render(t ?? e, r);
  const h = s.domElement.toDataURL("image/png");
  return s.clear(), e.visible = a, e.traverseVisible((u) => {
    u.layers.disable(i);
  }), r.layers.enableAll(), h;
}
class ZB {
  constructor() {
    this._lights = [], this.shapes = {
      sphere: new Se(new fr(1)),
      cube: new Se(new Si(1, 1, 1)),
      cylinder: new Se(new yn(0.5, 0.5, 1))
    };
    const e = new tc();
    this._channel = 7;
    const t = new PA(16777215, 4473924, 1);
    t.position.set(0, 10, 0), t.layers.set(this._channel), e.add(t), this._lights.push(t), this._scene = e;
  }
  dispose() {
    [...this._lights].forEach((e) => e.dispose()), Object.values(this.shapes).forEach((e) => {
      e.geometry && e.geometry.dispose();
    });
  }
  // todo: show an overlay when this is happening
  generate(e, t, i, n = "sphere") {
    const r = this.shapes[n] || new Se(new fr(1));
    r.material = e, r.geometry.attributes.tangent || r.geometry.computeTangents(), this._scene.add(r), this._scene.environment = i ?? null;
    const a = e.envMapIntensity;
    typeof a == "number" && (e.envMapIntensity = Math.max(a, 2));
    const o = dE(t, r, this._scene, this._channel, new M(0, 0, 1.5));
    return typeof a == "number" && (e.envMapIntensity = a), this._scene.remove(r), r.material = void 0, o;
  }
}
const i_ = new is(), md = new M();
class ea extends Hw {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], i = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(i), this.setAttribute("position", new Te(e, 3)), this.setAttribute("uv", new Te(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, i = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), i.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const i = new op(t, 6, 1);
    return this.setAttribute("instanceStart", new Cn(i, 3, 0)), this.setAttribute("instanceEnd", new Cn(i, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const i = new op(t, 6, 1);
    return this.setAttribute("instanceColorStart", new Cn(i, 3, 0)), this.setAttribute("instanceColorEnd", new Cn(i, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new DA(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new is());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), i_.setFromBufferAttribute(t), this.boundingBox.union(i_));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new ns()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const i = this.boundingSphere.center;
      this.boundingBox.getCenter(i);
      let n = 0;
      for (let r = 0, a = e.count; r < a; r++)
        md.fromBufferAttribute(e, r), n = Math.max(n, i.distanceToSquared(md)), md.fromBufferAttribute(t, r), n = Math.max(n, i.distanceToSquared(md));
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
Re.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new ie(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
Ci.line = {
  uniforms: Ec.merge([
    Re.common,
    Re.fog,
    Re.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class uu extends ln {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: Ec.clone(Ci.line.uniforms),
      vertexShader: Ci.line.vertexShader,
      fragmentShader: Ci.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1));
  }
}
const n_ = new M(), s_ = new M(), mn = new it(), gn = new it(), nr = new it(), em = new M(), tm = new Ue(), An = new UR(), r_ = new M(), gd = new is(), Ad = new ns(), sr = new it();
let cr, fo;
function a_(s, e, t) {
  return sr.set(0, 0, -e, 1).applyMatrix4(s.projectionMatrix), sr.multiplyScalar(1 / sr.w), sr.x = fo / t.width, sr.y = fo / t.height, sr.applyMatrix4(s.projectionMatrixInverse), sr.multiplyScalar(1 / sr.w), Math.abs(Math.max(sr.x, sr.y));
}
function eP(s, e) {
  const t = s.matrixWorld, i = s.geometry, n = i.attributes.instanceStart, r = i.attributes.instanceEnd, a = Math.min(i.instanceCount, n.count);
  for (let o = 0, l = a; o < l; o++) {
    An.start.fromBufferAttribute(n, o), An.end.fromBufferAttribute(r, o), An.applyMatrix4(t);
    const c = new M(), h = new M();
    cr.distanceSqToSegment(An.start, An.end, h, c), h.distanceTo(c) < fo * 0.5 && e.push({
      point: h,
      pointOnLine: c,
      distance: cr.origin.distanceTo(h),
      object: s,
      face: null,
      faceIndex: o,
      uv: null,
      uv1: null
    });
  }
}
function tP(s, e, t) {
  const i = e.projectionMatrix, r = s.material.resolution, a = s.matrixWorld, o = s.geometry, l = o.attributes.instanceStart, c = o.attributes.instanceEnd, h = Math.min(o.instanceCount, l.count), u = -e.near;
  cr.at(1, nr), nr.w = 1, nr.applyMatrix4(e.matrixWorldInverse), nr.applyMatrix4(i), nr.multiplyScalar(1 / nr.w), nr.x *= r.x / 2, nr.y *= r.y / 2, nr.z = 0, em.copy(nr), tm.multiplyMatrices(e.matrixWorldInverse, a);
  for (let d = 0, p = h; d < p; d++) {
    if (mn.fromBufferAttribute(l, d), gn.fromBufferAttribute(c, d), mn.w = 1, gn.w = 1, mn.applyMatrix4(tm), gn.applyMatrix4(tm), mn.z > u && gn.z > u)
      continue;
    if (mn.z > u) {
      const g = mn.z - gn.z, _ = (mn.z - u) / g;
      mn.lerp(gn, _);
    } else if (gn.z > u) {
      const g = gn.z - mn.z, _ = (gn.z - u) / g;
      gn.lerp(mn, _);
    }
    mn.applyMatrix4(i), gn.applyMatrix4(i), mn.multiplyScalar(1 / mn.w), gn.multiplyScalar(1 / gn.w), mn.x *= r.x / 2, mn.y *= r.y / 2, gn.x *= r.x / 2, gn.y *= r.y / 2, An.start.copy(mn), An.start.z = 0, An.end.copy(gn), An.end.z = 0;
    const y = An.closestPointToPointParameter(em, !0);
    An.at(y, r_);
    const A = ri.lerp(mn.z, gn.z, y), m = A >= -1 && A <= 1, v = em.distanceTo(r_) < fo * 0.5;
    if (m && v) {
      An.start.fromBufferAttribute(l, d), An.end.fromBufferAttribute(c, d), An.start.applyMatrix4(a), An.end.applyMatrix4(a);
      const g = new M(), _ = new M();
      cr.distanceSqToSegment(An.start, An.end, _, g), t.push({
        point: _,
        pointOnLine: g,
        distance: cr.origin.distanceTo(_),
        object: s,
        face: null,
        faceIndex: d,
        uv: null,
        uv1: null
      });
    }
  }
}
class Tc extends Se {
  constructor(e = new ea(), t = new uu({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, i = e.attributes.instanceEnd, n = new Float32Array(2 * t.count);
    for (let a = 0, o = 0, l = t.count; a < l; a++, o += 2)
      n_.fromBufferAttribute(t, a), s_.fromBufferAttribute(i, a), n[o] = o === 0 ? 0 : n[o - 1], n[o + 1] = n[o] + n_.distanceTo(s_);
    const r = new op(n, 2, 1);
    return e.setAttribute("instanceDistanceStart", new Cn(r, 1, 0)), e.setAttribute("instanceDistanceEnd", new Cn(r, 1, 1)), this;
  }
  raycast(e, t) {
    const i = this.material.worldUnits, n = e.camera;
    n === null && !i && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const r = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    cr = e.ray;
    const a = this.matrixWorld, o = this.geometry, l = this.material;
    fo = l.linewidth + r, o.boundingSphere === null && o.computeBoundingSphere(), Ad.copy(o.boundingSphere).applyMatrix4(a);
    let c;
    if (i)
      c = fo * 0.5;
    else {
      const u = Math.max(n.near, Ad.distanceToPoint(cr.origin));
      c = a_(n, u, l.resolution);
    }
    if (Ad.radius += c, cr.intersectsSphere(Ad) === !1)
      return;
    o.boundingBox === null && o.computeBoundingBox(), gd.copy(o.boundingBox).applyMatrix4(a);
    let h;
    if (i)
      h = fo * 0.5;
    else {
      const u = Math.max(n.near, gd.distanceToPoint(cr.origin));
      h = a_(n, u, l.resolution);
    }
    gd.expandByScalar(h), cr.intersectsBox(gd) !== !1 && (i ? eP(this, t) : tP(this, n, t));
  }
}
var iP = Object.defineProperty, nP = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && iP(e, t, n), n;
};
const [o_, l_, c_, h_, u_, d_] = Array(6).fill(0).map((s, e) => e), Od = [
  new se(16725587),
  new se(9100032),
  new se(2920447)
], sP = new NA(), fa = new M(), io = new rt(), Nd = new rt(), fg = new rt(), nh = new M(), rP = 2 * Math.PI, pE = new QA(), im = new ie(), sh = new ut();
let qA = 0;
class fE extends ut {
  constructor(e, t, i = "bottom-right", n = 128, r = 2) {
    super(), this.orthoCamera = new _r(-1.8, 1.8, 1.8, -1.8, 0, 4), this.isViewHelper = !0, this.animating = !1, this.target = new M(), this.viewport = new it(), this.offsetHeight = 0, this.renderer = new kp({
      canvas: document.createElement("canvas"),
      alpha: !0,
      antialias: !0,
      preserveDrawingBuffer: !1
    }), this.renderer.setPixelRatio(r), this.camera = e, this.domElement = t, this.orthoCamera.position.set(0, 0, 2), this.backgroundSphere = lP(), this.axesLines = oP(), this.spritePoints = cP(), this.add(this.backgroundSphere, this.axesLines, ...this.spritePoints), this.domContainer = aP(i, n), this.domContainer.appendChild(this.renderer.domElement), this.renderer.domElement.style.width = "100%", this.renderer.domElement.style.height = "100%", this.domElement.parentElement.appendChild(this.domContainer), this.domRect = this.domContainer.getBoundingClientRect(), this.startListening(), this.update(), this.updateOrientation();
  }
  startListening() {
    this.domContainer.onpointermove = (e) => this.onPointerMove(e), this.domContainer.onpointerleave = (e) => this.onPointerLeave(e), this.domContainer.onclick = (e) => this.handleClick(e);
  }
  // onPointerDown(e: PointerEvent) {
  //     const drag = (e1: PointerEvent) => {
  //         if (!this.dragging && isClick(e1, mouseStart)) return
  //         if (!this.dragging) {
  //             resetSprites(this.spritePoints)
  //             this.dragging = true
  //         }
  //
  //         mouseAngle
  //             .set(e1.clientX, e1.clientY)
  //             .sub(mouseStart)
  //             .multiplyScalar(1 / this.domRect.width * Math.PI)
  //
  //         this.rotation.x = MathUtils.clamp(
  //             rotationStart.x + mouseAngle.y,
  //             Math.PI / -2 + 0.001,
  //             Math.PI / 2 - 0.001
  //         )
  //         this.rotation.y = rotationStart.y + mouseAngle.x
  //         this.updateMatrixWorld()
  //
  //         q1.copy(this.quaternion).invert()
  //
  //         this.camera.position
  //             .set(0, 0, 1)
  //             .applyQuaternion(q1)
  //             .multiplyScalar(radius)
  //             .add(this.target)
  //
  //         this.camera.rotation.setFromQuaternion(q1)
  //
  //         this.updateOrientation(false)
  //     }
  //     const endDrag = () => {
  //         document.removeEventListener('pointermove', drag, false)
  //         document.removeEventListener('pointerup', endDrag, false)
  //
  //         if (!this.dragging) {
  //             // this.handleClick(e)
  //             return
  //         }
  //
  //         this.dragging = false
  //     }
  //
  //     if (this.animating === true) return
  //     e.preventDefault()
  //
  //     mouseStart.set(e.clientX, e.clientY)
  //
  //     const rotationStart = euler.copy(this.rotation)
  //
  //     setRadius(this.camera, this.target)
  //
  //     document.addEventListener('pointermove', drag, false)
  //     document.addEventListener('pointerup', endDrag, false)
  // }
  onPointerMove(e) {
    this.backgroundSphere.material.opacity = 0.4, this.handleHover(e), this.dispatchEvent({ type: "update", event: e, change: "pointer" });
  }
  onPointerLeave(e) {
    this.backgroundSphere.material.opacity = 0.2, f_(this.spritePoints), this.domContainer.style.cursor = "", this.dispatchEvent({ type: "update", event: e, change: "pointer" });
  }
  handleClick(e) {
    const t = p_(
      e,
      this.domRect,
      this.orthoCamera,
      this.spritePoints
    );
    t && this.setOrientation(t.userData.type);
  }
  handleHover(e) {
    const t = p_(
      e,
      this.domRect,
      this.orthoCamera,
      this.spritePoints
    );
    f_(this.spritePoints), t ? (t.material.map.offset.x = 0.5, t.scale.multiplyScalar(1.2), this.domContainer.style.cursor = "pointer") : this.domContainer.style.cursor = "";
  }
  // setControls(controls?: OrbitControls | TrackballControls) {
  //     if (this.controls) {
  //         (this.controls as any).removeEventListener(
  //             'change',
  //             this.controlsChangeEvent.listener
  //         )
  //         this.target = new Vector3()
  //     }
  //
  //     if (!controls) return
  //
  //     this.controls = controls;
  //     (controls as any).addEventListener('change', this.controlsChangeEvent.listener)
  //     this.target = controls.target
  // }
  render() {
    const e = sP.getDelta();
    this.animating && this.animate(Math.min(e, 1 / 30));
    const t = this.renderer.autoClear;
    this.renderer.autoClear = !1, this.renderer.render(this, this.orthoCamera), this.renderer.autoClear = t;
  }
  updateOrientation(e = !0) {
    e && (this.quaternion.copy(this.camera.quaternion).invert(), this.updateMatrixWorld()), fP(this.spritePoints, this.camera);
  }
  update() {
    this.domRect = this.domContainer.getBoundingClientRect(), this.offsetHeight = this.domElement.offsetHeight, mE(this.camera, this.target), this.renderer.getViewport(this.viewport), this.updateOrientation();
  }
  animate(e) {
    const t = e * rP;
    Nd.rotateTowards(fg, t), this.camera.position.set(0, 0, 1).applyQuaternion(Nd).multiplyScalar(qA).add(this.target), this.camera.quaternion.rotateTowards(io, t), this.updateOrientation(), Nd.angleTo(fg) === 0 && (this.animating = !1);
  }
  setOrientation(e) {
    uP(this.camera, this.target, e), this.animating = !0, this.dispatchEvent({ type: "update", change: "orientation" });
  }
  dispose() {
    this.axesLines.geometry.dispose(), this.axesLines.material.dispose(), this.backgroundSphere.geometry.dispose(), this.backgroundSphere.material.dispose(), this.spritePoints.forEach((e) => {
      e.material.map.dispose(), e.material.dispose();
    }), this.domContainer.remove();
  }
}
nP([
  nB()
], fE.prototype, "animating");
function aP(s, e) {
  const t = document.createElement("div"), i = t.style;
  i.height = `${e}px`, i.width = `${e}px`, i.borderRadius = "100%", i.position = "absolute";
  const [n, r] = s.split("-");
  return i.transform = "", i.left = r === "left" ? "0" : r === "center" ? "50%" : "", i.right = r === "right" ? "0" : "", i.transform += r === "center" ? "translateX(-50%)" : "", i.top = n === "top" ? "0" : n === "bottom" ? "" : "50%", i.bottom = n === "bottom" ? "0" : "", i.transform += n === "center" ? "translateY(-50%)" : "", t;
}
function oP() {
  const e = Array(3).fill(0).map((n, r) => [
    r ? 0 : 0.9,
    r === 1 ? 0.9 : 0,
    r === 2 ? 0.9 : 0,
    0,
    0,
    0
  ]).flat(), t = Array(6).fill(0).map(
    (n, r) => r < 2 ? Od[0].toArray() : r < 4 ? Od[1].toArray() : Od[2].toArray()
  ).flat(), i = new ea();
  return i.setPositions(e), i.setColors(t), new Tc(
    i,
    new uu({
      linewidth: 0.02,
      vertexColors: !0
    })
  );
}
function lP() {
  const s = new fr(1.6);
  return new Se(
    s,
    new $s({
      color: 16777215,
      side: vn,
      transparent: !0,
      opacity: 0.2,
      depthTest: !1
    })
  );
}
function cP() {
  const s = ["x", "y", "z"];
  return Array(6).fill(0).map((e, t) => {
    const i = t < 3, n = i ? "+" : "-", r = s[t % 3], a = Od[t % 3], o = new mA(
      hP(a, i ? r : null)
    );
    return o.userData.type = `${n}${r}`, o.scale.setScalar(i ? 0.6 : 0.4), o.position[r] = i ? 1.2 : -1.2, o.renderOrder = 1, o;
  });
}
function hP(s, e = null) {
  const t = document.createElement("canvas"), i = 0, n = 1, r = 0;
  t.width = 128 * n + 4 * i + r * 2, t.height = 64 * n + 2 * i + r * 2;
  const a = t.getContext("2d", { alpha: !0 });
  a.beginPath(), a.arc(32 * n + i, 32 * n + i, 32 * n - i, 0, 2 * Math.PI), a.closePath(), a.fillStyle = s.getStyle(), a.fill(), a.beginPath(), a.arc(32 * n + i, 32 * n + i, 35 * n - i, 0, 2 * Math.PI), a.closePath(), a.fillStyle = "#" + s.getHexString() + "01", a.fill(), a.beginPath(), a.arc(96 * n + i * 3 + r, 32 * n + i + r, 32 * n - i - r, 0, 2 * Math.PI), a.closePath(), a.fillStyle = "#FFF", a.fill(), a.beginPath(), a.arc(96 * n + i * 3 + r, 32 * n + i + r, 35 + n - i - r, 0, 2 * Math.PI), a.closePath(), a.fillStyle = "#FFFFFF01", a.fill(), e !== null && (a.font = "bold calc(44px * " + n + ") Arial", a.textAlign = "center", a.fillStyle = "#111", a.fillText(e.toUpperCase(), 32 * n + i, 48 * n + i), a.fillText(e.toUpperCase(), 96 * n + i * 3 + r, 48 * n + i + r));
  const o = new Qp(t);
  return o.wrapS = o.wrapT = xn, o.repeat.x = 0.5, o.colorSpace = dt, o.minFilter = tt, o.magFilter = tt, o.generateMipmaps = !1, o.needsUpdate = !0, new Gp({
    map: o,
    toneMapped: !1,
    transparent: !0
  });
}
function uP(s, e, t) {
  switch (t) {
    case "+x":
      fa.set(1, 0, 0), io.setFromEuler(new xi(0, Math.PI * 0.5, 0));
      break;
    case "+y":
      fa.set(0, 1, 0), io.setFromEuler(new xi(-Math.PI * 0.5, 0, 0));
      break;
    case "+z":
      fa.set(0, 0, 1), io.setFromEuler(new xi());
      break;
    case "-x":
      fa.set(-1, 0, 0), io.setFromEuler(new xi(0, -Math.PI * 0.5, 0));
      break;
    case "-y":
      fa.set(0, -1, 0), io.setFromEuler(new xi(Math.PI * 0.5, 0, 0));
      break;
    case "-z":
      fa.set(0, 0, -1), io.setFromEuler(new xi(0, Math.PI, 0));
      break;
    default:
      console.error("ViewHelper: Invalid axis.");
  }
  mE(s, e), dP(s, e);
}
function mE(s, e) {
  qA = s.position.distanceTo(e);
}
function dP(s, e) {
  fa.multiplyScalar(qA).add(e), sh.position.copy(e), sh.lookAt(s.position), Nd.copy(sh.quaternion), sh.lookAt(fa), fg.copy(sh.quaternion);
}
function pP(s, e, t) {
  im.x = (s.clientX - e.left) / e.width * 2 - 1, im.y = -((s.clientY - e.top) / e.height) * 2 + 1, pE.setFromCamera(im, t);
}
function p_(s, e, t, i) {
  pP(s, e, t);
  const n = pE.intersectObjects(i);
  return n.length ? n[0].object : null;
}
function f_(s) {
  let e = s.length;
  for (; e--; ) {
    const t = e < 3 ? 0.6 : 0.4;
    s[e].scale.set(t, t, t), s[e].material.map.offset.x = 1;
  }
}
function fP(s, e) {
  nh.set(0, 0, 1), nh.applyQuaternion(e.quaternion), nh.x >= 0 ? (s[o_].material.opacity = 1, s[h_].material.opacity = 0.5) : (s[o_].material.opacity = 0.5, s[h_].material.opacity = 1), nh.y >= 0 ? (s[l_].material.opacity = 1, s[u_].material.opacity = 0.5) : (s[l_].material.opacity = 0.5, s[u_].material.opacity = 1), nh.z >= 0 ? (s[c_].material.opacity = 1, s[d_].material.opacity = 0.5) : (s[c_].material.opacity = 0.5, s[d_].material.opacity = 1);
}
function gE(s, e) {
  var t = {};
  for (var i in s) Object.prototype.hasOwnProperty.call(s, i) && e.indexOf(i) < 0 && (t[i] = s[i]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, i = Object.getOwnPropertySymbols(s); n < i.length; n++)
      e.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(s, i[n]) && (t[i[n]] = s[i[n]]);
  return t;
}
var m_ = function() {
};
const mg = (s, e, t) => Math.min(Math.max(t, s), e), g_ = 1e-3, mP = 0.01, gP = 10, AP = 0.05, yP = 1;
function vP({ duration: s = 800, bounce: e = 0.25, velocity: t = 0, mass: i = 1 }) {
  let n, r, a = 1 - e;
  a = mg(AP, yP, a), s = mg(mP, gP, s / 1e3), a < 1 ? (n = (c) => {
    const h = c * a, u = h * s, d = h - t, p = gg(c, a), f = Math.exp(-u);
    return g_ - d / p * f;
  }, r = (c) => {
    const u = c * a * s, d = u * t + t, p = Math.pow(a, 2) * Math.pow(c, 2) * s, f = Math.exp(-u), y = gg(Math.pow(c, 2), a);
    return (-n(c) + g_ > 0 ? -1 : 1) * ((d - p) * f) / y;
  }) : (n = (c) => {
    const h = Math.exp(-c * s), u = (c - t) * s + 1;
    return -1e-3 + h * u;
  }, r = (c) => {
    const h = Math.exp(-c * s), u = (t - c) * (s * s);
    return h * u;
  });
  const o = 5 / s, l = xP(n, r, o);
  if (s = s * 1e3, isNaN(l))
    return {
      stiffness: 100,
      damping: 10,
      duration: s
    };
  {
    const c = Math.pow(l, 2) * i;
    return {
      stiffness: c,
      damping: a * 2 * Math.sqrt(i * c),
      duration: s
    };
  }
}
const _P = 12;
function xP(s, e, t) {
  let i = t;
  for (let n = 1; n < _P; n++)
    i = i - s(i) / e(i);
  return i;
}
function gg(s, e) {
  return s * Math.sqrt(1 - e * e);
}
const wP = ["duration", "bounce"], EP = ["stiffness", "damping", "mass"];
function A_(s, e) {
  return e.some((t) => s[t] !== void 0);
}
function bP(s) {
  let e = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1 }, s);
  if (!A_(s, EP) && A_(s, wP)) {
    const t = vP(s);
    e = Object.assign(Object.assign(Object.assign({}, e), t), { velocity: 0, mass: 1 }), e.isResolvedFromDuration = !0;
  }
  return e;
}
function XA(s) {
  var { from: e = 0, to: t = 1, restSpeed: i = 2, restDelta: n } = s, r = gE(s, ["from", "to", "restSpeed", "restDelta"]);
  const a = { done: !1, value: e };
  let { stiffness: o, damping: l, mass: c, velocity: h, duration: u, isResolvedFromDuration: d } = bP(r), p = y_, f = y_;
  function y() {
    const A = h ? -(h / 1e3) : 0, m = t - e, v = l / (2 * Math.sqrt(o * c)), g = Math.sqrt(o / c) / 1e3;
    if (n === void 0 && (n = Math.min(Math.abs(t - e) / 100, 0.4)), v < 1) {
      const _ = gg(g, v);
      p = (w) => {
        const S = Math.exp(-v * g * w);
        return t - S * ((A + v * g * m) / _ * Math.sin(_ * w) + m * Math.cos(_ * w));
      }, f = (w) => {
        const S = Math.exp(-v * g * w);
        return v * g * S * (Math.sin(_ * w) * (A + v * g * m) / _ + m * Math.cos(_ * w)) - S * (Math.cos(_ * w) * (A + v * g * m) - _ * m * Math.sin(_ * w));
      };
    } else if (v === 1)
      p = (_) => t - Math.exp(-g * _) * (m + (A + g * m) * _);
    else {
      const _ = g * Math.sqrt(v * v - 1);
      p = (w) => {
        const S = Math.exp(-v * g * w), C = Math.min(_ * w, 300);
        return t - S * ((A + v * g * m) * Math.sinh(C) + _ * m * Math.cosh(C)) / _;
      };
    }
  }
  return y(), {
    next: (A) => {
      const m = p(A);
      if (d)
        a.done = A >= u;
      else {
        const v = f(A) * 1e3, g = Math.abs(v) <= i, _ = Math.abs(t - m) <= n;
        a.done = g && _;
      }
      return a.value = a.done ? t : m, a;
    },
    flipTarget: () => {
      h = -h, [e, t] = [t, e], y();
    }
  };
}
XA.needsInterpolation = (s, e) => typeof s == "string" || typeof e == "string";
const y_ = (s) => 0, AE = (s, e, t) => {
  const i = e - s;
  return i === 0 ? 1 : (t - s) / i;
}, YA = (s, e, t) => -t * s + t * e + s, yE = (s, e) => (t) => Math.max(Math.min(t, e), s), Eh = (s) => s % 1 ? Number(s.toFixed(5)) : s, hp = /(-)?([\d]*\.?[\d])+/g, Ag = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, SP = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function du(s) {
  return typeof s == "string";
}
const Kp = {
  test: (s) => typeof s == "number",
  parse: parseFloat,
  transform: (s) => s
}, vE = Object.assign(Object.assign({}, Kp), { transform: yE(0, 1) });
Object.assign(Object.assign({}, Kp), { default: 1 });
const CP = (s) => ({
  test: (e) => du(e) && e.endsWith(s) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${s}`
}), bh = CP("%");
Object.assign(Object.assign({}, bh), { parse: (s) => bh.parse(s) / 100, transform: (s) => bh.transform(s * 100) });
const KA = (s, e) => (t) => !!(du(t) && SP.test(t) && t.startsWith(s) || e && Object.prototype.hasOwnProperty.call(t, e)), _E = (s, e, t) => (i) => {
  if (!du(i))
    return i;
  const [n, r, a, o] = i.match(hp);
  return {
    [s]: parseFloat(n),
    [e]: parseFloat(r),
    [t]: parseFloat(a),
    alpha: o !== void 0 ? parseFloat(o) : 1
  };
}, lo = {
  test: KA("hsl", "hue"),
  parse: _E("hue", "saturation", "lightness"),
  transform: ({ hue: s, saturation: e, lightness: t, alpha: i = 1 }) => "hsla(" + Math.round(s) + ", " + bh.transform(Eh(e)) + ", " + bh.transform(Eh(t)) + ", " + Eh(vE.transform(i)) + ")"
}, MP = yE(0, 255), nm = Object.assign(Object.assign({}, Kp), { transform: (s) => Math.round(MP(s)) }), va = {
  test: KA("rgb", "red"),
  parse: _E("red", "green", "blue"),
  transform: ({ red: s, green: e, blue: t, alpha: i = 1 }) => "rgba(" + nm.transform(s) + ", " + nm.transform(e) + ", " + nm.transform(t) + ", " + Eh(vE.transform(i)) + ")"
};
function TP(s) {
  let e = "", t = "", i = "", n = "";
  return s.length > 5 ? (e = s.substr(1, 2), t = s.substr(3, 2), i = s.substr(5, 2), n = s.substr(7, 2)) : (e = s.substr(1, 1), t = s.substr(2, 1), i = s.substr(3, 1), n = s.substr(4, 1), e += e, t += t, i += i, n += n), {
    red: parseInt(e, 16),
    green: parseInt(t, 16),
    blue: parseInt(i, 16),
    alpha: n ? parseInt(n, 16) / 255 : 1
  };
}
const yg = {
  test: KA("#"),
  parse: TP,
  transform: va.transform
}, Jp = {
  test: (s) => va.test(s) || yg.test(s) || lo.test(s),
  parse: (s) => va.test(s) ? va.parse(s) : lo.test(s) ? lo.parse(s) : yg.parse(s),
  transform: (s) => du(s) ? s : s.hasOwnProperty("red") ? va.transform(s) : lo.transform(s)
}, xE = "${c}", wE = "${n}";
function IP(s) {
  var e, t, i, n;
  return isNaN(s) && du(s) && ((t = (e = s.match(hp)) === null || e === void 0 ? void 0 : e.length) !== null && t !== void 0 ? t : 0) + ((n = (i = s.match(Ag)) === null || i === void 0 ? void 0 : i.length) !== null && n !== void 0 ? n : 0) > 0;
}
function EE(s) {
  typeof s == "number" && (s = `${s}`);
  const e = [];
  let t = 0;
  const i = s.match(Ag);
  i && (t = i.length, s = s.replace(Ag, xE), e.push(...i.map(Jp.parse)));
  const n = s.match(hp);
  return n && (s = s.replace(hp, wE), e.push(...n.map(Kp.parse))), { values: e, numColors: t, tokenised: s };
}
function bE(s) {
  return EE(s).values;
}
function SE(s) {
  const { values: e, numColors: t, tokenised: i } = EE(s), n = e.length;
  return (r) => {
    let a = i;
    for (let o = 0; o < n; o++)
      a = a.replace(o < t ? xE : wE, o < t ? Jp.transform(r[o]) : Eh(r[o]));
    return a;
  };
}
const DP = (s) => typeof s == "number" ? 0 : s;
function RP(s) {
  const e = bE(s);
  return SE(s)(e.map(DP));
}
const CE = { test: IP, parse: bE, createTransformer: SE, getAnimatableNone: RP };
function sm(s, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * (2 / 3 - t) * 6 : s;
}
function v_({ hue: s, saturation: e, lightness: t, alpha: i }) {
  s /= 360, e /= 100, t /= 100;
  let n = 0, r = 0, a = 0;
  if (!e)
    n = r = a = t;
  else {
    const o = t < 0.5 ? t * (1 + e) : t + e - t * e, l = 2 * t - o;
    n = sm(l, o, s + 1 / 3), r = sm(l, o, s), a = sm(l, o, s - 1 / 3);
  }
  return {
    red: Math.round(n * 255),
    green: Math.round(r * 255),
    blue: Math.round(a * 255),
    alpha: i
  };
}
const BP = (s, e, t) => {
  const i = s * s, n = e * e;
  return Math.sqrt(Math.max(0, t * (n - i) + i));
}, PP = [yg, va, lo], __ = (s) => PP.find((e) => e.test(s)), ME = (s, e) => {
  let t = __(s), i = __(e), n = t.parse(s), r = i.parse(e);
  t === lo && (n = v_(n), t = va), i === lo && (r = v_(r), i = va);
  const a = Object.assign({}, n);
  return (o) => {
    for (const l in a)
      l !== "alpha" && (a[l] = BP(n[l], r[l], o));
    return a.alpha = YA(n.alpha, r.alpha, o), t.transform(a);
  };
}, LP = (s) => typeof s == "number", UP = (s, e) => (t) => e(s(t)), TE = (...s) => s.reduce(UP);
function IE(s, e) {
  return LP(s) ? (t) => YA(s, e, t) : Jp.test(s) ? ME(s, e) : RE(s, e);
}
const DE = (s, e) => {
  const t = [...s], i = t.length, n = s.map((r, a) => IE(r, e[a]));
  return (r) => {
    for (let a = 0; a < i; a++)
      t[a] = n[a](r);
    return t;
  };
}, FP = (s, e) => {
  const t = Object.assign(Object.assign({}, s), e), i = {};
  for (const n in t)
    s[n] !== void 0 && e[n] !== void 0 && (i[n] = IE(s[n], e[n]));
  return (n) => {
    for (const r in i)
      t[r] = i[r](n);
    return t;
  };
};
function x_(s) {
  const e = CE.parse(s), t = e.length;
  let i = 0, n = 0, r = 0;
  for (let a = 0; a < t; a++)
    i || typeof e[a] == "number" ? i++ : e[a].hue !== void 0 ? r++ : n++;
  return { parsed: e, numNumbers: i, numRGB: n, numHSL: r };
}
const RE = (s, e) => {
  const t = CE.createTransformer(e), i = x_(s), n = x_(e);
  return i.numHSL === n.numHSL && i.numRGB === n.numRGB && i.numNumbers >= n.numNumbers ? TE(DE(i.parsed, n.parsed), t) : (a) => `${a > 0 ? e : s}`;
}, OP = (s, e) => (t) => YA(s, e, t);
function NP(s) {
  if (typeof s == "number")
    return OP;
  if (typeof s == "string")
    return Jp.test(s) ? ME : RE;
  if (Array.isArray(s))
    return DE;
  if (typeof s == "object")
    return FP;
}
function kP(s, e, t) {
  const i = [], n = t || NP(s[0]), r = s.length - 1;
  for (let a = 0; a < r; a++) {
    let o = n(s[a], s[a + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[a] : e;
      o = TE(l, o);
    }
    i.push(o);
  }
  return i;
}
function GP([s, e], [t]) {
  return (i) => t(AE(s, e, i));
}
function zP(s, e) {
  const t = s.length, i = t - 1;
  return (n) => {
    let r = 0, a = !1;
    if (n <= s[0] ? a = !0 : n >= s[i] && (r = i - 1, a = !0), !a) {
      let l = 1;
      for (; l < t && !(s[l] > n || l === i); l++)
        ;
      r = l - 1;
    }
    const o = AE(s[r], s[r + 1], n);
    return e[r](o);
  };
}
function BE(s, e, { clamp: t = !0, ease: i, mixer: n } = {}) {
  const r = s.length;
  m_(r === e.length), m_(!i || !Array.isArray(i) || i.length === r - 1), s[0] > s[r - 1] && (s = [].concat(s), e = [].concat(e), s.reverse(), e.reverse());
  const a = kP(e, i, n), o = r === 2 ? GP(s, a) : zP(s, a);
  return t ? (l) => o(mg(s[0], s[r - 1], l)) : o;
}
const $p = (s) => (e) => 1 - s(1 - e), JA = (s) => (e) => e <= 0.5 ? s(2 * e) / 2 : (2 - s(2 * (1 - e))) / 2, QP = (s) => (e) => Math.pow(e, s), PE = (s) => (e) => e * e * ((s + 1) * e - s), HP = (s) => {
  const e = PE(s);
  return (t) => (t *= 2) < 1 ? 0.5 * e(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1)));
}, LE = 1.525, VP = 4 / 11, WP = 8 / 11, jP = 9 / 10, qP = (s) => s, $A = QP(2), XP = $p($A), UE = JA($A), FE = (s) => 1 - Math.sin(Math.acos(s)), OE = $p(FE), YP = JA(OE), ZA = PE(LE), KP = $p(ZA), JP = JA(ZA), $P = HP(LE), ZP = 4356 / 361, e2 = 35442 / 1805, t2 = 16061 / 1805, up = (s) => {
  if (s === 1 || s === 0)
    return s;
  const e = s * s;
  return s < VP ? 7.5625 * e : s < WP ? 9.075 * e - 9.9 * s + 3.4 : s < jP ? ZP * e - e2 * s + t2 : 10.8 * s * s - 20.52 * s + 10.72;
}, i2 = $p(up), n2 = (s) => s < 0.5 ? 0.5 * (1 - up(1 - s * 2)) : 0.5 * up(s * 2 - 1) + 0.5;
function s2(s, e) {
  return s.map(() => e || UE).splice(0, s.length - 1);
}
function r2(s) {
  const e = s.length;
  return s.map((t, i) => i !== 0 ? i / (e - 1) : 0);
}
function a2(s, e) {
  return s.map((t) => t * e);
}
function kd({ from: s = 0, to: e = 1, ease: t, offset: i, duration: n = 300 }) {
  const r = { done: !1, value: s }, a = Array.isArray(e) ? e : [s, e], o = a2(i && i.length === a.length ? i : r2(a), n);
  function l() {
    return BE(o, a, {
      ease: Array.isArray(t) ? t : s2(a, t)
    });
  }
  let c = l();
  return {
    next: (h) => (r.value = c(h), r.done = h >= n, r),
    flipTarget: () => {
      a.reverse(), c = l();
    }
  };
}
function o2({ velocity: s = 0, from: e = 0, power: t = 0.8, timeConstant: i = 350, restDelta: n = 0.5, modifyTarget: r }) {
  const a = { done: !1, value: e };
  let o = t * s;
  const l = e + o, c = r === void 0 ? l : r(l);
  return c !== l && (o = c - e), {
    next: (h) => {
      const u = -o * Math.exp(-h / i);
      return a.done = !(u > n || u < -n), a.value = a.done ? c : c + u, a;
    },
    flipTarget: () => {
    }
  };
}
const w_ = { keyframes: kd, spring: XA, decay: o2 };
function l2(s) {
  if (Array.isArray(s.to))
    return kd;
  if (w_[s.type])
    return w_[s.type];
  const e = new Set(Object.keys(s));
  return e.has("ease") || e.has("duration") && !e.has("dampingRatio") ? kd : e.has("dampingRatio") || e.has("stiffness") || e.has("mass") || e.has("damping") || e.has("restSpeed") || e.has("restDelta") ? XA : kd;
}
const NE = 1 / 60 * 1e3, c2 = typeof performance < "u" ? () => performance.now() : () => Date.now(), kE = typeof window < "u" ? (s) => window.requestAnimationFrame(s) : (s) => setTimeout(() => s(c2()), NE);
function h2(s) {
  let e = [], t = [], i = 0, n = !1, r = !1;
  const a = /* @__PURE__ */ new WeakSet(), o = {
    schedule: (l, c = !1, h = !1) => {
      const u = h && n, d = u ? e : t;
      return c && a.add(l), d.indexOf(l) === -1 && (d.push(l), u && n && (i = e.length)), l;
    },
    cancel: (l) => {
      const c = t.indexOf(l);
      c !== -1 && t.splice(c, 1), a.delete(l);
    },
    process: (l) => {
      if (n) {
        r = !0;
        return;
      }
      if (n = !0, [e, t] = [t, e], t.length = 0, i = e.length, i)
        for (let c = 0; c < i; c++) {
          const h = e[c];
          h(l), a.has(h) && (o.schedule(h), s());
        }
      n = !1, r && (r = !1, o.process(l));
    }
  };
  return o;
}
const u2 = 40;
let vg = !0, Hh = !1, _g = !1;
const Sh = {
  delta: 0,
  timestamp: 0
}, pu = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], Zp = pu.reduce((s, e) => (s[e] = h2(() => Hh = !0), s), {}), d2 = pu.reduce((s, e) => {
  const t = Zp[e];
  return s[e] = (i, n = !1, r = !1) => (Hh || m2(), t.schedule(i, n, r)), s;
}, {}), p2 = pu.reduce((s, e) => (s[e] = Zp[e].cancel, s), {});
pu.reduce((s, e) => (s[e] = () => Zp[e].process(Sh), s), {});
const f2 = (s) => Zp[s].process(Sh), GE = (s) => {
  Hh = !1, Sh.delta = vg ? NE : Math.max(Math.min(s - Sh.timestamp, u2), 1), Sh.timestamp = s, _g = !0, pu.forEach(f2), _g = !1, Hh && (vg = !1, kE(GE));
}, m2 = () => {
  Hh = !0, vg = !0, _g || kE(GE);
};
function zE(s, e, t = 0) {
  return s - e - t;
}
function g2(s, e, t = 0, i = !0) {
  return i ? zE(e + -s, e, t) : e - (s - e) + t;
}
function A2(s, e, t, i) {
  return i ? s >= e + t : s <= -t;
}
const y2 = (s) => {
  const e = ({ delta: t }) => s(t);
  return {
    start: () => d2.update(e, !0),
    stop: () => p2.update(e)
  };
};
function QE(s) {
  var e, t, { from: i, autoplay: n = !0, driver: r = y2, elapsed: a = 0, repeat: o = 0, repeatType: l = "loop", repeatDelay: c = 0, onPlay: h, onStop: u, onComplete: d, onRepeat: p, onUpdate: f } = s, y = gE(s, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  let { to: A } = y, m, v = 0, g = y.duration, _, w = !1, S = !0, C;
  const E = l2(y);
  !((t = (e = E).needsInterpolation) === null || t === void 0) && t.call(e, i, A) && (C = BE([0, 100], [i, A], {
    clamp: !1
  }), i = 0, A = 100);
  const x = E(Object.assign(Object.assign({}, y), { from: i, to: A }));
  function b() {
    v++, l === "reverse" ? (S = v % 2 === 0, a = g2(a, g, c, S)) : (a = zE(a, g, c), l === "mirror" && x.flipTarget()), w = !1, p && p();
  }
  function D() {
    m.stop(), d && d();
  }
  function O(B) {
    if (S || (B = -B), a += B, !w) {
      const Q = x.next(Math.max(0, a));
      _ = Q.value, C && (_ = C(_)), w = S ? Q.done : a <= 0;
    }
    f == null || f(_), w && (v === 0 && (g ?? (g = a)), v < o ? A2(a, g, c, S) && b() : D());
  }
  function Y() {
    h == null || h(), m = r(O), m.start();
  }
  return n && Y(), {
    stop: () => {
      u == null || u(), m.stop();
    }
  };
}
const v2 = (s) => -(Math.cos(Math.PI * s) - 1) / 2, ey = {
  linear: qP,
  easeIn: $A,
  easeOut: XP,
  easeInOut: UE,
  circIn: FE,
  circOut: OE,
  circInOut: YP,
  backIn: ZA,
  backOut: KP,
  backInOut: JP,
  anticipate: $P,
  bounceOut: up,
  bounceIn: i2,
  bounceInOut: n2,
  easeInOutSine: v2
};
function HE(s, e, t) {
  const i = s[e], n = () => {
    t == null || t();
  }, r = typeof i == "boolean";
  return i && i.isColor ? (a) => {
    i.set(a), n();
  } : i && typeof i.copy == "function" ? (a) => {
    i.copy(a), n();
  } : (a) => {
    s[e] = r ? !!a : a, n();
  };
}
async function Tz(s, e, t, i, n = !1) {
  e in s || console.error("invalid key", e, s);
  const r = HE(s, e), a = n || t.from === void 0 ? s[e] : t.from, o = (l) => {
    r(l), t.onUpdate && t.onUpdate(l);
  };
  if (typeof a == "boolean") {
    const { duration: l } = t;
    return bs(l ?? 0).then(() => o(t.to));
  } else
    return typeof t.to == "function" && (t = { ...t, to: t.to(a, s) }), _2({
      ...t,
      from: a,
      onUpdate: o
    }, i);
}
async function _2(s, e) {
  const t = s.onComplete, i = s.onStop, n = s.onEnd;
  return s = { ...s }, new Promise((r, a) => {
    const o = () => {
      try {
        n == null || n();
      } catch (c) {
        return a(c), !1;
      }
      return !0;
    };
    s.onComplete = () => {
      try {
        t == null || t();
      } catch (c) {
        if (!o()) return;
        a(c);
        return;
      }
      o() && r();
    }, s.onStop = () => {
      try {
        i == null || i();
      } catch (c) {
        if (!o()) return;
        a(c);
        return;
      }
      o() && r();
    };
    const l = QE(s);
    e && e.push(l);
  });
}
function E_(s, e, t) {
  const i = e - s;
  return i >= Math.PI ? s + (i - Math.PI * 2) * t : i <= -Math.PI ? s + (i + Math.PI * 2) * t : s + i * t;
}
const xg = ri.lerp;
function b_(s) {
  const e = s.position.clone();
  e.sub(s.target);
  const t = new sc().setFromVector3(e);
  return t.makeSafe(), t;
}
function x2(s, e) {
  const t = s.parent, i = s.target.clone(), n = s.getWorldPosition(new M()), r = {
    target: i,
    zoom: s.zoom,
    spherical: b_({ position: n, target: i })
  }, a = {
    position: new M(),
    target: new M(),
    zoom: 1,
    spherical: new sc()
  }, o = {
    position: e.position,
    target: e.target,
    zoom: e.zoom,
    spherical: b_(e)
  };
  function l() {
    s.position.copy(t ? t.worldToLocal(a.position) : a.position), s.target.copy(a.target), s.zoom = a.zoom, s.setDirty();
  }
  return {
    from: 0,
    to: 1,
    onUpdate: (c) => {
      a.spherical.phi = E_(r.spherical.phi, o.spherical.phi, c), a.spherical.theta = E_(r.spherical.theta, o.spherical.theta, c), a.spherical.radius = xg(r.spherical.radius, o.spherical.radius, c), a.target.copy(r.target).lerp(o.target, c), a.position.setFromSpherical(a.spherical), a.position.add(a.target), a.zoom = xg(r.zoom, o.zoom, c), l();
    },
    onComplete: () => {
      a.position.copy(o.position), a.target.copy(o.target), a.zoom = o.zoom, l();
    },
    onStop: () => {
      throw new Error("Animation Stopped");
    }
  };
}
function w2(s, e) {
  const t = s.parent, i = s.target.clone(), n = s.getWorldPosition(new M()), r = s.getWorldQuaternion(new rt()), a = {
    position: n,
    target: i,
    quaternion: r,
    zoom: s.zoom
  }, o = {
    position: new M(),
    target: new M(),
    quaternion: new rt(),
    zoom: 1
  }, l = e;
  function c() {
    s.position.copy(t ? t.worldToLocal(o.position) : o.position), s.target.copy(o.target), s.quaternion.copy(t ? VB(t, o.quaternion, s.quaternion) : o.quaternion), s.zoom = o.zoom, s.setDirty();
  }
  return {
    from: 0,
    to: 1,
    onUpdate: (h) => {
      o.position.lerpVectors(a.position, l.position, h), o.target.lerpVectors(a.target, l.target, h), o.quaternion.slerpQuaternions(a.quaternion, l.quaternion, h), o.zoom = xg(a.zoom, l.zoom, h), c();
    },
    onComplete: () => {
      o.position.copy(l.position), o.target.copy(l.target), o.quaternion.copy(l.quaternion), o.zoom = l.zoom, c();
    },
    onStop: () => {
      throw new Error("Animation Stopped");
    }
  };
}
function E2(s, e) {
  return s.multiplyScalar(s.w * e), s.w = 1, s;
}
function Iz(s, e) {
  return E2(s, e), new se(s.x, s.y, s.z);
}
function b2(s, e) {
  const t = Math.max(s.x, Math.max(s.y, s.z));
  let i = Math.max(Math.min(t / e, 1), 0);
  return i = Math.ceil(i * 255) / 255, s.divideScalar(i * e), s.w = i, s;
}
function Dz(s, e) {
  return b2(new it(s.r, s.g, s.b, 1), e);
}
function S_() {
  return navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome");
}
const Cy = class Cy {
  static async GetClonedCanvas(e, {
    rect: t = { x: 0, y: 0, width: e.width, height: e.height, assumeClientRect: !1, normalized: !1 },
    displayPixelRatio: i = 1,
    scale: n = 1
  }) {
    var c, h, u;
    t = { ...t };
    const r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    t.normalized ? (t.x = Math.floor(t.x * e.width), t.y = Math.floor(t.y * e.height), t.width = Math.floor(t.width * e.width), t.height = Math.floor(t.height * e.height), t.assumeClientRect && console.warn("CanvasSnapshot: rect.assumeClientRect is ignored when rect is normalized")) : t.assumeClientRect && (t.x = Math.floor(t.x * e.width / (i * e.clientWidth)), t.y = Math.floor(t.y * e.height / (i * e.clientHeight)), t.width = Math.floor(t.width * e.width / (i * e.clientWidth)), t.height = Math.floor(t.height * e.height / (i * e.clientHeight))), r.width = Math.floor(t.width * n * i), r.height = Math.floor(t.height * n * i);
    const a = r.getContext("2d");
    if (!a)
      return console.error("snapshot: cannot create context"), r;
    const o = e.style.background || ((c = e.parentElement) == null ? void 0 : c.style.background) || "";
    if (o.includes("url")) {
      const d = (h = /url\("(.*)"\)/ig.exec(o)) == null ? void 0 : h[1];
      if (d) {
        const p = new Image();
        p.src = d, await new Promise((f, y) => {
          p.onload = () => f(), p.onerror = () => y(), p.complete && f();
        }), a.drawImage(
          p,
          Math.floor(p.width * t.x * i / e.width),
          Math.floor(p.height * t.y * i / e.height),
          Math.floor(p.width * t.width * i / e.width),
          Math.floor(p.height * t.height * i / e.height),
          0,
          0,
          r.width,
          r.height
        );
      }
    } else
      a.fillStyle = e.style.background || ((u = e.parentElement) == null ? void 0 : u.style.backgroundColor) || "#00000000", a.fillRect(0, 0, r.width, r.height);
    return a == null || a.drawImage(
      e,
      Math.floor(t.x * i),
      Math.floor(t.y * i),
      Math.floor(t.width * i),
      Math.floor(t.height * i),
      0,
      0,
      r.width,
      r.height
    ), this.Debug && (document.body.appendChild(r), r.style.position = "absolute", r.style.top = "0", r.style.left = "0", r.style.borderWidth = "2px", r.style.borderColor = "#ff00ff", setTimeout(() => r.remove(), 5e3)), r;
  }
  static async GetDataUrl(e, { mimeType: t = "image/png", quality: i, ...n }) {
    const r = S_() || n.cloneCanvas || n.rect || n.scale || n.displayPixelRatio;
    !r && (n.rect || n.scale || n.displayPixelRatio) && console.warn("CanvasSnapshot: rect, scale and displayPixelRatio are ignored when cloneCanvas is false");
    const a = r ? await this.GetClonedCanvas(e, n) : e, o = a.toDataURL(t, i);
    return !this.Debug && a !== e && a.remove(), o;
  }
  // set one of canvas or context to draw in.
  static async GetImage(e, t = {}) {
    const i = await this.GetDataUrl(e, t);
    return new Promise((n, r) => {
      const a = new Image();
      a.onload = () => n(a), a.onerror = () => r(), a.src = i;
    });
  }
  static async GetBlob(e, t = {}) {
    const i = S_() || t.cloneCanvas || t.rect || t.scale || t.displayPixelRatio;
    !i && (t.rect || t.scale || t.displayPixelRatio) && console.warn("rect, scale and displayPixelRatio are ignored when cloneCanvas is false");
    const n = i ? await this.GetClonedCanvas(e, t) : e, r = await new Promise((a, o) => {
      n.toBlob((l) => {
        l ? a(l) : o(new Error("CanvasSnapshot Failed to export blob from canvas"));
      }, t.mimeType ?? "image/png", t.quality);
    });
    return !this.Debug && n !== e && n.remove(), r;
  }
  static async GetFile(e, t = "image", i = {}) {
    var a, o;
    const n = "." + (((o = (a = i.mimeType) == null ? void 0 : a.split("/")[1]) == null ? void 0 : o.toLowerCase()) || "png"), r = t.toLowerCase().endsWith(n) ? t : t + n;
    return i.getDataUrl ? await this.GetDataUrl(e, i) : new File([await this.GetBlob(e, i)], r, {
      type: i.mimeType ?? "image/png",
      lastModified: zn()
    });
  }
  static async GetTiledFiles(e, t = "image", i = 2, n = 2, r = {}) {
    var l;
    const a = r.rect ?? { x: 0, y: 0, width: 1, height: 1, assumeClientRect: !1, normalized: !0 }, o = [];
    for (let c = 0; c < n; c++)
      for (let h = 0; h < i; h++) {
        const u = ((l = r.mimeType) == null ? void 0 : l.split("/")[1]) ?? "png", d = await this.GetFile(e, `${t}_${c}_${h}.${u}`, {
          rect: {
            x: a.x + c * a.width / n,
            y: a.y + h * a.height / i,
            width: a.width / n,
            height: a.height / i,
            assumeClientRect: a.assumeClientRect,
            normalized: a.normalized
          }
        }).catch((p) => (console.error(`CanvasSnapshot - Error exporting tiled file ${c}, ${h}`, p), null));
        d && o.push(d);
      }
    return o;
  }
};
Cy.Debug = !1;
let dp = Cy;
const My = class My extends Vi {
  constructor() {
    super(...arguments), this._dirty = !1, this.uiConfig = void 0, this._viewerListeners = {}, this._onViewerEvent = (e) => {
      var i, n;
      const t = e.eType;
      return t && ((n = (i = this._viewerListeners)[t]) == null || n.call(i, e)), e;
    }, this._disabledBy = /* @__PURE__ */ new Set(), this.disable = (e, t = !0) => {
      const i = this._disabledBy.size;
      this._disabledBy.add(e), t && this.setDirty && i !== this._disabledBy.size && this.setDirty();
    }, this.enable = (e, t = !0) => {
      const i = this._disabledBy.size;
      this._disabledBy.delete(e), t && this.setDirty && i !== this._disabledBy.size && this.setDirty();
    }, this.isDisabled = () => this._disabledBy.size > 0 || !this.enabled;
  }
  dispose() {
  }
  toJSON(e) {
    const t = mt.Serialize(this, e, !0);
    return t.type = this.constructor.PluginType, t.assetType = "config", this.dispatchEvent({ type: "serialize", data: t }), t;
  }
  fromJSON(e, t) {
    return e.type !== this.constructor.PluginType && e.type !== this.constructor.OldPluginType ? null : (mt.Deserialize(e, this, t, !0), this.dispatchEvent({ type: "deserialize", data: e, meta: t }), this);
  }
  _storeKey(e) {
    return (e ?? "webgi") + "_" + (this.constructor.PluginType || this.constructor.name);
  }
  exportState() {
    var e, t;
    return ((e = this._viewer) == null ? void 0 : e.exportPluginConfig(this)) ?? ((t = this.toJSON) == null ? void 0 : t.call(this));
  }
  async importState(e) {
    var t;
    this._viewer ? await this._viewer.importPluginConfig(e, this) : (t = this.fromJSON) == null || t.call(this, e);
  }
  // todo: move to ThreeViewer
  // storeState(prefix?: string, storage?: Storage, data?: any): void {
  //     storage = storage || (window ? window.localStorage : undefined)
  //     if (!storage) {
  //         console.warn('Unable to store state')
  //         return
  //     }
  //     if (data === undefined) data = this.exportState()
  //     if (data) storage.setItem(this._storeKey(prefix), JSON.stringify(data))
  // }
  //
  // async loadState(prefix?: string, storage?: Storage): Promise<void> {
  //     storage = storage || (window ? window.localStorage : undefined)
  //     if (!storage) {
  //         console.warn('Unable to load state')
  //         return
  //     }
  //     const data = storage.getItem(this._storeKey(prefix))
  //     if (data) await this.importState(JSON.parse(data))
  // }
  get dirty() {
    return this.enabled && this._dirty;
  }
  set dirty(e) {
    this._dirty = e;
  }
  /**
       * Template
  
       toJSON(meta?: any): any {
          const data = super.toJSON(meta)
          if (!data.type) return data
          // add here
          return data
      }
  
       fromJSON(data: any, meta?: any): this | null {
          if (!super.fromJSON(data, meta)) return null
          // add here
          return this
      }
       */
};
My.PluginType = "AViewerPlugin";
let pp = My;
class Tt extends pp {
  onAdded(e) {
    this._viewer = e, this._viewer.addEventListener("*", this._onViewerEvent);
  }
  onRemove(e) {
    var t;
    this._viewer !== e && e.console.error("Wrong viewer"), (t = this._viewer) == null || t.removeEventListener("*", this._onViewerEvent), this._viewer = void 0;
  }
}
class Rz extends pp {
  async onAdded(e) {
    this._viewer = e, this._viewer.addEventListener("*", this._onViewerEvent);
  }
  async onRemove(e) {
    var t;
    this._viewer !== e && e.console.error("Wrong viewer"), (t = this._viewer) == null || t.removeEventListener("*", this._onViewerEvent), this._viewer = void 0;
  }
}
/**
 * @license
 * uiconfig.js v0.1.5
 * Copyright 2022-2025 repalash <palash@shaders.app>
 * MIT License
 */
/**
 * @license
 * ts-browser-helpers v0.16.2
 * Copyright 2022-2025 repalash <palash@shaders.app>
 * MIT License
 * See ./dependencies.txt for bundled third-party dependencies and licenses.
 */
let S2 = class {
  constructor() {
    this._eventListeners = {}, this.dispatchEvent = this.dispatchEvent.bind(this), this.addEventListener = this.addEventListener.bind(this), this.removeEventListener = this.removeEventListener.bind(this), this.hasEventListener = this.hasEventListener.bind(this);
  }
  addEventListener(e, t) {
    const i = this._eventListeners;
    i[e] === void 0 && (i[e] = []), i[e].includes(t) || i[e].push(t);
  }
  hasEventListener(e, t) {
    const i = this._eventListeners;
    return i[e] !== void 0 && i[e].includes(t);
  }
  removeEventListener(e, t) {
    const i = this._eventListeners[e];
    if (i !== void 0) {
      const n = i.indexOf(t);
      n !== -1 && i.splice(n, 1);
    }
  }
  dispatchEvent(e) {
    const t = this._eventListeners[e.type];
    if (t !== void 0) {
      e.target = this;
      const i = t.slice(0);
      for (let n = 0, r = i.length; n < r; n++) i[n].call(this, e);
    }
  }
};
async function C2(s) {
  return new Promise((e) => setTimeout(e, Math.max(0, s)));
}
function M2() {
  return (typeof performance > "u" ? Date : performance).now();
}
/*!
 * Fork Of -
 * JavaScript Undo Manager 1.0.0
 * Simple JavaScript undo/redo command manager supporting transactions with no dependencies.
 *
 * Copyright: Alexey Grinko, 2017
 * Git repository: https://github.com/agrinko/js-undo-manager.git
 *
 * @license MIT - https://opensource.org/licenses/MIT
 *
 * Changes -
 * 1. Added presets commands
 * 2. Port to TypeScript
 * 3. Remove transactions
 */
let T2 = class {
  constructor(e) {
    this.options = {
      limit: 500,
      // maximum commands stack size
      debug: !1,
      // whether to emit execution status in console
      bindHotKeys: !1
      // whether to bind "undo" and "redo" commands to "Ctrl+Z", "Ctrl+Y" & "Ctrl+Shift+Z" hot keys
      // useTransactions: true   // whether to initialize transactions manager
    }, this.enabled = !0, this.presets = {}, this._keyDown = (t) => {
      if (!this.enabled) return;
      const i = t.ctrlKey || t.metaKey;
      t.code === "KeyZ" && i && !t.shiftKey ? this.undo() : (t.code === "KeyZ" && i && t.shiftKey || t.code === "KeyY" && t.ctrlKey) && this.redo();
    }, Object.assign(this.options, e), this.limit = e.limit, this.options = e, this.reset(), e.bindHotKeys && this.bindHotKeys(), this.log(`Initialized with stack limit of ${this.limit} commands`);
  }
  /**
   * Bind 'undo' and 'redo' actions to 'Ctrl/Cmd+Z', 'Ctrl+Y' & 'Ctrl/Cmd+Shift+Z' hot keys.
   * It is a basic implementation for quick testing and should be replaced with custom event handlers
   * for more flexible processing.
   * @returns {JSUndoManager}
   */
  bindHotKeys() {
    return this.log("Bound 'undo' and 'redo' actions to 'Ctrl/Cmd+Z', 'Ctrl+Y' & 'Ctrl/Cmd+Shift+Z' hot keys"), (this.options.hotKeyRoot ?? document).addEventListener("keydown", this._keyDown), this;
  }
  dispose() {
    return (this.options.hotKeyRoot ?? document).removeEventListener("keydown", this._keyDown), this.reset();
  }
  /**
   * Remember executed command containing "redo" and "undo" functions
   * @param {Object|Function} command - either an object with "redo" and "undo" functions
   * @returns {JSUndoManager}
   */
  record(e) {
    return this.enabled ? (this._record(e), this) : this;
  }
  replaceLast(e) {
    const t = this.peek();
    if (t)
      return this.log("replace", t, "with", e), this.stack[this.sp] = e, this;
  }
  /**
   * Execute function and record it with its opposite "undo" function
   * @param {Object|Function} command - either an object with "redo" and "undo" functions
   * @param {Function} [undo] - "undo" function, used if the first argument is also a function
   * @returns {JSUndoManager}
   */
  execute(e) {
    if (!this.enabled) return;
    let t = this._rc(e), i = t.redo;
    return this.record.apply(this, t), this.log("Executing function..."), i.apply(e), this;
  }
  _rc(e) {
    if (e.type) {
      const t = this.presets[e.type];
      if (typeof t == "function")
        return t(e);
      throw console.error(e, t, this.presets), new Error("Preset command not found");
    } else
      return e;
  }
  _record(e) {
    this.enabled && (this.log("Recording command", e), this._rebase(), this.stack.push(e), this.sp++, this._keepLimit());
  }
  //forget "future" commands if stack pointer is not at the end
  _rebase() {
    this.canRedo() && (this.stack.length = this.sp + 1);
  }
  //sustain limited size of stack; cut extra commands starting with the latest ones
  _keepLimit() {
    if (this.stack.length <= this.limit)
      return;
    let e = this.stack.length - this.limit;
    this.log("Stack size reached its limit: ${this.limit} commands. Cutting off most old commands..."), e === 1 ? this.stack.shift() : this.stack.splice(0, e), this.sp -= e;
  }
  /**
   * Undo previous command if possible
   * @returns {JSUndoManager}
   */
  undo() {
    if (!this.canUndo())
      return this;
    let e = this.stack[this.sp];
    return this.log("undo"), this.sp--, this._rc(e).undo(), this;
  }
  /**
   * Check whether undoing previous command is possible
   * @returns {boolean}
   */
  canUndo() {
    return this.sp >= 0 && this.enabled;
  }
  /**
   * Get the last command that was done
   */
  peek() {
    return this.canUndo() ? this.stack[this.sp] : null;
  }
  /**
   * Redo the command which was previously undone
   * @returns {JSUndoManager}
   */
  redo() {
    if (!this.canRedo())
      return this;
    let e = this.stack[this.sp + 1];
    return this.log("redo"), this.sp++, this._rc(e).redo(), this;
  }
  /**
   * Check whether redoing command is possible
   * @returns {boolean}
   */
  canRedo() {
    return this.sp < this.stack.length - 1 && this.enabled;
  }
  /**
   * Gets the last command that was undone
   */
  peekForward() {
    return this.canRedo() ? this.stack[this.sp + 1] : null;
  }
  /**
   * Change stack size limit initially defined in the constructor options
   * @param {number} limit
   */
  setLimit(e) {
    let t = this.stack.length - this.sp - 1;
    if (e < 1 || typeof e != "number")
      throw new TypeError(`JSUndoManager.setLimit(): unexpected argument limit=${e}. Should be a positive number`);
    return e < t ? console.warn(`JSUndoManager.setLimit(): cannot set stack limit (${e}) less than the number of 'redoable' commands (${t})`) : (this.limit = Math.floor(e), this._keepLimit()), this;
  }
  /**
   * Reset all commands from memory
   */
  reset() {
    return this.log("reset"), this.stack = [], this.sp = -1, this;
  }
  /**
   * Check whether the commands stack is empty
   * @returns {boolean}
   */
  isEmpty() {
    return !this.stack.length;
  }
  /**
   * Check whether the commands stack size reaches its limit
   * @returns {boolean}
   */
  isFull() {
    return this.stack.length === this.limit;
  }
  /**
   * Get number of commands in memory stack
   * @returns {Number}
   */
  getSize() {
    return this.stack.length;
  }
  log(e, ...t) {
    this.options.debug && console.log(`Command Manager: ${e}`, ...t);
  }
};
function I2(s, e) {
  let t;
  do
    t = Object.getOwnPropertyDescriptor(s, e);
  while (!t && (s = Object.getPrototypeOf(s)));
  return t;
}
function D2(s, e, t = !0, i = !1) {
  const n = I2(s, e);
  return !!(n != null && n.set) || t && (n == null ? void 0 : n.writable) !== !1 && (n == null ? void 0 : n.get) === void 0 || i && !n;
}
function R2(s, e, t, i = !0, n = !1) {
  return s && D2(s, e, i, n) ? (s[e] = t, !0) : !1;
}
function ks(s, ...e) {
  return typeof s == "function" && (s = s(...e)), s;
}
function VE() {
  const s = (i, n) => i.toString(16).padStart(n, "0"), e = crypto.getRandomValues(new Uint8Array(16));
  e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
  const t = new DataView(e.buffer);
  return `${s(t.getUint32(0), 8)}-${s(t.getUint16(4), 4)}-${s(t.getUint16(6), 4)}-${s(t.getUint16(8), 4)}-${s(t.getUint32(10), 8)}${s(t.getUint16(14), 4)}`;
}
function B2(s, e = null) {
  return new URL(window.location.href).searchParams.get(s) ?? e;
}
class Ch {
}
Ch.Map = /* @__PURE__ */ new Map();
function C_(s, e, t, i) {
  i = i ?? s[e];
  const n = i == null ? void 0 : i.uiConfig;
  let r;
  if (n)
    r = n;
  else {
    const a = P2(i);
    a === "folder" ? r = ty(e + "", i, {}, "folder", !0) : a && (r = {
      type: a,
      label: e + "",
      property: [s, e]
    });
  }
  return t = t ?? e + "", r && !r.label && (r.label = t), r;
}
function mr(s) {
  if (!s)
    return [];
  let e = s.constructor || Object;
  e === Array && (e = Object);
  const t = [], i = [];
  for (; e && e !== Object; )
    i.push(e), e = Object.getPrototypeOf(e);
  if (!i.length || Array.isArray(s)) {
    const n = typeof s == "object" ? Object.keys(s) : Array.isArray(s) ? s.map((r, a) => a) : [];
    for (const r of n) {
      const a = s[r];
      if (a == null)
        continue;
      const o = () => C_(s, r, r + "", a);
      o && t.push(o);
    }
  }
  return i.reverse().forEach((n) => {
    var r;
    (r = Ch.Map.get(n)) === null || r === void 0 || r.forEach(({ params: a, propKey: o, uiType: l }) => {
      let c;
      if (l || (c = () => C_(s, o)), c || (c = {
        property: [s, o],
        type: l || "input"
        // ...params,
        // ...extraParams,
      }), a) {
        const h = typeof a.params == "function" ? a.params(s) : a.params || {}, u = Object.assign({}, a);
        if (delete u.params, typeof c == "function") {
          const d = c;
          c = () => Object.assign(d(), Object.assign(Object.assign({}, u), h));
        }
        Object.assign(c, Object.assign(Object.assign({}, u), h));
      }
      t.push(c);
    });
  }), t;
}
function ty(s, e, t = {}, i = "folder", n = !1) {
  return Object.assign({ type: i, label: s, children: n ? () => mr(e) : mr(e), uuid: VE() }, t);
}
function P2(s) {
  return s == null ? null : Array.isArray(s) ? "folder" : typeof s == "boolean" ? "checkbox" : typeof s == "number" ? "number" : typeof s == "string" ? "input" : typeof s == "function" ? "button" : typeof s.x == "number" ? "vec" : typeof s.r == "number" ? "color" : s.isTexture ? "image" : typeof s == "object" ? "folder" : null;
}
function L2(s) {
  return (e, t) => {
    const i = e.constructor;
    if (i === Object)
      throw new Error("Not possible to use uiConfig decorator on an object, use class instead");
    Ch.Map.has(i) || Ch.Map.set(i, []), s(e, t, Ch.Map.get(i));
  };
}
function Ki(s, e) {
  return L2((t, i, n) => {
    const r = n.findIndex((a) => a.propKey === i);
    if (r && r < 0)
      n.push({
        params: e || {},
        propKey: i,
        uiType: s
      });
    else
      throw new Error(`Property ${i} already has a uiConfig decorator`);
  });
}
function WE(s, e, t = "panel") {
  return (i) => class extends i {
    constructor() {
      super(...arguments), this.uiConfig = ty(ks(s, this) || "", this, e || {}, t);
    }
  };
}
function Ic(s, e) {
  return Ki("monitor", { label: s, params: e });
}
function Ye(s, e, t, i) {
  return Ki("slider", { label: s, bounds: e, stepSize: t, params: i });
}
function Ji(s, e, t, i) {
  return Ki("vec", { label: s, bounds: e, stepSize: t, params: i });
}
function er(s, e, t) {
  return Array.isArray(e) && typeof e[0] == "string" && (e = e.map((i) => ({ label: i, value: i }))), Ki("dropdown", { label: s, children: e, params: t });
}
function Pt(s, e) {
  return Ki("button", { label: s, params: e });
}
function pt(s, e) {
  return Ki("input", { label: s, params: e });
}
function ii(s, e) {
  return Ki("number", { label: s, params: e });
}
function wr(s, e) {
  return Ki("color", { label: s, params: e });
}
function ta(s, e) {
  return Ki("image", { label: s, params: e });
}
function ue(s, e) {
  return Ki("checkbox", { label: s, params: e });
}
function Tn(s, e) {
  return WE(s, e, "panel");
}
function Lt(s, e) {
  return WE(s, e, "folder");
}
function ha(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(a) {
      a(r);
    });
  }
  return new (t || (t = Promise))(function(r, a) {
    function o(h) {
      try {
        c(i.next(h));
      } catch (u) {
        a(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        a(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(o, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
}
function _a(s) {
  return s === null || typeof s != "object" ? s : Array.isArray(s) ? s.map(_a) : !s._ui_isPrimitive && typeof s.clone == "function" && s._ui_primitiveClone !== !1 ? s.clone() : s;
}
function Gd(s, e) {
  return s === null || typeof s != "object" ? s === e : Array.isArray(s) ? Array.isArray(e) && s.length === e.length && s.every((t, i) => Gd(t, e[i])) : !s._ui_isPrimitive && typeof s.equals == "function" && s._ui_primitiveEquals !== !1 ? !!s.equals(e) : s === e;
}
function fp(s, e) {
  if (e === null || typeof e != "object")
    return e;
  if (Array.isArray(e))
    if (s && Array.isArray(s)) {
      if (s.length < e.length) {
        for (let t = 0; t < s.length; t++)
          s[t] = fp(s[t], e[t]);
        for (let t = s.length; t < e.length; t++)
          s.push(_a(e[t]));
      } else {
        for (let t = 0; t < e.length; t++)
          s[t] = fp(s[t], e[t]);
        s.length = e.length;
      }
      return s;
    } else
      return _a(e);
  else return !e._ui_isPrimitive && typeof e.copy == "function" && e._ui_primitiveCopy !== !1 ? s && typeof s == "object" && !Array.isArray(s) && !s._ui_isPrimitive && typeof s.copy == "function" && s._ui_primitiveCopy !== !1 ? (s.copy(e), s) : _a(e) : e;
}
class U2 {
  constructor(e) {
    this._renderer = e, this.undoEditingWaitTime = 2e3, this.undoPresets = {
      UiConfigMethods_set: (t) => {
        const i = () => {
          var n, r;
          return (r = (n = t.config).uiRefresh) === null || r === void 0 ? void 0 : r.call(n, !1);
        };
        return {
          undo: () => {
            this.setValue(t.config, t.lastVal, t.props, void 0, !1).then(i);
          },
          redo: () => {
            this.setValue(t.config, t.val, t.props, void 0, !1).then(i);
          }
        };
      },
      UiConfigMethods_action: (t) => {
        const i = () => {
          var n, r;
          return (r = (n = t.config).uiRefresh) === null || r === void 0 ? void 0 : r.call(n, !1);
        };
        return {
          undo: () => ha(this, void 0, void 0, function* () {
            yield t.undo.call(t.target, ...t.args), i();
          }),
          redo: () => ha(this, void 0, void 0, function* () {
            yield t.redo.call(t.target, ...t.args), i();
          })
        };
      }
    };
  }
  getBinding(e, t = !0) {
    let i = ks(e.property, e);
    const n = ks(e.path, e);
    if (i === void 0 && Object.hasOwn(e, "value") && (i = [e, "value"]), i === void 0 && t && (i = ks(e.parentProperty, e)), !i || typeof i[0] != "object" || !i[1])
      return [void 0, ""];
    if (typeof i[1] == "string" && n && n.length && (i = [i[0], i[1] + "." + n]), typeof i[1] == "string" && i[1].includes(".")) {
      const r = i[1].split(".");
      let a = i[0];
      const o = r.pop() || "";
      for (const l of r)
        if (a = Array.isArray(a) ? a[parseInt(l)] : a[l], !a)
          return console.warn("Cannot determine property, invalid property path", e, i), [void 0, ""];
      i = [a, o];
    }
    return Array.isArray(i[0]) && typeof i[1] == "string" && (i[1] = parseInt(i[1])), i;
  }
  getRawValue(e) {
    const [t, i] = this.getBinding(e);
    return t ? t[i] : void 0;
  }
  /**
   * Get the value from config
   * @param config
   * @param val - existing value, new value can be copied to this if not equal.
   * @param copyOnEqual - whether the value should be copied to val if equal. Default is true.
   * @returns The value from the binding, cloned or copied if possible. If the value is equal and copyOnEqual is false, then undefined is returned. this can be used to check if the value is changed
   */
  getValue(e, t, i = !0) {
    const [n, r] = this.getBinding(e);
    if (!n)
      return;
    const a = n[r];
    return t !== void 0 && a !== void 0 ? Gd(t, a) && !i ? void 0 : fp(t, a) : _a(a);
  }
  dispatchOnChangeSync(e, t, ...i) {
    var n, r, a;
    const l = [{
      type: "change",
      last: (n = t.last) !== null && n !== void 0 ? n : !0,
      config: (r = t.config) !== null && r !== void 0 ? r : e,
      configPath: [e, ...t.configPath || []],
      target: e,
      value: t.value,
      lastValue: t.lastValue
    }, ...i];
    typeof e.onChange == "function" ? e.onChange(...l) : Array.isArray(e.onChange) ? e.onChange.flat().forEach((c) => typeof c == "function" && (c == null ? void 0 : c(...l))) : e.onChange && console.error("Invalid onChange type, must be a function or array of functions", e.onChange), (a = e.parentOnChange) === null || a === void 0 || a.call(e, ...l);
  }
  recordUndo(e) {
    const t = this._renderer.undoManager;
    if (!t || !t.enabled)
      return;
    const i = e;
    if (i.type !== "UiConfigMethods_set")
      return t.record(e);
    const n = t.peek();
    let r = !!n && n.type === "UiConfigMethods_set" && n.config === i.config;
    if (r) {
      const a = n;
      !a.final && i.time - a.time < this.undoEditingWaitTime ? (i.lastVal = a.lastVal, i.val = _a(i.val), t.replaceLast(i)) : r = !1;
    }
    r || Gd(i.lastVal, i.val) || (i.val = _a(i.val), t.record(i));
  }
  /**
   *
   * @param config
   * @param value
   * @param props - only the prop `last` need to be set, rest are optional. `lastValue` can be set if known (but it should be exactly equal to the value in the binding and not cloned). `config`, `configPath` are for parentOnChange, no need to set that.
   * @param forceOnChange
   * @param trackUndo
   */
  setValue(e, t, i, n) {
    return ha(this, arguments, void 0, function* (r, a, o, l, c = !0) {
      return this.runAtEvent(r, () => {
        var h, u;
        const [d, p] = this.getBinding(r), f = (h = o.lastValue) !== null && h !== void 0 ? h : d == null ? void 0 : d[p];
        let y = !1;
        const A = (u = o.last) !== null && u !== void 0 ? u : !0, m = Gd(f, a), v = _a(f);
        return m ? y = !A : d ? fp(f, a) !== f ? y = !R2(d, p, a, !0, !0) : y = !1 : y = !0, y && !l ? !1 : (c && !y && (A || !m) && this.recordUndo({
          type: "UiConfigMethods_set",
          config: r,
          lastVal: v,
          val: a,
          final: A,
          props: o,
          time: Date.now()
        }), this.dispatchOnChangeSync(r, Object.assign(Object.assign({}, o), { last: A, value: a, lastValue: v })), !0);
      });
    });
  }
  /**
   *
   * @param config
   * @param props - only last needs to be set. check the docs for `setValue`
   */
  dispatchOnChange(e, t) {
    return ha(this, void 0, void 0, function* () {
      return this.runAtEvent(e, () => {
        this.dispatchOnChangeSync(e, t);
      });
    });
  }
  getLabel(e) {
    var t, i;
    return ((t = ks(e.label, e)) !== null && t !== void 0 ? t : (i = this.getBinding(e)) === null || i === void 0 ? void 0 : i[1]) + "";
  }
  getChildren(e) {
    var t;
    return ((t = ks(e.children, e)) !== null && t !== void 0 ? t : []).map((i) => ks(i)).flat(2).filter((i) => i);
  }
  clickButton(e, t) {
    return ha(this, void 0, void 0, function* () {
      return this.runAtEvent(e, () => ha(this, void 0, void 0, function* () {
        var i, n, r, a, o, l;
        const c = this.getBinding(e, !1), h = c[0], u = c[1], d = ks(e.sendArgs, e) === !1 ? [] : (i = t == null ? void 0 : t.args) !== null && i !== void 0 ? i : [], p = [];
        if (h) {
          const f = (n = h[u]) !== null && n !== void 0 ? n : h.value;
          typeof f == "function" ? p.push([f, h]) : f && console.warn("Invalid action type for button", f);
        }
        typeof e.onClick == "function" && p.push([e.onClick, e]);
        for (const [f, y] of p) {
          let A = yield f.call(y, ...d);
          const m = typeof A == "function" ? A : (r = A == null ? void 0 : A.undo) === null || r === void 0 ? void 0 : r.bind(A), v = typeof A != "function" ? (a = A == null ? void 0 : A.action) === null || a === void 0 ? void 0 : a.bind(A) : null, g = typeof A == "function" ? f : (l = (o = A == null ? void 0 : A.redo) === null || o === void 0 ? void 0 : o.bind(A)) !== null && l !== void 0 ? l : v;
          typeof v == "function" && (A = yield v()), typeof m == "function" && this.recordUndo({
            type: "UiConfigMethods_action",
            config: e,
            target: y,
            undo: m,
            redo: g,
            args: d
          });
        }
        yield this.dispatchOnChange(e, {});
      }));
    });
  }
  runAtEvent(e, t) {
    return ha(this, void 0, void 0, function* () {
      var i;
      const n = (i = ks(e.dispatchMode, e)) !== null && i !== void 0 ? i : "postFrame";
      return n === "immediate" ? t() : new Promise((r) => {
        const a = () => ha(this, void 0, void 0, function* () {
          this._renderer.removeEventListener(n, a), r(yield t());
        });
        this._renderer.addEventListener(n, a);
      });
    });
  }
  initUiConfig(e) {
    e && (e.type || (console.warn("No type for config", e), e.type = "input"), e.uuid || (e.uuid = VE()), e.property === void 0 && (e.binding ? e.property = e.binding : e.value === void 0 ? (e.getValue || e.setValue) && (Object.defineProperty(e, "value", {
      get: () => e.getValue && e.getValue(),
      set: (t) => e.setValue && e.setValue(t)
    }), e.property = [e, "value"]) : (e.getValue || e.setValue) && console.warn("getValue/setValue is ignored since value is provided", e), e.property));
  }
  getBounds(e, t = !1) {
    var i, n;
    const r = ks(e.bounds), a = ((i = r == null ? void 0 : r.length) !== null && i !== void 0 ? i : 0) >= 2 ? r[1] : t ? 1 / 0 : 1, o = ((n = r == null ? void 0 : r.length) !== null && n !== void 0 ? n : 0) >= 1 ? r[0] : t ? -1 / 0 : 0, l = ks(e.stepSize) || (t ? 0.01 : Math.pow(10, Math.floor(Math.log10((a - o) / 100))));
    return { min: o, max: a, step: l };
  }
}
class Lz extends S2 {
  get undoManager() {
    return this._undoManager;
  }
  set undoManager(e) {
    this._undoManager = e, this._undoManager && Object.assign(this._undoManager.presets, this.methods.undoPresets);
  }
  constructor(e = !0, t, i) {
    super(), this._rafId = null, this.raf = () => {
      this._autoFrameEvents && (this.dispatchEvent({ type: "preFrame" }), this.dispatchEvent({ type: "preRender" }), this.dispatchEvent({ type: "postRender" }), this.dispatchEvent({ type: "postFrame" }), this._rafId = requestAnimationFrame(this.raf));
    }, this._refreshQueue = {
      preRender: [],
      postRender: [],
      preFrame: [],
      postFrame: []
    }, this._lastModeTime = {
      preRender: 0,
      postRender: 0,
      preFrame: 0,
      postFrame: 0
    }, this.methods = t || new U2(this), this.undoManager = i === !1 ? void 0 : i || new T2({ bindHotKeys: !0, limit: 1e3, debug: B2("debugUndo") !== null }), this._autoFrameEvents = e, e && (this.addEventListener("preFrame", () => this.refreshQueue("preFrame")), this.addEventListener("postFrame", () => this.refreshQueue("postFrame")), this.addEventListener("preRender", () => this.refreshQueue("preRender")), this.addEventListener("postRender", () => this.refreshQueue("postRender")));
  }
  // call from render or onMount
  start() {
    this._rafId === null && (this._rafId = requestAnimationFrame(this.raf));
  }
  // call from unmount or onDispose etc
  stop() {
    this._rafId !== null && (cancelAnimationFrame(this._rafId), this._rafId = null);
  }
  refreshQueue(e) {
    const t = this._refreshQueue[e], i = [], n = M2(), r = n - this._lastModeTime[e];
    t.forEach((a) => {
      a[1] > 1e-3 ? (a[1] -= r, i.push(a)) : this._refreshUiConfigObject(a[0]);
    }), this._refreshQueue[e] = i, this._lastModeTime[e] = n;
  }
  _addToRefreshQueue(e, t, i) {
    const n = t.uuid, r = this._refreshQueue[e], a = r.find((o) => o[2] === n);
    a ? a[1] = Math.max(a[1], i) : r.push([t, i, n]), this._refreshQueue[e] = r;
  }
  /**
   * Disposes the UI associated with a config, doesn't makes change to the object or its parent.
   * @param config
   * @param performDispose
   */
  disposeUiConfig(e, t = !0) {
    var i, n;
    e && (e.uiRef && (t && ((n = (i = e.uiRef).dispose) === null || n === void 0 || n.call(i)), e.uiRef = void 0), e.uiRefType = void 0, e.uiRefresh = void 0);
  }
  addToRefreshQueue(e, t, i, n) {
    const r = i ? this._flattenUiConfig(t) : [t];
    for (const a of r)
      e === "immediate" ? C2(n).then(() => this._refreshUiConfigObject(a)) : this._addToRefreshQueue(e, a, n);
  }
  _flattenUiConfig(e, t) {
    var i;
    return t = t ?? [], !e || !e.uiRef || (t.push(e), typeof e.children == "function") || (i = e.children) === null || i === void 0 || i.forEach((n) => {
      typeof n != "function" && n && (Array.isArray(n) ? n.forEach((r) => t = this._flattenUiConfig(r, t)) : t = this._flattenUiConfig(n, t));
    }), t;
  }
}
const M_ = { type: "change" }, rm = { type: "start" }, T_ = { type: "end" }, yd = new wc(), I_ = new Nr(), F2 = Math.cos(70 * ri.DEG2RAD);
class jE extends Vi {
  constructor(e, t) {
    super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new M(), this.cursor = new M(), this.minDistance = 1e-5, this.maxDistance = 1 / 0, this.autoPushTarget = !0, this.autoPullTarget = !0, this.clampMax = new M(1 / 0, 1 / 0, 1 / 0), this.clampMin = new M(-1 / 0, -1 / 0, -1 / 0), this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.maxZoomSpeed = 1, this.maxZoomSpeed = 1, this.dollyZoom = !1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.throttleUpdate = 0, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: Yo.ROTATE, MIDDLE: Yo.DOLLY, RIGHT: Yo.PAN }, this.touches = { ONE: Ko.ROTATE, TWO: Ko.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
      return o.phi;
    }, this.getAzimuthalAngle = function() {
      return o.theta;
    }, this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    }, this.listenToKeyEvents = function(z) {
      z.addEventListener("keydown", R), this._domElementKeyEvents = z;
    }, this.stopListenToKeyEvents = function() {
      this._domElementKeyEvents.removeEventListener("keydown", R), this._domElementKeyEvents = null;
    }, this.saveState = function() {
      i.target0.copy(i.target), i.position0.copy(i.object.position), i.zoom0 = i.object.zoom;
    }, this.reset = function() {
      i.target.copy(i.target0), i.object.position.copy(i.position0), i.object.zoom = i.zoom0, i.object.updateProjectionMatrix(), i.dispatchEvent(M_), i.update(), r = n.NONE;
    }, this.update = function() {
      const z = new M(), ye = new rt().setFromUnitVectors(e.up, new M(0, 1, 0)), le = ye.clone().invert(), at = new M(), qe = new rt(), je = new M(), Fe = 2 * Math.PI, He = 0;
      return function(q = null) {
        if (this.throttleUpdate && this.throttleUpdate >= 1 && Date.now() - He < 1e3 / this.throttleUpdate)
          return;
        const ke = i.object.position;
        z.copy(ke).sub(i.target), z.applyQuaternion(ye), o.setFromVector3(z), i.autoRotate && r === n.NONE && D(x(q)), i.enableDamping ? (o.theta += l.theta * i.dampingFactor, o.phi += l.phi * i.dampingFactor) : (o.theta += l.theta, o.phi += l.phi);
        let xe = i.minAzimuthAngle, ae = i.maxAzimuthAngle;
        isFinite(xe) && isFinite(ae) && (xe < -Math.PI ? xe += Fe : xe > Math.PI && (xe -= Fe), ae < -Math.PI ? ae += Fe : ae > Math.PI && (ae -= Fe), xe <= ae ? o.theta = Math.max(xe, Math.min(ae, o.theta)) : o.theta = o.theta > (xe + ae) / 2 ? Math.max(xe, o.theta) : Math.min(ae, o.theta)), o.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, o.phi)), o.makeSafe(), i.enableDamping === !0 ? i.target.addScaledVector(h, i.dampingFactor) : i.target.add(h), i.target.sub(i.cursor), i.target.clampLength(i.minTargetRadius, i.maxTargetRadius), i.target.add(i.cursor);
        let De = 0;
        i.zoomToCursor && S || i.object.isOrthographicCamera || (Math.abs(l.radius) > 0 && (i.dollyZoom && (i.object.zoom = Math.max(Math.max(i.minZoom, 0.1), Math.min(Math.min(i.maxZoom, 20), i.object.zoom * (1 + l.radius * (i.enableDamping ? i.dampingFactor : 1)))), i.object.updateProjectionMatrix(), (i.object.zoom >= Math.min(i.maxZoom, 20) || i.object.zoom <= Math.max(i.minZoom, 0.1)) && (l.radius = 0)), o.radius *= 1 + l.radius * (i.enableDamping ? i.dampingFactor : 1)), Math.abs(c - 1) > 1e-5 && (i.dollyZoom && (i.object.zoom = Math.max(Math.max(i.minZoom, 0.1), Math.min(Math.min(i.maxZoom, 20), i.object.zoom * c)), i.object.updateProjectionMatrix(), (i.object.zoom >= Math.min(i.maxZoom, 20) || i.object.zoom <= Math.max(i.minZoom, 0.1)) && (c = 1)), o.radius *= c), i.autoPushTarget && o.radius < i.minDistance && (De = i.minDistance - o.radius), i.autoPullTarget && o.radius > i.maxDistance && (De = i.maxDistance - o.radius)), o.radius = ee(o.radius), z.setFromSpherical(o), z.applyQuaternion(le), ke.copy(i.target).add(z), i.target.add(z.normalize().multiplyScalar(-De)), ke.clamp(i.clampMin, i.clampMax), i.target.clamp(i.clampMin, i.clampMax), i.object.lookAt(i.target);
        let st = !1;
        i.enableDamping === !0 && Math.abs(l.theta) + Math.abs(l.phi) + Math.abs(l.radius) + h.length() > 1e-3 ? (l.theta *= 1 - i.dampingFactor, l.phi *= 1 - i.dampingFactor, l.radius *= 1 - i.dampingFactor, h.multiplyScalar(1 - i.dampingFactor), st = !0) : (l.set(0, 0, 0), h.set(0, 0, 0));
        let Et = !1;
        if (i.zoomToCursor && S) {
          let Kt = null;
          if (i.object.isPerspectiveCamera) {
            const Fi = o.radius;
            Kt = o.radius * c, Kt = ee(Kt);
            const It = Fi - Kt;
            i.object.position.addScaledVector(_, It), i.object.updateMatrixWorld();
          } else if (i.object.isOrthographicCamera) {
            const Fi = new M(w.x, w.y, 0);
            Fi.unproject(i.object), i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / c)), i.object.updateProjectionMatrix(), Et = !0;
            const It = new M(w.x, w.y, 0);
            It.unproject(i.object), i.object.position.sub(It).add(Fi), i.object.updateMatrixWorld(), Kt = o.radius;
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), i.zoomToCursor = !1;
          Kt !== null && (this.screenSpacePanning ? i.target.set(0, 0, -1).transformDirection(i.object.matrix).multiplyScalar(Kt).add(i.object.position) : (yd.origin.copy(i.object.position), yd.direction.set(0, 0, -1).transformDirection(i.object.matrix), Math.abs(i.object.up.dot(yd.direction)) < F2 ? e.lookAt(i.target) : (I_.setFromNormalAndCoplanarPoint(i.object.up, i.target), yd.intersectPlane(I_, i.target))));
        } else i.object.isOrthographicCamera && (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / c)), i.object.updateProjectionMatrix(), Et = !0);
        return c = 1, S = !1, Et || st || at.distanceToSquared(i.object.position) > a || 8 * (1 - qe.dot(i.object.quaternion)) > a || je.distanceToSquared(i.target) > 0 ? (i.dispatchEvent(M_), at.copy(i.object.position), qe.copy(i.object.quaternion), je.copy(i.target), Et = !1, !0) : !1;
      };
    }(), this.stopDamping = function() {
      l.set(0, 0, 0), h.set(0, 0, 0);
    }, this.dispose = function() {
      i.domElement.removeEventListener("contextmenu", Ae), i.domElement.removeEventListener("pointerdown", Ne), i.domElement.removeEventListener("pointercancel", nt), i.domElement.removeEventListener("wheel", F), i.domElement.removeEventListener("pointermove", Ge), i.domElement.removeEventListener("pointerup", nt), i._domElementKeyEvents !== null && (i._domElementKeyEvents.removeEventListener("keydown", R), i._domElementKeyEvents = null);
    };
    const i = this, n = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let r = n.NONE;
    const a = 1e-6, o = new sc(), l = new sc(0, 0, 0);
    let c = 1;
    const h = new M(), u = new ie(), d = new ie(), p = new ie(), f = new ie(), y = new ie(), A = new ie(), m = new ie(), v = new ie(), g = new ie(), _ = new M(), w = new ie();
    let S = !1;
    const C = [], E = {};
    function x(z) {
      return z !== null ? 2 * Math.PI / 60 * i.autoRotateSpeed * z : 2 * Math.PI / 60 / 60 * i.autoRotateSpeed;
    }
    function b() {
      return i.enableDamping && !i.zoomToCursor && !i.object.isOrthographicCamera ? 1 : Math.pow(0.95, i.zoomSpeed);
    }
    function D(z) {
      l.theta -= z;
    }
    function O(z) {
      l.phi -= z;
    }
    this.rotateUp = O, this.rotateLeft = D;
    const Y = function() {
      const z = new M();
      return function(le, at) {
        z.setFromMatrixColumn(at, 0), z.multiplyScalar(-le), h.add(z);
      };
    }(), B = function() {
      const z = new M();
      return function(le, at) {
        i.screenSpacePanning === !0 ? z.setFromMatrixColumn(at, 1) : (z.setFromMatrixColumn(at, 0), z.crossVectors(i.object.up, z)), z.multiplyScalar(le), h.add(z);
      };
    }(), Q = function() {
      const z = new M();
      return function(le, at) {
        const qe = i.domElement;
        if (i.object.isPerspectiveCamera) {
          const je = i.object.position;
          z.copy(je).sub(i.target);
          let Fe = z.length();
          Fe *= Math.tan(i.object.fov / 2 * Math.PI / 180), Y(2 * le * Fe / qe.clientHeight, i.object.matrix), B(2 * at * Fe / qe.clientHeight, i.object.matrix);
        } else i.object.isOrthographicCamera ? (Y(le * (i.object.right - i.object.left) / i.object.zoom / qe.clientWidth, i.object.matrix), B(at * (i.object.top - i.object.bottom) / i.object.zoom / qe.clientHeight, i.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), i.enablePan = !1);
      };
    }();
    function j(z, ye = 0) {
      i.object.isPerspectiveCamera || i.object.isOrthographicCamera ? (c /= z, l.radius = Math.max(-i.maxZoomSpeed, Math.min(i.maxZoomSpeed, l.radius - ye))) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1);
    }
    function X(z, ye = 0) {
      i.object.isPerspectiveCamera || i.object.isOrthographicCamera ? (c *= z, l.radius = Math.max(-i.maxZoomSpeed, Math.min(i.maxZoomSpeed, l.radius + ye))) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1);
    }
    this.zoomIn = function(z) {
      j(1, z * i.zoomSpeed);
    }, this.zoomOut = function(z) {
      X(1, z * i.zoomSpeed);
    };
    function Z(z) {
      if (!i.zoomToCursor)
        return;
      S = !0;
      const ye = i.domElement.getBoundingClientRect(), le = z.clientX - ye.left, at = z.clientY - ye.top, qe = ye.width, je = ye.height;
      w.x = le / qe * 2 - 1, w.y = -(at / je) * 2 + 1, _.set(w.x, w.y, 1).unproject(i.object).sub(i.object.position).normalize();
    }
    function ee(z) {
      return Math.max(i.minDistance, Math.min(i.maxDistance, z));
    }
    function J(z) {
      u.set(z.clientX, z.clientY);
    }
    function W(z) {
      Z(z), m.set(z.clientX, z.clientY);
    }
    function K(z) {
      f.set(z.clientX, z.clientY);
    }
    function ce(z) {
      d.set(z.clientX, z.clientY), p.subVectors(d, u).multiplyScalar(i.rotateSpeed);
      const ye = i.domElement;
      D(2 * Math.PI * p.x / ye.clientHeight), O(2 * Math.PI * p.y / ye.clientHeight), u.copy(d), i.update();
    }
    function fe(z) {
      v.set(z.clientX, z.clientY), g.subVectors(v, m), g.y > 0 ? j(b()) : g.y < 0 && X(b()), m.copy(v), i.update();
    }
    function ve(z) {
      y.set(z.clientX, z.clientY), A.subVectors(y, f).multiplyScalar(i.panSpeed), Q(A.x, A.y), f.copy(y), i.update();
    }
    function _e(z) {
      Z(z);
      let ye = 0;
      switch (z.deltaMode) {
        case 2:
          ye += z.deltaY * 1;
          break;
        case 1:
          ye += z.deltaY * 0.4;
          break;
        default:
          ye += z.deltaY * 0.01;
          break;
      }
      z.deltaY < 0 ? i.zoomToCursor || i.object.isOrthographicCamera ? X(b()) : X(1, ye * i.zoomSpeed) : z.deltaY > 0 && (i.zoomToCursor || i.object.isOrthographicCamera ? j(b()) : j(1, -ye * i.zoomSpeed)), i.update();
    }
    function ze(z) {
      let ye = !1;
      switch (z.code) {
        case i.keys.UP:
          z.ctrlKey || z.metaKey || z.shiftKey ? O(2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : Q(0, i.keyPanSpeed), ye = !0;
          break;
        case i.keys.BOTTOM:
          z.ctrlKey || z.metaKey || z.shiftKey ? O(-2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : Q(0, -i.keyPanSpeed), ye = !0;
          break;
        case i.keys.LEFT:
          z.ctrlKey || z.metaKey || z.shiftKey ? D(2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : Q(i.keyPanSpeed, 0), ye = !0;
          break;
        case i.keys.RIGHT:
          z.ctrlKey || z.metaKey || z.shiftKey ? D(-2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : Q(-i.keyPanSpeed, 0), ye = !0;
          break;
      }
      ye && (z.preventDefault(), i.update());
    }
    function Qe() {
      if (C.length === 1)
        u.set(C[0].pageX, C[0].pageY);
      else {
        const z = 0.5 * (C[0].pageX + C[1].pageX), ye = 0.5 * (C[0].pageY + C[1].pageY);
        u.set(z, ye);
      }
    }
    function ot() {
      if (C.length === 1)
        f.set(C[0].pageX, C[0].pageY);
      else {
        const z = 0.5 * (C[0].pageX + C[1].pageX), ye = 0.5 * (C[0].pageY + C[1].pageY);
        f.set(z, ye);
      }
    }
    function ht() {
      const z = C[0].pageX - C[1].pageX, ye = C[0].pageY - C[1].pageY, le = Math.sqrt(z * z + ye * ye);
      m.set(0, le);
    }
    function Xe() {
      i.enableZoom && ht(), i.enablePan && ot();
    }
    function G() {
      i.enableZoom && ht(), i.enableRotate && Qe();
    }
    function Be(z) {
      if (C.length == 1)
        d.set(z.pageX, z.pageY);
      else {
        const le = Le(z), at = 0.5 * (z.pageX + le.x), qe = 0.5 * (z.pageY + le.y);
        d.set(at, qe);
      }
      p.subVectors(d, u).multiplyScalar(i.rotateSpeed);
      const ye = i.domElement;
      D(2 * Math.PI * p.x / ye.clientHeight), O(2 * Math.PI * p.y / ye.clientHeight), u.copy(d);
    }
    function oe(z) {
      if (C.length === 1)
        y.set(z.pageX, z.pageY);
      else {
        const ye = Le(z), le = 0.5 * (z.pageX + ye.x), at = 0.5 * (z.pageY + ye.y);
        y.set(le, at);
      }
      A.subVectors(y, f).multiplyScalar(i.panSpeed), Q(A.x, A.y), f.copy(y);
    }
    function Ee(z) {
      const ye = Le(z), le = z.pageX - ye.x, at = z.pageY - ye.y, qe = Math.sqrt(le * le + at * at);
      v.set(0, qe), g.set(0, Math.pow(v.y / m.y, i.zoomSpeed * 6)), j(g.y), m.copy(v);
    }
    function de(z) {
      i.enableZoom && Ee(z), i.enablePan && oe(z);
    }
    function Ke(z) {
      i.enableZoom && Ee(z), i.enableRotate && Be(z);
    }
    function Ne(z) {
      i.enabled !== !1 && (C.length === 0 && (i.domElement.setPointerCapture(z.pointerId), i.domElement.addEventListener("pointermove", Ge), i.domElement.addEventListener("pointerup", nt)), Ce(z), z.pointerType === "touch" ? te(z) : wt(z));
    }
    function Ge(z) {
      i.enabled !== !1 && (z.pointerType === "touch" ? we(z) : z.buttons ? di(z) : nt(z));
    }
    function nt(z) {
      We(z), C.length === 0 && (i.domElement.releasePointerCapture(z.pointerId), i.domElement.removeEventListener("pointermove", Ge), i.domElement.removeEventListener("pointerup", nt)), i.dispatchEvent(T_), r = n.NONE;
    }
    function wt(z) {
      let ye;
      switch (z.button) {
        case 0:
          ye = i.mouseButtons.LEFT;
          break;
        case 1:
          ye = i.mouseButtons.MIDDLE;
          break;
        case 2:
          ye = i.mouseButtons.RIGHT;
          break;
        default:
          ye = -1;
      }
      switch (ye) {
        case Yo.DOLLY:
          if (i.enableZoom === !1) return;
          W(z), r = n.DOLLY;
          break;
        case Yo.ROTATE:
          if (z.ctrlKey || z.metaKey || z.shiftKey) {
            if (i.enablePan === !1) return;
            K(z), r = n.PAN;
          } else {
            if (i.enableRotate === !1) return;
            J(z), r = n.ROTATE;
          }
          break;
        case Yo.PAN:
          if (z.ctrlKey || z.metaKey || z.shiftKey) {
            if (i.enableRotate === !1) return;
            J(z), r = n.ROTATE;
          } else {
            if (i.enablePan === !1) return;
            K(z), r = n.PAN;
          }
          break;
        default:
          r = n.NONE;
      }
      r !== n.NONE && i.dispatchEvent(rm);
    }
    function di(z) {
      switch (r) {
        case n.ROTATE:
          if (i.enableRotate === !1) return;
          ce(z);
          break;
        case n.DOLLY:
          if (i.enableZoom === !1) return;
          fe(z);
          break;
        case n.PAN:
          if (i.enablePan === !1) return;
          ve(z);
          break;
      }
    }
    function F(z) {
      i.enabled === !1 || i.enableZoom === !1 || r !== n.NONE || (z.preventDefault(), i.dispatchEvent(rm), _e(z), i.dispatchEvent(T_));
    }
    function R(z) {
      i.enabled === !1 || i.enablePan === !1 || ze(z);
    }
    function te(z) {
      switch (Me(z), C.length) {
        case 1:
          switch (i.touches.ONE) {
            case Ko.ROTATE:
              if (i.enableRotate === !1) return;
              Qe(), r = n.TOUCH_ROTATE;
              break;
            case Ko.PAN:
              if (i.enablePan === !1) return;
              ot(), r = n.TOUCH_PAN;
              break;
            default:
              r = n.NONE;
          }
          break;
        case 2:
          switch (i.touches.TWO) {
            case Ko.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1) return;
              Xe(), r = n.TOUCH_DOLLY_PAN;
              break;
            case Ko.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1) return;
              G(), r = n.TOUCH_DOLLY_ROTATE;
              break;
            default:
              r = n.NONE;
          }
          break;
        default:
          r = n.NONE;
      }
      r !== n.NONE && i.dispatchEvent(rm);
    }
    function we(z) {
      switch (Me(z), r) {
        case n.TOUCH_ROTATE:
          if (i.enableRotate === !1) return;
          Be(z), i.update();
          break;
        case n.TOUCH_PAN:
          if (i.enablePan === !1) return;
          oe(z), i.update();
          break;
        case n.TOUCH_DOLLY_PAN:
          if (i.enableZoom === !1 && i.enablePan === !1) return;
          de(z), i.update();
          break;
        case n.TOUCH_DOLLY_ROTATE:
          if (i.enableZoom === !1 && i.enableRotate === !1) return;
          Ke(z), i.update();
          break;
        default:
          r = n.NONE;
      }
    }
    function Ae(z) {
      i.enabled !== !1 && z.preventDefault();
    }
    function Ce(z) {
      C.push(z);
    }
    function We(z) {
      delete E[z.pointerId];
      for (let ye = 0; ye < C.length; ye++)
        if (C[ye].pointerId == z.pointerId) {
          C.splice(ye, 1);
          return;
        }
    }
    function Me(z) {
      let ye = E[z.pointerId];
      ye === void 0 && (ye = new ie(), E[z.pointerId] = ye), ye.set(z.pageX, z.pageY);
    }
    function Le(z) {
      const ye = z.pointerId === C[0].pointerId ? C[1] : C[0];
      return E[ye.pointerId];
    }
    i.domElement.addEventListener("contextmenu", Ae), i.domElement.addEventListener("pointerdown", Ne), i.domElement.addEventListener("pointercancel", nt), i.domElement.addEventListener("wheel", F, { passive: !1 }), this.update();
  }
}
var O2 = Object.defineProperty, N2 = Object.getOwnPropertyDescriptor, ni = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? N2(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && O2(e, t, n), n;
};
let jt = class extends jE {
  constructor() {
    super(...arguments), this.type = "OrbitControls", this.enabled = !0, this.dollyZoom = !1, this.zoomToCursor = !1, this.enableDamping = !0, this.dampingFactor = 0.08, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableZoom = !0, this.zoomSpeed = 0.15, this.maxZoomSpeed = 0.2, this.enableRotate = !0, this.rotateSpeed = 2, this.enablePan = !0, this.panSpeed = 1, this.autoPushTarget = !1, this.autoPullTarget = !1, this.minDistance = 0.35, this.maxDistance = 1e6, this.minZoom = 0.01, this.maxZoom = 1e6, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1e6, this.maxAzimuthAngle = 1e6, this.clampMin = new M(-1e6, -1e6, -1e6), this.clampMax = new M(1e6, 1e6, 1e6), this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.throttleUpdate = 60;
  }
};
ni([
  V()
], jt.prototype, "type", 2);
ni([
  ue()
], jt.prototype, "enabled", 2);
ni([
  ue(),
  V()
], jt.prototype, "dollyZoom", 2);
ni([
  ue(),
  V()
], jt.prototype, "zoomToCursor", 2);
ni([
  ue(),
  V()
], jt.prototype, "enableDamping", 2);
ni([
  pt(),
  V()
], jt.prototype, "dampingFactor", 2);
ni([
  ue(),
  V()
], jt.prototype, "autoRotate", 2);
ni([
  pt(),
  V()
], jt.prototype, "autoRotateSpeed", 2);
ni([
  ue(),
  V()
], jt.prototype, "enableZoom", 2);
ni([
  pt(),
  V()
], jt.prototype, "zoomSpeed", 2);
ni([
  pt(),
  V()
], jt.prototype, "maxZoomSpeed", 2);
ni([
  ue(),
  V()
], jt.prototype, "enableRotate", 2);
ni([
  pt(),
  V()
], jt.prototype, "rotateSpeed", 2);
ni([
  ue(),
  V()
], jt.prototype, "enablePan", 2);
ni([
  pt(),
  V()
], jt.prototype, "panSpeed", 2);
ni([
  pt(),
  V()
], jt.prototype, "autoPushTarget", 2);
ni([
  pt(),
  V()
], jt.prototype, "autoPullTarget", 2);
ni([
  pt(),
  V()
], jt.prototype, "minDistance", 2);
ni([
  pt(),
  V()
], jt.prototype, "maxDistance", 2);
ni([
  pt(),
  V()
], jt.prototype, "minZoom", 2);
ni([
  pt(),
  V()
], jt.prototype, "maxZoom", 2);
ni([
  pt(),
  V()
], jt.prototype, "minPolarAngle", 2);
ni([
  pt(),
  V()
], jt.prototype, "maxPolarAngle", 2);
ni([
  pt(),
  V()
], jt.prototype, "minAzimuthAngle", 2);
ni([
  pt(),
  V()
], jt.prototype, "maxAzimuthAngle", 2);
ni([
  Ji(),
  V()
], jt.prototype, "clampMin", 2);
ni([
  Ji(),
  V()
], jt.prototype, "clampMax", 2);
ni([
  V()
], jt.prototype, "screenSpacePanning", 2);
ni([
  V()
], jt.prototype, "keyPanSpeed", 2);
jt = ni([
  Tn("Orbit Controls")
], jt);
const $a = new QA(), bn = new M(), ua = new M(), _i = new rt(), D_ = {
  X: new M(1, 0, 0),
  Y: new M(0, 1, 0),
  Z: new M(0, 0, 1)
}, am = { type: "change" }, R_ = { type: "mouseDown" }, B_ = { type: "mouseUp", mode: null }, P_ = { type: "objectChange" };
class Eo extends ut {
  constructor(e, t) {
    super(), t === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none";
    const i = new V2();
    this._gizmo = i, this.add(i);
    const n = new W2();
    this._plane = n, this.add(n);
    const r = this;
    function a(v, g) {
      let _ = g;
      Object.defineProperty(r, v, {
        get: function() {
          return _ !== void 0 ? _ : g;
        },
        set: function(w) {
          _ !== w && (_ = w, n[v] = w, i[v] = w, r.dispatchEvent({ type: v + "-changed", value: w }), r.dispatchEvent(am));
        }
      }), r[v] = g, n[v] = g, i[v] = g;
    }
    a("camera", e), a("object", void 0), a("enabled", !0), a("axis", null), a("mode", "translate"), a("translationSnap", null), a("rotationSnap", null), a("scaleSnap", null), a("space", "world"), a("size", 1), a("dragging", !1), a("showX", !0), a("showY", !0), a("showZ", !0);
    const o = new M(), l = new M(), c = new rt(), h = new rt(), u = new M(), d = new rt(), p = new M(), f = new M(), y = new M(), A = 0, m = new M();
    a("worldPosition", o), a("worldPositionStart", l), a("worldQuaternion", c), a("worldQuaternionStart", h), a("cameraPosition", u), a("cameraQuaternion", d), a("pointStart", p), a("pointEnd", f), a("rotationAxis", y), a("rotationAngle", A), a("eye", m), this._offset = new M(), this._startNorm = new M(), this._endNorm = new M(), this._cameraScale = new M(), this._parentPosition = new M(), this._parentQuaternion = new rt(), this._parentQuaternionInv = new rt(), this._parentScale = new M(), this._worldScaleStart = new M(), this._worldQuaternionInv = new rt(), this._worldScale = new M(), this._positionStart = new M(), this._quaternionStart = new rt(), this._scaleStart = new M(), this._getPointer = k2.bind(this), this._onPointerDown = z2.bind(this), this._onPointerHover = G2.bind(this), this._onPointerMove = Q2.bind(this), this._onPointerUp = H2.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0 || e.buttons) return;
    $a.setFromCamera(e, this.camera);
    const t = om(this._gizmo.picker[this.mode], $a);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e.button !== 0) && this.axis !== null) {
      $a.setFromCamera(e, this.camera);
      const t = om(this._plane, $a, !0);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, R_.mode = this.mode, this.dispatchEvent(R_);
    }
  }
  pointerMove(e) {
    const t = this.axis, i = this.mode, n = this.object;
    let r = this.space;
    if (i === "scale" ? r = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (r = "world"), n === void 0 || t === null || this.dragging === !1 || e.button !== -1) return;
    $a.setFromCamera(e, this.camera);
    const a = om(this._plane, $a, !0);
    if (a) {
      if (this.pointEnd.copy(a.point).sub(this.worldPositionStart), i === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), r === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), r === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), n.position.copy(this._offset).add(this._positionStart), this.translationSnap && (r === "local" && (n.position.applyQuaternion(_i.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (n.position.x = Math.round(n.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (n.position.y = Math.round(n.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (n.position.z = Math.round(n.position.z / this.translationSnap) * this.translationSnap), n.position.applyQuaternion(this._quaternionStart)), r === "world" && (n.parent && n.position.add(bn.setFromMatrixPosition(n.parent.matrixWorld)), t.search("X") !== -1 && (n.position.x = Math.round(n.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (n.position.y = Math.round(n.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (n.position.z = Math.round(n.position.z / this.translationSnap) * this.translationSnap), n.parent && n.position.sub(bn.setFromMatrixPosition(n.parent.matrixWorld))));
      else if (i === "scale") {
        if (t.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), ua.set(o, o, o);
        } else
          bn.copy(this.pointStart), ua.copy(this.pointEnd), bn.applyQuaternion(this._worldQuaternionInv), ua.applyQuaternion(this._worldQuaternionInv), ua.divide(bn), t.search("X") === -1 && (ua.x = 1), t.search("Y") === -1 && (ua.y = 1), t.search("Z") === -1 && (ua.z = 1);
        n.scale.copy(this._scaleStart).multiply(ua), this.scaleSnap && (t.search("X") !== -1 && (n.scale.x = Math.round(n.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (n.scale.y = Math.round(n.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (n.scale.z = Math.round(n.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (i === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const o = 20 / this.worldPosition.distanceTo(bn.setFromMatrixPosition(this.camera.matrixWorld));
        let l = !1;
        t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(bn.copy(this.rotationAxis).cross(this.eye)) * o) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(D_[t]), bn.copy(D_[t]), r === "local" && bn.applyQuaternion(this.worldQuaternion), bn.cross(this.eye), bn.length() === 0 ? l = !0 : this.rotationAngle = this._offset.dot(bn.normalize()) * o), (t === "E" || l) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), r === "local" && t !== "E" && t !== "XYZE" ? (n.quaternion.copy(this._quaternionStart), n.quaternion.multiply(_i.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), n.quaternion.copy(_i.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), n.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(am), this.dispatchEvent(P_);
    }
  }
  pointerUp(e) {
    e.button === 0 && (this.dragging && this.axis !== null && (B_.mode = this.mode, this.dispatchEvent(B_)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
  // Set current object
  attach(e) {
    return this.object = e, this.visible = !0, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.visible = !1, this.axis = null, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(am), this.dispatchEvent(P_), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return $a;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
Eo.ObjectConstructors = {
  MeshBasicMaterial: $s,
  LineBasicMaterial: Ri
};
function k2(s) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: s.button,
      buttons: s.buttons
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (s.clientX - e.left) / e.width * 2 - 1,
      y: -(s.clientY - e.top) / e.height * 2 + 1,
      button: s.button,
      buttons: s.buttons
    };
  }
}
function G2(s) {
  if (this.enabled)
    switch (s.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(s));
        break;
    }
}
function z2(s) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(s)), this.pointerDown(this._getPointer(s)));
}
function Q2(s) {
  this.enabled && this.pointerMove(this._getPointer(s));
}
function H2(s) {
  this.enabled && (this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(s)));
}
function om(s, e, t) {
  const i = e.intersectObject(s, !0);
  for (let n = 0; n < i.length; n++)
    if (i[n].object.visible || t)
      return i[n];
  return !1;
}
const vd = new xi(), hi = new M(0, 1, 0), L_ = new M(0, 0, 0), U_ = new Ue(), _d = new rt(), zd = new rt(), rr = new M(), F_ = new Ue(), mh = new M(1, 0, 0), no = new M(0, 1, 0), gh = new M(0, 0, 1), xd = new M(), rh = new M(), ah = new M();
class V2 extends ut {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new Eo.ObjectConstructors.MeshBasicMaterial({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), t = new Eo.ObjectConstructors.LineBasicMaterial({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), i = e.clone();
    i.opacity = 0.15;
    const n = t.clone();
    n.opacity = 1;
    const r = e.clone();
    r.color.setHex(15663205), r.opacity = 0.95;
    const a = e.clone();
    a.color.setHex(2014720), a.opacity = 0.95;
    const o = e.clone();
    o.color.setHex(37885), o.opacity = 0.95;
    const l = e.clone();
    l.color.setHex(16618689), l.__color = r.color.getHex();
    const c = e.clone();
    c.color.setHex(12516474), c.__color = a.color.getHex();
    const h = e.clone();
    h.color.setHex(11397372), h.__color = o.color.getHex();
    const u = e.clone();
    u.color.setHex(15663205), u.opacity = 0.75;
    const d = e.clone();
    d.color.setHex(2014720), d.opacity = 0.75;
    const p = e.clone();
    p.color.setHex(37885), p.opacity = 0.75;
    const f = e.clone();
    f.color.setHex(12893629), f.opacity = 0.75;
    const y = e.clone();
    y.color.setHex(16777051), y.opacity = 0.25;
    const A = e.clone();
    A.color.setHex(7895160), A.opacity = 0.75;
    const m = new yn(0, 0.04, 0.1, 12);
    m.translate(0, 0.05, 0);
    const v = new Si(0.08, 0.08, 0.08);
    v.translate(0, 0.04, 0);
    const g = new Ze();
    g.setAttribute("position", new Te([0, 0, 0, 1, 0, 0], 3));
    const _ = new yn(75e-4, 75e-4, 0.5, 3);
    _.translate(0, 0.25, 0);
    function w(Z, ee) {
      const J = new kh(Z, 75e-4, 3, 64, ee * Math.PI * 2);
      return J.rotateY(Math.PI / 2), J.rotateX(Math.PI / 2), J;
    }
    function S(Z, ee) {
      const J = new kh(Z, 0.1, 4, 24, ee * Math.PI * 2);
      return J.rotateY(Math.PI / 2), J.rotateX(Math.PI / 2), J;
    }
    function C() {
      const Z = new Ze();
      return Z.setAttribute("position", new Te([0, 0, 0, 1, 1, 1], 3)), Z;
    }
    const E = {
      X: [
        [new Se(m, l), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        // [ new Mesh( arrowGeometry, matRed2 ), [ - 0.5, 0, 0 ], [ 0, 0, Math.PI / 2 ]],
        [new Se(_, r), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Se(m, c), [0, 0.5, 0]],
        // [ new Mesh( arrowGeometry, matGreen2 ), [ 0, - 0.5, 0 ], [ Math.PI, 0, 0 ]],
        [new Se(_, a)]
      ],
      Z: [
        [new Se(m, h), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        // [ new Mesh( arrowGeometry, matBlue2 ), [ 0, 0, - 0.5 ], [ - Math.PI / 2, 0, 0 ]],
        [new Se(_, o), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Se(new ya(0.1, 2), f.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Se(new Si(0.2, 0.2, 0.01), p.clone()), [0.2, 0.2, 0]]
      ],
      YZ: [
        [new Se(new Si(0.2, 0.2, 0.01), u.clone()), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Se(new Si(0.2, 0.2, 0.01), d.clone()), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]
      ]
    }, x = {
      X: [
        [new Se(new yn(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]]
        // [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ - 0.3, 0, 0 ], [ 0, 0, Math.PI / 2 ]]
      ],
      Y: [
        [new Se(new yn(0.2, 0, 0.6, 4), i), [0, 0.3, 0]]
        // [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, - 0.3, 0 ], [ 0, 0, Math.PI ]]
      ],
      Z: [
        [new Se(new yn(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]]
        // [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, - 0.3 ], [ - Math.PI / 2, 0, 0 ]]
      ],
      XYZ: [
        [new Se(new ya(0.2, 0), i)]
      ],
      XY: [
        [new Se(new Si(0.25, 0.25, 0.01), i), [0.2, 0.2, 0]]
      ],
      YZ: [
        [new Se(new Si(0.25, 0.25, 0.01), i), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Se(new Si(0.25, 0.25, 0.01), i), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]
      ]
    }, b = {
      START: [
        [new Se(new ya(0.01, 2), n), null, null, null, "helper"]
      ],
      END: [
        [new Se(new ya(0.01, 2), n), null, null, null, "helper"]
      ],
      DELTA: [
        [new an(C(), n), null, null, null, "helper"]
      ],
      X: [
        [new an(g, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new an(g, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new an(g, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, D = {
      XYZE: [
        [new Se(new fr(0.1, 10, 8), f)],
        [new Se(w(0.5, 1), A), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Se(w(0.5, 0.5), r)],
        [new Se(_, r), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Se(m.clone().translate(0.5, 0, 0), l), [0, 0, 0], [-Math.PI / 2, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Se(w(0.5, 0.5), a), null, [0, 0, -Math.PI / 2]],
        [new Se(_, a)],
        [new Se(m.clone().rotateZ(-Math.PI / 2).translate(0, 0.5, 0), c), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Se(w(0.5, 0.5), o), null, [0, Math.PI / 2, 0]],
        [new Se(_, o), null, [Math.PI / 2, 0, 0]],
        [new Se(m.clone().rotateZ(-Math.PI).translate(0, 0, 0.5), h), [0, 0, 0], [0, Math.PI / 2, 0]]
      ]
      // E: [
      //     [ new Mesh( CircleGeometry( 0.75, 1 ), matYellowTransparent ), null, [ 0, Math.PI / 2, 0 ]]
      // ]
    }, O = {
      AXIS: [
        [new an(g, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, Y = {
      XYZE: [
        [new Se(new fr(0.25, 10, 8), i)]
      ],
      X: [
        [new Se(S(0.5, 0.5), i)]
      ],
      Y: [
        [new Se(S(0.5, 0.5), i), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Se(S(0.5, 0.5), i), [0, 0, 0], [0, Math.PI / 2, 0]]
      ]
      // E: [
      //     [ new Mesh( new TorusGeometry( 0.75, 0.1, 2, 24 ), matInvisible ) ]
      // ]
    }, B = {
      X: [
        [new Se(v, l), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Se(_, r), [0, 0, 0], [0, 0, -Math.PI / 2]]
        // [ new Mesh( scaleHandleGeometry, matRed ), [ - 0.5, 0, 0 ], [ 0, 0, Math.PI / 2 ]],
      ],
      Y: [
        [new Se(v, c), [0, 0.5, 0]],
        [new Se(_, a)]
        // [ new Mesh( scaleHandleGeometry, matGreen ), [ 0, - 0.5, 0 ], [ 0, 0, Math.PI ]],
      ],
      Z: [
        [new Se(v, h), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Se(_, o), [0, 0, 0], [Math.PI / 2, 0, 0]]
        // [ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, - 0.5 ], [ - Math.PI / 2, 0, 0 ]]
      ],
      XY: [
        [new Se(new Si(0.15, 0.15, 0.01), p), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Se(new Si(0.15, 0.15, 0.01), u), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Se(new Si(0.15, 0.15, 0.01), d), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Se(new Si(0.1, 0.1, 0.1), f.clone())]
      ]
    }, Q = {
      X: [
        [new Se(new yn(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Se(new yn(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Se(new yn(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new Se(new yn(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Se(new yn(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Se(new yn(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Se(new Si(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Se(new Si(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Se(new Si(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Se(new Si(0.2, 0.2, 0.2), i), [0, 0, 0]]
      ]
    }, j = {
      X: [
        [new an(g, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new an(g, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new an(g, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function X(Z) {
      const ee = new ut();
      for (const J in Z)
        for (let W = Z[J].length; W--; ) {
          const K = Z[J][W][0].clone(), ce = Z[J][W][1], fe = Z[J][W][2], ve = Z[J][W][3], _e = Z[J][W][4];
          K.name = J, K.tag = _e, ce && K.position.set(ce[0], ce[1], ce[2]), fe && K.rotation.set(fe[0], fe[1], fe[2]), ve && K.scale.set(ve[0], ve[1], ve[2]), K.updateMatrix();
          const ze = K.geometry.clone();
          ze.applyMatrix4(K.matrix), K.geometry = ze, K.renderOrder = 1 / 0, K.position.set(0, 0, 0), K.rotation.set(0, 0, 0), K.scale.set(1, 1, 1), ee.add(K);
        }
      return ee;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = X(E)), this.add(this.gizmo.rotate = X(D)), this.add(this.gizmo.scale = X(B)), this.add(this.picker.translate = X(x)), this.add(this.picker.rotate = X(Y)), this.add(this.picker.scale = X(Q)), this.add(this.helper.translate = X(b)), this.add(this.helper.rotate = X(O)), this.add(this.helper.scale = X(j)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const i = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : zd;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let n = [];
    n = n.concat(this.picker[this.mode].children), n = n.concat(this.gizmo[this.mode].children), n = n.concat(this.helper[this.mode].children);
    for (let r = 0; r < n.length; r++) {
      const a = n[r];
      a.visible = !0, a.rotation.set(0, 0, 0), a.position.copy(this.worldPosition);
      let o;
      if (this.camera.isOrthographicCamera ? o = (this.camera.top - this.camera.bottom) / this.camera.zoom : o = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), a.scale.set(1, 1, 1).multiplyScalar(o * this.size / 4), a.tag === "helper") {
        a.visible = !1, a.name === "AXIS" ? (a.visible = !!this.axis, this.axis === "X" && (_i.setFromEuler(vd.set(0, 0, 0)), a.quaternion.copy(i).multiply(_i), Math.abs(hi.copy(mh).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Y" && (_i.setFromEuler(vd.set(0, 0, Math.PI / 2)), a.quaternion.copy(i).multiply(_i), Math.abs(hi.copy(no).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Z" && (_i.setFromEuler(vd.set(0, Math.PI / 2, 0)), a.quaternion.copy(i).multiply(_i), Math.abs(hi.copy(gh).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "XYZE" && (_i.setFromEuler(vd.set(0, Math.PI / 2, 0)), hi.copy(this.rotationAxis), a.quaternion.setFromRotationMatrix(U_.lookAt(L_, hi, no)), a.quaternion.multiply(_i), a.visible = this.dragging), this.axis === "E" && (a.visible = !1)) : a.name === "START" ? (a.position.copy(this.worldPositionStart), a.visible = this.dragging) : a.name === "END" ? (a.position.copy(this.worldPosition), a.visible = this.dragging) : a.name === "DELTA" ? (a.position.copy(this.worldPositionStart), a.quaternion.copy(this.worldQuaternionStart), bn.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), bn.applyQuaternion(this.worldQuaternionStart.clone().invert()), a.scale.copy(bn), a.visible = this.dragging) : (a.quaternion.copy(i), this.dragging ? a.position.copy(this.worldPositionStart) : a.position.copy(this.worldPosition), this.axis && (a.visible = this.axis.search(a.name) !== -1));
        continue;
      }
      a.quaternion.copy(i), this.mode === "translate" || this.mode === "scale" ? (a.name === "X" && Math.abs(hi.copy(mh).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Y" && Math.abs(hi.copy(no).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Z" && Math.abs(hi.copy(gh).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XY" && Math.abs(hi.copy(gh).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "YZ" && Math.abs(hi.copy(mh).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XZ" && Math.abs(hi.copy(no).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1)) : this.mode === "rotate" && (_d.copy(i), hi.copy(this.eye).applyQuaternion(_i.copy(i).invert()), a.name.search("E") !== -1 && a.quaternion.setFromRotationMatrix(U_.lookAt(this.eye, L_, no)), a.name === "X" && (_i.setFromAxisAngle(mh, Math.atan2(-hi.y, hi.z)), _i.multiplyQuaternions(_d, _i), a.quaternion.copy(_i)), a.name === "Y" && (_i.setFromAxisAngle(no, Math.atan2(hi.x, hi.z)), _i.multiplyQuaternions(_d, _i), a.quaternion.copy(_i)), a.name === "Z" && (_i.setFromAxisAngle(gh, Math.atan2(hi.y, hi.x)), _i.multiplyQuaternions(_d, _i), a.quaternion.copy(_i))), a.visible = a.visible && (a.name.indexOf("X") === -1 || this.showX), a.visible = a.visible && (a.name.indexOf("Y") === -1 || this.showY), a.visible = a.visible && (a.name.indexOf("Z") === -1 || this.showZ), a.visible = a.visible && (a.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), a.material._color = a.material._color || a.material.color.clone(), a.material._opacity = a.material._opacity || a.material.opacity, a.material.color.copy(a.material._color), a.material.opacity = a.material._opacity, this.enabled && this.axis && (a.name === this.axis || this.axis.split("").some(function(l) {
        return a.name === l;
      })) && (a.material.__color && a.material.color.setHex(a.material.__color), a.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class W2 extends Se {
  constructor() {
    super(
      new No(1e5, 1e5, 2, 2),
      new Eo.ObjectConstructors.MeshBasicMaterial({ visible: !1, wireframe: !0, side: zi, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), xd.copy(mh).applyQuaternion(t === "local" ? this.worldQuaternion : zd), rh.copy(no).applyQuaternion(t === "local" ? this.worldQuaternion : zd), ah.copy(gh).applyQuaternion(t === "local" ? this.worldQuaternion : zd), hi.copy(rh), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            hi.copy(this.eye).cross(xd), rr.copy(xd).cross(hi);
            break;
          case "Y":
            hi.copy(this.eye).cross(rh), rr.copy(rh).cross(hi);
            break;
          case "Z":
            hi.copy(this.eye).cross(ah), rr.copy(ah).cross(hi);
            break;
          case "XY":
            rr.copy(ah);
            break;
          case "YZ":
            rr.copy(xd);
            break;
          case "XZ":
            hi.copy(ah), rr.copy(rh);
            break;
          case "XYZ":
          case "E":
            rr.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        rr.set(0, 0, 0);
    }
    rr.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (F_.lookAt(bn.set(0, 0, 0), rr, hi), this.quaternion.setFromRotationMatrix(F_)), super.updateMatrixWorld(e);
  }
}
var j2 = Object.defineProperty, q2 = Object.getOwnPropertyDescriptor, Ho = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? q2(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && j2(e, t, n), n;
};
let Yr = class extends Eo {
  constructor(s, e) {
    super(s, e), this.isWidget = !0, this.assetType = "widget", this.setDirty = ct.setDirty.bind(this), this.refreshUi = ct.refreshUi.bind(this), this.visible = !1, this.userData.bboxVisible = !1, this.size = 2, this.addEventListener("objectChange", () => {
      var t;
      (t = this == null ? void 0 : this.object) != null && t.setDirty && this.object.setDirty({ frameFade: !1 });
    }), this.addEventListener("change", () => {
      this.setDirty({ frameFade: !1 });
    }), this._keyUpListener = this._keyUpListener.bind(this), this._keyDownListener = this._keyDownListener.bind(this), window.addEventListener("keydown", this._keyDownListener), window.addEventListener("keyup", this._keyUpListener);
  }
  _keyDownListener(s) {
    if (this.enabled && this.object && !(s.metaKey || s.ctrlKey)) {
      switch (s.code) {
        case "KeyQ":
          this.space = this.space === "local" ? "world" : "local";
          break;
        case "ShiftLeft":
          this.translationSnap = 0.5, this.rotationSnap = ri.degToRad(15), this.scaleSnap = 0.25;
          break;
        case "KeyW":
          this.mode = "translate";
          break;
        case "KeyE":
          this.mode = "rotate";
          break;
        case "KeyR":
          this.mode = "scale";
          break;
        case "Equal":
        case "NumpadAdd":
        case "Plus":
          this.size = this.size + 0.1;
          break;
        case "Minus":
        case "NumpadSubtract":
        case "Underscore":
          this.size = Math.max(this.size - 0.1, 0.1);
          break;
        case "KeyX":
          this.showX = !this.showX;
          break;
        case "KeyY":
          this.showY = !this.showY;
          break;
        case "KeyZ":
          this.showZ = !this.showZ;
          break;
        case "Space":
          this.enabled = !this.enabled;
          break;
        default:
          return;
      }
      this.setDirty({ refreshScene: !0, frameFade: !0 });
    }
  }
  _keyUpListener(s) {
    if (this.enabled) {
      switch (s.code) {
        case "ShiftLeft":
          this.translationSnap = null, this.rotationSnap = null, this.scaleSnap = null;
          break;
      }
      this.object && s.code;
    }
  }
  dispose() {
    window.removeEventListener("keydown", this._keyDownListener), window.removeEventListener("keyup", this._keyUpListener), super.dispose();
  }
  // dragging: boolean
  // endregion
  /**
   * Get the threejs object
   * @deprecated
   */
  get modelObject() {
    return this;
  }
  // endregion
};
Ho([
  er("Mode", ["translate", "rotate", "scale"].map((s) => ({ label: s })))
], Yr.prototype, "mode", 2);
Ho([
  er("Space", ["world", "local"].map((s) => ({ label: s })))
], Yr.prototype, "space", 2);
Ho([
  Ye("Size", [0.1, 10], 0.1)
], Yr.prototype, "size", 2);
Ho([
  ue("Show X")
], Yr.prototype, "showX", 2);
Ho([
  ue("Show Y")
], Yr.prototype, "showY", 2);
Ho([
  ue("Show Z")
], Yr.prototype, "showZ", 2);
Yr = Ho([
  Lt("Transform Controls")
], Yr);
var X2 = Object.defineProperty, Y2 = Object.getOwnPropertyDescriptor, In = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? Y2(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && X2(e, t, n), n;
};
const O_ = new M(), lm = new sc(), cm = new M(), K2 = { type: "change" };
let cn = class extends Vi {
  constructor(s, e) {
    super(), this.enabled = !0, this.enableKeys = !0, this.movementSpeed = 1, this.lookSpeed = 5e-3, this.lookVertical = !0, this.autoForward = !1, this.activeLook = !0, this.heightSpeed = !1, this.heightCoef = 1, this.heightMin = 0, this.heightMax = 1, this.constrainVertical = !1, this.verticalMin = 0, this.verticalMax = Math.PI, this.mouseDragOn = !1, this.autoSpeedFactor = 0, this.pointerX = 0, this.pointerY = 0, this.moveForward = !1, this.moveBackward = !1, this.moveLeft = !1, this.moveRight = !1, this.moveUp = !1, this.moveDown = !1, this.viewHalfX = 0, this.viewHalfY = 0, this.lat = 0, this.lon = 0, this.targetPosition = new M(), this._lastTime = -1, this.object = s, this.domElement = e, this.onPointerMove = this.onPointerMove.bind(this), this.onPointerDown = this.onPointerDown.bind(this), this.onPointerUp = this.onPointerUp.bind(this), this.onKeyDown = this.onKeyDown.bind(this), this.onKeyUp = this.onKeyUp.bind(this), this.onContextMenu = this.onContextMenu.bind(this), this.domElement.addEventListener("contextmenu", this.onContextMenu), this.domElement.addEventListener("pointermove", this.onPointerMove), this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("pointerup", this.onPointerUp), window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp), this.handleResize(), this.setOrientation();
  }
  setOrientation() {
    const s = this.object.quaternion;
    O_.set(0, 0, -1).applyQuaternion(s), lm.setFromVector3(O_), this.lat = 90 - ri.radToDeg(lm.phi), this.lon = ri.radToDeg(lm.theta);
  }
  handleResize() {
    this.domElement === document ? (this.viewHalfX = window.innerWidth / 2, this.viewHalfY = window.innerHeight / 2) : (this.viewHalfX = this.domElement.offsetWidth / 2, this.viewHalfY = this.domElement.offsetHeight / 2);
  }
  onPointerDown(s) {
    if (this.domElement !== document && this.domElement.focus(), this.activeLook)
      switch (s.button) {
        case 0:
          this.moveForward = !0;
          break;
        case 2:
          this.moveBackward = !0;
          break;
      }
    this.mouseDragOn = !0;
  }
  onPointerUp(s) {
    if (this.activeLook)
      switch (s.button) {
        case 0:
          this.moveForward = !1;
          break;
        case 2:
          this.moveBackward = !1;
          break;
      }
    this.mouseDragOn = !1;
  }
  onPointerMove(s) {
    this.domElement === document ? (this.pointerX = s.pageX - this.viewHalfX, this.pointerY = s.pageY - this.viewHalfY) : (this.pointerX = s.pageX - this.domElement.offsetLeft - this.viewHalfX, this.pointerY = s.pageY - this.domElement.offsetTop - this.viewHalfY);
  }
  onKeyDown(s) {
    if (this.enableKeys)
      switch (s.code) {
        case "ArrowUp":
        case "KeyW":
          this.moveForward = !0;
          break;
        case "ArrowLeft":
        case "KeyA":
          this.moveLeft = !0;
          break;
        case "ArrowDown":
        case "KeyS":
          this.moveBackward = !0;
          break;
        case "ArrowRight":
        case "KeyD":
          this.moveRight = !0;
          break;
        case "KeyR":
          this.moveUp = !0;
          break;
        case "KeyF":
          this.moveDown = !0;
          break;
      }
  }
  onKeyUp(s) {
    if (this.enableKeys)
      switch (s.code) {
        case "ArrowUp":
        case "KeyW":
          this.moveForward = !1;
          break;
        case "ArrowLeft":
        case "KeyA":
          this.moveLeft = !1;
          break;
        case "ArrowDown":
        case "KeyS":
          this.moveBackward = !1;
          break;
        case "ArrowRight":
        case "KeyD":
          this.moveRight = !1;
          break;
        case "KeyR":
          this.moveUp = !1;
          break;
        case "KeyF":
          this.moveDown = !1;
          break;
      }
  }
  lookAt(s, e, t) {
    return s.isVector3 ? cm.copy(s) : e === void 0 || t === void 0 ? console.error("FirstPersonControls2.lookAt: y and z parameters are required") : cm.set(s, e, t), this.object.lookAt(cm), this.setOrientation(), this;
  }
  // in ms
  update() {
    const s = zn(), e = (this._lastTime < 0 ? 16 : Math.min(s - this._lastTime, 1e3)) / 1e3;
    if (this._lastTime = s, !this.enabled) return;
    if (this.heightSpeed) {
      const c = ri.clamp(this.object.position.y, this.heightMin, this.heightMax) - this.heightMin;
      this.autoSpeedFactor = e * (c * this.heightCoef);
    } else
      this.autoSpeedFactor = 0;
    const t = e * this.movementSpeed;
    (this.moveForward || this.autoForward && !this.moveBackward) && this.object.translateZ(-(t + this.autoSpeedFactor)), this.moveBackward && this.object.translateZ(t), this.moveLeft && this.object.translateX(-t), this.moveRight && this.object.translateX(t), this.moveUp && this.object.translateY(t), this.moveDown && this.object.translateY(-t);
    let i = e * this.lookSpeed;
    this.activeLook || (i = 0);
    let n = 1;
    this.constrainVertical && (n = Math.PI / (this.verticalMax - this.verticalMin)), this.lon -= this.pointerX * i, this.lookVertical && (this.lat -= this.pointerY * i * n), this.lat = Math.max(-85, Math.min(85, this.lat));
    let r = ri.degToRad(90 - this.lat);
    const a = ri.degToRad(this.lon);
    this.constrainVertical && (r = ri.mapLinear(r, 0, Math.PI, this.verticalMin, this.verticalMax));
    const o = this.object.position;
    this.targetPosition.setFromSphericalCoords(1, r, a).add(o), this.object.lookAt(this.targetPosition), this.dispatchEvent(K2);
  }
  dispose() {
    this.domElement.removeEventListener("contextmenu", this.onContextMenu), this.domElement.removeEventListener("pointerdown", this.onPointerDown), this.domElement.removeEventListener("pointermove", this.onPointerMove), this.domElement.removeEventListener("pointerup", this.onPointerUp), window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp);
  }
  onContextMenu(s) {
    this.enableKeys && s.preventDefault();
  }
};
In([
  V(),
  ue()
], cn.prototype, "enabled", 2);
In([
  V(),
  ue()
], cn.prototype, "enableKeys", 2);
In([
  V(),
  pt()
], cn.prototype, "movementSpeed", 2);
In([
  V(),
  pt()
], cn.prototype, "lookSpeed", 2);
In([
  V(),
  ue()
], cn.prototype, "lookVertical", 2);
In([
  V(),
  ue()
], cn.prototype, "autoForward", 2);
In([
  V(),
  ue()
], cn.prototype, "activeLook", 2);
In([
  V(),
  ue()
], cn.prototype, "heightSpeed", 2);
In([
  V(),
  pt()
], cn.prototype, "heightCoef", 2);
In([
  V(),
  pt()
], cn.prototype, "heightMin", 2);
In([
  V(),
  pt()
], cn.prototype, "heightMax", 2);
In([
  V(),
  ue()
], cn.prototype, "constrainVertical", 2);
In([
  V(),
  pt()
], cn.prototype, "verticalMin", 2);
In([
  V(),
  pt()
], cn.prototype, "verticalMax", 2);
In([
  V(),
  ue()
], cn.prototype, "mouseDragOn", 2);
cn = In([
  Tn("First Person Controls")
], cn);
var J2 = Object.defineProperty, $2 = Object.getOwnPropertyDescriptor, Dc = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? $2(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && J2(e, t, n), n;
};
const gl = new xi(0, 0, 0, "YXZ"), Al = new M(), Z2 = { type: "change" }, eL = { type: "lock" }, tL = { type: "unlock" }, N_ = Math.PI / 2;
let Ba = class extends Vi {
  constructor(s, e) {
    super(), this.isLocked = !1, this.enabled = !0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.pointerSpeed = 1, this.autoLockOnClick = !0, this._movementX = 0, this._movementY = 0, this._forwardDirection = new M(0, 0, -1), this.domElement = e, this.object = s, this.onElementClick = this.onElementClick.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.onPointerlockChange = this.onPointerlockChange.bind(this), this.onPointerlockError = this.onPointerlockError.bind(this), this.connect();
  }
  onElementClick(s) {
    this.isLocked || this.autoLockOnClick && (s.preventDefault(), this.lock());
  }
  onMouseMove(s) {
    this.isLocked && (this._movementX += s.movementX || s.mozMovementX || s.webkitMovementX || 0, this._movementY += s.movementY || s.mozMovementY || s.webkitMovementY || 0);
  }
  onPointerlockChange() {
    this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(eL), this.isLocked = !0) : (this.dispatchEvent(tL), this.isLocked = !1);
  }
  onPointerlockError() {
    console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
  }
  connect() {
    this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError), this.domElement.addEventListener("click", this.onElementClick);
  }
  disconnect() {
    this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError), this.domElement.removeEventListener("click", this.onElementClick);
  }
  dispose() {
    this.disconnect();
  }
  getDirection(s) {
    return s.copy(this._forwardDirection).applyQuaternion(this.object.quaternion);
  }
  moveForward(s) {
    Al.setFromMatrixColumn(this.object.matrix, 0), Al.crossVectors(this.object.up, Al), this.object.position.addScaledVector(Al, s);
  }
  moveRight(s) {
    Al.setFromMatrixColumn(this.object.matrix, 0), this.object.position.addScaledVector(Al, s);
  }
  lock() {
    this.domElement.requestPointerLock();
  }
  unlock() {
    this.domElement.ownerDocument.exitPointerLock();
  }
  update() {
    Math.abs(this._movementX) < 1e-4 && Math.abs(this._movementY) < 1e-4 || (gl.setFromQuaternion(this.object.quaternion), gl.y -= this._movementX * 2e-3 * this.pointerSpeed, gl.x -= this._movementY * 2e-3 * this.pointerSpeed, this._movementX = 0, this._movementY = 0, gl.x = Math.max(N_ - this.maxPolarAngle, Math.min(N_ - this.minPolarAngle, gl.x)), this.object.quaternion.setFromEuler(gl), this.dispatchEvent(Z2));
  }
};
Dc([
  ue(),
  V()
], Ba.prototype, "enabled", 2);
Dc([
  pt(),
  V()
], Ba.prototype, "minPolarAngle", 2);
Dc([
  pt(),
  V()
], Ba.prototype, "maxPolarAngle", 2);
Dc([
  pt(),
  V()
], Ba.prototype, "pointerSpeed", 2);
Dc([
  ue(),
  V()
], Ba.prototype, "autoLockOnClick", 2);
Ba = Dc([
  Tn("Pointer Lock Controls")
], Ba);
var iL = Object.defineProperty, nL = Object.getOwnPropertyDescriptor, fu = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? nL(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && iL(e, t, n), n;
};
const sL = new M(0, 0, 1), k_ = new xi(), rL = new rt(), aL = new rt(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)), yl = new rt(), oL = { type: "change" }, lL = 1e-6;
let bo = class extends Vi {
  constructor(s) {
    super(), this.enabled = !1, this.lastOrder = "XYZ", this.dampingFactor = 0.05, this.lastQuaternion = new rt(), this.onDeviceOrientationChangeEvent = (e) => {
      this.deviceOrientation = e;
    }, this.onScreenOrientationChangeEvent = () => {
      this.screenOrientation = screen.orientation;
    }, this._initQuaternion = new rt(), this._initQuaternionInvert = new rt(), this._initQuaternionDest = new rt(), this._lastTime = -1, window.isSecureContext === !1 && console.error("DeviceOrientationControls2: DeviceOrientationEvent is only available in secure contexts (https)"), this.object = s, this.lastOrder = this.object.rotation.order, this.object.rotation.reorder("YXZ"), this.connect();
  }
  resetView() {
    this._initQuaternionDest.__init = !1;
  }
  connect() {
    this.enabled || (this.onScreenOrientationChangeEvent(), window.DeviceOrientationEvent !== void 0 && typeof window.DeviceOrientationEvent.requestPermission == "function" ? window.DeviceOrientationEvent.requestPermission().then((s) => {
      s == "granted" && (window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent));
    }).catch((s) => {
      console.error("DeviceOrientationControls2: Unable to use DeviceOrientation API:", s);
    }) : (window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent)), this.enabled = !0, this._initQuaternion.copy(this.object.quaternion), this._initQuaternionInvert.copy(this.object.quaternion).invert());
  }
  disconnect() {
    this.enabled && (window.removeEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.removeEventListener("deviceorientation", this.onDeviceOrientationChangeEvent), this._initQuaternion.identity(), this._initQuaternionInvert.identity(), this._initQuaternionDest = new rt(), this.object.rotation.reorder(this.lastOrder), this.lastOrder = "XYZ", this.enabled = !1);
  }
  update() {
    if (!this.enabled) return;
    const s = this.deviceOrientation;
    if (s) {
      const e = s.alpha !== null ? ri.degToRad(s.alpha) : 0, t = s.beta !== null ? ri.degToRad(s.beta) : 0, i = s.gamma !== null ? ri.degToRad(s.gamma) : 0, n = this.screenOrientation ? ri.degToRad(this.screenOrientation.angle) : 0;
      this.setObjectQuaternion(e, t, i, n), 8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > lL && (this.lastQuaternion.copy(this.object.quaternion), this.dispatchEvent(oL));
    }
  }
  dispose() {
    this.disconnect();
  }
  // The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''
  setObjectQuaternion(s, e, t, i) {
    const n = zn() / 1e3;
    k_.set(e, s, -t, "YXZ"), yl.setFromEuler(k_), yl.multiply(aL), yl.multiply(rL.setFromAxisAngle(sL, -i)), this._initQuaternionDest.__init || (this._initQuaternionDest.copy(yl).invert(), this._initQuaternionDest.__init = !0), yl.premultiply(this._initQuaternionDest);
    const r = 1 / 60;
    this.object.quaternion.multiply(this._initQuaternionInvert), this.object.quaternion.slerp(yl, this.dampingFactor / (Math.min(1, n - this._lastTime) / r)), this.object.quaternion.multiply(this._initQuaternion), this._lastTime = n;
  }
};
fu([
  V(),
  Ye("Damping", [0, 1], 0.01)
], bo.prototype, "dampingFactor", 2);
fu([
  Pt("Reset View")
], bo.prototype, "resetView", 1);
fu([
  Pt()
], bo.prototype, "connect", 1);
fu([
  Pt()
], bo.prototype, "disconnect", 1);
bo = fu([
  Tn("Device Orientation Controls")
], bo);
const Br = new M(), Za = new M(), wd = new M(), hm = new M(), Ed = new M(), vl = new M();
let um = 1;
const cL = new M(0, 1, 0);
class Uz extends jE {
  constructor(e, t) {
    super(e, t), this.throttleUpdate = 60, this.targetOffset = new M(0, 0, 0);
    const i = this.update;
    this.update = () => this._update(i);
  }
  _update(e) {
    this.target.add(this.targetOffset), Br.copy(this.object.position).sub(this.target), um = Br.length(), vl.copy(this.target);
    const t = e();
    return vl.sub(this.target), Br.copy(this.object.position).sub(this.target), um /= Br.length(), this.target.add(vl), this.object.position.copy(this.target).add(Br), Br.normalize(), Za.crossVectors(cL, Br).normalize(), wd.crossVectors(Br, Za).normalize(), hm.crossVectors(Za, wd).normalize().negate(), Za.length() > 0.1 && this.object.up.crossVectors(Br.clone().normalize(), Za), this.enablePan && (Ed.set(0, 0, 0).addScaledVector(Za, vl.x).addScaledVector(wd, vl.y).addScaledVector(hm, vl.z), this.targetOffset.add(Ed), this.targetOffset.multiplyScalar(1 / um)), Ed.set(0, 0, 0).addScaledVector(Za, -this.targetOffset.x).addScaledVector(wd, -this.targetOffset.y).addScaledVector(hm, -this.targetOffset.z), this.object.lookAt(Ed.add(this.target)), this.object.updateMatrixWorld(), this.object.isCamera && this.object.updateProjectionMatrix(), this.target.sub(this.targetOffset), t;
  }
}
class hL extends Kn {
  constructor() {
    super(), this.isWidget = !0, this._object = null, this.boundingScaleMultiplier = 1, this.position.set(0, 0, 0), this.visible = !1, this.renderOrder = 100, this.userData.bboxVisible = !1, this._updater = this._updater.bind(this);
  }
  _updater() {
    const e = this._object;
    if (e) {
      const t = new Nn().expandByObject(e, !1);
      t.getCenter(this.position);
      const i = t.getBoundingSphere(new ns()).radius;
      this.scale.setScalar(i * this.boundingScaleMultiplier), this.setVisible(!0);
    } else
      this.setVisible(!1);
  }
  setVisible(e) {
    var t;
    e !== this.visible && (this.visible = e, (t = this.setDirty) == null || t.call(this, { sceneUpdate: !1 }));
  }
  attach(e) {
    return this.detach(), e ? (this._object = e, this._object.addEventListener("objectUpdate", this._updater), this._object.addEventListener("geometryUpdate", this._updater), this._updater(), this) : this;
  }
  detach() {
    var e, t;
    return this._object ? ((e = this._object) == null || e.removeEventListener("objectUpdate", this._updater), (t = this._object) == null || t.removeEventListener("geometryUpdate", this._updater), this._object = null, this._updater(), this) : this;
  }
  get object() {
    return this._object;
  }
  dispose() {
    this.detach();
  }
}
var uL = Object.defineProperty, dL = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && uL(e, t, n), n;
};
const wg = class extends ut {
  constructor(e) {
    super(), this.modelObject = this, this.isWidget = !0, this.assetType = "widget", this.visible = !0, this.uiConfig = ty("Widget", this), this.object = e, this.object.updateMatrixWorld(), this.object.updateProjectionMatrix && this.object.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.dispose = this.dispose.bind(this), this._objectUpdate = this._objectUpdate.bind(this), this.attach(e), this.traverse((t) => {
      t.userData.__keepShadowDef = !0, t.castShadow = !1, t.receiveShadow = !1;
    });
  }
  dispose() {
    this.detach();
  }
  update() {
    ct.setDirty.call(this);
  }
  _objectUpdate() {
    this.object && this.update();
  }
  attach(e) {
    var t, i;
    return this.object && this.detach(), this.object = e, this.object && (this.update(), this.object.addEventListener("objectUpdate", this._objectUpdate), this.object.addEventListener("dispose", this.dispose), this.uiConfig && ((i = (t = this.object.uiConfig) == null ? void 0 : t.children) == null || i.push(this.uiConfig)), this.visible = !0), this;
  }
  detach() {
    var e, t, i, n;
    if (this.object) {
      if (this.object.removeEventListener("objectUpdate", this._objectUpdate), this.object.removeEventListener("dispose", this.dispose), this.uiConfig) {
        const r = (t = (e = this.object.uiConfig) == null ? void 0 : e.children) == null ? void 0 : t.indexOf(this.uiConfig);
        r !== void 0 && r >= 0 && ((n = (i = this.object.uiConfig) == null ? void 0 : i.children) == null || n.splice(r, 1));
      }
      this.object = void 0, this.visible = !1;
    }
    return this;
  }
};
dL([
  ue(),
  Pi(wg.prototype.update)
], wg.prototype, "visible");
let qE = wg;
class pL extends qE {
  constructor(e) {
    super(e), this.camera = e, this.traverse((t) => {
      t.userData.__keepShadowDef = !0, t.castShadow = !1, t.receiveShadow = !1;
    });
  }
}
class iy extends qE {
  constructor(e) {
    super(e), this.light = e, this.traverse((t) => {
      t.userData.__keepShadowDef = !0, t.castShadow = !1, t.receiveShadow = !1;
    });
  }
}
const Ty = class Ty {
  static ApplyMaterialExtensions(e, t, i, n) {
    for (const r of i)
      this.ApplyMaterialExtension(e, t, r, n);
  }
  static ApplyMaterialExtension(e, t, i, n) {
    let r = gi(i.parsFragmentSnippet, n, e) ?? "";
    r.length && (t.fragmentShader = Ct(t.fragmentShader, this.VoidMain, `
` + r + `
`, { prepend: !0 })), r = gi(i.parsVertexSnippet, n, e) ?? "", r.length && (t.vertexShader = Ct(t.vertexShader, this.VoidMain, `
` + r + `
`, { prepend: !0 })), i.extraUniforms && (t.uniforms = Object.assign(t.uniforms, iB(i.extraUniforms, (a) => gi(a, t) || { value: null }))), i.extraDefines && Vo(i.extraDefines, e), i.shaderExtender && i.shaderExtender(t, e, n), e.lastShader = t;
  }
  static CacheKeyForExtensions(e, t) {
    let i = "";
    for (const n of t)
      i += this.CacheKeyForExtension(e, n);
    return i;
  }
  static CacheKeyForExtension(e, t) {
    let i = "";
    return t.computeCacheKey ? i += gi(t.computeCacheKey, e) : i += t.uuid, t.extraDefines && (i += Object.values(t.extraDefines).map((n) => gi(n) ?? "").join("")), i;
  }
  static RegisterExtensions(e, t) {
    const i = [];
    if (Array.isArray(e.materialExtensions) || (e.materialExtensions = []), t)
      for (const n of t)
        e.materialExtensions.includes(n) || n.isCompatible !== void 0 && (!n.isCompatible || !n.isCompatible(e)) || (i.push(n), n.uuid || (n.uuid = Ss()), n.__setDirty || (n.__setDirty = () => {
          n.updateVersion || (n.updateVersion = 0), n.updateVersion++;
        }), n.setDirty || (n.setDirty = n.__setDirty));
    if (!i.length) return [];
    e.materialExtensions = [...e.materialExtensions || [], ...i].sort((n, r) => (r.priority || 0) - (n.priority || 0)), e.__ext_beforeRenderListen || (e.__ext_beforeRenderListen = !0, e.addEventListener("beforeRender", G_)), e.__ext_afterRenderListen || (e.__ext_afterRenderListen = !0, e.addEventListener("afterRender", z_)), e.__ext_addToMeshListen || (e.__ext_addToMeshListen = !0, e.addEventListener("addToMesh", Q_)), e.__ext_removeFromMeshListen || (e.__ext_removeFromMeshListen = !0, e.addEventListener("removeFromMesh", H_)), e.__ext_materialUpdateListen || (e.__ext_materialUpdateListen = !0, e.addEventListener("materialUpdate", V_));
    for (const n of i)
      n.onRegister && n.onRegister(e);
    return e.needsUpdate = !0, i;
  }
  static UnregisterExtensions(e, t) {
    var i, n;
    if (t) {
      e.materialExtensions = ((i = e.materialExtensions) == null ? void 0 : i.filter((r) => !t.includes(r))) || [];
      for (const r of t)
        r.onUnregister && r.onUnregister(e);
    }
    (n = e.materialExtensions) != null && n.length || (e.removeEventListener("beforeRender", G_), e.removeEventListener("afterRender", z_), e.removeEventListener("addToMesh", Q_), e.removeEventListener("removeFromMesh", H_), e.removeEventListener("materialUpdate", V_), e.__ext_beforeRenderListen = !1, e.__ext_afterRenderListen = !1, e.__ext_addToMeshListen = !1, e.__ext_removeFromMeshListen = !1, e.__ext_materialUpdateListen = !1);
  }
};
Object.assign(ft, lp), Ty.VoidMain = "void main()";
let Dl = Ty;
function Vo(s, e) {
  if (!s || !e) return;
  (e.defines === void 0 || e.defines === null) && (e.defines = {});
  let t = !1;
  const i = Object.entries(s);
  for (const [n, r] of i) {
    const a = gi(r);
    a === void 0 ? e.defines[n] !== void 0 && (delete e.defines[n], t = !0) : e.defines[n] !== a && (e.defines[n] = typeof a == "boolean" ? +a : a, t = !0);
  }
  t && (e.needsUpdate = !0);
}
function G_({ target: s, object: e, renderer: t }) {
  const i = s;
  if (!i || !e || !t) throw new Error("Invalid material, object or renderer");
  if (i.materialExtensions)
    for (const n of i.materialExtensions) {
      if (n.onObjectRender && n.onObjectRender(e, i, t), i.lastShader) {
        const a = gi(n.updaters) || [];
        for (const o of a) o && o.updateShaderProperties(i.lastShader);
      }
      const r = "_" + n.uuid + "_version";
      n.updateVersion !== i.userData[r] && (i.userData[r] = n.updateVersion, i.needsUpdate = !0);
    }
}
function z_({ target: s, object: e, renderer: t }) {
  const i = s;
  if (!i || !e || !t) throw new Error("Invalid material, object or renderer");
  if (i.materialExtensions)
    for (const n of i.materialExtensions)
      n.onAfterRender && n.onAfterRender(e, i, t);
}
function Q_({ target: s, object: e }) {
  const t = s;
  if (!t || !e) throw new Error("Invalid material or object");
  if (t.materialExtensions)
    for (const i of t.materialExtensions)
      i.onAddToMesh && i.onAddToMesh(e, t);
}
function H_({ target: s, object: e }) {
  const t = s;
  if (!t || !e) throw new Error("Invalid material or object");
  if (t.materialExtensions)
    for (const i of t.materialExtensions)
      i.onRemoveFromMesh && i.onRemoveFromMesh(e, t);
}
function V_({ target: s }) {
  const e = s;
  if (!e) throw new Error("Invalid material");
  if (e.materialExtensions)
    for (const t of e.materialExtensions)
      t.onMaterialUpdate && t.onMaterialUpdate(e);
}
function fL(s, e) {
  const t = e || Ss();
  return {
    uuid: t,
    // todo clean code.
    getUiConfig: (i) => {
      if (i.__uiConfigs || (i.__uiConfigs = {}), i.__uiConfigs[t]) return i.__uiConfigs[t];
      const n = s(i);
      return i.__uiConfigs[t] = n, n;
    },
    isCompatible: () => !0
  };
}
const Na = {
  // uuid: '', // DONT COPY, should remain commented
  name: "",
  blending: dr,
  side: $n,
  vertexColors: !1,
  opacity: 1,
  transparent: !1,
  blendSrc: Xl,
  blendDst: Yl,
  blendEquation: kr,
  blendSrcAlpha: null,
  blendDstAlpha: null,
  blendEquationAlpha: null,
  blendColor: "#000000",
  blendAlpha: 0,
  depthFunc: Kl,
  depthTest: !0,
  depthWrite: !0,
  stencilWriteMask: 255,
  stencilFunc: Km,
  stencilRef: 0,
  stencilFuncMask: 255,
  stencilFail: Or,
  stencilZFail: Or,
  stencilZPass: Or,
  stencilWrite: !1,
  clippingPlanes: null,
  clipIntersection: !1,
  clipShadows: !1,
  shadowSide: null,
  colorWrite: !0,
  precision: null,
  polygonOffset: !1,
  polygonOffsetFactor: 0,
  polygonOffsetUnits: 0,
  dithering: !1,
  alphaToCoverage: !1,
  premultipliedAlpha: !1,
  forceSinglePass: !1,
  visible: !0,
  toneMapped: !0,
  userData: {},
  // wireframeLinecap: 'round',
  // wireframeLinejoin: 'round',
  alphaTest: 0,
  alphaHash: !1
  // fog: true,
}, ge = {
  threeMaterialPropList: Na,
  setDirty: function(s) {
    var e, t;
    (s == null ? void 0 : s.needsUpdate) !== !1 && (this.needsUpdate = !0), this.dispatchEvent({ bubbleToObject: !0, bubbleToParent: !0, ...s, type: "materialUpdate" }), (s == null ? void 0 : s.last) !== !1 && ((t = (e = this.uiConfig) == null ? void 0 : e.uiRefresh) == null || t.call(e, !0, "postFrame", 1));
  },
  setValues: (s) => function(e) {
    var l;
    const t = (e == null ? void 0 : e.metadata) && (e == null ? void 0 : e.metadata.version) <= 4.5, i = Rt.enabled;
    t && (Rt.enabled = !1);
    const n = this.constructor.MaterialProperties, r = n ? $R(e, {}, Array.from(Object.keys(n))) : { ...e };
    for (const c of Object.keys(r)) r[c] === void 0 && delete r[c];
    const a = r.userData;
    return delete r.userData, s.call(this, r), a && aE(this.userData, a), ((e == null ? void 0 : e.metadata) && (e == null ? void 0 : e.metadata.version) <= 4.6 || this.userData.legacyBumpScale) && (this == null ? void 0 : this.bumpScale) !== void 0 && (this != null && this.bumpMap) && this.defines && (console.warn("MaterialManager: Old format material loaded, bump map might be incorrect.", e, e.bumpScale), this.defines.BUMP_MAP_SCALE_LEGACY = "1", this.userData.legacyBumpScale = !0, this.needsUpdate = !0), t && (Rt.enabled = i), (l = this.setDirty) == null || l.call(this), this;
  },
  dispose: (s) => function(e = !0) {
    !e && (this.userData.disposeOnIdle === !1 || Qh(this)) || s.call(this);
  },
  clone: (s) => function(e = !1) {
    var i, n;
    e && (this.userData.cloneId || (this.userData.cloneId = "0"), this.userData.cloneCount || (this.userData.cloneCount = 0), this.userData.cloneCount += 1);
    const t = ((n = (i = this.generator) == null ? void 0 : i.call(this, {})) == null ? void 0 : n.setValues(this, !1)) ?? s.call(this);
    return e && (t.userData.cloneId = t.userData.cloneId + "_" + this.userData.cloneCount, t.userData.cloneCount = 0, t.name = (t.name || "mat") + "_" + t.userData.cloneId), t;
  },
  dispatchEvent: (s) => function(e) {
    s.call(this, e);
    const t = e.type;
    e.bubbleToObject && (t === "beforeDeserialize" || t === "materialUpdate" || t === "textureUpdate") && this.appliedMeshes.forEach((i) => i.dispatchEvent({ ...e, material: this, type: t }));
  },
  customProgramCacheKey: function() {
    return Dl.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap;
  },
  registerMaterialExtensions: function(s) {
    Dl.RegisterExtensions(this, s);
  },
  unregisterMaterialExtensions: function(s) {
    Dl.UnregisterExtensions(this, s);
  },
  // shader is not Shader but WebglUniforms.getParameters return value type so includes defines
  onBeforeCompile: function(s, e) {
    this.materialExtensions && Dl.ApplyMaterialExtensions(this, s, this.materialExtensions, e), this.dispatchEvent({ type: "beforeCompile", shader: s, renderer: e }), s.fragmentShader = s.fragmentShader.replaceAll("#glMarker", "// "), s.vertexShader = s.vertexShader.replaceAll("#glMarker", "// ");
  },
  onBeforeRender: function(s, e, t, i, n) {
    this.envMapIntensity !== void 0 && !this.userData.separateEnvMapIntensity && e.envMapIntensity !== void 0 && (this.userData.__envIntensity = this.envMapIntensity, this.envMapIntensity = e.envMapIntensity), this.defines && this.envMap !== void 0 && e.fixedEnvMapDirection !== void 0 && (e.fixedEnvMapDirection ? this.defines.FIX_ENV_DIRECTION || (this.defines.FIX_ENV_DIRECTION = "1", this.needsUpdate = !0) : this.defines.FIX_ENV_DIRECTION !== void 0 && (delete this.defines.FIX_ENV_DIRECTION, this.needsUpdate = !0)), this.dispatchEvent({ type: "beforeRender", renderer: s, scene: e, camera: t, geometry: i, object: n });
  },
  onAfterRender: function(s, e, t, i, n) {
    this.userData.__envIntensity !== void 0 && (this.envMapIntensity = this.userData.__envIntensity, delete this.userData.__envIntensity), this.dispatchEvent({ type: "afterRender", renderer: s, scene: e, camera: t, geometry: i, object: n });
  },
  onBeforeCompileOverride: (s) => function(e, t) {
    ge.onBeforeCompile.call(this, e, t), s.call(this, e, t);
  },
  onBeforeRenderOverride: (s) => function(...e) {
    s.call(this, ...e), ge.onBeforeRender.call(this, ...e);
  },
  onAfterRenderOverride: (s) => function(...e) {
    s.call(this, ...e), ge.onAfterRender.call(this, ...e);
  },
  customProgramCacheKeyOverride: (s) => function() {
    return s.call(this) + ge.customProgramCacheKey.call(this);
  },
  upgradeMaterial: mL
  // todo;
};
function mL() {
  return this.isMaterial ? (this.setDirty || (this.setDirty = ge.setDirty), this.appliedMeshes || (this.appliedMeshes = /* @__PURE__ */ new Set()), this.userData || (this.userData = {}), this.userData.uuid = this.uuid, this.userData.setDirty || (this.userData.setDirty = (s) => {
    console.warn("userData.setDirty is deprecated. Use setDirty instead."), this.setDirty(s);
  }), this.assetType === "material" ? this : (this.assetType = "material", this.setValues = ge.setValues(this.setValues), this.dispose = ge.dispose(this.dispose), this.clone = ge.clone(this.clone), this.dispatchEvent = ge.dispatchEvent(this.dispatchEvent), this.extraUniformsToUpload || (this.extraUniformsToUpload = {}), this.materialExtensions || (this.materialExtensions = []), this.registerMaterialExtensions || (this.registerMaterialExtensions = ge.registerMaterialExtensions), this.unregisterMaterialExtensions || (this.unregisterMaterialExtensions = ge.unregisterMaterialExtensions), this.onBeforeCompile = ge.onBeforeCompileOverride(this.onBeforeCompile), this.onBeforeRender = ge.onBeforeRenderOverride(this.onBeforeRender), this.onAfterRender = ge.onAfterRenderOverride(this.onAfterRender), this.customProgramCacheKey = ge.customProgramCacheKeyOverride(this.customProgramCacheKey), this)) : (console.error("Material is not a material", this), this);
}
function bi(s, e, t, i, n) {
  return n = n ?? (() => s.setDirty && s.setDirty()), {
    type: "folder",
    label: t ?? e + " Sampler",
    hidden: () => !s[e] || i && i(),
    onChange: n,
    children: [
      () => ({
        type: "vec2",
        label: "Repeat",
        stepSize: 1e-3,
        property: [s[e], "repeat"]
      }),
      () => ({
        type: "vec2",
        label: "Offset",
        stepSize: 1e-3,
        property: [s[e], "offset"]
      }),
      () => ({
        type: "vec2",
        label: "Center",
        stepSize: 1e-3,
        property: [s[e], "center"]
      }),
      () => ({
        type: "input",
        label: "Rotation",
        stepSize: 1e-3,
        bounds: [-Math.PI, Math.PI],
        property: [s[e], "rotation"]
      }),
      () => ({
        type: "dropdown",
        label: "Color space",
        property: [s[e], "colorSpace"],
        children: [
          ["Linear", Mt],
          ["sRGB", dt]
          // ['RGBM', RGBM16ColorSpace],
        ].map((r) => ({
          label: r[0],
          value: r[1]
        })),
        onChange: [() => {
          const r = s[e];
          r && (r.needsUpdate = !0);
        }]
      }),
      () => ({
        type: "dropdown",
        label: "UV Channel",
        property: [s[e], "channel"],
        children: [0, 1, 2, 3].map((r) => ({ label: r.toString(), value: r })),
        onChange: () => {
          const r = s[e];
          r && (r.needsUpdate = !0);
        }
      }),
      () => ({
        type: "checkbox",
        label: "Flip Y",
        getValue: () => {
          var r;
          return ((r = s[e]) == null ? void 0 : r.flipY) ?? !1;
        },
        setValue: (r) => {
          const a = s[e];
          if (a && a.flipY !== r)
            if (a.image && ImageBitmap && a.image instanceof ImageBitmap) {
              const o = a, l = a.source.data;
              createImageBitmap(l, {
                imageOrientation: "flipY"
              }).then((c) => {
                l.close && l.close(), o.flipY = r, o.source.data = c, o.source.needsUpdate = !0, o.needsUpdate = !0, n();
              });
            } else
              a.flipY = r, a.needsUpdate = !0, n();
        }
      }),
      () => ({
        type: "dropdown",
        label: "Wrap S",
        property: [s[e], "wrapS"],
        children: [
          ["ClampToEdge", Zt],
          ["MirroredRepeat", Xr],
          ["Repeat", xn]
        ].map((r) => ({
          label: r[0],
          value: r[1]
        })),
        onChange: [() => {
          s[e] && (s[e].needsUpdate = !0);
        }]
      }),
      () => ({
        type: "dropdown",
        label: "Wrap T",
        property: [s[e], "wrapT"],
        children: [
          ["ClampToEdge", Zt],
          ["MirroredRepeat", Xr],
          ["Repeat", xn]
        ].map((r) => ({
          label: r[0],
          value: r[1]
        })),
        onChange: [() => {
          s[e] && (s[e].needsUpdate = !0);
        }]
      }),
      () => ({
        type: "input",
        label: "Anisotropy",
        bounds: [1, 6],
        stepSize: 1,
        property: [s[e], "anisotropy"],
        onChange: [() => {
          s[e] && (s[e].needsUpdate = !0), s.needsUpdate = !0;
        }]
      }),
      () => ({
        type: "dropdown",
        label: "Min Filter",
        property: [s[e], "minFilter"],
        children: [
          ["Linear", tt],
          ["Nearest", pi],
          ["NearestMipmapNearest", Jl],
          ["NearestMipmapLinear", co],
          ["LinearMipmapNearest", nu],
          ["LinearMipmapLinear", Qn]
        ].map((r) => ({
          label: r[0],
          value: r[1]
        })),
        onChange: [() => {
          s[e] && (s[e].needsUpdate = !0);
        }]
      }),
      () => ({
        type: "dropdown",
        label: "Mag Filter",
        property: [s[e], "magFilter"],
        children: [
          ["Linear", tt],
          ["Nearest", pi]
        ].map((r) => ({
          label: r[0],
          value: r[1]
        })),
        onChange: [() => {
          s[e] && (s[e].needsUpdate = !0);
        }]
      })
    ]
  };
}
const Ut = {
  base: (s) => [
    {
      type: "input",
      property: [s, "name"]
    },
    // {
    //     type: 'monitor',
    //     property: [material, 'uuid'],
    // },
    {
      type: "checkbox",
      property: [s, "wireframe"]
    },
    {
      type: "checkbox",
      property: [s, "vertexColors"]
    },
    {
      type: "color",
      property: [s, "color"]
    },
    s.flatShading !== void 0 ? {
      type: "checkbox",
      property: [s, "flatShading"]
    } : {},
    {
      type: "image",
      property: [s, "map"]
    },
    bi(s, "map")
  ],
  blending: (s) => ({
    type: "folder",
    label: "Blending",
    children: [
      {
        type: "slider",
        bounds: [0, 1],
        property: [s, "opacity"]
      },
      {
        type: "checkbox",
        property: [s, "transparent"],
        onChange: (e) => s.setDirty({ uiChangeEvent: e })
      },
      {
        type: "dropdown",
        property: [s, "depthFunc"],
        children: [
          ["Never", Vx],
          ["Always", Wx],
          ["Less", jx],
          ["LessEqual", Kl],
          ["Equal", qx],
          ["GreaterEqual", Xx],
          ["Greater", Yx],
          ["NotEqual", Kx]
        ].map((e) => ({
          label: e[0],
          value: e[1]
        }))
      },
      {
        type: "checkbox",
        property: [s, "depthTest"],
        onChange: (e) => s.setDirty({ uiChangeEvent: e })
      },
      {
        type: "checkbox",
        property: [s, "depthWrite"],
        onChange: (e) => s.setDirty({ uiChangeEvent: e })
      },
      {
        type: "checkbox",
        property: [s, "colorWrite"],
        onChange: (e) => s.setDirty({ uiChangeEvent: e })
      },
      {
        type: "slider",
        bounds: [0, 1],
        stepSize: 1e-3,
        property: [s, "alphaTest"]
      },
      {
        type: "checkbox",
        property: [s, "alphaHash"]
      },
      {
        type: "checkbox",
        property: [s, "dithering"]
      },
      {
        type: "dropdown",
        label: "Blending",
        property: [s, "blending"],
        children: [
          ["None", _n],
          ["Normal", dr],
          ["Additive", qd],
          ["Subtractive", Xd],
          ["Multiply", Yd],
          ["Custom", or]
        ].map((e) => ({
          label: e[0],
          value: e[1]
        }))
      },
      {
        type: "dropdown",
        hidden: () => s.blending !== or,
        property: [s, "blendingEquation"],
        children: [
          ["Add", kr],
          ["Subtract", zx],
          ["Reverse Subtract", Qx],
          ["Min", Rm],
          ["Max", Bm]
        ].map((e) => ({
          label: e[0],
          value: e[1]
        }))
      },
      {
        type: "dropdown",
        property: [s, "blendSrc"],
        hidden: () => s.blending !== or,
        children: [
          ["Zero", Pm],
          ["One", Lm],
          ["Src Color", Um],
          ["One Minus Src Color", Fm],
          ["Src Alpha", Xl],
          ["One Minus Src Alpha", Yl],
          ["Dst Alpha", Om],
          ["One Minus Dst Alpha", Nm],
          ["Dst Color", km],
          ["One Minus Dst Color", Gm],
          ["Src Alpha Saturate", Hx],
          ["Constant Color", ch],
          ["One Minus Constant Color", hh],
          ["Constant Alpha", uh],
          ["One Minus Constant Alpha", dh]
        ].map((e) => ({
          label: e[0],
          value: e[1]
        }))
      },
      {
        type: "dropdown",
        property: [s, "blendDst"],
        hidden: () => s.blending !== or,
        children: [
          ["Zero", Pm],
          ["One", Lm],
          ["Src Color", Um],
          ["One Minus Src Color", Fm],
          ["Src Alpha", Xl],
          ["One Minus Src Alpha", Yl],
          ["Dst Alpha", Om],
          ["One Minus Dst Alpha", Nm],
          ["Dst Color", km],
          ["One Minus Dst Color", Gm],
          // ['Src Alpha Saturate', SrcAlphaSaturateFactor],
          ["Constant Color", ch],
          ["One Minus Constant Color", hh],
          ["Constant Alpha", uh],
          ["One Minus Constant Alpha", dh]
        ].map((e) => ({
          label: e[0],
          value: e[1]
        }))
      },
      {
        type: "slider",
        bounds: [0, 1],
        hidden: () => s.blending !== or,
        property: [s, "blendSrcAlpha"]
      },
      {
        type: "slider",
        bounds: [0, 1],
        hidden: () => s.blending !== or,
        property: [s, "blendDstAlpha"]
      },
      {
        type: "color",
        hidden: () => s.blending !== or || s.blendSrc !== ch && s.blendSrc !== hh && s.blendDst !== ch && s.blendDst !== hh,
        property: [s, "blendColor"]
      },
      {
        type: "slider",
        hidden: () => s.blending !== or || s.blendSrc !== uh && s.blendSrc !== dh && s.blendDst !== uh && s.blendDst !== dh,
        bounds: [0, 1],
        property: [s, "blendAlpha"]
      },
      s.alphaMap !== void 0 ? {
        type: "image",
        property: [s, "alphaMap"]
      } : {},
      s.alphaMap !== void 0 ? bi(s, "alphaMap") : {},
      {
        type: "checkbox",
        label: "Render to Gbuffer",
        // hidden: ()=>!material.transparent && material.transmission < 0.001,
        getValue: () => s.userData.renderToGBuffer === !0,
        setValue: (e) => {
          !e && !s.userData.renderToGBuffer || (s.userData.renderToGBuffer = e, s.setDirty());
        }
      },
      {
        type: "checkbox",
        label: "Render to Depth",
        hidden: () => s.userData.renderToDepth !== void 0,
        getValue: () => s.userData.renderToDepth === !0,
        setValue: (e) => {
          !e && !s.userData.renderToDepth || (s.userData.renderToDepth = e, s.setDirty());
        }
      },
      s.isPhysicalMaterial ? {
        type: "checkbox",
        label: "Inverse AlphaMap",
        hidden: () => !s.transparent,
        getValue: () => s.userData.inverseAlphaMap === !0,
        setValue: (e) => {
          s.userData.inverseAlphaMap = e || void 0, s.setDirty();
        }
      } : {}
    ]
  }),
  polygonOffset: (s) => ({
    type: "folder",
    label: "Polygon Offset",
    children: [
      {
        type: "checkbox",
        label: "Polygon Offset",
        property: [s, "polygonOffset"]
      },
      {
        type: "slider",
        label: "Polygon Offset Factor",
        bounds: [-10, 10],
        property: [s, "polygonOffsetFactor"]
      },
      {
        type: "slider",
        label: "Polygon Offset Units",
        bounds: [-10, 10],
        property: [s, "polygonOffsetUnits"]
      }
    ]
  }),
  aoLightMap: (s) => ({
    type: "folder",
    label: "AO/Lightmap",
    children: [
      {
        type: "slider",
        bounds: [0, 2],
        property: [s, "aoMapIntensity"]
      },
      {
        type: "image",
        property: [s, "aoMap"]
      },
      bi(s, "aoMap"),
      {
        type: "slider",
        bounds: [0, 2],
        property: [s, "lightMapIntensity"]
      },
      {
        type: "image",
        property: [s, "lightMap"]
      },
      bi(s, "lightMap")
    ]
  }),
  environment: (s) => ({
    type: "folder",
    label: "Environment",
    children: [
      {
        type: "checkbox",
        label: "Override Environment",
        // property: [material.userData, 'separateEnvMapIntensity'],
        getValue: () => s.userData.separateEnvMapIntensity === !0,
        setValue: (e) => {
          s.userData.separateEnvMapIntensity = e, e || delete s.userData.separateEnvMapIntensity;
        }
        // onChange: material.setDirty,
      },
      {
        type: "slider",
        bounds: [0, 20],
        hidden: () => !s.userData.separateEnvMapIntensity,
        label: "Environment Intensity",
        property: [s, "envMapIntensity"]
      },
      {
        type: "dropdown",
        hidden: () => !s.userData.separateEnvMapIntensity && !s.userData.envMapSlotKey,
        label: "Environment Map",
        children: ["", "environment1", "environment2"].map((e) => ({ label: e || "default", value: e })),
        getValue: () => s.userData.envMapSlotKey || "",
        setValue: (e) => {
          s.userData.envMapSlotKey = e, e || delete s.userData.envMapSlotKey, s.setDirty();
        }
      }
    ]
  }),
  misc: (s) => [
    () => {
      var e;
      return (e = s.materialExtensions) == null ? void 0 : e.map((t) => {
        var i, n;
        return t.uuid = t.uuid || Ss(), s.__matExtUiConfigs = s.__matExtUiConfigs || {}, s.__matExtUiConfigs[t.uuid] || (s.__matExtUiConfigs[t.uuid] = (n = t.getUiConfig) == null ? void 0 : n.call(t, s, (i = s.uiConfig) == null ? void 0 : i.uiRefresh)), s.__matExtUiConfigs[t.uuid];
      }).filter((t) => t);
    },
    {
      type: "dropdown",
      label: "Side",
      property: [s, "side"],
      children: [
        ["Front", $n],
        ["Back", vn],
        ["Double", zi]
      ].map((e) => ({
        label: e[0],
        value: e[1]
      }))
    },
    {
      type: "input",
      label: "Mesh count",
      getValue: () => s.appliedMeshes.size || 0,
      disabled: !0
    },
    {
      type: "button",
      label: `Download ${s.constructor.TypeSlug}`,
      value: () => {
        const e = new Blob([JSON.stringify(s.toJSON(), null, 2)], { type: "application/json" });
        jp(e, `material.${s.constructor.TypeSlug}`);
      }
    },
    {
      type: "button",
      label: `Select ${s.constructor.TypeSlug}`,
      value: async () => XR(!1, !1, s.constructor.TypeSlug).then(async (e) => {
        var t;
        return (t = e == null ? void 0 : e[0]) == null ? void 0 : t.text();
      }).then((e) => {
        if (!e) return;
        const t = JSON.parse(e);
        t.uuid && delete t.uuid;
        const i = s.toJSON();
        return s.fromJSON(t, Sa()), {
          undo: () => s.fromJSON(i, Sa()),
          redo: () => s.fromJSON(t, Sa())
        };
      })
    }
  ],
  roughMetal: (s) => ({
    type: "folder",
    label: "Rough/Metal",
    children: [
      {
        type: "slider",
        bounds: [0, 1],
        property: [s, "roughness"]
      },
      {
        type: "slider",
        bounds: [0, 1],
        property: [s, "metalness"]
      },
      {
        type: "image",
        property: [s, "roughnessMap"]
      },
      bi(s, "roughnessMap"),
      {
        type: "image",
        property: [s, "metalnessMap"]
      },
      bi(s, "metalnessMap")
    ]
  }),
  bumpNormal: (s) => ({
    type: "folder",
    // uuid: 'bump_normal',
    label: "Bump/Normal",
    children: [
      {
        type: "slider",
        bounds: [-500, 500],
        stepSize: 1e-3,
        property: [s, "bumpScale"],
        hidden: () => !s.bumpMap
      },
      {
        type: "image",
        property: [s, "bumpMap"]
      },
      bi(s, "bumpMap"),
      {
        type: "image",
        property: [s, "normalMap"]
      },
      {
        type: "vec2",
        property: [s, "normalScale"],
        hidden: () => !s.normalMap
      },
      {
        type: "dropdown",
        hidden: () => !s.normalMap,
        property: [s, "normalMapType"],
        children: [
          ["TangentSpace", Ts],
          ["ObjectSpace", hw]
        ].map((e) => ({
          label: e[0],
          value: e[1]
        }))
      },
      bi(s, "normalMap"),
      {
        type: "input",
        property: [s, "displacementScale"],
        hidden: () => !s.displacementMap
      },
      {
        type: "image",
        property: [s, "displacementMap"]
      },
      bi(s, "displacementMap")
    ]
  }),
  emission: (s) => ({
    type: "folder",
    label: "Emission",
    children: [
      {
        type: "color",
        property: [s, "emissive"]
      },
      {
        type: "slider",
        bounds: [0, 100],
        property: [s, "emissiveIntensity"]
      },
      {
        type: "image",
        property: [s, "emissiveMap"]
      },
      bi(s, "emissiveMap")
    ]
  }),
  transmission: (s) => ({
    type: "folder",
    label: "Refraction",
    children: [
      // {
      //     type: 'slider',
      //     bounds: [0, 1],
      //     property: [material, 'reflectivity'],
      // },
      {
        type: "slider",
        bounds: [0, 4],
        property: [s, "ior"]
      },
      {
        type: "slider",
        bounds: [0, 1],
        property: [s, "transmission"]
      },
      {
        type: "slider",
        bounds: [0, 1],
        stepSize: 1e-3,
        property: [s, "thickness"]
      },
      {
        type: "image",
        property: [s, "transmissionMap"]
      },
      bi(s, "transmissionMap"),
      {
        type: "image",
        property: [s, "thicknessMap"]
      },
      bi(s, "thicknessMap"),
      {
        type: "number",
        property: [s, "attenuationDistance"]
      },
      {
        type: "color",
        property: [s, "attenuationColor"]
      }
    ]
  }),
  clearcoat: (s) => ({
    type: "folder",
    label: "Clearcoat",
    children: [
      {
        type: "slider",
        bounds: [0, 1],
        property: [s, "clearcoat"]
      },
      {
        type: "slider",
        bounds: [0, 1],
        hidden: () => s.clearcoat < 1e-3,
        property: [s, "clearcoatRoughness"]
      },
      {
        type: "image",
        property: [s, "clearcoatMap"]
      },
      bi(s, "clearcoatMap"),
      {
        type: "slider",
        bounds: [0, 1],
        property: [s, "clearcoatRoughness"]
      },
      {
        type: "image",
        property: [s, "clearcoatRoughnessMap"]
      },
      bi(s, "clearcoatRoughnessMap"),
      {
        type: "image",
        property: [s, "clearcoatNormalMap"]
      },
      {
        type: "vec2",
        property: [s, "clearcoatNormalScale"],
        hidden: () => !s.clearcoatNormalMap
      },
      bi(s, "clearcoatNormalMap")
    ]
  }),
  iridescence: (s) => ({
    type: "folder",
    label: "Iridescence",
    children: [
      {
        type: "slider",
        bounds: [0, 3],
        label: "Intensity",
        property: [s, "iridescence"]
      },
      {
        type: "slider",
        bounds: [0, 3],
        label: "IOR",
        property: [s, "iridescenceIOR"]
      },
      {
        type: "slider",
        bounds: [0, 500],
        label: "Thickness0",
        property: [s.iridescenceThicknessRange, "0"],
        onChange: (e) => s.setDirty({ uiChangeEvent: e })
      },
      {
        type: "slider",
        bounds: [0, 500],
        label: "Thickness1",
        property: [s.iridescenceThicknessRange, "1"],
        onChange: (e) => s.setDirty({ uiChangeEvent: e })
      },
      {
        type: "image",
        property: [s, "iridescenceMap"]
      },
      bi(s, "iridescenceMap"),
      {
        type: "image",
        property: [s, "iridescenceThicknessMap"]
      },
      bi(s, "iridescenceThicknessMap")
    ]
  }),
  sheen: (s) => ({
    type: "folder",
    label: "Sheen",
    children: [
      {
        type: "slider",
        bounds: [0, 1],
        property: [s, "sheen"]
      },
      {
        type: "color",
        hidden: () => s.sheen < 1e-3,
        property: [s, "sheenColor"]
      },
      {
        type: "image",
        property: [s, "sheenColorMap"]
      },
      bi(s, "sheenColorMap"),
      {
        type: "slider",
        bounds: [0, 1],
        property: [s, "sheenRoughness"]
      },
      {
        type: "image",
        property: [s, "sheenRoughnessMap"]
      },
      bi(s, "sheenRoughnessMap")
    ]
  })
};
var gL = Object.defineProperty, tr = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && gL(e, t, n), n;
}, Xn;
const Ps = (Xn = class extends uu {
  constructor({ customMaterialExtensions: e, ...t } = {}) {
    super(), this.assetType = "material", this.isLineMaterial2 = !0, this.appliedMeshes = /* @__PURE__ */ new Set(), this.setDirty = ge.setDirty, this.materialExtensions = [], this.extraUniformsToUpload = {}, this.registerMaterialExtensions = ge.registerMaterialExtensions, this.unregisterMaterialExtensions = ge.unregisterMaterialExtensions, this.autoUpdateResolution = !0, this.uiConfig = {
      type: "folder",
      label: "Line Material",
      uuid: "MPM2_" + this.uuid,
      expanded: !0,
      onChange: (i) => {
        !i.config || i.config.onChange || this.setDirty({ uiChangeEvent: i, needsUpdate: !!i.last, refreshUi: !!i.last });
      },
      children: [
        ...mr(this) || [],
        Ut.blending(this),
        Ut.polygonOffset(this),
        ...Ut.misc(this)
      ]
    }, this.fog = !1, this.setDirty = this.setDirty.bind(this), e && this.registerMaterialExtensions(e), ge.upgradeMaterial.call(this), this.setValues(t);
  }
  dispose() {
    return ge.dispose(super.dispose).call(this);
  }
  clone(e = !1) {
    return ge.clone(super.clone).call(this, e);
  }
  dispatchEvent(e) {
    ge.dispatchEvent(super.dispatchEvent).call(this, e);
  }
  customProgramCacheKey() {
    return super.customProgramCacheKey() + ge.customProgramCacheKey.call(this);
  }
  onBeforeCompile(e, t) {
    const i = [
      ["vec4 diffuseColor = ", "beforeAccumulation"],
      ["#include <clipping_planes_fragment>", "mainStart"]
    ], n = [
      ["#ifdef USE_COLOR", "mainStart"]
    ];
    for (const r of n) e.vertexShader = Ct(e.vertexShader, r[0], "#glMarker " + r[1] + `
` + r[0]);
    for (const r of i) e.fragmentShader = Ct(e.fragmentShader, r[0], "#glMarker " + r[1] + `
` + r[0]);
    ge.onBeforeCompile.call(this, e, t), super.onBeforeCompile(e, t);
  }
  onBeforeRender(e, t, i, n, r) {
    this.autoUpdateResolution && e.getSize(this.resolution), super.onBeforeRender(e, t, i, n, r), ge.onBeforeRender.call(this, e, t, i, n, r);
  }
  onAfterRender(e, t, i, n, r) {
    super.onAfterRender(e, t, i, n, r), ge.onAfterRender.call(this, e, t, i, n, r);
  }
  // endregion UI Config
  // region Serialization
  /**
   * Sets the values of this material based on the values of the passed material or an object with material properties
   * The input is expected to be a valid material or a deserialized material parameters object(including the deserialized userdata)
   * @param parameters - material or material parameters object
   * @param allowInvalidType - if true, the type of the oldMaterial is not checked. Objects without type are always allowed.
   * @param clearCurrentUserData - if undefined, then depends on material.isMaterial. if true, the current userdata is cleared before setting the new values, because it can have data which wont be overwritten if not present in the new material.
   */
  setValues(e, t = !0, i = void 0) {
    return e ? e.type && !t && !["LineMaterial", this.constructor.TYPE].includes(e.type) && !e.isLineMaterial && !e.isLineMaterial2 ? (console.error("Material type is not supported:", e.type), this) : (i === void 0 && (i = e.isMaterial), i && (this.userData = {}), ge.setValues(super.setValues).call(this, e), this.userData.uuid = this.uuid, this) : this;
  }
  copy(e) {
    return this.setValues(e, !1);
  }
  /**
   * Serializes this material to JSON.
   * @param meta - metadata for serialization
   * @param _internal - Calls only super.toJSON, does internal three.js serialization and `@serialize` tags. Set it to true only if you know what you are doing. This is used in Serialization->serializer->material
   */
  toJSON(e, t = !1) {
    return t ? {
      ...super.toJSON(e),
      ...mt.Serialize(this, e, !0)
      // this will serialize the properties of this class(like defined with @serialize and @serialize attribute)
    } : mt.Serialize(this, e, !1);
  }
  /**
   * Deserializes the material from JSON.
   * Note: some properties that are not serialized in Material.toJSON when they are default values (like side, alphaTest, blending, maps), they wont be reverted back if not present in JSON
   * If _internal = true, Textures should be loaded and in meta.textures before calling this method.
   * @param data
   * @param meta
   * @param _internal
   */
  fromJSON(e, t, i = !1) {
    return i ? (mt.Deserialize(e, this, t, !0), this.setValues(e)) : (this.dispatchEvent({ type: "beforeDeserialize", data: e, meta: t, bubbleToObject: !0, bubbleToParent: !0 }), this);
  }
}, Xn.TypeSlug = "lmat", Xn.TYPE = "LineMaterial2", Xn.MaterialProperties = {
  // keep updated with properties in LineMaterial.js
  ...Na,
  color: new se(16777215),
  dashed: !1,
  dashScale: 1,
  dashSize: 1,
  dashOffset: 0,
  gapSize: 1,
  linewidth: 1,
  resolution: new ie(1, 1),
  alphaToCoverage: !1,
  worldUnits: !1,
  uniforms: {},
  defines: {},
  extensions: {},
  clipping: !1,
  fog: !0,
  fragmentShader: "",
  vertexShader: ""
}, Xn.MaterialTemplate = {
  materialType: Xn.TYPE,
  name: "line",
  typeSlug: Xn.TypeSlug,
  alias: ["line", "line_physical", Xn.TYPE, Xn.TypeSlug, "LineMaterial"],
  params: {
    color: new se(1, 1, 1)
  },
  generator: (e) => new Xn(e)
}, Xn);
tr([
  pt()
], Ps.prototype, "name");
tr([
  wr()
], Ps.prototype, "color");
tr([
  ue()
], Ps.prototype, "dashed");
tr([
  ii()
], Ps.prototype, "dashScale");
tr([
  ii()
], Ps.prototype, "dashSize");
tr([
  ii()
], Ps.prototype, "dashOffset");
tr([
  ii()
], Ps.prototype, "gapSize");
tr([
  ii()
], Ps.prototype, "linewidth");
tr([
  Ji()
], Ps.prototype, "resolution");
tr([
  ue()
], Ps.prototype, "alphaToCoverage");
tr([
  ue()
], Ps.prototype, "worldUnits");
let Xs = Ps;
class Oz extends Xs {
}
class AL extends hL {
  constructor() {
    super();
    const e = new Xs({
      color: "#ff2222",
      transparent: !0,
      opacity: 0.9,
      linewidth: 5,
      // in pixels
      resolution: new ie(1024, 1024),
      // to be set by renderer, eventually
      worldUnits: !1,
      dashed: !1,
      toneMapped: !1
    });
    e.userData.renderToGBuffer = !1, e.userData.renderToDepth = !1, this.lineMaterial = e;
    const t = new ea();
    t.setPositions([1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1].map((n) => n - 0.5));
    const i = new Tc(t, e);
    i.computeLineDistances(), i.scale.set(1, 1, 1), i.visible = !0, this.add(i);
  }
  _updater() {
    super._updater();
    const e = this.object;
    e && (new Nn().expandByObject(e, !1).getSize(this.scale).multiplyScalar(this.boundingScaleMultiplier).clampScalar(0.1, 1e8), this.setVisible(!0));
  }
}
class ny extends pL {
  constructor(e) {
    super(e), this._vector = new M(), this._camera = new Up();
    const t = new ea(), i = new Xs({
      color: 16777215,
      linewidth: 5,
      // in world units with size attenuation, pixels otherwise
      vertexColors: !0,
      worldUnits: !1,
      dashed: !1,
      alphaToCoverage: !0,
      toneMapped: !1,
      transparent: !0,
      depthTest: !1,
      depthWrite: !1
    });
    i.userData.renderToGBuffer = !1, i.userData.renderToDepth = !1;
    const { vertices: n, colors: r, pointMap: a } = yL();
    t.setPositions(n), t.setColors(r), this.line = new Tc(t, i), this.line.frustumCulled = !1, this.add(this.line), this.pointMap = a, this.update();
    const o = new se(16755200), l = new se(16711680), c = new se(43775), h = new se(16777215), u = new se(3355443);
    this.setColors(o, l, c, h, u);
  }
  setColors(e, t, i, n, r) {
    const a = this.line.geometry, o = a.getAttribute("instanceColorStart"), l = a.getAttribute("instanceColorEnd");
    function c(h, u) {
      o.setXYZ(h / 2, u.r, u.g, u.b), l.setXYZ(h / 2, u.r, u.g, u.b);
    }
    c(0, e), c(2, e), c(4, e), c(6, e), c(8, e), c(10, e), c(12, e), c(14, e), c(16, e), c(18, e), c(20, e), c(22, e), c(24, t), c(26, t), c(28, t), c(30, t), c(32, i), c(34, i), c(36, i), c(38, n), c(40, r), c(42, r), c(44, r), c(46, r), c(48, r), o.needsUpdate = !0, l.needsUpdate = !0;
  }
  update() {
    if (!this.camera) return;
    const e = this.line.geometry, t = this.pointMap, i = 1, n = 1, { _camera: r, _vector: a } = this;
    r.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Ni("c", t, e, r, 0, 0, -1, a), Ni("t", t, e, r, 0, 0, 1, a), Ni("n1", t, e, r, -1, -1, -1, a), Ni("n2", t, e, r, i, -1, -1, a), Ni("n3", t, e, r, -1, n, -1, a), Ni("n4", t, e, r, i, n, -1, a), Ni("f1", t, e, r, -1, -1, 1, a), Ni("f2", t, e, r, i, -1, 1, a), Ni("f3", t, e, r, -1, n, 1, a), Ni("f4", t, e, r, i, n, 1, a), Ni("u1", t, e, r, i * 0.7, n * 1.1, -1, a), Ni("u2", t, e, r, -1 * 0.7, n * 1.1, -1, a), Ni("u3", t, e, r, 0, n * 2, -1, a), Ni("cf1", t, e, r, -1, 0, 1, a), Ni("cf2", t, e, r, i, 0, 1, a), Ni("cf3", t, e, r, 0, -1, 1, a), Ni("cf4", t, e, r, 0, n, 1, a), Ni("cn1", t, e, r, -1, 0, -1, a), Ni("cn2", t, e, r, i, 0, -1, a), Ni("cn3", t, e, r, 0, -1, -1, a), Ni("cn4", t, e, r, 0, n, -1, a), e.getAttribute("instanceStart").needsUpdate = !0, e.getAttribute("instanceEnd").needsUpdate = !0, e.computeBoundingBox(), e.computeBoundingSphere(), super.update();
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), super.dispose();
  }
  static Check(e) {
    return e.isCamera;
  }
  static Create(e) {
    return new ny(e);
  }
}
function Ni(s, e, t, i, n, r, a, o) {
  o.set(n, r, a).unproject(i);
  const l = e[s];
  if (l !== void 0) {
    const c = t.getAttribute("instanceStart"), h = t.getAttribute("instanceEnd");
    for (let u = 0, d = l.length; u < d; u++) {
      const p = Math.floor(l[u] / 2);
      (l[u] % 2 === 0 ? c : h).setXYZ(p, o.x, o.y, o.z);
    }
  }
}
function yL() {
  const s = [], e = [], t = {};
  i("n1", "n2"), i("n2", "n4"), i("n4", "n3"), i("n3", "n1"), i("f1", "f2"), i("f2", "f4"), i("f4", "f3"), i("f3", "f1"), i("n1", "f1"), i("n2", "f2"), i("n3", "f3"), i("n4", "f4"), i("p", "n1"), i("p", "n2"), i("p", "n3"), i("p", "n4"), i("u1", "u2"), i("u2", "u3"), i("u3", "u1"), i("c", "t"), i("p", "c"), i("cn1", "cn2"), i("cn3", "cn4"), i("cf1", "cf2"), i("cf3", "cf4");
  function i(r, a) {
    n(r), n(a);
  }
  function n(r) {
    s.push(0, 0, 0), e.push(0, 0, 0), t[r] === void 0 && (t[r] = []), t[r].push(s.length / 3 - 1);
  }
  return { vertices: s, colors: e, pointMap: t };
}
class mp extends ea {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, i = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      i[2 * n] = e[n], i[2 * n + 1] = e[n + 1], i[2 * n + 2] = e[n + 2], i[2 * n + 3] = e[n + 3], i[2 * n + 4] = e[n + 4], i[2 * n + 5] = e[n + 5];
    return super.setPositions(i), this;
  }
  setColors(e) {
    const t = e.length - 3, i = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      i[2 * n] = e[n], i[2 * n + 1] = e[n + 1], i[2 * n + 2] = e[n + 2], i[2 * n + 3] = e[n + 3], i[2 * n + 4] = e[n + 4], i[2 * n + 5] = e[n + 5];
    return super.setColors(i), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class Eg extends Tc {
  constructor(e = new mp(), t = new uu({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
var vL = Object.defineProperty, sy = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && vL(e, t, n), n;
};
const So = class XE extends iy {
  constructor(e, t, i) {
    super(e), this.lineWidth = 5, this.size = 0.5, this._v1 = new M(), this._v2 = new M(), this._v3 = new M(), this.color = i, t !== void 0 && (this.size = t);
    let n = new mp();
    this.material = new Xs({
      color: 16711680,
      linewidth: 5,
      // in world units with size attenuation, pixels otherwise
      vertexColors: !1,
      worldUnits: !1,
      dashed: !1,
      alphaToCoverage: !0,
      toneMapped: !1,
      transparent: !0,
      depthTest: !1,
      depthWrite: !1
    }), this.material.userData.renderToGBuffer = !1, this.material.userData.renderToDepth = !1, this.lightPlane = new Eg(n, this.material), this.add(this.lightPlane), n = new mp(), n.setPositions([0, 0, 0, 0, 0, 1]), this.targetLine = new Eg(n, this.material), this.add(this.targetLine), this.update(), this.traverse((r) => {
      r.userData.__keepShadowDef = !0, r.castShadow = !1, r.receiveShadow = !1;
    });
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose(), super.dispose();
  }
  update() {
    !this.light || !this.lightPlane || (this._v1.setFromMatrixPosition(this.light.matrixWorld), this._v2.setFromMatrixPosition(this.light.target.matrixWorld), this._v3.subVectors(this._v2, this._v1), this.lightPlane.geometry.setPositions([
      -this.size,
      this.size,
      0,
      this.size,
      this.size,
      0,
      this.size,
      -this.size,
      0,
      -this.size,
      -this.size,
      0,
      -this.size,
      this.size,
      0
    ]), this.lightPlane.lookAt(this._v2), this.lightPlane.material = this.material, this.targetLine.material = this.material, this.material.color.set(this.color ?? this.light.color), this.material.linewidth = this.lineWidth, this.targetLine.lookAt(this._v2), this.targetLine.scale.z = this.light.intensity / 3, super.update());
  }
  static Check(e) {
    return e.isDirectionalLight;
  }
  static Create(e) {
    return new XE(e);
  }
};
sy([
  Oe(So.prototype.update)
], So.prototype, "material");
sy([
  Oe(So.prototype.update),
  Ye(void 0, [0.1, 20], 0.01)
], So.prototype, "lineWidth");
sy([
  Oe(So.prototype.update),
  Ye(void 0, [0.01, 10], 0.01)
], So.prototype, "size");
let _L = So;
class YE extends ea {
  constructor(e) {
    super(), this.isWireframeGeometry2 = !0, this.type = "WireframeGeometry2", this.fromWireframeGeometry(new DA(e));
  }
}
const W_ = new M(), j_ = new M();
class xL extends Se {
  constructor(e = new ea(), t = new uu({ color: Math.random() * 16777215 })) {
    super(e, t), this.isWireframe = !0, this.type = "Wireframe";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, i = e.attributes.instanceEnd, n = new Float32Array(2 * t.count);
    for (let a = 0, o = 0, l = t.count; a < l; a++, o += 2)
      W_.fromBufferAttribute(t, a), j_.fromBufferAttribute(i, a), n[o] = o === 0 ? 0 : n[o - 1], n[o + 1] = n[o] + W_.distanceTo(j_);
    const r = new op(n, 2, 1);
    return e.setAttribute("instanceDistanceStart", new Cn(r, 1, 0)), e.setAttribute("instanceDistanceEnd", new Cn(r, 1, 1)), this;
  }
}
var wL = Object.defineProperty, ry = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && wL(e, t, n), n;
};
const Co = class KE extends iy {
  constructor(e, t, i) {
    super(e), this.lineWidth = 5, this.size = 0.5, this.color = i, t !== void 0 && (this.size = t);
    const n = new YE(new fr(0.5, 4, 2));
    this.material = new Xs({
      color: 16711680,
      linewidth: 5,
      // in world units with size attenuation, pixels otherwise
      vertexColors: !1,
      worldUnits: !1,
      dashed: !1,
      alphaToCoverage: !0,
      toneMapped: !1,
      transparent: !0,
      depthTest: !1,
      depthWrite: !1
    }), this.material.userData.renderToGBuffer = !1, this.material.userData.renderToDepth = !1, this.lightSphere = new xL(n, this.material), this.lightSphere.computeLineDistances(), this.add(this.lightSphere), this.update(), this.traverse((r) => {
      r.userData.__keepShadowDef = !0, r.castShadow = !1, r.receiveShadow = !1;
    });
  }
  dispose() {
    this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose(), super.dispose();
  }
  update() {
    !this.light || !this.lightSphere || (this.material.color.set(this.color ?? this.light.color), this.material.linewidth = this.lineWidth, this.lightSphere.scale.setScalar(this.size), super.update());
  }
  static Check(e) {
    return e.isPointLight;
  }
  static Create(e) {
    return new KE(e);
  }
};
ry([
  Oe(Co.prototype.update)
], Co.prototype, "material");
ry([
  Oe(Co.prototype.update),
  Ye(void 0, [0.1, 20], 0.01)
], Co.prototype, "lineWidth");
ry([
  Oe(Co.prototype.update),
  Ye(void 0, [0.01, 10], 0.01)
], Co.prototype, "size");
let EL = Co;
var bL = Object.defineProperty, JE = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && bL(e, t, n), n;
};
const Vh = class $E extends iy {
  constructor(e, t, i) {
    super(e), this.lineWidth = 5, this._v1 = new M(), this.color = i;
    const n = new ea(), r = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let a = 0, o = 1, l = 32; a < l; a++, o++) {
      const c = a / l * Math.PI * 2, h = o / l * Math.PI * 2;
      r.push(
        Math.cos(c),
        Math.sin(c),
        1,
        Math.cos(h),
        Math.sin(h),
        1
      );
    }
    n.setPositions(r), this.material = new Xs({
      color: 16711680,
      linewidth: 5,
      // in world units with size attenuation, pixels otherwise
      vertexColors: !1,
      worldUnits: !1,
      dashed: !1,
      alphaToCoverage: !0,
      toneMapped: !1,
      transparent: !0,
      depthTest: !1,
      depthWrite: !1
    }), this.material.userData.renderToGBuffer = !1, this.material.userData.renderToDepth = !1, this.cone = new Tc(n, this.material), this.add(this.cone), this.update(), this.traverse((a) => {
      a.userData.__keepShadowDef = !0, a.castShadow = !1, a.receiveShadow = !1;
    });
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose(), super.dispose();
  }
  update() {
    if (!this.light || !this.cone) return;
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), this._v1.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(this._v1), this.material.color.set(this.color ?? this.light.color), this.material.linewidth = this.lineWidth, super.update();
  }
  static Check(e) {
    return e.isSpotLight;
  }
  static Create(e) {
    return new $E(e);
  }
};
JE([
  Oe(Vh.prototype.update)
], Vh.prototype, "material");
JE([
  Oe(Vh.prototype.update),
  Ye(void 0, [0.1, 20], 0.01)
], Vh.prototype, "lineWidth");
let SL = Vh;
const Gs = class Gs extends $s {
  constructor({ customMaterialExtensions: e, ...t } = {}) {
    super(), this.assetType = "material", this.isUnlitMaterial = !0, this.appliedMeshes = /* @__PURE__ */ new Set(), this.setDirty = ge.setDirty, this.envMap = null, this.materialExtensions = [], this.extraUniformsToUpload = {}, this.registerMaterialExtensions = ge.registerMaterialExtensions, this.unregisterMaterialExtensions = ge.unregisterMaterialExtensions, this.onBeforeRender = ge.onBeforeRenderOverride(super.onBeforeRender), this.onAfterRender = ge.onAfterRenderOverride(super.onAfterRender), this.uiConfig = {
      type: "folder",
      label: "Unlit Material",
      uuid: "MBM2_" + this.uuid,
      expanded: !0,
      onChange: (i) => {
        !i.config || i.config.onChange || this.setDirty({ uiChangeEvent: i, needsUpdate: !!i.last, refreshUi: !!i.last });
      },
      children: [
        ...Ut.base(this),
        ...mr(this),
        Ut.blending(this),
        Ut.aoLightMap(this),
        Ut.polygonOffset(this),
        // iMaterialUI.environment(this),
        ...Ut.misc(this)
      ]
    }, !this.defines && (this.defines = {}), this.fog = !1, this.setDirty = this.setDirty.bind(this), e && this.registerMaterialExtensions(e), ge.upgradeMaterial.call(this), this.setValues(t);
  }
  dispose() {
    return ge.dispose(super.dispose).call(this);
  }
  clone(e = !1) {
    return ge.clone(super.clone).call(this, e);
  }
  dispatchEvent(e) {
    ge.dispatchEvent(super.dispatchEvent).call(this, e);
  }
  customProgramCacheKey() {
    return super.customProgramCacheKey() + ge.customProgramCacheKey.call(this);
  }
  onBeforeCompile(e, t) {
    const i = [
      ["vec3 outgoingLight = ", "afterModulation"],
      // added markers before found substring
      ["#include <aomap_fragment>", "beforeModulation"],
      ["ReflectedLight reflectedLight = ", "beforeAccumulation"],
      ["#include <clipping_planes_fragment>", "mainStart"]
    ], n = [
      ["#include <uv_vertex>", "mainStart"]
    ];
    for (const r of n) e.vertexShader = Ct(e.vertexShader, r[0], "#glMarker " + r[1] + `
` + r[0]);
    for (const r of i) e.fragmentShader = Ct(e.fragmentShader, r[0], "#glMarker " + r[1] + `
` + r[0]);
    ge.onBeforeCompile.call(this, e, t), super.onBeforeCompile(e, t);
  }
  // endregion
  // region Serialization
  /**
   * Sets the values of this material based on the values of the passed material or an object with material properties
   * The input is expected to be a valid material or a deserialized material parameters object(including the deserialized userdata)
   * @param parameters - material or material parameters object
   * @param allowInvalidType - if true, the type of the oldMaterial is not checked. Objects without type are always allowed.
   * @param clearCurrentUserData - if undefined, then depends on material.isMaterial. if true, the current userdata is cleared before setting the new values, because it can have data which wont be overwritten if not present in the new material.
   */
  setValues(e, t = !0, i = void 0) {
    return e ? e.type && !t && !["MeshBasicMaterial", "MeshBasicMaterial2", this.constructor.TYPE].includes(e.type) ? (console.error("Material type is not supported:", e.type), this) : (i === void 0 && (i = e.isMaterial), i && (this.userData = {}), ge.setValues(super.setValues).call(this, e), this.userData.uuid = this.uuid, this) : this;
  }
  copy(e) {
    return this.setValues(e, !1);
  }
  /**
   * Serializes this material to JSON.
   * @param meta - metadata for serialization
   * @param _internal - Calls only super.toJSON, does internal three.js serialization and `@serialize` tags. Set it to true only if you know what you are doing. This is used in Serialization->serializer->material
   */
  toJSON(e, t = !1) {
    return t ? {
      ...super.toJSON(e),
      ...mt.Serialize(this, e, !0)
      // this will serialize the properties of this class(like defined with @serialize and @serialize attribute)
    } : mt.Serialize(this, e, !1);
  }
  /**
   * Deserializes the material from JSON.
   * Textures should be loaded and in meta.textures before calling this method.
   * @param data
   * @param meta
   * @param _internal
   */
  fromJSON(e, t, i = !1) {
    return i ? (mt.Deserialize(e, this, t, !0), this.setValues(e)) : (this.dispatchEvent({ type: "beforeDeserialize", data: e, meta: t, bubbleToObject: !0, bubbleToParent: !0 }), this);
  }
};
Gs.TypeSlug = "bmat", Gs.TYPE = "UnlitMaterial", Gs.MaterialProperties = {
  ...Na,
  color: new se(16777215),
  map: null,
  lightMap: null,
  lightMapIntensity: 1,
  aoMap: null,
  aoMapIntensity: 1,
  specularMap: null,
  alphaMap: null,
  envMap: null,
  combine: _c,
  envMapIntensity: 1,
  reflectivity: 1,
  refractionRatio: 0.98,
  wireframe: !1,
  wireframeLinewidth: 1,
  wireframeLinecap: "round",
  wireframeLinejoin: "round",
  skinning: !1,
  fog: !0,
  flatShading: !1
}, Gs.MaterialTemplate = {
  materialType: Gs.TYPE,
  name: "unlit",
  typeSlug: Gs.TypeSlug,
  alias: ["basic", "unlit", Gs.TYPE, Gs.TypeSlug, "MeshBasicMaterial", "MeshBasicMaterial2"],
  params: {
    color: new se(1, 1, 1)
  },
  generator: (e) => new Gs(e)
};
let Pa = Gs;
class Nz extends Pa {
  constructor(e) {
    super(e), console.error("MeshBasicMaterial2 is deprecated, use UnlitMaterial instead");
  }
}
const zs = class zs extends Sc {
  constructor({ customMaterialExtensions: e, ...t } = {}) {
    super(), this.assetType = "material", this.isPhysicalMaterial = !0, this.appliedMeshes = /* @__PURE__ */ new Set(), this.setDirty = ge.setDirty, this.map = null, this.alphaMap = null, this.roughnessMap = null, this.metalnessMap = null, this.normalMap = null, this.bumpMap = null, this.displacementMap = null, this.materialExtensions = [], this.extraUniformsToUpload = {}, this.registerMaterialExtensions = ge.registerMaterialExtensions, this.unregisterMaterialExtensions = ge.unregisterMaterialExtensions, this.onAfterRender = ge.onAfterRenderOverride(super.onAfterRender), this.uiConfig = {
      type: "folder",
      label: "Physical Material",
      uuid: "MPM2_" + this.uuid,
      expanded: !0,
      onChange: (i) => {
        !i.config || i.config.onChange || this.setDirty({ uiChangeEvent: i, needsUpdate: !!i.last, refreshUi: !!i.last });
      },
      children: [
        ...Ut.base(this),
        ...mr(this),
        Ut.blending(this),
        Ut.roughMetal(this),
        Ut.bumpNormal(this),
        Ut.emission(this),
        Ut.transmission(this),
        Ut.environment(this),
        Ut.aoLightMap(this),
        Ut.clearcoat(this),
        Ut.iridescence(this),
        Ut.sheen(this),
        Ut.polygonOffset(this),
        ...Ut.misc(this)
      ]
    }, this.fog = !1, this.attenuationDistance = 0, this.setDirty = this.setDirty.bind(this), e && this.registerMaterialExtensions(e), ge.upgradeMaterial.call(this), this.setValues(t);
  }
  dispose() {
    return ge.dispose(super.dispose).call(this);
  }
  clone(e = !1) {
    return ge.clone(super.clone).call(this, e);
  }
  dispatchEvent(e) {
    ge.dispatchEvent(super.dispatchEvent).call(this, e);
  }
  customProgramCacheKey() {
    return super.customProgramCacheKey() + ge.customProgramCacheKey.call(this);
  }
  onBeforeCompile(e, t) {
    const i = [
      ["vec3 totalDiffuse = ", "afterModulation"],
      ["#include <aomap_fragment>", "beforeModulation"],
      ["#include <lights_physical_fragment>", "beforeAccumulation"],
      ["#include <clipping_planes_fragment>", "mainStart"]
    ], n = [
      ["#include <uv_vertex>", "mainStart"]
    ];
    for (const r of n) e.vertexShader = Ct(e.vertexShader, r[0], "#glMarker " + r[1] + `
` + r[0]);
    for (const r of i) e.fragmentShader = Ct(e.fragmentShader, r[0], "#glMarker " + r[1] + `
` + r[0]);
    e.fragmentShader = Ct(e.fragmentShader, "#include <opaque_fragment>", `gl_FragColor = clamp(gl_FragColor, 0.0, 1000.0);
`, { append: !0 }), ge.onBeforeCompile.call(this, e, t), e.defines && (e.defines.INVERSE_ALPHAMAP = this.userData.inverseAlphaMap ? 1 : 0), super.onBeforeCompile(e, t);
  }
  onBeforeRender(e, t, i, n, r) {
    super.onBeforeRender(e, t, i, n, r), ge.onBeforeRender.call(this, e, t, i, n, r);
    const a = this.userData.inverseAlphaMap ? 1 : 0;
    a !== this.defines.INVERSE_ALPHAMAP && (this.defines.INVERSE_ALPHAMAP = a, this.needsUpdate = !0);
  }
  // endregion UI Config
  // region Serialization
  /**
   * Sets the values of this material based on the values of the passed material or an object with material properties
   * The input is expected to be a valid material or a deserialized material parameters object(including the deserialized userdata)
   * @param parameters - material or material parameters object
   * @param allowInvalidType - if true, the type of the oldMaterial is not checked. Objects without type are always allowed.
   * @param clearCurrentUserData - if undefined, then depends on material.isMaterial. if true, the current userdata is cleared before setting the new values, because it can have data which wont be overwritten if not present in the new material.
   */
  setValues(e, t = !0, i = void 0) {
    return e ? e.type && !t && !["MeshPhysicalMaterial", "MeshStandardMaterial", "MeshStandardMaterial2", this.constructor.TYPE].includes(e.type) ? (console.error("Material type is not supported:", e.type), this) : (typeof e.normalScale == "number" && (e.normalScale = [e.normalScale, e.normalScale]), i === void 0 && (i = e.isMaterial), i && (this.userData = {}), e.ior !== void 0 && (this.ior = e.ior), ge.setValues(super.setValues).call(this, e), isFinite(this.attenuationDistance) || (this.attenuationDistance = 0), this.userData.uuid = this.uuid, this) : this;
  }
  copy(e) {
    return this.setValues(e, !1);
  }
  /**
   * Serializes this material to JSON.
   * @param meta - metadata for serialization
   * @param _internal - Calls only super.toJSON, does internal three.js serialization and `@serialize` tags. Set it to true only if you know what you are doing. This is used in Serialization->serializer->material
   */
  toJSON(e, t = !1) {
    return t ? {
      ...super.toJSON(e),
      ...mt.Serialize(this, e, !0)
      // this will serialize the properties of this class(like defined with @serialize and @serialize attribute)
    } : mt.Serialize(this, e, !1);
  }
  /**
   * Deserializes the material from JSON.
   * Note: some properties that are not serialized in Material.toJSON when they are default values (like side, alphaTest, blending, maps), they wont be reverted back if not present in JSON
   * If _internal = true, Textures should be loaded and in meta.textures before calling this method.
   * @param data
   * @param meta
   * @param _internal
   */
  fromJSON(e, t, i = !1) {
    return i ? (mt.Deserialize(e, this, t, !0), this.setValues(e)) : (this.dispatchEvent({ type: "beforeDeserialize", data: e, meta: t, bubbleToObject: !0, bubbleToParent: !0 }), this);
  }
};
zs.TypeSlug = "pmat", zs.TYPE = "PhysicalMaterial", zs.MaterialProperties = {
  // keep updated with properties in MeshStandardMaterial.js
  ...Na,
  color: new se(16777215),
  roughness: 1,
  metalness: 0,
  map: null,
  lightMap: null,
  lightMapIntensity: 1,
  aoMap: null,
  aoMapIntensity: 1,
  emissive: "#000000",
  emissiveIntensity: 1,
  emissiveMap: null,
  bumpMap: null,
  bumpScale: 1,
  normalMap: null,
  normalMapType: Ts,
  normalScale: new ie(1, 1),
  displacementMap: null,
  displacementScale: 1,
  displacementBias: 0,
  roughnessMap: null,
  metalnessMap: null,
  alphaMap: null,
  envMap: null,
  envMapIntensity: 1,
  // refractionRatio: 0,
  wireframe: !1,
  wireframeLinewidth: 1,
  wireframeLinecap: "round",
  wireframeLinejoin: "round",
  flatShading: !1,
  fog: !0,
  // skinning: false,
  // vertexTangents: false, //removed from threejs
  // morphTargets: false,
  // morphNormals: false,
  // GLTF Extensions // todo: supported anywhere?
  // glossiness: 0,
  // glossinessMap: null,
  // specularColor: new Color(0),
  // specularColorMap: null,
  // keep updated with properties in MeshPhysicalMaterial.js
  clearcoat: 0,
  clearcoatMap: null,
  clearcoatRoughness: 0,
  clearcoatRoughnessMap: null,
  clearcoatNormalScale: new ie(1, 1),
  clearcoatNormalMap: null,
  reflectivity: 0.5,
  // because this is used in Material.js->toJSON and fromJSON instead of ior
  iridescence: 0,
  iridescenceMap: null,
  iridescenceIOR: 1.3,
  iridescenceThicknessRange: [100, 400],
  iridescenceThicknessMap: null,
  sheen: 0,
  sheenColor: new se(0),
  sheenColorMap: null,
  sheenRoughness: 1,
  sheenRoughnessMap: null,
  transmission: 0,
  transmissionMap: null,
  thickness: 0,
  thicknessMap: null,
  attenuationDistance: 1 / 0,
  attenuationColor: new se(1, 1, 1),
  specularIntensity: 1,
  specularIntensityMap: null,
  specularColor: new se(1, 1, 1),
  specularColorMap: null,
  anisotropy: 0,
  anisotropyRotation: 0,
  anisotropyMap: null
}, zs.MaterialTemplate = {
  materialType: zs.TYPE,
  name: "physical",
  typeSlug: zs.TypeSlug,
  alias: ["standard", "physical", zs.TYPE, zs.TypeSlug, "MeshStandardMaterial", "MeshStandardMaterial2", "MeshPhysicalMaterial"],
  params: {
    color: new se(1, 1, 1)
  },
  generator: (e) => new zs(e)
};
let Ds = zs;
class kz extends Ds {
  constructor(e) {
    super(e), console.error("MeshStandardMaterial2 is deprecated, use UnlitMaterial instead");
  }
}
const Qs = class Qs extends Ri {
  constructor({ customMaterialExtensions: e, ...t } = {}) {
    super(), this.assetType = "material", this.isUnlitLineMaterial = !0, this.appliedMeshes = /* @__PURE__ */ new Set(), this.setDirty = ge.setDirty, this.materialExtensions = [], this.extraUniformsToUpload = {}, this.registerMaterialExtensions = ge.registerMaterialExtensions, this.unregisterMaterialExtensions = ge.unregisterMaterialExtensions, this.onBeforeRender = ge.onBeforeRenderOverride(super.onBeforeRender), this.onAfterRender = ge.onAfterRenderOverride(super.onAfterRender), this.uiConfig = {
      type: "folder",
      label: "Unlit Line Material",
      uuid: "MBLM2_" + this.uuid,
      expanded: !0,
      onChange: (i) => {
        !i.config || i.config.onChange || this.setDirty({ uiChangeEvent: i, needsUpdate: !!i.last, refreshUi: !!i.last });
      },
      children: [
        {
          type: "input",
          property: [this, "name"]
        },
        // {
        //     type: 'monitor',
        //     property: [this, 'uuid'],
        // },
        {
          type: "checkbox",
          property: [this, "vertexColors"]
        },
        {
          type: "color",
          property: [this, "color"]
        },
        bi(this, "map"),
        {
          type: "number",
          property: [this, "linewidth"]
        },
        {
          type: "dropdown",
          property: [this, "linecap"],
          children: ["butt", "round", "square"].map((i) => ({ label: i }))
        },
        {
          type: "dropdown",
          property: [this, "linejoin"],
          children: ["bevel", "round", "miter"].map((i) => ({ label: i }))
        },
        // {
        //     type: 'checkbox',
        //     property: [this, 'fog'],
        // },
        Ut.blending(this),
        Ut.polygonOffset(this),
        ...Ut.misc(this)
      ]
    }, !this.defines && (this.defines = {}), this.fog = !1, this.setDirty = this.setDirty.bind(this), e && this.registerMaterialExtensions(e), ge.upgradeMaterial.call(this), this.setValues(t);
  }
  dispose() {
    return ge.dispose(super.dispose).call(this);
  }
  clone(e = !1) {
    return ge.clone(super.clone).call(this, e);
  }
  dispatchEvent(e) {
    ge.dispatchEvent(super.dispatchEvent).call(this, e);
  }
  customProgramCacheKey() {
    return super.customProgramCacheKey() + ge.customProgramCacheKey.call(this);
  }
  onBeforeCompile(e, t) {
    const i = [
      ["vec3 outgoingLight = ", "afterModulation"],
      // added markers before found substring
      ["#include <aomap_fragment>", "beforeModulation"],
      ["ReflectedLight reflectedLight = ", "beforeAccumulation"],
      ["#include <clipping_planes_fragment>", "mainStart"]
    ], n = [
      ["#include <uv_vertex>", "mainStart"]
    ];
    for (const r of n) e.vertexShader = Ct(e.vertexShader, r[0], "#glMarker " + r[1] + `
` + r[0]);
    for (const r of i) e.fragmentShader = Ct(e.fragmentShader, r[0], "#glMarker " + r[1] + `
` + r[0]);
    ge.onBeforeCompile.call(this, e, t), super.onBeforeCompile(e, t);
  }
  // endregion
  // region Serialization
  /**
   * Sets the values of this material based on the values of the passed material or an object with material properties
   * The input is expected to be a valid material or a deserialized material parameters object(including the deserialized userdata)
   * @param parameters - material or material parameters object
   * @param allowInvalidType - if true, the type of the oldMaterial is not checked. Objects without type are always allowed.
   * @param clearCurrentUserData - if undefined, then depends on material.isMaterial. if true, the current userdata is cleared before setting the new values, because it can have data which wont be overwritten if not present in the new material.
   */
  setValues(e, t = !0, i = void 0) {
    return e ? e.type && !t && !["LineBasicMaterial", "LineBasicMaterial2", this.constructor.TYPE].includes(e.type) ? (console.error("Material type is not supported:", e.type), this) : (i === void 0 && (i = e.isMaterial), i && (this.userData = {}), ge.setValues(super.setValues).call(this, e), this.userData.uuid = this.uuid, this) : this;
  }
  copy(e) {
    return this.setValues(e, !1);
  }
  /**
   * Serializes this material to JSON.
   * @param meta - metadata for serialization
   * @param _internal - Calls only super.toJSON, does internal three.js serialization and `@serialize` tags. Set it to true only if you know what you are doing. This is used in Serialization->serializer->material
   */
  toJSON(e, t = !1) {
    return t ? {
      ...super.toJSON(e),
      ...mt.Serialize(this, e, !0)
      // this will serialize the properties of this class(like defined with @serialize and @serialize attribute)
    } : mt.Serialize(this, e, !1);
  }
  /**
   * Deserializes the material from JSON.
   * Textures should be loaded and in meta.textures before calling this method.
   * todo - needs to be tested
   * @param data
   * @param meta
   * @param _internal
   */
  fromJSON(e, t, i = !1) {
    return i ? (mt.Deserialize(e, this, t, !0), this.setValues(e)) : (this.dispatchEvent({ type: "beforeDeserialize", data: e, meta: t, bubbleToObject: !0, bubbleToParent: !0 }), this);
  }
};
Qs.TypeSlug = "blmat", Qs.TYPE = "UnlitLineMaterial", Qs.MaterialProperties = {
  ...Na,
  color: new se(16777215),
  map: null,
  linewidth: 1,
  linecap: "round",
  linejoin: "round",
  fog: !0
}, Qs.MaterialTemplate = {
  materialType: Qs.TYPE,
  name: "unlit_line",
  typeSlug: Qs.TypeSlug,
  alias: ["line_basic", "unlit_line", Qs.TYPE, Qs.TypeSlug, "LineBasicMaterial", "LineBasicMaterial2"],
  params: {
    color: new se(1, 1, 1)
  },
  generator: (e) => new Qs(e)
};
let pr = Qs;
class Gz extends pr {
  constructor(e) {
    super(e), console.error("LineBasicMaterial2 is deprecated, use UnlitLineMaterial instead");
  }
}
const Rl = new Pa();
Rl.name = "Default Unlit Material";
Rl.uiConfig = void 0;
const Mh = new pr();
Mh.name = "Default Unlit Line Material";
Mh.uiConfig = void 0;
const Th = new Xs();
Th.name = "Default Line Material";
Th.uiConfig = void 0;
function ay(s) {
  return [
    {
      type: "button",
      label: "Set View",
      value: () => {
        var e;
        this.setViewToMain({ ui: !0 }), (e = s.uiRefresh) == null || e.call(s, !0, "postFrame");
      }
    },
    {
      type: "button",
      label: "Activate main",
      hidden: () => this == null ? void 0 : this.isMainCamera,
      value: () => {
        var e;
        this.activateMain({ ui: !0 }), (e = s.uiRefresh) == null || e.call(s, !0, "postFrame");
      }
    },
    {
      type: "button",
      label: "Deactivate main",
      hidden: () => !(this != null && this.isMainCamera),
      value: () => {
        var e;
        this.deactivateMain({ ui: !0 }), (e = s.uiRefresh) == null || e.call(s, !0, "postFrame");
      }
    },
    {
      type: "checkbox",
      label: "Auto LookAt Target",
      getValue: () => this.userData.autoLookAtTarget ?? !1,
      setValue: (e) => {
        var t;
        this.userData.autoLookAtTarget = e, (t = s.uiRefresh) == null || t.call(s, !0, "postFrame");
      }
    }
  ];
}
function CL(s) {
  if (!this) return {};
  if (this.uiConfig) return this.uiConfig;
  const e = {
    type: "folder",
    label: () => this.name || "unnamed",
    expanded: !0,
    onChange: (t) => {
      !t.config || t.config.onChange || this.setDirty({ uiChangeEvent: t, refreshScene: !1, refreshUi: !0 });
    },
    children: [
      {
        type: "checkbox",
        label: "Visible",
        property: [this, "visible"],
        onChange: (t) => {
          var i;
          (i = this.setDirty) == null || i.call(this, { uiChangeEvent: t, refreshScene: !0, refreshUi: !0, change: "visible" });
        }
      },
      // moved to PickingPlugin
      // {
      //     type: 'button',
      //     label: 'Pick/Focus', // todo: move to the plugin that does the picking
      //     value: ()=>{
      //         this.dispatchEvent({type: 'select', ui: true, object: this, bubbleToParent: true, focusCamera: true})
      //     },
      // },
      // {
      //     type: 'button',
      //     label: 'Pick Parent', // todo: move to the plugin that does the picking
      //     hidden: ()=>!this.parent,
      //     value: ()=>{
      //         const parent = this.parent
      //         if (parent) {
      //             parent.dispatchEvent({type: 'select', ui: true, bubbleToParent: true, object: parent})
      //         }
      //     },
      // },
      {
        type: "input",
        label: "Name",
        property: [this, "name"],
        onChange: (t) => {
          var i;
          t.last && ((i = this.setDirty) == null || i.call(this, { uiChangeEvent: t, refreshScene: !0, frameFade: !1, refreshUi: !0 }));
        }
      },
      {
        type: "checkbox",
        label: "Casts Shadow",
        hidden: () => !this.isMesh,
        property: [this, "castShadow"],
        onChange: (t) => {
          var i;
          (i = this.setDirty) == null || i.call(this, { uiChangeEvent: t, refreshScene: !0, refreshUi: !0, change: "castShadow" });
        }
      },
      {
        type: "checkbox",
        label: "Receive Shadow",
        hidden: () => !this.isMesh,
        property: [this, "receiveShadow"],
        onChange: (t) => {
          var i;
          (i = this.setDirty) == null || i.call(this, { uiChangeEvent: t, refreshScene: !0, refreshUi: !0, change: "receiveShadow" });
        }
      },
      {
        type: "checkbox",
        label: "Frustum culled",
        property: [this, "frustumCulled"]
      },
      {
        type: "vec3",
        label: "Position",
        property: [this, "position"]
      },
      {
        type: "vec3",
        label: "Rotation",
        property: [this, "rotation"]
      },
      {
        type: "vec3",
        label: "Scale",
        property: [this, "scale"]
      },
      {
        type: "input",
        label: "Render Order",
        property: [this, "renderOrder"]
      },
      {
        type: "button",
        label: "Auto Scale",
        hidden: () => !this.autoScale,
        // prompt: ['Auto Scale Radius: Object will be scaled to the given radius', this.userData.autoScaleRadius || '2', true],
        value: async () => {
          const t = (this.userData.autoScaleRadius || 2) + "", i = await $t.Dialog.prompt("Auto Scale Radius: Object will be scaled to the given radius", t);
          if (i === null) return;
          const n = parseFloat(i || t);
          if (Math.abs(n) > 0)
            return {
              action: () => {
                var r;
                return (r = this.autoScale) == null ? void 0 : r.call(this, n);
              },
              undo: () => {
                var r;
                return (r = this.autoScale) == null ? void 0 : r.call(this, n, void 0, void 0, !0);
              }
            };
        }
      },
      {
        type: "button",
        label: "Auto Center",
        value: () => ({
          action: () => {
            var t;
            return (t = this.autoCenter) == null ? void 0 : t.call(this, !0);
          },
          undo: () => {
            var t;
            return (t = this.autoCenter) == null ? void 0 : t.call(this, !0, !0);
          }
        })
      },
      {
        type: "button",
        label: "Pivot to Node Center",
        value: async () => {
          var i;
          if (await $t.Dialog.confirm("Pivot to Center: Adjust the pivot to bounding box center. The object will rotate around the new pivot, are you sure you want to proceed?"))
            return (i = this.pivotToBoundsCenter) == null ? void 0 : i.call(this, !0);
        }
      },
      {
        type: "button",
        label: "Delete Object",
        tags: ["context-menu"],
        value: async () => {
          if (!await $t.Dialog.confirm("Delete Object: Are you sure you want to delete this object?")) return;
          const i = this.parent;
          return this.dispose(!0), () => {
            i && i.add(this);
          };
        }
      },
      {
        type: "folder",
        label: "Rotate model",
        children: [
          "X +",
          "X -",
          "Y +",
          "Y -",
          "Z +",
          "Z -"
        ].map((t) => ({
          type: "button",
          label: "Rotate " + t + "90",
          value: () => {
            const i = new M(t.includes("X") ? 1 : 0, t.includes("Y") ? 1 : 0, t.includes("Z") ? 1 : 0), n = Math.PI / 2 * (t.includes("-") ? -1 : 1);
            return {
              action: () => {
                var r;
                this.rotateOnAxis(i, n), (r = this.setDirty) == null || r.call(this, { refreshScene: !0, refreshUi: !1 });
              },
              undo: () => {
                var r;
                this.rotateOnAxis(i, -n), (r = this.setDirty) == null || r.call(this, { refreshScene: !0, refreshUi: !1 });
              }
            };
          }
        }))
      },
      this.userData.license !== void 0 ? {
        type: "input",
        label: "License/Credits",
        property: [this.userData, "license"]
      } : {}
    ]
  };
  if ((this.isLine || this.isMesh) && s !== !1) {
    const t = [
      // morph targets
      () => {
        const i = Object.entries(this.morphTargetDictionary || {});
        return i.length ? {
          label: "Morph Targets",
          type: "folder",
          children: i.map(([n, r]) => ({
            type: "slider",
            label: n,
            bounds: [0, 1],
            stepSize: 1e-4,
            property: [this.morphTargetInfluences, r],
            onChange: (a) => {
              var o;
              (o = this.setDirty) == null || o.call(this, { refreshScene: a.last, frameFade: !1, refreshUi: !1 });
            }
          }))
        } : void 0;
      },
      // geometry
      () => {
        var i;
        return (i = this.geometry) == null ? void 0 : i.uiConfig;
      },
      // material(s)
      () => {
        var i;
        return Array.isArray(this.material) ? this.material.length < 1 ? void 0 : {
          label: "Materials",
          type: "folder",
          children: this.material.map((n) => n == null ? void 0 : n.uiConfig).filter((n) => n)
        } : (i = this.material) == null ? void 0 : i.uiConfig;
      },
      {
        label: "Remove Material(s)",
        type: "button",
        hidden: () => {
          var i;
          return !((i = this.materials) != null && i.length) || this.materials.length === 1 && [Rl, Th, Mh].includes(this.materials[0]);
        },
        value: () => {
          const i = this.materials;
          return this.material = this.isLineSegments2 ? [Th] : this.isLineSegments ? [Mh] : [Rl], () => this.material = i;
        }
      },
      {
        label: "New Line Material",
        type: "button",
        hidden: () => {
          var i;
          return !this.isLineSegments2 || !(!((i = this.materials) != null && i.length) || this.materials.length === 1 && this.materials[0] === Th);
        },
        value: () => {
          const i = this.materials;
          return this.material = [new Xs()], () => this.material = i;
        }
      },
      {
        label: "New Unlit Line Material",
        type: "button",
        hidden: () => {
          var i;
          return !this.isLineSegments || !(!((i = this.materials) != null && i.length) || this.materials.length === 1 && this.materials[0] === Mh);
        },
        value: () => {
          const i = this.materials;
          return this.material = [new pr()], () => this.material = i;
        }
      },
      {
        label: "New Physical Material",
        type: "button",
        hidden: () => {
          var i;
          return !(!((i = this.materials) != null && i.length) || this.materials.length === 1 && this.materials[0] === Rl) || !!this.isLineSegments2 || !!this.isLineSegments;
        },
        value: () => {
          const i = this.materials;
          return this.material = [new Ds()], () => this.material = i;
        }
      },
      {
        label: "New Unlit Material",
        type: "button",
        hidden: () => {
          var i;
          return !(!((i = this.materials) != null && i.length) || this.materials.length === 1 && this.materials[0] === Rl) || !!this.isLineSegments2 || !!this.isLineSegments;
        },
        value: () => {
          const i = this.materials;
          return this.material = [new Pa()], () => this.material = i;
        }
      }
    ];
    e.children.push(...t);
  }
  if (this.isCamera) {
    const t = ay.call(this, e);
    e.children.push(...t);
  }
  return this.uiConfig = e, e;
}
const ai = {
  setDirty: function(s) {
    this.dispatchEvent({ bubbleToObject: !0, ...s, type: "geometryUpdate", geometry: this }), this.refreshUi();
  },
  refreshUi: function() {
    var s, e;
    (e = (s = this.uiConfig) == null ? void 0 : s.uiRefresh) == null || e.call(s, !0, "postFrame", 1);
  },
  dispose: (s) => function(e = !0) {
    !e && (this.userData.disposeOnIdle === !1 || Qh(this)) || s.call(this);
  },
  clone: (s) => function() {
    return ai.upgradeGeometry.call(s.call(this));
  },
  upgradeGeometry: ML,
  center: (s) => function(e, t = !1, i = !0) {
    if (t) {
      e = e ? e.clone() : new M(), s.call(this, e), e.negate();
      const n = this.appliedMeshes;
      for (const r of n)
        r.updateMatrix(), r.position.copy(e).applyMatrix4(r.matrix), i && r.setDirty();
    } else
      s.call(this, e);
    return i && this.setDirty(), this;
  },
  center2: function(s, e = !1, t = !0) {
    const i = s || new M();
    if (e) {
      this.center(i, !1, !1);
      const n = this.appliedMeshes, r = /* @__PURE__ */ new WeakMap();
      for (const a of n)
        a.updateMatrix(), r.set(a, a.position.clone()), a.position.set(-i.x, -i.y, -i.z).applyMatrix4(a.matrix), t && a.setDirty();
      return t && this.setDirty(), () => {
        for (const a of n) {
          const o = r.get(a);
          if (!o) {
            console.warn("GeometryCommons: No position found for mesh", a);
            continue;
          }
          a.position.copy(o), t && a.setDirty();
        }
        t && this.setDirty();
      };
    } else
      return this.center(i, !1, !1), t && this.setDirty(), () => {
        this.translate(-i.x, -i.y, -i.z), t && this.setDirty();
      };
  },
  makeUiConfig: function() {
    return this.uiConfig ? this.uiConfig : {
      label: "Geometry",
      type: "folder",
      children: [
        {
          type: "input",
          property: [this, "uuid"],
          disabled: !0
        },
        {
          type: "input",
          property: [this, "name"]
        },
        {
          type: "button",
          label: "Center Geometry",
          value: async () => {
            if (await $t.Dialog.confirm("This will move the objects based on the geometry center, do you want to continue?"))
              return this.center2();
          }
        },
        {
          type: "button",
          label: "Center Geometry (keep position)",
          value: async () => {
            if (await $t.Dialog.confirm("This will move the geometry center keeping the object position, do you want to continue?"))
              return this.center2(void 0, !0);
          }
        },
        {
          type: "button",
          label: "Compute vertex normals",
          value: async () => {
            this.hasAttribute("normal") && !await $t.Dialog.confirm(`Normals already exist, replace with computed normals?
This action cannot be undone.`) || (this.computeVertexNormals(), this.setDirty());
          }
        },
        {
          type: "button",
          label: "Compute vertex tangents",
          value: async () => {
            this.hasAttribute("tangent") && !await $t.Dialog.confirm(`Tangents already exist, replace with computed tangents?
This action cannot be undone.`) || (this.computeTangents(), this.setDirty());
          }
        },
        {
          type: "button",
          label: "Normalize normals",
          value: () => {
            this.normalizeNormals(), this.setDirty();
          }
        },
        {
          type: "button",
          label: "Convert to indexed",
          hidden: () => !!this.index,
          value: async () => {
            if (this.attributes.index) return;
            const s = parseFloat(await $t.Dialog.prompt("Convert to Indexed: Tolerance?", "-1") ?? "-1");
            cE(this, s), this.setDirty();
          }
        },
        {
          type: "button",
          label: "Convert to non-indexed",
          hidden: () => !this.index,
          value: () => {
            this.attributes.index && (this.toNonIndexed(), this.setDirty());
          }
        },
        {
          type: "button",
          label: "Create uv1 from uv",
          value: async () => {
            this.hasAttribute("uv1") && !await $t.Dialog.confirm(`uv1 already exists, replace with uv data?
This action cannot be undone.`) || (this.setAttribute("uv1", this.getAttribute("uv")), this.setDirty());
          }
        },
        {
          type: "button",
          label: "Remove vertex color attribute",
          hidden: () => !this.hasAttribute("color"),
          value: async () => {
            if (!this.hasAttribute("color")) {
              await $t.Dialog.prompt("No color attribute found");
              return;
            }
            await $t.Dialog.confirm("Remove color attribute?") && (this.deleteAttribute("color"), this.setDirty());
          }
        },
        {
          type: "button",
          label: "Auto GPU Instances",
          hidden: () => !this.appliedMeshes || this.appliedMeshes.size < 2,
          value: async () => {
            await $t.Dialog.confirm("This will automatically create Instanced Mesh from geometry instances. This action is irreversible, do you want to continue?") && uE(this);
          }
        },
        {
          type: "input",
          label: "Mesh count",
          getValue: () => {
            var s;
            return ((s = this.appliedMeshes) == null ? void 0 : s.size) ?? 0;
          },
          disabled: !0
        }
      ]
    };
  }
};
function ML() {
  return this.assetType === "geometry" ? this : this.isBufferGeometry ? (this.assetType = "geometry", this.dispose = ai.dispose(this.dispose), this.center = ai.center(this.center), this.clone = ai.clone(this.clone), this.center2 || (this.center2 = ai.center2), this.setDirty || (this.setDirty = ai.setDirty), this.refreshUi || (this.refreshUi = ai.refreshUi), this.appliedMeshes || (this.appliedMeshes = /* @__PURE__ */ new Set()), this.userData || (this.userData = {}), this.uiConfig = ai.makeUiConfig.call(this), this) : (console.error("Geometry is not a BufferGeometry", this), this);
}
const ct = {
  setDirty: function(s, ...e) {
    var t, i;
    typeof s == "string" && (s = { change: s }), this.dispatchEvent({ bubbleToParent: ((t = this.userData) == null ? void 0 : t.autoUpdateParent) ?? !0, ...s, type: "objectUpdate", object: this, args: e }), (s == null ? void 0 : s.refreshUi) !== !1 && (s == null ? void 0 : s.last) !== !1 && ((i = this.refreshUi) == null || i.call(this));
  },
  upgradeObject3D: ZE,
  makeUiConfig: CL,
  autoCenter: function(s = !0, e = !1) {
    if (e) {
      if (!this.userData.autoCentered || !this.userData._lastCenter) return this;
      if (!isFinite(this.userData._lastCenter.lengthSq())) return this;
      this.position.add(this.userData._lastCenter), delete this.userData.autoCentered, delete this.userData.isCentered, delete this.userData._lastCenter;
    } else {
      const i = new Nn().expandByObject(this, !0, !0).getCenter(new M());
      if (!isFinite(i.lengthSq())) return this;
      this.userData._lastCenter = i, this.position.sub(i), this.userData.autoCentered = !0, this.userData.isCentered = !0;
    }
    return this.updateMatrix(), s && this.setDirty({ change: "autoCenter", undo: e }), this;
  },
  autoScale: function(s, e, t = !0, i = !1) {
    let n = 1;
    if (i) {
      if (!this.userData.autoScaled || !this.userData._lastScaleRadius) return this;
      const r = this.userData.autoScaleRadius || s || 1;
      if (n = this.userData._lastScaleRadius / r, !isFinite(n)) return this;
      this.userData.autoScaled = !0, this.userData.autoScaleRadius = s, delete this.userData._lastScaleRadius;
    } else {
      const a = new Nn().expandByObject(this, !0, !0).getSize(new M()).length() * 0.5;
      if (s === void 0 && (s = this.userData.autoScaleRadius || 1), n = s / a, !isFinite(n)) return this;
      this.userData.autoScaled = !0, this.userData.autoScaleRadius = s, this.userData._lastScaleRadius = a;
    }
    return this.userData.pseudoCentered ? this.children.forEach((r) => {
      r.scale.multiplyScalar(n);
    }) : this.scale.multiplyScalar(n), (e || this.userData.isCentered) && this.position.multiplyScalar(n), this.traverse((r) => {
      var o, l;
      const a = r;
      a.isLight && ((l = (o = a.shadow) == null ? void 0 : o.camera) != null && l.right) && (a.shadow.camera.right *= n, a.shadow.camera.left *= n, a.shadow.camera.top *= n, a.shadow.camera.bottom *= n, r.setDirty()), a.isCamera && a.right && (a.right *= n, a.left *= n, a.top *= n, a.bottom *= n, r.setDirty());
    }), t && this.setDirty({ change: "autoScale", undo: i }), this;
  },
  pivotToBoundsCenter: function(s = !0) {
    const t = new Nn().expandByObject(this, !0, !0).getCenter(new M());
    return ct.pivotToPoint.call(this, t, s);
  },
  pivotToPoint: function(s, e = !0) {
    var l;
    const t = new M().copy(s), i = new M().copy(t), n = new Ue().copy(this.matrixWorld).invert(), r = (l = this.parent) == null ? void 0 : l.matrixWorld, a = new Ue();
    r !== void 0 && a.copy(r).invert(), t.applyMatrix4(a);
    const o = this.position.clone();
    return this.position.copy(t), i.applyMatrix4(n).negate(), this.geometry && this.geometry.translate(i.x, i.y, i.z), this.children.forEach((c) => {
      c.position.add(i);
    }), e && this.setDirty({ change: "pivotToPoint", undo: !1 }), () => {
      this.position.copy(o), this.geometry && this.geometry.translate(-i.x, -i.y, -i.z), this.children.forEach((c) => {
        c.position.sub(i);
      }), e && this.setDirty({ change: "pivotToPoint", undo: !0 });
    };
  },
  eventCallbacks: {
    onAddedToParent: function(s) {
      var t, i;
      const e = ((t = this.parent) == null ? void 0 : t.parentRoot) ?? this.parent;
      !this.objectProcessor && (e != null && e.objectProcessor) && this.traverse((n) => {
        var r;
        n.objectProcessor = e.objectProcessor, (r = n.objectProcessor) == null || r.processObject(n);
      }), e !== this.parentRoot && this.traverse((n) => {
        n.parentRoot = e;
      }), (i = this.setDirty) == null || i.call(this, { ...s, change: "addedToParent" });
    },
    onRemovedFromParent: function(s) {
      var e;
      (e = this.setDirty) == null || e.call(this, { ...s, change: "removedFromParent" }), this.parentRoot !== void 0 && this.traverse((t) => {
        t.parentRoot = void 0;
      });
    },
    onGeometryUpdate: function(s) {
      s.bubbleToObject && this.dispatchEvent({ bubbleToParent: !0, ...s, object: this, geometry: s.geometry });
    }
  },
  initMaterial: function() {
    if (Jn(this, "_currentMaterial")) return;
    this._currentMaterial = null;
    const s = this.material;
    delete this.material, Object.defineProperty(this, "material", {
      get: ct.getMaterial,
      set: ct.setMaterial
    }), Object.defineProperty(this, "materials", {
      get: ct.getMaterials,
      set: ct.setMaterials
    }), this.material = s, this.setMaterial || (this.setMaterial = (e) => {
      const t = this.material;
      return console.error("setMaterial is deprecated, use material property directly"), this.material = e, t;
    }), this.userData.setMaterial && console.error("userData.setMaterial already defined"), this.userData.setMaterial = (e) => {
      console.error("userData.setMaterial is deprecated, use setMaterial directly"), this.material = e;
    };
  },
  getMaterial: function() {
    return this._currentMaterial || void 0;
  },
  getMaterials: function() {
    return this._currentMaterial ? Array.isArray(this._currentMaterial) ? [...this._currentMaterial] : [this._currentMaterial] : [];
  },
  setMaterial: function(s) {
    const e = (Array.isArray(s) ? s : [s]).filter((o) => o);
    if (this.material == e || e.length === 1 && this.material === e[0]) return [];
    const t = this.material, i = Array.isArray(t) ? [...t] : [t];
    let n = [];
    const r = [];
    for (const o of i)
      o && n.push(o);
    const a = [];
    for (const o of e)
      o && (o.assetType || (console.warn("Upgrading Material", o), ge.upgradeMaterial.call(o)), n.includes(o) ? n = n.filter((l) => l !== o) : r.push(o), a.push(o));
    for (const o of n)
      o.appliedMeshes && (o.appliedMeshes.delete(this), o.dispose(!1)), o.dispatchEvent({ type: "removeFromMesh", object: this });
    for (const o of r)
      o.appliedMeshes && o.appliedMeshes.add(this), o.dispatchEvent({ type: "addToMesh", object: this });
    this._currentMaterial = a.length ? a.length !== 1 ? a : a[0] || null : null, this.dispatchEvent({ type: "materialChanged", material: this._currentMaterial ?? null, oldMaterial: t ?? null, object: this, bubbleToParent: !0 }), this.refreshUi();
  },
  setMaterials: function(s) {
    this.material = s || void 0;
  },
  initGeometry: function() {
    const s = this.geometry;
    this._currentGeometry = null, delete this.geometry, Object.defineProperty(this, "geometry", {
      get: ct.getGeometry,
      set: ct.setGeometry
    }), this.geometry = s, this.setGeometry || (this.setGeometry = (e) => {
      const t = this.geometry;
      return console.error("setGeometry is deprecated, use geometry property directly"), this.geometry = e, t;
    }), this.userData.setGeometry && console.error("userData.setGeometry already defined"), this.userData.setGeometry = (e) => {
      console.error("userData.setGeometry is deprecated, use setGeometry directly"), this.geometry = e;
    };
  },
  getGeometry: function() {
    return this._currentGeometry || void 0;
  },
  setGeometry: function(s) {
    const e = this.geometry || void 0;
    e !== s && (e && (this._onGeometryUpdate && e.removeEventListener("geometryUpdate", this._onGeometryUpdate), e.appliedMeshes && (e.appliedMeshes.delete(this), e.dispose(!1))), s && (s.assetType || ai.upgradeGeometry.call(s)), this._currentGeometry = s || null, s && (this.updateMorphTargets(), this._onGeometryUpdate && s.addEventListener("geometryUpdate", this._onGeometryUpdate), s.appliedMeshes && s.appliedMeshes.add(this)), this.dispatchEvent({ type: "geometryChanged", geometry: s ?? null, oldGeometry: e, bubbleToParent: !0, object: this }), this.refreshUi());
  },
  refreshUi: function() {
    var s, e;
    (e = (s = this.uiConfig) == null ? void 0 : s.uiRefresh) == null || e.call(s, !0, "postFrame", 1);
  },
  dispatchEvent: (s) => function(e) {
    var t, i;
    if (!(e.target && e.target !== this && this.acceptChildEvents === !1)) {
      if (e.bubbleToParent || (i = (t = this.userData) == null ? void 0 : t.__autoBubbleToParentEvents) != null && i.includes(e.type)) {
        const n = this.parentRoot || this.parent;
        this.parentRoot !== this && (n == null || n.dispatchEvent(e));
      }
      s.call(this, e);
    }
  },
  clone: (s) => function(...e) {
    const t = this.userData;
    this.userData = {};
    const i = s.call(this, ...e);
    this.userData = t, hg(i.userData, t);
    const n = this.parentRoot || void 0;
    return n && n.assetType !== "model" && console.warn("Cloning an IObject with a parent that is not an 'model' is not supported"), ct.upgradeObject3D.call(i, n, this.objectProcessor), i.userData.cloneParent = this.uuid, i;
  },
  copy: (s) => function(e, ...t) {
    const i = this.isLight ? this.target : null, n = e.userData;
    e.userData = {};
    const r = this.userData;
    return s.call(this, e, ...t), this.userData = r, e.userData = n, hg(this.userData, e.userData), i && this.target && (i.position.copy(this.target.position), i.updateMatrixWorld(), this.target = i), this;
  },
  add: (s) => function(...e) {
    if (this.autoUpgradeChildren !== !1)
      for (const t of e) ct.upgradeObject3D.call(t, this.parentRoot || this, this.objectProcessor);
    return s.call(this, ...e);
  },
  dispose: (s) => function(e = !0) {
    e && this.parent && (this.removeFromParent(), delete this.parentRoot), this.dispatchEvent({ type: "dispose", bubbleToParent: !1 });
    for (const t of [...this.children]) t != null && t.dispose && t.dispose(!1);
    s == null || s.call(this);
  }
};
function ZE(s, e) {
  var t, i;
  if (!this) return this;
  if (this.userData || (this.userData = {}), this.userData.uuid = this.uuid, this.userData.__objectSetup) return this;
  if (this.userData.__objectSetup = !0, this.objectProcessor || (this.objectProcessor = e || ((t = this.parent) == null ? void 0 : t.objectProcessor) || (s == null ? void 0 : s.objectProcessor)), this.userData.__autoBubbleToParentEvents || (this.userData.__autoBubbleToParentEvents = ["select"]), this.isLight ? this.assetType = "light" : this.isCamera ? this.assetType = "camera" : this.isWidget ? this.assetType = "widget" : this.assetType = "model", s && (this.parentRoot = s), this.dispatchEvent = ct.dispatchEvent(this.dispatchEvent), this.dispose = ct.dispose(this.dispose), this.clone = ct.clone(this.clone), this.copy = ct.copy(this.copy), this.add = ct.add(this.add), this.setDirty || (this.setDirty = ct.setDirty), this.refreshUi || (this.refreshUi = ct.refreshUi), this.autoScale || (this.autoScale = ct.autoScale.bind(this)), this.autoCenter || (this.autoCenter = ct.autoCenter.bind(this)), this.pivotToBoundsCenter || (this.pivotToBoundsCenter = ct.pivotToBoundsCenter.bind(this)), this.pivotToPoint || (this.pivotToPoint = ct.pivotToPoint.bind(this)), this.addEventListener("added", ct.eventCallbacks.onAddedToParent), this.addEventListener("removed", ct.eventCallbacks.onRemovedFromParent), (this.isMesh || this.isLine) && !this.userData.__meshSetup) {
    if (this.userData.__meshSetup = !0, this._onGeometryUpdate = (n) => ct.eventCallbacks.onGeometryUpdate.call(this, n), ct.initMaterial.call(this), ct.initGeometry.call(this), !this.userData.__keepShadowDef) {
      const n = Array.isArray(this.material) ? this.material[0] : this.material;
      this.castShadow = !n || !n.transparent && !n.transmission, this.receiveShadow = !0, this.userData.__keepShadowDef = !0;
    }
    this.addEventListener("dispose", () => {
      var n;
      (this.materials || [this.material]).forEach((r) => r == null ? void 0 : r.dispose(!1)), (n = this.geometry) == null || n.dispose(!1);
    });
  }
  if (!this.uiConfig && (this.assetType === "model" || this.assetType === "camera") && ct.makeUiConfig.call(this), this.autoUpgradeChildren !== !1) {
    const n = [...this.children];
    for (const r of n) ZE.call(r, this);
  }
  return !this.userData.dispose && (this.userData.dispose = () => {
    console.warn("userData.dispose is deprecated, use dispose directly"), this.dispose && this.dispose();
  }), !this.modelObject && Object.defineProperty(this, "modelObject", {
    get: () => (console.error("modelObject is deprecated, use object directly"), this)
  }), !this.userData.setDirty && (this.userData.setDirty = (n) => {
    var r;
    console.error("object.userData.setDirty is deprecated, use object.setDirty directly"), (r = this.setDirty) == null || r.call(this, n);
  }), (i = this.objectProcessor) == null || i.processObject(this), this;
}
const Zi = {
  setDirty: function(s) {
    this.controls && this.controls.target && this.controls.enabled !== !1 && this.target !== this.controls.target ? this.controls.target.copy(this.target) : this.userData.autoLookAtTarget && this.lookAt(this.target), this.dispatchEvent({ ...s, type: "update", bubbleToParent: !1, camera: this }), this.dispatchEvent({ ...s, type: "cameraUpdate", bubbleToParent: !0, camera: this }), ct.setDirty.call(this, { refreshScene: !1, ...s });
  },
  activateMain: function(s = {}, e = !1, t = !0, i) {
    if (!e)
      return s.camera === null ? this.deactivateMain(s, e, t) : this.dispatchEvent({
        type: "activateMain",
        ...s,
        camera: this,
        bubbleToParent: !0
      });
    this.userData.__isMainCamera || (this.userData.__isMainCamera = !0, this.userData.__lastScale = this.scale.clone(), this.scale.divide(this.getWorldScale(new M())), i ? this.setCanvas(i, t) : t && (this.refreshCameraControls(!1), this.refreshAspect(!1)), this.setDirty({ change: "activateMain", ...s }));
  },
  deactivateMain: function(s = {}, e = !1, t = !0, i = !1) {
    if (!e) return this.dispatchEvent({
      type: "activateMain",
      ...s,
      camera: null,
      bubbleToParent: !0
    });
    this.userData.__isMainCamera && (this.userData.__isMainCamera = !1, this.userData.__lastScale && (this.scale.copy(this.userData.__lastScale), delete this.userData.__lastScale), i ? this.setCanvas(void 0, t) : t && this.refreshCameraControls(!1), t && this.refreshCameraControls(!1), this.setDirty({ change: "deactivateMain", ...s }));
  },
  refreshUi: function() {
    var s, e;
    (e = (s = this.uiConfig) == null ? void 0 : s.uiRefresh) == null || e.call(s, !0, "postFrame", 1);
  },
  refreshTarget: function(s = 4, e = !0) {
    var t;
    (t = this.controls) != null && t.enabled && this.controls.target ? this.controls.target !== this.target && this.target.copy(this.controls.target) : this.getWorldDirection(this.target).multiplyScalar(s).add(this.getWorldPosition(new M())), e && this.setDirty({ change: "target" });
  },
  upgradeCamera: TL,
  copy: (s) => function(e, t, i, n, ...r) {
    var a, o;
    if (!e.isCamera)
      return console.error("ICamera.copy: camera is not a Camera", e), this;
    if (s.call(this, e, t, ...r), (a = e.target) != null && a.isVector3) this.target.copy(e.target);
    else {
      const l = ((o = this.controls) == null ? void 0 : o.minDistance) ?? i ?? 4;
      e.getWorldDirection(this.target).multiplyScalar(l).add(this.getWorldPosition(new M()));
    }
    if (n) {
      const l = e.getWorldPosition(this.position);
      this.parent && this.position.copy(this.parent.worldToLocal(l));
    }
    return this.updateMatrixWorld(!0), this.updateProjectionMatrix(), this.refreshAspect(!1), this.setDirty(), this;
  }
};
function TL() {
  if (!this.isCamera) {
    console.error("Object is not a camera", this);
    return;
  }
  this.userData.__cameraSetup || (this.userData.__cameraSetup = !0, ct.upgradeObject3D.call(this), this.copy = Zi.copy(this.copy), this.target || (this.target = new M()), this.refreshTarget || (this.refreshTarget = Zi.refreshTarget), this.activateMain || (this.activateMain = Zi.activateMain), this.deactivateMain || (this.deactivateMain = Zi.deactivateMain), this.refreshUi || (this.refreshUi = Zi.refreshUi), this.setDirty || (this.setDirty = Zi.setDirty), this.assetType = "camera");
}
var IL = Object.defineProperty, DL = Object.getOwnPropertyDescriptor, Ls = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? DL(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && IL(e, t, n), n;
};
let hn = class extends Vi {
  constructor(s, e, t, i, n, r = 1) {
    super(), this.uuid = Ss(), this.name = "Camera View", this.position = new M(), this.target = new M(), this.quaternion = new rt(), this.zoom = 1, this.duration = 1, this.isWorldSpace = !0, this.set = (a) => this.dispatchEvent({ type: "setView", camera: a, view: this }), this.update = (a) => this.dispatchEvent({ type: "updateView", camera: a, view: this }), this.delete = (a) => this.dispatchEvent({ type: "deleteView", camera: a, view: this }), this.animate = (a, o) => this.dispatchEvent({ type: "animateView", camera: a, duration: o, view: this }), s !== void 0 && (this.name = s), e && this.position.copy(e), t && this.target.copy(t), i && this.quaternion.copy(i), n !== void 0 && (this.zoom = n), r !== void 0 && r !== 0 && (this.duration = r);
  }
  _nameChanged() {
    var s, e;
    this.uiConfig && (this.uiConfig.label = this.name, (e = (s = this.uiConfig).uiRefresh) == null || e.call(s));
  }
  clone() {
    return new hn(this.name, this.position, this.target, this.quaternion, this.zoom);
  }
  // uiConfig = generateUiFolder(this.name, this)
};
Ls([
  Oe(hn.prototype._nameChanged),
  V(),
  pt()
], hn.prototype, "name", 2);
Ls([
  V(),
  Ji()
], hn.prototype, "position", 2);
Ls([
  V(),
  Ji()
], hn.prototype, "target", 2);
Ls([
  V(),
  Ji()
], hn.prototype, "quaternion", 2);
Ls([
  V(),
  ii()
], hn.prototype, "zoom", 2);
Ls([
  V(),
  ii()
], hn.prototype, "duration", 2);
Ls([
  V()
], hn.prototype, "isWorldSpace", 2);
Ls([
  Pt()
], hn.prototype, "set", 2);
Ls([
  Pt()
], hn.prototype, "update", 2);
Ls([
  Pt()
], hn.prototype, "delete", 2);
Ls([
  Pt()
], hn.prototype, "animate", 2);
hn = Ls([
  $w("CameraView"),
  Tn("Camera View")
], hn);
var RL = Object.defineProperty, un = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && RL(e, t, n), n;
};
const fi = class extends ki {
  // bound to userData so that it's saved in the glb.
  constructor(e, t, i, n, r) {
    super(n, r), this.assetType = "camera", this._currentControlsMode = "", this.userData = {}, this.target = new M(0, 0, 0), this.near = 0.01, this.far = 50, this.autoLookAtTarget = !1, this.autoNearFar = !0, this.minNearPlane = 0.5, this.maxFarPlane = 1e3, this.dollyFov = !1, this._interactionsDisabledBy = /* @__PURE__ */ new Set(), this.refreshUi = Zi.refreshUi, this.refreshTarget = Zi.refreshTarget, this.activateMain = Zi.activateMain, this.deactivateMain = Zi.deactivateMain, this._controlsCtors = /* @__PURE__ */ new Map([["orbit", (a, o) => {
      const l = o ? o.ownerDocument ? o : o.documentElement : document.body, c = new jt(a, l);
      return l.tabIndex === -1 && (l.tabIndex = 1e3, l.style.outline = "none"), c.listenToKeyEvents(l), c.screenSpacePanning = !0, c;
    }]]), this._controlsChanged = () => {
      this._controls && this._controls.target && this.refreshTarget(void 0, !1), this.setDirty({ change: "controls" });
    }, this._positionWorld = new M(), this._camUi = [
      ...mr(this) || [],
      {
        type: "input",
        label: () => (this.autoNearFar ? "Min" : "") + " Near",
        property: [this, "minNearPlane"]
      },
      {
        type: "input",
        label: () => (this.autoNearFar ? "Max" : "") + " Far",
        property: [this, "maxFarPlane"]
      },
      {
        type: "input",
        label: "Auto Near Far",
        property: [this, "autoNearFar"]
      },
      {
        type: "input",
        label: "Dolly FoV",
        property: [this, "dollyFov"]
      },
      () => ({
        // because _controlsCtors can change
        type: "dropdown",
        label: "Controls Mode",
        property: [this, "controlsMode"],
        children: ["", "orbit", ...this._controlsCtors.keys()].map((a) => ({ label: a === "" ? "none" : a, value: a })),
        onChange: () => this.refreshCameraControls()
      }),
      () => ay.call(this, this.uiConfig)
    ], this.uiConfig = {
      type: "folder",
      label: () => this.name || "Camera",
      children: [
        ...this._camUi,
        // todo hack for zoom in and out for now.
        () => {
          var a;
          return (a = this._controls) != null && a.zoomIn ? {
            type: "button",
            label: "Zoom in",
            value: () => {
              var o;
              return (o = this._controls) == null ? void 0 : o.zoomIn(1);
            }
          } : {};
        },
        () => {
          var a;
          return (a = this._controls) != null && a.zoomOut ? {
            type: "button",
            label: "Zoom out",
            value: () => {
              var o;
              return (o = this._controls) == null ? void 0 : o.zoomOut(1);
            }
          } : {};
        },
        () => {
          var a;
          return (a = this._controls) == null ? void 0 : a.uiConfig;
        }
      ]
    }, this._canvas = t, this.autoAspect = i ?? !!t, Zi.upgradeCamera.call(this), this.controlsMode = e || "", this.refreshTarget(void 0, !1), this.setDirty();
  }
  get controls() {
    return this._controls;
  }
  get isMainCamera() {
    return this.userData && this.userData.__isMainCamera || !1;
  }
  /**
   * If interactions are enabled for this camera. It can be disabled by some code or plugin.
   * see also {@link setInteractions}
   * @deprecated use {@link canUserInteract} to check if the user can interact with this camera
   * @readonly
   */
  get interactionsEnabled() {
    return this._interactionsDisabledBy.size === 0;
  }
  setInteractions(e, t, i = !0) {
    const n = this._interactionsDisabledBy.size;
    e ? this._interactionsDisabledBy.delete(t) : this._interactionsDisabledBy.add(t), n !== this._interactionsDisabledBy.size && this.refreshCameraControls(i);
  }
  get canUserInteract() {
    return this._interactionsDisabledBy.size === 0 && this.isMainCamera && this.controlsMode !== "";
  }
  // endregion
  // region refreshing
  setDirty(e) {
    if (!this._positionWorld) return;
    const t = typeof e == "string" ? e : e == null ? void 0 : e.key;
    (!t || t === "fov" || t === "zoom") && this.updateProjectionMatrix(), typeof e == "string" && (e = void 0), this.getWorldPosition(this._positionWorld), Zi.setDirty.call(this, e), (e == null ? void 0 : e.last) !== !1 && this._camUi.forEach((i) => {
      var n;
      return (n = i == null ? void 0 : i.uiRefresh) == null ? void 0 : n.call(i, !1, "postFrame", 1);
    });
  }
  /**
   * when aspect ratio is set to auto it must be refreshed on resize, this is done by the viewer for the main camera.
   * @param setDirty
   */
  refreshAspect(e = !0) {
    if (this.autoAspect)
      if (!this._canvas) console.error("PerspectiveCamera2: cannot calculate aspect ratio without canvas/container");
      else {
        let t = this._canvas.clientWidth / this._canvas.clientHeight;
        isFinite(t) || (t = 1), this.aspect = t, this.updateProjectionMatrix && this.updateProjectionMatrix();
      }
    e && this.setDirty();
  }
  _nearFarChanged() {
    this.view !== void 0 && this.updateProjectionMatrix && this.updateProjectionMatrix();
  }
  setControlsCtor(e, t, i = !1) {
    if (!i && this._controlsCtors.has(e)) {
      console.error("PerspectiveCamera2: " + e + " already exists.");
      return;
    }
    this._controlsCtors.set(e, t);
  }
  removeControlsCtor(e) {
    this._controlsCtors.delete(e);
  }
  _initCameraControls() {
    var t, i;
    const e = this.controlsMode;
    this._controls = ((t = this._controlsCtors.get(e)) == null ? void 0 : t(this, this._canvas)) ?? void 0, !this._controls && e !== "" && console.error("PerspectiveCamera2 - Unable to create controls with mode " + e + ". Are you missing a plugin?"), (i = this._controls) == null || i.addEventListener("change", this._controlsChanged), this._currentControlsMode = this._controls ? e : "";
  }
  _disposeCameraControls() {
    var e, t;
    this._controls && (this._controls.target === this.target && (this._controls.target = new M()), (e = this._controls) == null || e.removeEventListener("change", this._controlsChanged), (t = this._controls) == null || t.dispose()), this._currentControlsMode = "", this._controls = void 0;
  }
  refreshCameraControls(e = !0) {
    if (this._controlsCtors) {
      if (this._controls ? (this._currentControlsMode !== this.controlsMode || this !== this._controls.object || this._controls.domElement && this._canvas !== this._controls.domElement) && (this._disposeCameraControls(), this._initCameraControls()) : this._initCameraControls(), this._controls) {
        const t = this.canUserInteract;
        this._controls.enabled = t, t && this.up.copy(ut.DEFAULT_UP);
      }
      e && this.setDirty(), this.refreshUi();
    }
  }
  // endregion
  // region serialization
  /**
   * Serializes this camera with controls to JSON.
   * @param meta - metadata for serialization
   * @param baseOnly - Calls only super.toJSON, does internal three.js serialization. Set it to true only if you know what you are doing.
   */
  toJSON(e, t = !1) {
    return t ? super.toJSON(e) : mt.Serialize(this, e, !0);
  }
  fromJSON(e, t) {
    if ((e.camOptions || e.aspect === "auto") && (e = { ...e }), e.camOptions) {
      const i = e.camOptions;
      i.fov && (e.fov = i.fov), i.focus && (e.focus = i.focus), i.zoom && (e.zoom = i.zoom), i.aspect && (e.aspect = i.aspect), i.controlsMode && (e.controlsMode = i.controlsMode), delete e.camOptions;
    }
    return e.aspect === "auto" && (e.aspect = this.aspect, this.autoAspect = !0), mt.Deserialize(e, this, t, !0), this.setDirty({ change: "deserialize" }), this;
  }
  // endregion
  // region camera views
  getView(e = !0, t) {
    var o, l;
    const i = new M();
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld;
    i.x = n.elements[4], i.y = n.elements[5], i.z = n.elements[6], i.normalize();
    const r = t || new hn();
    r.name = this.name, r.position.copy(this.position), r.target.copy(this.target), r.quaternion.copy(this.quaternion), r.zoom = this.zoom;
    const a = this.parent;
    return a && (e ? (r.position.applyMatrix4(a.matrixWorld), this.getWorldQuaternion(r.quaternion)) : i.transformDirection(a.matrixWorld.clone().invert())), r.isWorldSpace = e, (l = (o = r.uiConfig) == null ? void 0 : o.uiRefresh) == null || l.call(o, !0, "postFrame"), r;
  }
  setView(e) {
    this.position.copy(e.position), this.target.copy(e.target), this.quaternion.copy(e.quaternion), this.zoom = e.zoom, this.setDirty();
  }
  setViewFromCamera(e, t, i = !0) {
    this.copy(e, void 0, t, i);
  }
  setViewToMain(e) {
    this.dispatchEvent({ type: "setView", ...e, camera: this, bubbleToParent: !0 });
  }
  /**
   * See also cameraHelpers.glsl
   * @param material
   */
  updateShaderProperties(e) {
    var t, i, n, r;
    return (i = (t = e.uniforms.cameraPositionWorld) == null ? void 0 : t.value) == null || i.copy(this._positionWorld), (r = (n = e.uniforms.cameraNearFar) == null ? void 0 : n.value) == null || r.set(this.near, this.far), e.uniforms.projection && (e.uniforms.projection.value = this.projectionMatrix), e.defines.PERSPECTIVE_CAMERA = this.type === "PerspectiveCamera" ? "1" : "0", this;
  }
  dispose() {
    this._disposeCameraControls();
  }
  setCanvas(e, t = !0) {
    this._canvas = e, t && (this.refreshCameraControls(), this.refreshAspect(!1));
  }
  get isActiveCamera() {
    return this.isMainCamera;
  }
  /**
   * @deprecated use `<T>camera.controls` instead
   */
  getControls() {
    return this._controls;
  }
  /**
   * @deprecated use `this` instead
   */
  get cameraObject() {
    return this;
  }
  /**
   * @deprecated use `this` instead
   */
  get modelObject() {
    return this;
  }
  /**
   * @deprecated - use setDirty directly
   * @param setDirty
   */
  targetUpdated(e = !0) {
    e && this.setDirty();
  }
  // endregion
};
un([
  pt("Name")
], fi.prototype, "name");
un([
  V("camControls")
], fi.prototype, "_controls");
un([
  Pi(fi.prototype.refreshCameraControls)
], fi.prototype, "controlsMode");
un([
  V()
], fi.prototype, "userData");
un([
  bt(fi.prototype.setDirty),
  Ye("Field Of View", [1, 180], 1e-3),
  V()
], fi.prototype, "fov");
un([
  bt(fi.prototype.setDirty),
  V()
], fi.prototype, "focus");
un([
  bt(fi.prototype.setDirty),
  ii("FoV Zoom"),
  V()
], fi.prototype, "zoom");
un([
  Ji("Position", void 0, void 0, (s) => ({ onChange: () => s.setDirty() })),
  V()
], fi.prototype, "position");
un([
  Ji("Target", void 0, void 0, (s) => ({ onChange: () => s.setDirty() })),
  V()
], fi.prototype, "target");
un([
  V(),
  Pi(fi.prototype.refreshAspect),
  ue("Auto Aspect")
], fi.prototype, "autoAspect");
un([
  Pi(fi.prototype._nearFarChanged)
], fi.prototype, "near");
un([
  Pi(fi.prototype._nearFarChanged)
], fi.prototype, "far");
un([
  Ht({ obj: "userData", onChange: "setDirty" })
], fi.prototype, "autoLookAtTarget");
un([
  Ht({ obj: "userData", onChange: "setDirty" })
], fi.prototype, "autoNearFar");
un([
  Ht({ obj: "userData", onChange: "setDirty" })
], fi.prototype, "minNearPlane");
un([
  Ht({ obj: "userData", onChange: "setDirty" })
], fi.prototype, "maxFarPlane");
un([
  Ht({ obj: "userData" })
], fi.prototype, "dollyFov");
un([
  Oe((s, e) => {
    e || console.warn("Setting camera invisible is not supported", s, e);
  })
], fi.prototype, "visible");
let mu = fi;
class BL extends mu {
  constructor(e, t, i, n) {
    super(void 0, void 0, void 0, e, t || 1), this.dollyFov = !1, (i || n) && (this.autoNearFar = !1, i && (this.near = i, this.minNearPlane = i), n && (this.far = n, this.maxFarPlane = n));
  }
}
var PL = Object.defineProperty, LL = Object.getOwnPropertyDescriptor, Wi = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? LL(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && PL(e, t, n), n;
};
const Yt = class extends _r {
  constructor(e, t, i, n, r, a, o, l, c, h, u) {
    super(r, a, o, l, c, h), this.assetType = "camera", this._currentControlsMode = "", this.userData = {}, this._frustumSize = void 0, this.target = new M(0, 0, 0), this.near = 0.01, this.far = 50, this.autoLookAtTarget = !1, this.autoNearFar = !0, this.minNearPlane = 0.5, this.maxFarPlane = 1e3, this._interactionsDisabledBy = /* @__PURE__ */ new Set(), this.refreshUi = Zi.refreshUi, this.refreshTarget = Zi.refreshTarget, this.activateMain = Zi.activateMain, this.deactivateMain = Zi.deactivateMain, this._controlsCtors = /* @__PURE__ */ new Map([["orbit", (d, p) => {
      const f = p ? p.ownerDocument ? p : p.documentElement : document.body, y = new jt(d, f);
      return f.tabIndex === -1 && (f.tabIndex = 1e3, f.style.outline = "none"), y.listenToKeyEvents(f), y.screenSpacePanning = !0, y;
    }]]), this._controlsChanged = () => {
      this._controls && this._controls.target && this.refreshTarget(void 0, !1), this.setDirty({ change: "controls" });
    }, this._positionWorld = new M(), this._camUi = [
      ...mr(this) || [],
      {
        type: "input",
        label: () => (this.autoNearFar ? "Min" : "") + " Near",
        property: [this, "minNearPlane"]
      },
      {
        type: "input",
        label: () => (this.autoNearFar ? "Max" : "") + " Far",
        property: [this, "maxFarPlane"]
      },
      () => ({
        // because _controlsCtors can change
        type: "dropdown",
        label: "Controls Mode",
        property: [this, "controlsMode"],
        children: ["", "orbit", ...this._controlsCtors.keys()].map((d) => ({ label: d === "" ? "none" : d, value: d })),
        onChange: () => this.refreshCameraControls()
      }),
      () => ay.call(this, this.uiConfig)
    ], this.uiConfig = {
      type: "folder",
      label: () => this.name || "Camera",
      children: [
        ...this._camUi,
        () => {
          var d;
          return (d = this._controls) == null ? void 0 : d.uiConfig;
        }
      ]
    }, this._canvas = t, this.aspect = u || 1, this._frustumSize = n ?? 4, this.autoAspect = i ?? !!t, Zi.upgradeCamera.call(this), this.controlsMode = e || "", this.refreshTarget(void 0, !1), this.refreshFrustum(!1), this.setDirty();
  }
  get controls() {
    return this._controls;
  }
  get isMainCamera() {
    return this.userData && this.userData.__isMainCamera || !1;
  }
  get frustumSize() {
    return this._frustumSize ?? 0;
  }
  set frustumSize(e) {
    this._frustumSize = e <= 0 ? void 0 : e, this.refreshFrustum(!1), this.setDirty();
  }
  /**
   * If interactions are enabled for this camera. It can be disabled by some code or plugin.
   * see also {@link setInteractions}
   * @deprecated use {@link canUserInteract} to check if the user can interact with this camera
   * @readonly
   */
  get interactionsEnabled() {
    return this._interactionsDisabledBy.size === 0;
  }
  setInteractions(e, t) {
    const i = this._interactionsDisabledBy.size;
    e ? this._interactionsDisabledBy.delete(t) : this._interactionsDisabledBy.add(t), i !== this._interactionsDisabledBy.size && this.refreshCameraControls(!0);
  }
  get canUserInteract() {
    return this._interactionsDisabledBy.size === 0 && this.isMainCamera && this.controlsMode !== "";
  }
  // endregion
  // region refreshing
  setDirty(e) {
    if (!this._positionWorld) return;
    const t = typeof e == "string" ? e : e == null ? void 0 : e.key;
    (!t || ["zoom", "left", "right", "top", "bottom", "aspect", "frustumSize"].includes(t)) && this.updateProjectionMatrix(), typeof e == "string" && (e = void 0), this.getWorldPosition(this._positionWorld), Zi.setDirty.call(this, e), (e == null ? void 0 : e.last) !== !1 && this._camUi.forEach((i) => {
      var n;
      return (n = i == null ? void 0 : i.uiRefresh) == null ? void 0 : n.call(i, !1, "postFrame", 1);
    });
  }
  /**
   * when aspect ratio is set to auto it must be refreshed on resize, this is done by the viewer for the main camera.
   * @param setDirty
   */
  refreshAspect(e = !0) {
    if (this.autoAspect)
      if (!this._canvas) console.error("OrthographicCamera2: cannot calculate aspect ratio without canvas/container");
      else {
        let t = this._canvas.clientWidth / this._canvas.clientHeight;
        isFinite(t) || (t = 1), this.aspect = t, this.refreshFrustum(!1);
      }
    e && this.setDirty();
  }
  _nearFarChanged() {
    this.view !== void 0 && this.updateProjectionMatrix && this.updateProjectionMatrix();
  }
  refreshFrustum(e = !0) {
    this._frustumSize !== void 0 && (this.top = this._frustumSize / 2, this.bottom = -this.top, this.left = this.bottom * this.aspect, this.right = this.top * this.aspect, e && this.setDirty());
  }
  setControlsCtor(e, t, i = !1) {
    if (!i && this._controlsCtors.has(e)) {
      console.error("OrthographicCamera2: " + e + " already exists.");
      return;
    }
    this._controlsCtors.set(e, t);
  }
  removeControlsCtor(e) {
    this._controlsCtors.delete(e);
  }
  _initCameraControls() {
    var t, i;
    const e = this.controlsMode;
    this._controls = ((t = this._controlsCtors.get(e)) == null ? void 0 : t(this, this._canvas)) ?? void 0, !this._controls && e !== "" && console.error("OrthographicCamera2 - Unable to create controls with mode " + e + ". Are you missing a plugin?"), (i = this._controls) == null || i.addEventListener("change", this._controlsChanged), this._currentControlsMode = this._controls ? e : "";
  }
  _disposeCameraControls() {
    var e, t;
    this._controls && (this._controls.target === this.target && (this._controls.target = new M()), (e = this._controls) == null || e.removeEventListener("change", this._controlsChanged), (t = this._controls) == null || t.dispose()), this._currentControlsMode = "", this._controls = void 0;
  }
  refreshCameraControls(e = !0) {
    if (this._controlsCtors) {
      if (this._controls ? (this._currentControlsMode !== this.controlsMode || this !== this._controls.object || this._controls.domElement && this._canvas !== this._controls.domElement) && (this._disposeCameraControls(), this._initCameraControls()) : this._initCameraControls(), this._controls) {
        const t = this.canUserInteract;
        this._controls.enabled = t, t && this.up.copy(ut.DEFAULT_UP);
      }
      e && this.setDirty(), this.refreshUi();
    }
  }
  // endregion
  // region serialization
  /**
   * Serializes this camera with controls to JSON.
   * @param meta - metadata for serialization
   * @param baseOnly - Calls only super.toJSON, does internal three.js serialization. Set it to true only if you know what you are doing.
   */
  toJSON(e, t = !1) {
    return t ? super.toJSON(e) : mt.Serialize(this, e, !0);
  }
  fromJSON(e, t) {
    return mt.Deserialize(e, this, t, !0), this.setDirty({ change: "deserialize" }), this;
  }
  // endregion
  // region camera views
  getView(e = !0, t) {
    var o, l;
    const i = new M();
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld;
    i.x = n.elements[4], i.y = n.elements[5], i.z = n.elements[6], i.normalize();
    const r = t || new hn();
    r.name = this.name, r.position.copy(this.position), r.target.copy(this.target), r.quaternion.copy(this.quaternion), r.zoom = this.zoom;
    const a = this.parent;
    return a && (e ? (r.position.applyMatrix4(a.matrixWorld), this.getWorldQuaternion(r.quaternion)) : i.transformDirection(a.matrixWorld.clone().invert())), r.isWorldSpace = e, (l = (o = r.uiConfig) == null ? void 0 : o.uiRefresh) == null || l.call(o, !0, "postFrame"), r;
  }
  setView(e) {
    this.position.copy(e.position), this.target.copy(e.target), this.quaternion.copy(e.quaternion), this.zoom = e.zoom, this.setDirty();
  }
  setViewFromCamera(e, t, i = !0) {
    this.copy(e, void 0, t, i);
  }
  setViewToMain(e) {
    this.dispatchEvent({ type: "setView", ...e, camera: this, bubbleToParent: !0 });
  }
  /**
   * See also cameraHelpers.glsl
   * @param material
   */
  updateShaderProperties(e) {
    var t, i, n, r;
    return (i = (t = e.uniforms.cameraPositionWorld) == null ? void 0 : t.value) == null || i.copy(this._positionWorld), (r = (n = e.uniforms.cameraNearFar) == null ? void 0 : n.value) == null || r.set(this.near, this.far), e.uniforms.projection && (e.uniforms.projection.value = this.projectionMatrix), e.defines.PERSPECTIVE_CAMERA = this.type === "OrthographicCamera" ? "1" : "0", e.defines.ORTHOGRAPHIC_CAMERA = this.type === "OrthographicCamera" ? "1" : "0", this;
  }
  dispose() {
    this._disposeCameraControls();
  }
  setCanvas(e, t = !0) {
    this._canvas = e, t && (this.refreshCameraControls(), this.refreshAspect(!1));
  }
  get isActiveCamera() {
    return this.isMainCamera;
  }
  /**
   * @deprecated use `<T>camera.controls` instead
   */
  getControls() {
    return this._controls;
  }
  /**
   * @deprecated use `this` instead
   */
  get cameraObject() {
    return this;
  }
  /**
   * @deprecated use `this` instead
   */
  get modelObject() {
    return this;
  }
  /**
   * @deprecated - use setDirty directly
   * @param setDirty
   */
  targetUpdated(e = !0) {
    e && this.setDirty();
  }
  // endregion
};
Wi([
  pt("Name")
], Yt.prototype, "name", 2);
Wi([
  V("camControls")
], Yt.prototype, "_controls", 2);
Wi([
  Pi(Yt.prototype.refreshCameraControls)
], Yt.prototype, "controlsMode", 2);
Wi([
  V()
], Yt.prototype, "userData", 2);
Wi([
  bt(Yt.prototype.setDirty),
  ii("Zoom"),
  V()
], Yt.prototype, "zoom", 2);
Wi([
  bt(Yt.prototype.setDirty),
  ii("Left", (s) => ({ hidden: () => s._frustumSize !== void 0 })),
  V()
], Yt.prototype, "left", 2);
Wi([
  bt(Yt.prototype.setDirty),
  ii("Right", (s) => ({ hidden: () => s._frustumSize !== void 0 })),
  V()
], Yt.prototype, "right", 2);
Wi([
  bt(Yt.prototype.setDirty),
  ii("Top", (s) => ({ hidden: () => s._frustumSize !== void 0 })),
  V()
], Yt.prototype, "top", 2);
Wi([
  bt(Yt.prototype.setDirty),
  ii("Bottom", (s) => ({ hidden: () => s._frustumSize !== void 0 })),
  V()
], Yt.prototype, "bottom", 2);
Wi([
  pt(
    "Frustum Size"
    /* , (t)=>({hidden: ()=>t.frustumSize === undefined})*/
  )
], Yt.prototype, "frustumSize", 1);
Wi([
  Ji("Position", void 0, void 0, (s) => ({ onChange: () => s.setDirty() })),
  V()
], Yt.prototype, "position", 2);
Wi([
  Ji("Target", void 0, void 0, (s) => ({ onChange: () => s.setDirty() })),
  V()
], Yt.prototype, "target", 2);
Wi([
  V(),
  Pi(Yt.prototype.refreshAspect),
  ue("Auto Aspect")
], Yt.prototype, "autoAspect", 2);
Wi([
  V(),
  Pi(Yt.prototype.refreshAspect),
  ue("Aspect Ratio", (s) => ({ disabled: () => s.autoAspect }))
], Yt.prototype, "aspect", 2);
Wi([
  Pi(Yt.prototype._nearFarChanged)
], Yt.prototype, "near", 2);
Wi([
  Pi(Yt.prototype._nearFarChanged)
], Yt.prototype, "far", 2);
Wi([
  Ht({ obj: "userData", onChange: "setDirty" })
], Yt.prototype, "autoLookAtTarget", 2);
Wi([
  Ht({ obj: "userData", onChange: "setDirty" })
], Yt.prototype, "autoNearFar", 2);
Wi([
  Ht({ obj: "userData", onChange: "setDirty" })
], Yt.prototype, "minNearPlane", 2);
Wi([
  Ht({ obj: "userData", onChange: "setDirty" })
], Yt.prototype, "maxFarPlane", 2);
Wi([
  Oe((s, e) => {
    e || console.warn("Setting camera invisible is not supported", s, e);
  })
], Yt.prototype, "visible", 2);
let eb = Yt;
class Hz extends eb {
  constructor(e, t, i, n, r, a) {
    super(void 0, void 0, void 0, void 0, e, t, i, n, r, a, 1), (r !== void 0 || a) && (this.autoNearFar = !1, r && (this.near = r, this.minNearPlane = r), a && (this.far = a, this.maxFarPlane = a));
  }
}
const Bh = class Bh extends ln {
  constructor({ customMaterialExtensions: e, ...t } = {}, i = !1) {
    super(), this.assetType = "material", this.isAShaderMaterial = !0, this.appliedMeshes = /* @__PURE__ */ new Set(), this.setDirty = ge.setDirty, this.type = "ShaderMaterial", this.materialExtensions = [], this.extraUniformsToUpload = {}, this.registerMaterialExtensions = ge.registerMaterialExtensions, this.unregisterMaterialExtensions = ge.unregisterMaterialExtensions, this.isRawShaderMaterial = i, i && (this.type = "RawShaderMaterial"), e && this.registerMaterialExtensions(e), ge.upgradeMaterial.call(this), this.setValues(t);
  }
  dispose() {
    return ge.dispose(super.dispose).call(this);
  }
  clone(e = !1) {
    return ge.clone(super.clone).call(this, e);
  }
  dispatchEvent(e) {
    ge.dispatchEvent(super.dispatchEvent).call(this, e);
  }
  customProgramCacheKey() {
    return super.customProgramCacheKey() + ge.customProgramCacheKey.call(this);
  }
  onBeforeCompile(e, t) {
    ge.onBeforeCompile.call(this, e, t), super.onBeforeCompile(e, t);
  }
  onBeforeRender(e, t, i, n, r) {
    super.onBeforeRender(e, t, i, n, r), ge.onBeforeRender.call(this, e, t, i, n, r);
  }
  onAfterRender(e, t, i, n, r) {
    super.onAfterRender(e, t, i, n, r), ge.onAfterRender.call(this, e, t, i, n, r);
  }
  // endregion
  /**
   * Sets the values of this material based on the values of the passed material or an object with material properties
   * The input is expected to be a valid material or a deserialized material parameters object(including the deserialized userdata)
   * @param parameters - material or material parameters object
   */
  setValues(e) {
    return ge.setValues(super.setValues).call(this, e);
  }
  toJSON(e) {
    throw new Error("Method not supported for this material.");
  }
  fromJSON(e, t) {
    throw new Error("Method not supported for this material.");
  }
  /**
   * @deprecated use this directly
   */
  get materialObject() {
    return this;
  }
};
Bh.TypeSlug = "shaderMat", Bh.TYPE = "ShaderMaterial2", Bh.MaterialProperties = {
  ...Na,
  fragmentShader: "",
  vertexShader: "",
  uniforms: {},
  defines: {},
  extensions: {},
  isRawShaderMaterial: !1,
  uniformsGroups: {},
  wireframe: !1,
  wireframeLinewidth: 1,
  clipping: !1,
  lights: !1,
  fog: !1,
  glslVersion: null,
  defaultAttributeValues: {}
};
let gp = Bh;
class UL extends gp {
  constructor(e, t, i = !1) {
    super(e, i), this.textures = [], this.setTextureIds(t);
  }
  setTextureIds(e) {
    this.textures.map((t) => t.id).join(";") !== e.join(";") && (this.textures = e.map((t) => ({ id: t, colorSpace: Mt })), this.setDirty());
  }
  _setUniformTexSize(e, t) {
    if (!t || !e) return;
    const i = (t == null ? void 0 : t.width) ?? 512, n = (t == null ? void 0 : t.height) ?? 512, r = e.value;
    r.isVector2 || console.warn("uniform is not a Vector2"), r && Math.abs(r.x - i) + Math.abs(r.y - n) > 0.1 && (r.x = i, r.y = n, this.uniformsNeedUpdate = !0);
  }
  onBeforeRender(e, t, i, n, r) {
    var a;
    this.uniforms.screenSize && this._setUniformTexSize(this.uniforms.screenSize, e.getRenderTarget() ?? e.getSize(new ie()));
    for (const o of this.textures) {
      const l = o.id, c = (a = this.uniforms[l]) == null ? void 0 : a.value;
      c && (this._setUniformTexSize(this.uniforms[l + "Size"], c.image), c.colorSpace !== o.colorSpace && (o.colorSpace = c.colorSpace, this.needsUpdate = !0));
    }
    super.onBeforeRender(e, t, i, n, r);
  }
  onBeforeCompile(e, t) {
    const i = `
` + this.textures.map((n) => `uniform sampler2D ${n.id}; 
` + lE(n.id ?? "input", n.colorSpace)).join(`
`);
    e.fragmentShader.includes("#include <encodings_pars_fragment>") ? e.fragmentShader = Ct(e.fragmentShader, "#include <encodings_pars_fragment>", i, { append: !0 }) : e.fragmentShader.includes("precision highp float;") ? e.fragmentShader = Ct(e.fragmentShader, "precision highp float;", i, { append: !0 }) : e.fragmentShader = i + e.fragmentShader, super.onBeforeCompile(e, t);
  }
  customProgramCacheKey() {
    return super.customProgramCacheKey() + this.textures.map((e) => e.id + e.colorSpace).join(";");
  }
}
const Hs = class Hs extends ln {
  // envMap: ITexture | null = null
  constructor({ customMaterialExtensions: e, ...t } = {}) {
    super(), this.assetType = "material", this.isObjectShaderMaterial = !0, this.appliedMeshes = /* @__PURE__ */ new Set(), this.setDirty = ge.setDirty, this.materialExtensions = [], this.extraUniformsToUpload = {}, this.registerMaterialExtensions = ge.registerMaterialExtensions, this.unregisterMaterialExtensions = ge.unregisterMaterialExtensions, this.onBeforeRender = ge.onBeforeRenderOverride(super.onBeforeRender), this.onAfterRender = ge.onAfterRenderOverride(super.onAfterRender), this.uiConfig = {
      type: "folder",
      label: "Shader Material",
      uuid: "OSM2_" + this.uuid,
      expanded: !0,
      onChange: (i) => {
        !i.config || i.config.onChange || this.setDirty({ uiChangeEvent: i, needsUpdate: !!i.last, refreshUi: !!i.last });
      },
      children: [
        ...mr(this),
        ...Ut.base(this),
        Ut.blending(this),
        Ut.polygonOffset(this),
        ...Ut.misc(this)
      ]
    }, !this.defines && (this.defines = {}), this.fog = !1, this.setDirty = this.setDirty.bind(this), e && this.registerMaterialExtensions(e), ge.upgradeMaterial.call(this), this.setValues(t);
  }
  dispose() {
    return ge.dispose(super.dispose).call(this);
  }
  clone(e = !1) {
    return ge.clone(super.clone).call(this, e);
  }
  dispatchEvent(e) {
    ge.dispatchEvent(super.dispatchEvent).call(this, e);
  }
  customProgramCacheKey() {
    return super.customProgramCacheKey() + ge.customProgramCacheKey.call(this);
  }
  onBeforeCompile(e, t) {
    ge.onBeforeCompile.call(this, e, t), super.onBeforeCompile(e, t);
  }
  // endregion
  // region Serialization
  /**
   * Sets the values of this material based on the values of the passed material or an object with material properties
   * The input is expected to be a valid material or a deserialized material parameters object(including the deserialized userdata)
   * @param parameters - material or material parameters object
   * @param allowInvalidType - if true, the type of the oldMaterial is not checked. Objects without type are always allowed.
   * @param clearCurrentUserData - if undefined, then depends on material.isMaterial. if true, the current userdata is cleared before setting the new values, because it can have data which wont be overwritten if not present in the new material.
   */
  setValues(e, t = !0, i = void 0) {
    return e ? e.type && !t && !["ShaderMaterial", "ShaderMaterial2", "ExtendedShaderMaterial", this.constructor.TYPE].includes(e.type) ? (console.error("Material type is not supported:", e.type), this) : (i === void 0 && (i = e.isMaterial), i && (this.userData = {}), ge.setValues(super.setValues).call(this, e), this.userData.uuid = this.uuid, this) : this;
  }
  copy(e) {
    return this.setValues(e, !1);
  }
  /**
   * Serializes this material to JSON.
   * @param meta - metadata for serialization
   * @param _internal - Calls only super.toJSON, does internal three.js serialization and `@serialize` tags. Set it to true only if you know what you are doing. This is used in Serialization->serializer->material
   */
  toJSON(e, t = !1) {
    return t ? {
      ...super.toJSON(e),
      ...mt.Serialize(this, e, !0)
      // this will serialize the properties of this class(like defined with @serialize and @serialize attribute)
    } : mt.Serialize(this, e, !1);
  }
  /**
   * Deserializes the material from JSON.
   * Textures should be loaded and in meta.textures before calling this method.
   * todo - needs to be tested
   * @param data
   * @param meta
   * @param _internal
   */
  fromJSON(e, t, i = !1) {
    return i ? (mt.Deserialize(e, this, t, !0), this.setValues(e)) : (this.dispatchEvent({ type: "beforeDeserialize", data: e, meta: t, bubbleToObject: !0, bubbleToParent: !0 }), this);
  }
};
Hs.TypeSlug = "shmat", Hs.TYPE = "ObjectShaderMaterial", Hs.MaterialProperties = {
  ...Na,
  defines: {},
  uniforms: {},
  uniformsGroups: [],
  vertexShader: "",
  fragmentShader: "",
  linewidth: 1,
  wireframe: !1,
  wireframeLinewidth: 1,
  fog: !1,
  // set to use scene fog
  lights: !1,
  // set to use scene lights
  clipping: !1,
  // set to use user-defined clipping planes
  forceSinglePass: !0,
  extensions: {
    derivatives: !1,
    // set to use derivatives
    fragDepth: !1,
    // set to use fragment depth values
    drawBuffers: !1,
    // set to use draw buffers
    shaderTextureLOD: !1
    // set to use shader texture LOD
  },
  // When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.
  defaultAttributeValues: {
    color: [1, 1, 1],
    uv: [0, 0],
    uv1: [0, 0]
  },
  index0AttributeName: void 0,
  uniformsNeedUpdate: !1,
  glslVersion: null,
  flatShading: !1
}, Hs.MaterialTemplate = {
  materialType: Hs.TYPE,
  name: "shader",
  typeSlug: Hs.TypeSlug,
  alias: ["shader", Hs.TYPE, Hs.TypeSlug, "ShaderMaterial", "ShaderMaterial2", "ExtendedShaderMaterial"],
  params: {
    vertexShader: lp.defaultVertex,
    fragmentShader: lp.defaultFragment
  },
  generator: (e) => new Hs(e)
};
let bg = Hs;
const Vs = class Vs extends Hl {
  constructor({ customMaterialExtensions: e, ...t } = {}) {
    super(), this.assetType = "material", this.isLegacyPhongMaterial = !0, this.appliedMeshes = /* @__PURE__ */ new Set(), this.setDirty = ge.setDirty, this.envMap = null, this.materialExtensions = [], this.extraUniformsToUpload = {}, this.registerMaterialExtensions = ge.registerMaterialExtensions, this.unregisterMaterialExtensions = ge.unregisterMaterialExtensions, this.onBeforeRender = ge.onBeforeRenderOverride(super.onBeforeRender), this.onAfterRender = ge.onAfterRenderOverride(super.onAfterRender), this.uiConfig = {
      type: "folder",
      label: "Phong Material",
      uuid: "MBM2_" + this.uuid,
      expanded: !0,
      onChange: (i) => {
        !i.config || i.config.onChange || this.setDirty({ uiChangeEvent: i, needsUpdate: !!i.last, refreshUi: !!i.last });
      },
      children: [
        ...Ut.base(this),
        Ut.blending(this),
        Ut.polygonOffset(this),
        Ut.aoLightMap(this),
        {
          type: "folder",
          label: "Specular",
          children: [
            {
              type: "color",
              property: [this, "specular"]
            },
            {
              type: "image",
              property: [this, "specularMap"]
            },
            bi(this, "specularMap"),
            {
              type: "slider",
              label: "Shininess",
              property: [this, "shininess"],
              bounds: [0, 100],
              stepSize: 0.1
            },
            {
              type: "slider",
              label: "Reflectivity",
              property: [this, "reflectivity"],
              bounds: [0, 1],
              stepSize: 0.01
            },
            {
              type: "slider",
              label: "Refraction Ratio",
              property: [this, "refractionRatio"],
              bounds: [0, 3],
              stepSize: 0.01
            }
          ]
        },
        Ut.bumpNormal(this),
        Ut.emission(this),
        {
          type: "folder",
          label: "Env Map",
          children: [
            {
              type: "image",
              property: [this, "envMap"]
            },
            bi(this, "envMap"),
            {
              type: "slider",
              label: "Env Map Intensity",
              property: [this, "envMapIntensity"],
              bounds: [0, 5],
              stepSize: 0.01
            }
          ]
        },
        ...Ut.misc(this)
      ]
    }, !this.defines && (this.defines = {}), this.fog = !1, this.setDirty = this.setDirty.bind(this), e && this.registerMaterialExtensions(e), ge.upgradeMaterial.call(this), this.setValues(t);
  }
  dispose() {
    return ge.dispose(super.dispose).call(this);
  }
  clone(e = !1) {
    return ge.clone(super.clone).call(this, e);
  }
  dispatchEvent(e) {
    ge.dispatchEvent(super.dispatchEvent).call(this, e);
  }
  customProgramCacheKey() {
    return super.customProgramCacheKey() + ge.customProgramCacheKey.call(this);
  }
  onBeforeCompile(e, t) {
    const i = [
      ["vec3 outgoingLight = ", "afterModulation"],
      // added markers before found substring
      ["#include <aomap_fragment>", "beforeModulation"],
      ["ReflectedLight reflectedLight = ", "beforeAccumulation"],
      ["#include <clipping_planes_fragment>", "mainStart"]
    ], n = [
      ["#include <uv_vertex>", "mainStart"]
    ];
    for (const r of n) e.vertexShader = Ct(e.vertexShader, r[0], "#glMarker " + r[1] + `
` + r[0]);
    for (const r of i) e.fragmentShader = Ct(e.fragmentShader, r[0], "#glMarker " + r[1] + `
` + r[0]);
    ge.onBeforeCompile.call(this, e, t), super.onBeforeCompile(e, t);
  }
  // endregion
  // region Serialization
  /**
   * Sets the values of this material based on the values of the passed material or an object with material properties
   * The input is expected to be a valid material or a deserialized material parameters object(including the deserialized userdata)
   * @param parameters - material or material parameters object
   * @param allowInvalidType - if true, the type of the oldMaterial is not checked. Objects without type are always allowed.
   * @param clearCurrentUserData - if undefined, then depends on material.isMaterial. if true, the current userdata is cleared before setting the new values, because it can have data which wont be overwritten if not present in the new material.
   */
  setValues(e, t = !0, i = void 0) {
    return e ? e.type && !t && !["MeshPhongMaterial", "MeshPhongMaterial2", this.constructor.TYPE].includes(e.type) ? (console.error("Material type is not supported:", e.type), this) : (i === void 0 && (i = e.isMaterial), i && (this.userData = {}), ge.setValues(super.setValues).call(this, e), this.userData.uuid = this.uuid, this) : this;
  }
  copy(e) {
    return this.setValues(e, !1);
  }
  /**
   * Serializes this material to JSON.
   * @param meta - metadata for serialization
   * @param _internal - Calls only super.toJSON, does internal three.js serialization and `@serialize` tags. Set it to true only if you know what you are doing. This is used in Serialization->serializer->material
   */
  toJSON(e, t = !1) {
    return t ? {
      ...super.toJSON(e),
      ...mt.Serialize(this, e, !0)
      // this will serialize the properties of this class(like defined with @serialize and @serialize attribute)
    } : mt.Serialize(this, e, !1);
  }
  /**
   * Deserializes the material from JSON.
   * Textures should be loaded and in meta.textures before calling this method.
   * todo - needs to be tested
   * @param data
   * @param meta
   * @param _internal
   */
  fromJSON(e, t, i = !1) {
    return i ? (mt.Deserialize(e, this, t, !0), this.setValues(e)) : (this.dispatchEvent({ type: "beforeDeserialize", data: e, meta: t, bubbleToObject: !0, bubbleToParent: !0 }), this);
  }
};
Vs.TypeSlug = "phongmat", Vs.TYPE = "LegacyPhongMaterial", Vs.MaterialProperties = {
  ...Na,
  color: new se(16777215),
  specular: new se(1118481),
  shininess: 30,
  map: null,
  lightMap: null,
  lightMapIntensity: 1,
  aoMap: null,
  aoMapIntensity: 1,
  emissive: new se(0),
  emissiveIntensity: 1,
  emissiveMap: null,
  bumpMap: null,
  bumpScale: 1,
  normalMap: null,
  normalMapType: "TangentSpaceNormalMap",
  normalScale: new ie(1, 1),
  displacementMap: null,
  displacementScale: 1,
  displacementBias: 0,
  specularMap: null,
  alphaMap: null,
  envMap: null,
  combine: _c,
  envMapIntensity: 1,
  reflectivity: 1,
  refractionRatio: 0.98,
  wireframe: !1,
  wireframeLinewidth: 1,
  wireframeLinecap: "round",
  wireframeLinejoin: "round",
  skinning: !1,
  fog: !0,
  flatShading: !1
}, Vs.MaterialTemplate = {
  materialType: Vs.TYPE,
  name: "phong",
  typeSlug: Vs.TypeSlug,
  alias: ["phong", "legacy-phong", Vs.TYPE, Vs.TypeSlug, "MeshPhongMaterial", "MeshPhongMaterial2", "PhongMaterial"],
  params: {
    color: new se(1, 1, 1)
  },
  generator: (e) => new Vs(e)
};
let Sg = Vs;
class FL extends Se {
  constructor(e, t) {
    super(e, t), this.assetType = "model", this.setDirty = ct.setDirty, this.refreshUi = ct.refreshUi, ct.upgradeObject3D.call(this);
  }
  /**
   * @deprecated use `this` instead
   */
  get modelObject() {
    return this;
  }
  // endregion
}
class OL extends Eg {
  constructor(e, t) {
    super(e, t), this.assetType = "model", this.setDirty = ct.setDirty, this.refreshUi = ct.refreshUi, this.isMeshLine = !0, ct.upgradeObject3D.call(this);
  }
  /**
   * @deprecated use `this` instead
   */
  get modelObject() {
    return this;
  }
  // endregion
}
class NL extends Tc {
  constructor(e, t) {
    super(e, t), this.assetType = "model", this.setDirty = ct.setDirty, this.refreshUi = ct.refreshUi, this.isMeshLineSegments = !0, ct.upgradeObject3D.call(this);
  }
  /**
   * @deprecated use `this` instead
   */
  get modelObject() {
    return this;
  }
  // endregion
}
class Vz extends Ze {
  constructor() {
    super(), this.center2 = ai.center2, this.setDirty = ai.setDirty, this.refreshUi = ai.refreshUi, this.appliedMeshes = /* @__PURE__ */ new Set(), ai.upgradeGeometry.call(this);
  }
}
class kL extends mp {
  constructor() {
    super(), this.center2 = ai.center2, this.setDirty = ai.setDirty, this.refreshUi = ai.refreshUi, this.appliedMeshes = /* @__PURE__ */ new Set(), ai.upgradeGeometry.call(this);
  }
}
class GL extends ea {
  constructor() {
    super(), this.center2 = ai.center2, this.setDirty = ai.setDirty, this.refreshUi = ai.refreshUi, this.appliedMeshes = /* @__PURE__ */ new Set(), ai.upgradeGeometry.call(this);
  }
}
class Wz extends YE {
  constructor(e) {
    super(e), this.center2 = ai.center2, this.setDirty = ai.setDirty, this.refreshUi = ai.refreshUi, this.appliedMeshes = /* @__PURE__ */ new Set(), ai.upgradeGeometry.call(this);
  }
}
const en = {
  setDirty: function(s, ...e) {
    typeof s == "string" && (s = { change: s }), ct.setDirty.call(this, s, ...e);
  },
  upgradeLight: zL,
  refreshUi: ct.refreshUi
};
function zL(s, e) {
  this && ct.upgradeObject3D.call(this, s, e);
}
var QL = Object.defineProperty, HL = Object.getOwnPropertyDescriptor, ef = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? HL(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && QL(e, t, n), n;
};
let Mo = class extends UA {
  constructor(s, e) {
    super(s, e), this.assetType = "light", this.setDirty = en.setDirty, this.refreshUi = en.refreshUi, this.isAmbientLight2 = !0, en.upgradeLight.call(this);
  }
  autoScale() {
    return console.warn("AutoScale not supported on Lights"), this;
  }
  autoCenter() {
    return console.warn("AutoCenter not supported on Lights"), this;
  }
  /**
   * @deprecated use `this` instead
   */
  get lightObject() {
    return this;
  }
  /**
   * @deprecated use `this` instead
   */
  get modelObject() {
    return this;
  }
  // endregion
};
ef([
  ue("Enabled"),
  bt("setDirty")
], Mo.prototype, "visible", 2);
ef([
  wr("Color", (s) => ({ onChange: () => s.setDirty() }))
], Mo.prototype, "color", 2);
ef([
  Ye("Intensity", [0, 30], 0.01),
  bt("setDirty")
], Mo.prototype, "intensity", 2);
Mo = ef([
  Tn("Ambient Light")
], Mo);
var VL = Object.defineProperty, WL = Object.getOwnPropertyDescriptor, ss = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? WL(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && VL(e, t, n), n;
};
let Bi = class extends hu {
  constructor(s, e) {
    super(s, e), this.assetType = "light", this.setDirty = en.setDirty, this.refreshUi = en.refreshUi, this.isDirectionalLight2 = !0, this.target.position.set(0, 0, -1), this.add(this.target), en.upgradeLight.call(this), this.shadowFrustum = 10;
  }
  _mapSizeChanged() {
    var s, e;
    (s = this.shadow.map) == null || s.dispose(), (e = this.shadow.mapPass) == null || e.dispose(), this.shadow.map = null, this.shadow.mapPass = null, this.setDirty({ change: "shadowMapSize" });
  }
  _shadowFrustumChanged() {
    const s = this.shadowFrustum;
    this.shadow.camera.left = -s / 2, this.shadow.camera.right = s / 2, this.shadow.camera.top = s / 2, this.shadow.camera.bottom = -s / 2, this.shadow.camera.updateProjectionMatrix(), this.setDirty({ change: "shadowFrustum" });
  }
  _shadowCamUpdate(s) {
    this.shadow.camera.updateProjectionMatrix(), this.setDirty({ change: s });
  }
  autoScale() {
    return console.warn("DirectionalLight2: AutoScale not supported on Lights"), this;
  }
  autoCenter() {
    return console.warn("DirectionalLight2: AutoCenter not supported on Lights"), this;
  }
  /**
   * @deprecated use `this` instead
   */
  get lightObject() {
    return this;
  }
  /**
   * @deprecated use `this` instead
   */
  get modelObject() {
    return this;
  }
  // endregion
};
ss([
  ue("Enabled"),
  bt("setDirty")
], Bi.prototype, "visible", 2);
ss([
  wr("Color", (s) => ({ onChange: () => s.setDirty() }))
], Bi.prototype, "color", 2);
ss([
  Ye("Intensity", [0, 100], 0.01),
  bt("setDirty")
], Bi.prototype, "intensity", 2);
ss([
  Ji("Position", void 0, void 0, (s) => ({ onChange: () => s.setDirty() }))
], Bi.prototype, "position", 2);
ss([
  Ji("Rotation", void 0, void 0, (s) => ({ onChange: () => s.setDirty() }))
], Bi.prototype, "rotation", 2);
ss([
  ue("Cast Shadow"),
  bt("setDirty")
], Bi.prototype, "castShadow", 2);
ss([
  Ji("Shadow Map Size"),
  Ht({ obj: "shadow", key: "mapSize", onChange: Bi.prototype._mapSizeChanged, onChangeParams: !1 })
], Bi.prototype, "shadowMapSize", 2);
ss([
  Ye("Shadow Bias", [-1e-3, 1e-3], 1e-5),
  Ht({ obj: "shadow", key: "bias", onChange: "setDirty" })
], Bi.prototype, "shadowBias", 2);
ss([
  Ye("Shadow Normal Bias", [-0.1, 0.1], 5e-3),
  Ht({ obj: "shadow", key: "normalBias", onChange: "setDirty" })
], Bi.prototype, "shadowNormalBias", 2);
ss([
  Ye("Shadow Radius", [0, 5], 0.01),
  Ht({ obj: "shadow", key: "radius", onChange: "setDirty" })
], Bi.prototype, "shadowRadius", 2);
ss([
  Ye("Shadow Frustum", [0.1, 50], 0.01),
  Pi(Bi.prototype._shadowFrustumChanged)
], Bi.prototype, "shadowFrustum", 2);
ss([
  ii("Shadow Near"),
  Ht({ obj: "shadow", key: ["camera", "near"], onChange: Bi.prototype._shadowCamUpdate })
], Bi.prototype, "shadowNear", 2);
ss([
  ii("Shadow Far"),
  Ht({ obj: "shadow", key: ["camera", "far"], onChange: Bi.prototype._shadowCamUpdate })
], Bi.prototype, "shadowFar", 2);
Bi = ss([
  Tn("Directional Light")
], Bi);
var jL = Object.defineProperty, qL = Object.getOwnPropertyDescriptor, Rc = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? qL(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && jL(e, t, n), n;
};
let Kr = class extends PA {
  constructor(s, e, t) {
    super(s, e, t), this.assetType = "light", this.setDirty = en.setDirty, this.refreshUi = en.refreshUi, this.isHemisphereLight2 = !0, en.upgradeLight.call(this);
  }
  autoScale() {
    return console.warn("AutoScale not supported on Lights"), this;
  }
  autoCenter() {
    return console.warn("AutoCenter not supported on Lights"), this;
  }
  /**
   * @deprecated use `this` instead
   */
  get lightObject() {
    return this;
  }
  /**
   * @deprecated use `this` instead
   */
  get modelObject() {
    return this;
  }
  // endregion
};
Rc([
  ue("Enabled"),
  bt("setDirty")
], Kr.prototype, "visible", 2);
Rc([
  wr("Sky Color", (s) => ({ onChange: () => s.setDirty() }))
], Kr.prototype, "color", 2);
Rc([
  wr("Ground Color", (s) => ({ onChange: () => s.setDirty() }))
], Kr.prototype, "groundColor", 2);
Rc([
  Ye("Intensity", [0, 30], 0.01),
  bt("setDirty")
], Kr.prototype, "intensity", 2);
Rc([
  Ji("Position", void 0, void 0, (s) => ({ onChange: () => s.setDirty() }))
], Kr.prototype, "position", 2);
Kr = Rc([
  Tn("Hemisphere Light")
], Kr);
var XL = Object.defineProperty, YL = Object.getOwnPropertyDescriptor, Dn = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? YL(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && XL(e, t, n), n;
};
let yi = class extends nc {
  constructor(s, e, t, i) {
    super(s, e, t, i), this.assetType = "light", this.setDirty = en.setDirty, this.refreshUi = en.refreshUi, this.isPointLight2 = !0, en.upgradeLight.call(this);
  }
  _mapSizeChanged() {
    var s, e;
    (s = this.shadow.map) == null || s.dispose(), (e = this.shadow.mapPass) == null || e.dispose(), this.shadow.map = null, this.shadow.mapPass = null, this.setDirty({ change: "shadowMapSize" });
  }
  _shadowCamUpdate(s) {
    this.shadow.camera.updateProjectionMatrix(), this.setDirty({ change: s });
  }
  autoScale() {
    return console.warn("AutoScale not supported on Lights"), this;
  }
  autoCenter() {
    return console.warn("AutoCenter not supported on Lights"), this;
  }
  /**
   * @deprecated use `this` instead
   */
  get lightObject() {
    return this;
  }
  /**
   * @deprecated use `this` instead
   */
  get modelObject() {
    return this;
  }
  // endregion
};
Dn([
  ue("Enabled"),
  bt("setDirty")
], yi.prototype, "visible", 2);
Dn([
  wr("Color", (s) => ({ onChange: () => s.setDirty() }))
], yi.prototype, "color", 2);
Dn([
  Ye("Intensity", [0, 30], 0.01),
  bt("setDirty")
], yi.prototype, "intensity", 2);
Dn([
  ii("Distance"),
  bt("setDirty")
], yi.prototype, "distance", 2);
Dn([
  ii("Decay"),
  bt("setDirty")
], yi.prototype, "decay", 2);
Dn([
  ii("Power"),
  bt("setDirty")
], yi.prototype, "power", 2);
Dn([
  Ji("Position", void 0, void 0, (s) => ({ onChange: () => s.setDirty() }))
], yi.prototype, "position", 2);
Dn([
  ue("Cast Shadow"),
  bt("setDirty")
], yi.prototype, "castShadow", 2);
Dn([
  Ji("Shadow Map Size"),
  Ht({ obj: "shadow", key: "mapSize", onChange: yi.prototype._mapSizeChanged, onChangeParams: !1 })
], yi.prototype, "shadowMapSize", 2);
Dn([
  Ye("Shadow Bias", [-1e-3, 1e-3], 1e-5),
  Ht({ obj: "shadow", key: "bias", onChange: "setDirty" })
], yi.prototype, "shadowBias", 2);
Dn([
  Ye("Shadow Radius", [0, 5], 0.01),
  Ht({ obj: "shadow", key: "radius", onChange: "setDirty" })
], yi.prototype, "shadowRadius", 2);
Dn([
  ii("Shadow Near"),
  Ht({ obj: "shadow", key: ["camera", "near"], onChange: yi.prototype._shadowCamUpdate })
], yi.prototype, "shadowNear", 2);
Dn([
  ii("Shadow Far"),
  Ht({ obj: "shadow", key: ["camera", "far"], onChange: yi.prototype._shadowCamUpdate })
], yi.prototype, "shadowFar", 2);
Dn([
  ii("Shadow Aspect"),
  Ht({ obj: "shadow", key: "aspect", onChange: yi.prototype._shadowCamUpdate })
], yi.prototype, "shadowAspect", 2);
Dn([
  Ye("Shadow FOV", [1, 179], 1),
  Ht({ obj: "shadow", key: "fov", onChange: yi.prototype._shadowCamUpdate })
], yi.prototype, "shadowFov", 2);
yi = Dn([
  Tn("Point Light")
], yi);
var KL = Object.defineProperty, JL = Object.getOwnPropertyDescriptor, Wo = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? JL(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && KL(e, t, n), n;
};
let gr = class extends FA {
  constructor(s, e, t, i) {
    super(s, e, t, i), this.assetType = "light", this.setDirty = en.setDirty, this.refreshUi = en.refreshUi, this.isRectAreaLight2 = !0, en.upgradeLight.call(this);
  }
  autoScale() {
    return console.warn("AutoScale not supported on Lights"), this;
  }
  autoCenter() {
    return console.warn("AutoCenter not supported on Lights"), this;
  }
  /**
   * @deprecated use `this` instead
   */
  get lightObject() {
    return this;
  }
  /**
   * @deprecated use `this` instead
   */
  get modelObject() {
    return this;
  }
  // endregion
};
Wo([
  ue("Enabled"),
  bt("setDirty")
], gr.prototype, "visible", 2);
Wo([
  wr("Color", (s) => ({ onChange: () => s.setDirty() }))
], gr.prototype, "color", 2);
Wo([
  Ye("Intensity", [0, 30], 0.01),
  bt("setDirty")
], gr.prototype, "intensity", 2);
Wo([
  ii("Width"),
  bt("setDirty")
], gr.prototype, "width", 2);
Wo([
  ii("Height"),
  bt("setDirty")
], gr.prototype, "height", 2);
Wo([
  ii("Power"),
  bt("setDirty")
], gr.prototype, "power", 2);
gr = Wo([
  Tn("RectArea Light")
], gr);
var $L = Object.defineProperty, ZL = Object.getOwnPropertyDescriptor, sn = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? ZL(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && $L(e, t, n), n;
};
let oi = class extends cu {
  constructor(s, e, t, i, n, r) {
    super(s, e, t, i, n, r), this.assetType = "light", this.setDirty = en.setDirty, this.refreshUi = en.refreshUi, this.isSpotLight2 = !0, this.target.position.set(0, 0, -1), this.add(this.target), en.upgradeLight.call(this);
  }
  _mapSizeChanged() {
    var s, e;
    (s = this.shadow.map) == null || s.dispose(), (e = this.shadow.mapPass) == null || e.dispose(), this.shadow.map = null, this.shadow.mapPass = null, this.setDirty({ change: "shadowMapSize" });
  }
  _shadowCamUpdate(s) {
    this.shadow.camera.updateProjectionMatrix(), this.setDirty({ change: s });
  }
  autoScale() {
    return console.warn("AutoScale not supported on Lights"), this;
  }
  autoCenter() {
    return console.warn("AutoCenter not supported on Lights"), this;
  }
  /**
   * @deprecated use `this` instead
   */
  get lightObject() {
    return this;
  }
  /**
   * @deprecated use `this` instead
   */
  get modelObject() {
    return this;
  }
  // endregion
};
sn([
  ue("Enabled"),
  bt("setDirty")
], oi.prototype, "visible", 2);
sn([
  wr("Color", (s) => ({ onChange: () => s.setDirty() }))
], oi.prototype, "color", 2);
sn([
  Ye("Intensity", [0, 30], 0.01),
  bt("setDirty")
], oi.prototype, "intensity", 2);
sn([
  Ye("Angle", [0, 2], 0.01),
  bt("setDirty")
], oi.prototype, "angle", 2);
sn([
  Ye("Penumbra", [0, 0.9999], 0.01),
  bt("setDirty")
], oi.prototype, "penumbra", 2);
sn([
  pt("Distance"),
  bt("setDirty")
], oi.prototype, "distance", 2);
sn([
  pt("Decay"),
  bt("setDirty")
], oi.prototype, "decay", 2);
sn([
  Ji("Position", void 0, void 0, (s) => ({ onChange: () => s.setDirty() }))
], oi.prototype, "position", 2);
sn([
  Ji("Rotation", void 0, void 0, (s) => ({ onChange: () => s.setDirty() }))
], oi.prototype, "rotation", 2);
sn([
  ue("Cast Shadow"),
  bt("setDirty")
], oi.prototype, "castShadow", 2);
sn([
  Ji("Shadow Map Size"),
  Ht({ obj: "shadow", key: "mapSize", onChange: oi.prototype._mapSizeChanged, onChangeParams: !1 })
], oi.prototype, "shadowMapSize", 2);
sn([
  Ye("Shadow Bias", [-1e-3, 1e-3], 1e-5),
  Ht({ obj: "shadow", key: "bias", onChange: "setDirty" })
], oi.prototype, "shadowBias", 2);
sn([
  Ye("Shadow Radius", [0, 5], 0.01),
  Ht({ obj: "shadow", key: "radius", onChange: "setDirty" })
], oi.prototype, "shadowRadius", 2);
sn([
  Ye("Shadow Focus", [0, 1], 1e-3),
  Ht({ obj: "shadow", key: "focus", onChange: "setDirty" })
], oi.prototype, "shadowFocus", 2);
sn([
  ii("Shadow Near"),
  Ht({ obj: "shadow", key: ["camera", "near"], onChange: oi.prototype._shadowCamUpdate })
], oi.prototype, "shadowNear", 2);
sn([
  ii("Shadow Far"),
  Ht({ obj: "shadow", key: ["camera", "far"], onChange: oi.prototype._shadowCamUpdate })
], oi.prototype, "shadowFar", 2);
sn([
  ii("Shadow Aspect"),
  Ht({ obj: "shadow", key: "aspect", onChange: oi.prototype._shadowCamUpdate })
], oi.prototype, "shadowAspect", 2);
sn([
  Ye("Shadow FOV", [1, 179], 1),
  Ht({ obj: "shadow", key: "fov", onChange: oi.prototype._shadowCamUpdate })
], oi.prototype, "shadowFov", 2);
oi = sn([
  Tn("Spot Light")
], oi);
function tb() {
  this.assetType = "texture", this.userData || (this.userData = {}), this._appliedMaterials || (this._appliedMaterials = /* @__PURE__ */ new Set()), this.setDirty || (this.setDirty = () => this.needsUpdate = !0);
}
function eU(s) {
  var e;
  return (e = this.userData) != null && e.__isIWebGLRenderer ? this : (this.userData || (this.userData = { __isIWebGLRenderer: !0 }), this.userData.__isIWebGLRenderer = !0, this.renderWithModes || (this.renderWithModes = ib), this.renderManager = s, this.baseRenderer || Object.defineProperty(this, "baseRenderer", {
    get: () => (console.warn("IWebGLRenderer.baseRenderer is deprecated, use IWebGLRenderer.renderManager instead"), this.renderManager)
  }), this);
}
function ib(s, e) {
  const t = this.userData, { backgroundRender: i, transparentRender: n, shadowMapRender: r, mainRenderPass: a, opaqueRender: o, transmissionRender: l, sceneRender: c, screenSpaceRendering: h } = t;
  s.backgroundRender !== void 0 && (t.backgroundRender = s.backgroundRender), s.transparentRender !== void 0 && (t.transparentRender = s.transparentRender), s.shadowMapRender !== void 0 && (t.shadowMapRender = s.shadowMapRender), s.mainRenderPass !== void 0 && (t.mainRenderPass = s.mainRenderPass), s.opaqueRender !== void 0 && (t.opaqueRender = s.opaqueRender), s.sceneRender !== void 0 && (t.sceneRender = s.sceneRender), s.transmissionRender !== void 0 && (t.transmissionRender = s.transmissionRender), s.screenSpaceRendering !== void 0 && (t.screenSpaceRendering = s.screenSpaceRendering), e(), t.backgroundRender = i, t.transparentRender = n, t.shadowMapRender = r, t.mainRenderPass = a, t.opaqueRender = o, t.sceneRender = c, t.transmissionRender = l, t.screenSpaceRendering = h;
}
const jz = ib;
function nb(s, e) {
  const t = e.getSize(new M());
  let i = 1;
  if (s.isPerspectiveCamera && t.length() > 1e-4) {
    const n = isFinite(s.aspect) ? s.aspect : 1, r = Math.max(1, s.fov) * (Math.PI / 180), a = 2 * Math.atan(Math.tan(r / 2) * n), o = t.z / 2 + Math.abs(t.x / 2 / Math.tan(a / 2)), l = t.z / 2 + Math.abs(t.y / 2 / Math.tan(r / 2));
    i = Math.max(o, l);
  }
  return i;
}
var tU = Object.defineProperty, iU = Object.getOwnPropertyDescriptor, Us = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? iU(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && tU(e, t, n), n;
};
let Qi = class extends tc {
  /**
   * Create a scene instance. This is done automatically in the {@link ThreeViewer} and must not be created separately.
   * @param camera
   * @param objectProcessor
   */
  constructor(s, e) {
    super(), this.isRootScene = !0, this.assetType = "model", this._mainCamera = null, this.backgroundColor = null, this.background = null, this.backgroundIntensity = 1, this.environment = null, this.envMapIntensity = 1, this.envMapRotation = 0, this.textureSlots = {}, this.fixedEnvMapDirection = !1, this.autoDisposeSceneMaps = !0, this._dummyCam = new mu(""), this._mainCameraUpdate = (t) => {
      this.setDirty({ refreshScene: !1 }), this.refreshActiveCameraNearFar(), t.key === "fov" && this.dollyActiveCameraFov(), this.dispatchEvent({ ...t, type: "mainCameraUpdate" }), this.dispatchEvent({ ...t, type: "activeCameraUpdate" });
    }, this._sceneBounds = new Nn(), this._sceneBoundingRadius = 0, this.refreshUi = ct.refreshUi.bind(this), this._v1 = new M(), this._v2 = new M(), this.autoNearFarEnabled = !0, this.setDirty = this.setDirty.bind(this), ct.upgradeObject3D.call(this, void 0, e), this.addEventListener("materialUpdate", (t) => this.dispatchEvent({ ...t, type: "sceneMaterialUpdate" })), this.addEventListener("objectUpdate", this.refreshScene), this.addEventListener("geometryUpdate", this.refreshScene), this.addEventListener("geometryChanged", this.refreshScene), this.defaultCamera = s, this.modelRoot = new ut(), this.modelRoot.userData.rootSceneModelRoot = !0, this.modelRoot.name = "Scene", this.add(this.modelRoot), this.add(this.defaultCamera), this.mainCamera = this.defaultCamera;
  }
  get mainCamera() {
    return this._mainCamera || this._dummyCam;
  }
  set mainCamera(s) {
    const e = this.mainCamera;
    s || (s = this.defaultCamera), e !== s && (e && (e.deactivateMain(void 0, !0), e.removeEventListener("cameraUpdate", this._mainCameraUpdate)), s ? (this._mainCamera = s, s.addEventListener("cameraUpdate", this._mainCameraUpdate), s.activateMain(void 0, !0)) : this._mainCamera = null, this.dispatchEvent({ type: "activeCameraChange", lastCamera: e, camera: s }), this.dispatchEvent({ type: "mainCameraChange", lastCamera: e, camera: s }), this.setDirty());
  }
  get renderCamera() {
    return this._renderCamera ?? this.mainCamera;
  }
  set renderCamera(s) {
    const e = this._renderCamera;
    this._renderCamera = s, this.dispatchEvent({ type: "renderCameraChange", lastCamera: e, camera: s });
  }
  /**
   * Add a widget (non-physical/interactive) object to the scene. like gizmos, ui components etc.
   * @param model
   * @param options
   */
  // addWidget(model: IWidget, options: AnyOptions = {}): void {
  //     if (model.assetType !== 'widget') {
  //         console.warn('Invalid asset type for ', model, ', adding anyway')
  //     }
  //     this.add(model.modelObject)
  //
  //     // todo: dispatch event, add event listeners, etc
  // }
  /**
   * Add any object to the scene.
   * @param imported
   * @param options
   */
  addObject(s, e) {
    return (e != null && e.clearSceneObjects || e != null && e.disposeSceneObjects) && this.clearSceneModels(e.disposeSceneObjects), s && (s.isObject3D ? (this._addObject3D(s, e), this.dispatchEvent({ type: "addSceneObject", object: s, options: e }), s) : (console.error("Invalid object, cannot add to scene.", s), s));
  }
  /**
   * Load model root scene exported to GLTF format. Used internally by {@link ThreeViewer.addSceneObject}.
   * @param obj
   * @param options
   */
  loadModelRoot(s, e) {
    var i, n, r;
    if ((e != null && e.clearSceneObjects || e != null && e.disposeSceneObjects) && this.clearSceneModels(e.disposeSceneObjects), (i = s.userData) != null && i.rootSceneModelRoot || console.error("RootScene: Invalid model root scene object. Trying to add anyway.", s), s.userData && (s.userData.__importData && (this.modelRoot.userData.__importData = {
      ...this.modelRoot.userData.__importData,
      ...s.userData.__importData
    }), s.userData.gltfAsset && (this.modelRoot.userData.__gltfAsset = {
      // todo: merge values?
      ...this.modelRoot.userData.__gltfAsset,
      ...s.userData.gltfAsset
    }), s.userData.gltfExtras && (this.modelRoot.userData.__gltfExtras = {
      ...this.modelRoot.userData.__gltfExtras,
      ...s.userData.gltfExtras
    })), (r = (n = s.userData) == null ? void 0 : n.gltfAsset) != null && r.copyright && s.children.forEach((a) => {
      var o;
      return !a.userData.license && (a.userData.license = (o = s.userData.gltfAsset) == null ? void 0 : o.copyright);
    }), s.animations) {
      this.modelRoot.animations || (this.modelRoot.animations = []);
      for (const a of s.animations)
        this.modelRoot.animations.includes(a) || this.modelRoot.animations.push(a);
    }
    return (s._childrenCopy || [...s.children]).map((a) => this.addObject(a, { ...e, clearSceneObjects: !1, disposeSceneObjects: !1 }));
  }
  _addObject3D(s, { autoCenter: e = !1, centerGeometries: t = !1, centerGeometriesKeepPosition: i = !0, autoScale: n = !1, autoScaleRadius: r = 2, addToRoot: a = !1, license: o } = {}) {
    const l = s;
    if (!l) {
      console.error("Invalid object, cannot add to scene.");
      return;
    }
    a ? this.add(l) : this.modelRoot.add(l);
    const c = () => {
      e && !l.userData.isCentered && !l.userData.pseudoCentered ? l.autoCenter && l.autoCenter() : l.userData.isCentered = !0, n && !l.userData.autoScaled ? l.autoScale && l.autoScale(l.userData.autoScaleRadius || r) : l.userData.autoScaled = !0, t && !l.userData.geometriesCentered && this.centerAllGeometries(i, l), l.userData.geometriesCentered = !0;
    };
    l._loadingPromise ? l._loadingPromise.finally(c) : c(), o && (l.userData.license = [l.userData.license, o].filter((h) => h).join(", ")), this.setDirty({ refreshScene: !0 });
  }
  centerAllGeometries(s = !0, e) {
    const t = /* @__PURE__ */ new Set();
    (e ?? this.modelRoot).traverse((n) => n.geometry && t.add(n.geometry));
    const i = [];
    return t.forEach((n) => i.push(n.center2(void 0, s))), () => i.forEach((n) => n());
  }
  clearSceneModels(s = !1, e = !0) {
    if (s) return this.disposeSceneModels(e);
    this.modelRoot.clear(), this.modelRoot.children = [], e && this.setDirty({ refreshScene: !0 });
  }
  disposeSceneModels(s = !0, e = !0) {
    if (e) {
      for (const t of [...this.modelRoot.children])
        t.dispose ? t.dispose() : t.removeFromParent();
      this.modelRoot.clear(), s && this.setDirty({ refreshScene: !0 });
    } else
      for (const t of this.modelRoot.children)
        t.dispose && t.dispose(!1);
  }
  _onEnvironmentChange(s) {
    var e, t;
    s != null && s.oldValue && s.oldValue !== s.value && this.autoDisposeSceneMaps && typeof s.oldValue.dispose == "function" && s.oldValue.dispose(), ((e = this.environment) == null ? void 0 : e.mapping) === iu && (this.environment.mapping = Ia, this.environment.needsUpdate = !0), this.dispatchEvent({ type: "environmentChanged", environment: this.environment }), this.setDirty({ refreshScene: !0, geometryChanged: !1 }), (t = this.refreshUi) == null || t.call(this);
  }
  onBackgroundChange(s) {
    var e;
    s != null && s.oldValue && s.oldValue !== s.value && this.autoDisposeSceneMaps && typeof s.oldValue.dispose == "function" && s.oldValue.dispose(), this.dispatchEvent({ type: "backgroundChanged", background: this.background, backgroundColor: this.backgroundColor }), this.setDirty({ refreshScene: !0, geometryChanged: !1 }), (e = this.refreshUi) == null || e.call(this);
  }
  /**
   * @deprecated Use {@link addObject}
   */
  add(...s) {
    return super.add(...s), this;
  }
  /**
   * Sets the backgroundColor property from a string, number or Color, and updates the scene.
   * @param color
   */
  setBackgroundColor(s) {
    this.backgroundColor = s ? new se(s) : null;
  }
  /**
   * Mark the scene dirty, and force render in the next frame.
   * @param options - set `refreshScene` to true to mark that any object transformations have changed. It might trigger effects like frame fade depening on plugins.
   * @returns {this}
   */
  setDirty(s) {
    return s != null && s.sceneUpdate && (console.warn("sceneUpdate is deprecated, use refreshScene instead."), s.refreshScene = !0), s != null && s.refreshScene ? this.refreshScene(s) : (this.dispatchEvent({ type: "update", bubbleToParent: !1, object: this }), ct.setDirty.call(this, { ...s, scene: this })), this;
  }
  /**
   * For visualizing the scene bounds. API incomplete.
   * @type {Box3Helper}
   */
  // readonly boxHelper: Box3Helper
  refreshScene(s) {
    var e;
    return s && s.type === "objectUpdate" && s.object === this ? this : (s == null ? void 0 : s.sceneUpdate) === !1 || (s == null ? void 0 : s.refreshScene) === !1 || (e = s == null ? void 0 : s.object) != null && e.isCamera ? this.setDirty(s) : (this.refreshActiveCameraNearFar(), this._sceneBounds = this.getBounds(!1, !0), this._sceneBoundingRadius = this._sceneBounds.getSize(new M()).length() / 2, this.dispatchEvent({ ...s, type: "sceneUpdate", hierarchyChanged: ["addedToParent", "removedFromParent"].includes((s == null ? void 0 : s.change) || "") }), ct.setDirty.call(this, s), this);
  }
  /**
   * Dispose the scene and clear all resources.
   * WARNING - Not fully implemented yet, just clears the scene.
   */
  dispose(s = !0) {
    var e, t, i, n;
    this.disposeSceneModels(!1, s), s && ([...this.children].forEach((r) => r.dispose ? r.dispose() : r.removeFromParent()), this.clear()), (e = this.environment) == null || e.dispose(), (t = this.background) != null && t.isTexture && ((n = (i = this.background) == null ? void 0 : i.dispose) == null || n.call(i)), s && (this.environment = null, this.background = null);
  }
  /**
   * Returns the bounding box of the whole scene (model root and other meta objects).
   * To get the bounds of just the objects added by the user(not by plugins) use `new Box3B().expandByObject(scene.modelRoot)`
   * @param precise
   * @param ignoreInvisible
   * @param ignoreWidgets
   * @param ignoreObject
   * @returns {Box3B}
   */
  getBounds(s = !1, e = !0, t = !0, i) {
    return new Nn().expandByObject(this, s, e, (n) => t && (n.isWidget || n.assetType === "widget") ? !0 : (i == null ? void 0 : i(n)) ?? !1);
  }
  /**
   * Similar to {@link getBounds}, but returns the bounding box of just the {@link modelRoot}.
   * @param precise
   * @param ignoreInvisible
   * @param ignoreWidgets
   * @param ignoreObject
   * @returns {Box3B}
   */
  getModelBounds(s = !1, e = !0, t = !0, i) {
    return this.modelRoot == null ? new Nn() : new Nn().expandByObject(this.modelRoot, s, e, (n) => t && n.assetType === "widget" ? !0 : (i == null ? void 0 : i(n)) ?? !1);
  }
  autoGPUInstanceMeshes() {
    const s = /* @__PURE__ */ new Set();
    this.modelRoot.traverse((e) => e.geometry && s.add(e.geometry)), s.forEach((e) => uE(e));
  }
  /**
   * Refreshes the scene active camera near far values, based on the scene bounding box.
   * This is called automatically every time the camera is updated.
   */
  refreshActiveCameraNearFar() {
    const s = this.mainCamera;
    if (!s) return;
    if (!this.autoNearFarEnabled || s.userData.autoNearFar === !1) {
      s.near = s.userData.minNearPlane ?? 0.5, s.far = s.userData.maxFarPlane ?? 1e3;
      return;
    }
    const e = this.getBounds(!1), t = e.getSize(this._v2).length();
    if (t < 1e-3) {
      s.near = s.userData.minNearPlane ?? 0.5, s.far = s.userData.maxFarPlane ?? 1e3;
      return;
    }
    s.getWorldPosition(this._v1).sub(e.getCenter(this._v2));
    const i = 1.5 * Math.max(0.25, t) / 2, n = this._v1.length(), r = Math.max(0.1, -this._v1.normalize().dot(s.getWorldDirection(new M()))), a = Math.max(Math.max(s.userData.minNearPlane ?? 0.5, 1e-3), r * (n - i));
    let o = Math.min(Math.max(a + i, r * (n + i)), s.userData.maxFarPlane ?? 1e3);
    (o < a || o - a < 0.1) && (o = a + 0.1), s.near = a, s.far = o;
  }
  /**
   * Refreshes the scene active camera near far values, based on the scene bounding box.
   * This is called automatically every time the camera fov is updated.
   */
  dollyActiveCameraFov() {
    const s = this.mainCamera;
    if (!s || !s.userData.dollyFov)
      return;
    const e = this.getModelBounds(!1, !0, !0), t = nb(s, e) * 1.5, i = new M().subVectors(s.target, s.position).normalize();
    s.position.copy(i.multiplyScalar(-t).add(s.target)), s.setDirty();
  }
  updateShaderProperties(s) {
    return s.uniforms.sceneBoundingRadius ? s.uniforms.sceneBoundingRadius.value = this._sceneBoundingRadius : console.warn("RootScene: no uniform: sceneBoundingRadius"), this;
  }
  /**
   * Serialize the scene properties
   * @param meta
   * @returns {any}
   */
  toJSON(s) {
    return mt.Serialize(this, s, !0);
  }
  /**
   * Deserialize the scene properties
   * @param json - object from {@link toJSON}
   * @param meta
   * @returns {this<ICamera>}
   */
  fromJSON(s, e) {
    const t = s.environment;
    return t !== void 0 && (this.environment = mt.Deserialize(t, this.environment, e, !1), delete s.environment), mt.Deserialize(s, this, e, !0), s.environment = t, this;
  }
  addEventListener(s, e) {
    s === "activeCameraChange" && console.error("activeCameraChange is deprecated. Use mainCameraChange instead."), s === "activeCameraUpdate" && console.error("activeCameraUpdate is deprecated. Use mainCameraUpdate instead."), s === "sceneMaterialUpdate" && console.error("sceneMaterialUpdate is deprecated. Use materialUpdate instead."), s === "update" && console.error("update is deprecated. Use sceneUpdate instead."), super.addEventListener(s, e);
  }
  // endregion
  // region deprecated
  // /**
  //  * Set the scene environment map, this will be processed with PMREM automatically later.
  //  * @param asset
  //  * @returns {void}
  //  */
  // public setEnvironment(asset: ITexture|null|undefined): void {
  //     if (!asset) {
  //         // eslint-disable-next-line deprecation/deprecation
  //         this.environment = null
  //         this._onEnvironmentChange()
  //         return
  //     }
  //     if (!asset.isTexture) {
  //         console.error('Unknown Environment type', asset)
  //         return
  //     }
  //     if (asset.mapping === UVMapping) {
  //         asset.mapping = EquirectangularReflectionMapping // for PMREMGenerator
  //         asset.needsUpdate = true
  //     }
  //     // eslint-disable-next-line deprecation/deprecation
  //     this.environment = asset
  //     // eslint-disable-next-line deprecation/deprecation
  //     // this.background = texture // for testing.
  //     this._onEnvironmentChange()
  // }
  //
  // /**
  //  * Get the current scene environment map
  //  * @returns {ITexture<Texture>}
  //  */
  // getEnvironment(): ITexture | null {
  //     return this.environment || null
  // }
  /**
   * Find objects by name exact match in the complete hierarchy.
   * @deprecated Use {@link getObjectByName} instead.
   * @param name - name
   * @param parent - optional root node to start search from
   * @returns Array of found objects
   */
  findObjectsByName(s, e) {
    const t = [];
    return (e ?? this).traverse((i) => {
      i.name === s && t.push(i);
    }), t;
  }
  /**
   * @deprecated
   * Sets the camera pointing towards the object at a specific distance.
   * @param rootObject - The object to point at.
   * @param centerOffset - The distance offset from the object to point at.
   * @param targetOffset - The distance offset for the target from the center of object to point at.
   * @param options - Not used yet.
   */
  resetCamera(s = void 0, e = new M(1, 1, 1), t = new M(0, 0, 0)) {
    if (this._mainCamera) {
      this.matrixWorldNeedsUpdate = !0, this.updateMatrixWorld(!0);
      const i = s ? new Nn().expandByObject(s, !0, !0) : this.getBounds(!0), n = i.getCenter(new M()), r = i.getSize(new M()).length() * 0.5;
      n.add(t.clone().multiplyScalar(r)), this._mainCamera.position = new M(
        // todo: for nested cameras?
        n.x + e.x * r,
        n.y + e.y * r,
        n.z + e.z * r
      ), this._mainCamera.target = n, this.setDirty();
    }
  }
  /**
   * Minimum Camera near plane
   * @deprecated - use camera.minNearPlane instead
   */
  get minNearDistance() {
    return console.error("minNearDistance is deprecated. Use camera.userData.minNearPlane instead"), this.mainCamera.userData.minNearPlane ?? 0.02;
  }
  /**
   * @deprecated - use camera.minNearPlane instead
   */
  set minNearDistance(s) {
    console.error("minNearDistance is deprecated. Use camera.userData.minNearPlane instead"), this.mainCamera && (this.mainCamera.userData.minNearPlane = s);
  }
  /**
   * @deprecated
   */
  get activeCamera() {
    return console.error("activeCamera is deprecated. Use mainCamera instead."), this.mainCamera;
  }
  /**
   * @deprecated
   */
  set activeCamera(s) {
    console.error("activeCamera is deprecated. Use mainCamera instead."), this.mainCamera = s;
  }
  /**
   * Get the threejs scene object
   * @deprecated
   */
  get modelObject() {
    return this;
  }
  /**
   * @deprecated use {@link envMapIntensity} instead
   */
  get environmentIntensity() {
    return this.envMapIntensity;
  }
  /**
   * @deprecated use {@link envMapIntensity} instead
   */
  set environmentIntensity(s) {
    this.envMapIntensity = s;
  }
  /**
   * Add any processed scene object to the scene.
   * @deprecated renamed to {@link addObject}
   * @param imported
   * @param options
   */
  addSceneObject(s, e) {
    return this.addObject(s, e);
  }
  /**
   * Equivalent to setDirty({refreshScene: true}), dispatches 'sceneUpdate' event with the specified options.
   * @deprecated use refreshScene
   * @param options
   */
  updateScene(s) {
    return console.warn("updateScene is deprecated. Use refreshScene instead"), this.refreshScene(s || {});
  }
  /**
   * @deprecated renamed to {@link clearSceneModels}
   */
  removeSceneModels() {
    this.clearSceneModels();
  }
  // endregion
};
Us([
  wr("Background Color", (s) => ({
    onChange: () => s == null ? void 0 : s.onBackgroundChange()
  })),
  V(),
  Pi(Qi.prototype.onBackgroundChange)
], Qi.prototype, "backgroundColor", 2);
Us([
  bt(Qi.prototype.onBackgroundChange),
  V(),
  ta("Background Image")
], Qi.prototype, "background", 2);
Us([
  V(),
  bt(Qi.prototype.setDirty),
  Ye("Background Intensity", [0, 10], 0.01)
], Qi.prototype, "backgroundIntensity", 2);
Us([
  ta("Environment"),
  V(),
  bt(Qi.prototype._onEnvironmentChange)
], Qi.prototype, "environment", 2);
Us([
  Ye("Environment Intensity", [0, 10], 0.01),
  V(),
  bt(Qi.prototype.setDirty)
], Qi.prototype, "envMapIntensity", 2);
Us([
  Ye("Environment Rotation", [-Math.PI, Math.PI], 0.01),
  Ht({ obj: "environment", key: "rotation", onChange: Qi.prototype.setDirty, onChangeParams: !1 })
], Qi.prototype, "envMapRotation", 2);
Us([
  V()
], Qi.prototype, "textureSlots", 2);
Us([
  ue("Fixed Env Direction"),
  V(),
  bt(Qi.prototype.setDirty)
], Qi.prototype, "fixedEnvMapDirection", 2);
Us([
  Ki(),
  V()
], Qi.prototype, "defaultCamera", 2);
Us([
  Pt("Center All Geometries", { sendArgs: !1 })
], Qi.prototype, "centerAllGeometries", 1);
Us([
  Pt("Auto GPU Instance Meshes")
], Qi.prototype, "autoGPUInstanceMeshes", 1);
Qi = Us([
  Lt("Root Scene")
], Qi);
class tf {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const nU = new _r(-1, 1, 1, -1, 0, 1);
class sU extends Ze {
  constructor() {
    super(), this.setAttribute("position", new Te([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Te([0, 2, 0, 0, 2, 0], 2));
  }
}
const rU = new sU();
class aU {
  constructor(e) {
    this._mesh = new Se(rU, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, nU);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class sb extends tf {
  constructor(e, t, i = null, n = null, r = null) {
    super(), this.scene = e, this.camera = t, this.overrideMaterial = i, this.clearColor = n, this.clearAlpha = r, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new se();
  }
  render(e, t, i, n, r, a) {
    if (!this.scene || !this.camera) return;
    const o = e.autoClear;
    e.autoClear = !1;
    let l, c;
    if (this.overrideMaterial !== null && (c = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor)), this.clearAlpha !== null && (l = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : i), a) {
      const h = e.getContext();
      h.framebufferRenderbuffer(h.FRAMEBUFFER, h.DEPTH_ATTACHMENT, h.RENDERBUFFER, a);
    }
    if (this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), a) {
      const h = e.getContext();
      h.framebufferRenderbuffer(h.FRAMEBUFFER, h.DEPTH_ATTACHMENT, h.RENDERBUFFER, null);
    }
    this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(l), this.overrideMaterial !== null && (this.scene.overrideMaterial = c), e.autoClear = o;
  }
}
const rc = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class rb extends tf {
  constructor(e, t) {
    super(), this.textureID = t !== void 0 ? t : "tDiffuse", e instanceof ln ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = Ec.clone(e.uniforms), this.material = new ln({
      name: e.name !== void 0 ? e.name : "unspecified",
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this.fsQuad = new aU(this.material), this.useExistingRenderTarget = !1;
  }
  render(e, t, i) {
    this.uniforms[this.textureID] && i && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (this.useExistingRenderTarget || e.setRenderTarget(t || null), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
var oU = Object.defineProperty, lU = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && oU(e, t, n), n;
}, mo;
const Cg = (mo = class extends rb {
  constructor(e, ...t) {
    super(
      e.isMaterial ? e : new UL(e, t),
      t.length < 1 ? mo.DEFAULT_TEX_ID : t[0]
    ), this.overrideReadBuffer = null, this.isExtendedShaderPass = !0, this.enabled = !0, this.onDirty = [], this.setDirty = this.setDirty.bind(this);
  }
  // writes to writeBuffer
  render(e, t, i, n, r) {
    this.enabled && e.renderWithModes({
      backgroundRender: !1
    }, () => {
      super.render(e, t || null, this.overrideReadBuffer || i, n, r);
    });
  }
  /**
   * to be called from beforeRender or onObjectRender or similar.
   * @param updater
   */
  updateShaderProperties(e) {
    e && (Array.isArray(e) || (e = [e]), e.forEach((t) => t == null ? void 0 : t.updateShaderProperties(this.material)));
  }
  dispose() {
    var e, t, i, n;
    (t = (e = this.material) == null ? void 0 : e.dispose) == null || t.call(e), (n = (i = this.fsQuad) == null ? void 0 : i.dispose) == null || n.call(i), this.onDirty = [];
  }
  setDirty() {
    var e;
    this.material && (this.material.needsUpdate = !0), (e = this.onDirty) == null || e.forEach((t) => t());
  }
  // legacy
  /**
   * @deprecated renamed to {@link isExtendedShaderPass}
   */
  get isShaderPass2() {
    return console.error("isShaderPass2 is deprecated, use isExtendedShaderPass instead"), !0;
  }
}, mo.DEFAULT_TEX_ID = "tDiffuse", mo);
lU([
  ue("Enabled"),
  V(),
  Pi(Cg.prototype.setDirty)
], Cg.prototype, "enabled");
let gu = Cg;
class cU extends gu {
  constructor(e, t = "c = a + b;", i = "", n, r = 120) {
    super({
      vertexShader: rc.vertexShader,
      fragmentShader: `
                varying vec2 vUv;
                ${i}
                void main() {
                    vec4 a = tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) );
                    vec4 b = tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) );
                    vec4 c = vec4(0);
                    ${t}
                    c = clamp(c, vec4(0), vec4(MAX_INTENSITY));
                    gl_FragColor = c;
                    #include <colorspace_fragment>
                }
            `,
      uniforms: {
        tDiffuse: { value: null },
        tDiffuse2: { value: n },
        ...e
      },
      defines: {
        MAX_INTENSITY: r
      }
    }, "tDiffuse", "tDiffuse2"), this.clear = !1, this.needsSwap = !0;
  }
}
var hU = Object.defineProperty, uU = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && hU(e, t, n), n;
};
class ab extends sb {
  constructor(e, t, i = new se(0, 0, 0), n = 0) {
    super(void 0, void 0, t, i, n), this.isExtendedRenderPass = !0, this.enabled = !0, this.passId = "render", this._doTransmissionFix = !0, this.blurTransmissionTarget = !0, this.preserveTransparentTarget = !1, this.preserveOpaqueTarget = !1, this.onDirty = [], this.uiConfig = {
      label: "Render Pass",
      type: "folder",
      children: mr(this)
    }, this.renderManager = e, this._blendPass = new cU({}, "c = vec4(a.rgb * (1. - b.a) + b.rgb * b.a, 1.);", "", void 0, e.maxHDRIntensity), this.setDirty = this.setDirty.bind(this);
  }
  get transparentTarget() {
    if (!this._transparentTarget) {
      const e = this.renderManager.msaa;
      this._transparentTarget = this.renderManager.getTempTarget({
        sizeMultiplier: 1,
        samples: e ? typeof e != "number" ? Ar.DEFAULT_MSAA_SAMPLES : e : 0,
        colorSpace: Wt,
        type: this.renderManager.renderer.extensions.has("EXT_color_buffer_half_float") ? Qt : Ft,
        format: ei,
        minFilter: tt,
        magFilter: tt,
        depthBuffer: !1
      });
    }
    return this._transparentTarget;
  }
  _releaseTransparentTarget() {
    this._transparentTarget && this.renderManager.releaseTempTarget(this._transparentTarget), this._transparentTarget = void 0;
  }
  get opaqueTarget() {
    if (!this._opaqueTarget) {
      const e = this.renderManager.composerTarget, t = this.renderManager.msaa;
      this._opaqueTarget = this.renderManager.getTempTarget({
        sizeMultiplier: 1,
        samples: t ? typeof t != "number" ? Ar.DEFAULT_MSAA_SAMPLES : t : 0,
        colorSpace: e.texture.colorSpace,
        type: this.renderManager.rgbm ? Ft : Qt,
        format: e.texture.format,
        minFilter: e.texture.minFilter,
        magFilter: e.texture.magFilter,
        depthBuffer: e.depthBuffer,
        generateMipmaps: e.texture.generateMipmaps
      });
    }
    return this._opaqueTarget;
  }
  _releaseOpaqueTarget() {
    this._opaqueTarget && this.renderManager.releaseTempTarget(this._opaqueTarget), this._opaqueTarget = void 0;
  }
  // names are incorrect. We read from `writeBuffer` and write to `readBuffer`. same in super class
  render(e, t, i, n, r) {
    if (!this.enabled) return;
    let a = !1;
    if (e.userData.mainRenderPass = !0, !this._doTransmissionFix && !this.renderManager.rgbm) {
      super.render(e, t || null, i, n, r), this.needsSwap = a, e.userData.mainRenderPass = void 0;
      return;
    }
    const o = e.userData;
    o || console.error("threejs is not patched. Use the @repalash/three.js-modded to this functionality.");
    const l = (this.renderManager.zPrepass || !this.renderManager.depthBuffer) && this.renderManager.gbufferTarget;
    let c;
    if (l) {
      const d = this.renderManager.gbufferTarget;
      if (d) {
        const p = e.properties.get(d);
        c = p.__webglDepthRenderbuffer || p.__webglDepthbuffer;
      }
      c || console.warn("No depth/gbuffer present for zPrepass.");
    }
    const h = i;
    i = this.renderManager.msaa ? this.opaqueTarget : i;
    let u = () => {
      super.render(e, null, i, n, r, c);
    };
    if (this.renderManager.rgbm) {
      if (this.renderManager.rgbm) {
        a = !1;
        const d = this.renderToScreen;
        if (d && !t && console.error("ExtendedRenderPass: renderToScreen is true but writeBuffer is not set, which is required for rgbm"), this.renderToScreen = !1, e.info && !e.info.autoReset)
          throw "renderer.info.autoReset must be true";
        {
          const p = e.autoClearDepth;
          e.autoClearDepth = !l, e.renderWithModes({
            shadowMapRender: !0,
            backgroundRender: !0,
            opaqueRender: !0,
            transparentRender: !1,
            transmissionRender: !1
          }, u), e.autoClearDepth = p;
        }
        if (!l && i) {
          const p = e.properties.get(i);
          c = p.__webglDepthRenderbuffer || p.__webglDepthbuffer;
        }
        u = () => {
          super.render(e, null, this.transparentTarget, n, r, c);
        };
        {
          const p = this.clear, f = e.autoClearDepth;
          e.autoClearDepth = !1, this.clear = !0, e.renderWithModes({
            shadowMapRender: !1,
            backgroundRender: !1,
            opaqueRender: !1,
            transparentRender: !0,
            transmissionRender: !1
          }, u), this.clear = p, e.autoClearDepth = f;
        }
        (!e.info || e.info.render.calls > 0) && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e, t, i, n, r), a = !0);
        {
          const p = this.clear;
          this.clear = !1, o.transmissionRenderTarget = a ? t : i, o.blurTransmissionTarget = this.blurTransmissionTarget && o.transmissionRenderTarget.samples === 0, e.renderWithModes({
            shadowMapRender: !1,
            backgroundRender: !1,
            opaqueRender: !1,
            transparentRender: !1,
            transmissionRender: !0
          }, u), o.blurTransmissionTarget = void 0, o.transmissionRenderTarget = void 0, this.clear = p;
        }
        if ((!e.info || e.info.render.calls > 0) && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e, t, i, n, r), a = !0), d) {
          this.renderToScreen = !0;
          const p = a ? t == null ? void 0 : t.texture : i == null ? void 0 : i.texture, f = Array.isArray(p) ? p[0] : p;
          f && this.renderManager.blit(void 0, {
            source: f,
            respectColorSpace: !0
          });
        }
      }
    } else {
      {
        const d = this.clear, p = e.autoClearDepth;
        e.autoClearDepth = !l, this.clear = !0, e.renderWithModes({
          shadowMapRender: !0,
          backgroundRender: !0,
          opaqueRender: !0,
          transparentRender: !0,
          transmissionRender: !1
        }, u), this.clear = d, e.autoClearDepth = p;
      }
      {
        const d = i ? Array.isArray(i.texture) ? i.texture[0] : i.texture : void 0;
        this.renderManager.blit(t, { clear: !0, source: d });
        const p = this.clear;
        this.clear = !1, o.transmissionRenderTarget = t, o.blurTransmissionTarget = this.blurTransmissionTarget && o.transmissionRenderTarget.samples === 0, e.renderWithModes({
          shadowMapRender: !1,
          backgroundRender: !1,
          opaqueRender: !1,
          transparentRender: !1,
          transmissionRender: !0
        }, u), o.blurTransmissionTarget = void 0, o.transmissionRenderTarget = void 0, this.clear = p;
      }
      a = !1;
    }
    if (!a && h !== i && i) {
      const d = Array.isArray(i.texture) ? i.texture[0] : i.texture;
      d && this.renderManager.blit(h, {
        source: d,
        clear: !0
      }), i = h;
    }
    this.preserveTransparentTarget || this._releaseTransparentTarget(), this.preserveOpaqueTarget || this._releaseOpaqueTarget(), this.needsSwap = a, e.userData.mainRenderPass = void 0;
  }
  dispose() {
    var e;
    this._releaseTransparentTarget(), this.onDirty = [], this.scene = void 0, this.camera = void 0, (e = super.dispose) == null || e.call(this);
  }
  setDirty() {
    this.onDirty.forEach((e) => e());
  }
  beforeRender(e, t, i) {
    this.scene = e, this.camera = t;
  }
  // legacy
  /**
   * @deprecated renamed to {@link isExtendedRenderPass}
   */
  get isRenderPass2() {
    return console.error("isRenderPass2 is deprecated, use isExtendedRenderPass instead"), !0;
  }
}
uU([
  ue("Enabled"),
  V()
], ab.prototype, "enabled");
class ob extends gu {
  constructor(e, t = !0) {
    super({
      uniforms: Ec.clone(rc.uniforms),
      vertexShader: rc.vertexShader,
      fragmentShader: Oa`
                uniform float opacity;
                #include <alphatest_pars_fragment>
                varying vec2 vUv;
                void main() {
                    ${t ? "vec4 diffuseColor = tDiffuseTexelToLinear(texture2D(tDiffuse, vUv)) * opacity;" : "vec4 diffuseColor = texture2D(tDiffuse, vUv) * opacity;"}
                    #include <alphatest_fragment>
                    ${e ? gi(e, "diffuseColor") : ""}
                    #ifdef OPAQUE
                    diffuseColor.a = 1.0;
                    #endif
                    gl_FragColor = diffuseColor;
                    ${t ? "#include <colorspace_fragment>" : ""}
                }
            `
    }, "tDiffuse");
  }
}
var dU = Object.defineProperty, pU = Object.getOwnPropertyDescriptor, lb = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? pU(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && dU(e, t, n), n;
};
let To = class extends sb {
  constructor(s, e, t, i = new se(1, 1, 1), n = 1) {
    super(void 0, void 0, t, i, n), this.passId = s, this.target = e, this.isGBufferRenderPass = !0, this.enabled = !0, this._transparentMats = /* @__PURE__ */ new Set(), this._transmissiveMats = /* @__PURE__ */ new Set(), this.preprocessMaterial = (r, a) => {
      a = a ?? r.userData.renderToGBuffer, r.userData.pluginsDisabled && (a = !1), (r.transparent && (a || r.opacity > 0.99 && !r.map && !r.alphaMap) || // transparent and render to gbuffer
      !r.transparent && !r.transmission && a === !1) && (this._transparentMats.add(r), r.transparent = !r.transparent), r.transmission && Math.abs(r.transmission || 0) > 0 && a && (this._transmissiveMats.add([r, r.transmission]), r.transmission = 0);
    };
  }
  /**
   * Renders to {@link target}
   * @param renderer
   * @param _ - this is ignored
   * @param _1 - this is ignored
   * @param deltaTime
   * @param maskActive
   */
  render(s, e, t, i, n) {
    if (!this.scene || !this.camera) return;
    const r = s.getRenderTarget(), a = s.getActiveCubeFace(), o = s.getActiveMipmapLevel();
    this.scene.traverse(({ material: l }) => {
      l && (Array.isArray(l) ? l.forEach((c) => this.preprocessMaterial(c)) : this.preprocessMaterial(l));
    }), s.renderWithModes({
      shadowMapRender: !1,
      backgroundRender: !1,
      opaqueRender: !0,
      transparentRender: !1,
      transmissionRender: !1,
      mainRenderPass: !1
    }, () => super.render(s, null, gi(this.target), i, n)), this._transparentMats.forEach((l) => l.transparent = !l.transparent), this._transparentMats.clear(), this._transmissiveMats.forEach(([l, c]) => l.transmission = c), this._transmissiveMats.clear(), s.setRenderTarget(r, a, o);
  }
  beforeRender(s, e, t) {
    this.scene = s, this.camera = e;
  }
};
lb([
  ue("Enabled")
], To.prototype, "enabled", 2);
To = lb([
  Lt((s) => s.passId + " Render Pass")
], To);
const fU = `#include <packing>
varying vec2 vUv;
#include <alphatest_pars_fragment>
void main(){vec4 diffuseColor=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));
#ifdef HAS_TRANSPARENT_TARGET
vec4 transparentColor=tTransparentTexelToLinear(texture2D(tTransparent,vUv));
#else
vec4 transparentColor=vec4(0.0);
#endif
#ifdef HAS_GBUFFER
float depth=getDepth(vUv);bool isBackground=depth>0.99&&transparentColor.a<0.001;
#endif
#glMarker
#ifdef HAS_GBUFFER
#if (defined(CLIP_BACKGROUND) && CLIP_BACKGROUND > 0) || defined(CLIP_BACKGROUND_FORCE)
if(isBackground)diffuseColor.a=0.0;if(depth>0.99&&transparentColor.a>=0.001)diffuseColor.a=transparentColor.a;
#endif
if(depth<0.00001)diffuseColor.a=0.0;
#endif
#include <alphatest_fragment>
#ifdef OPAQUE
diffuseColor.a=1.0;
#endif
gl_FragColor=diffuseColor;
#include <colorspace_fragment>
}`;
var mU = Object.defineProperty, gU = Object.getOwnPropertyDescriptor, nf = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? gU(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && mU(e, t, n), n;
};
let La = class extends gu {
  constructor(s = "", ...e) {
    super(
      s != null && s.fragmentShader || s != null && s.isShaderMaterial ? s : AU(s),
      ...e.length ? e : ["tDiffuse", "tTransparent"]
    ), this.passId = "screen", this.after = ["render"], this.required = ["render"], this.outputColorSpace = dt, this._needsReRender = !1, this.clipBackgroundForce = !1, this.clipBackground = !1, this.material.addEventListener("materialUpdate", this.setDirty);
  }
  render(s, e, t, i, n) {
    const r = s.outputColorSpace;
    (!e || this.renderToScreen) && (s.outputColorSpace = this.outputColorSpace), super.render(s, e, t, i, n), this._lastReadBuffer = t, s.outputColorSpace = r, this._needsReRender = !1;
  }
  reRender(s, e, t, i) {
    this._lastReadBuffer && this.render(s, e, this._lastReadBuffer, t, i);
  }
  onPostFrame(s) {
    this._needsReRender && (this._needsReRender = !1, this.reRender(s.renderer), this.clipBackground && !s.gbufferTarget && console.warn("ScreenPass: clipBackground set to true but no gbufferTarget set. Try adding GBufferPlugin."));
  }
  dispose() {
    this._lastReadBuffer = void 0, super.dispose();
  }
  beforeRender(s, e, t) {
    var i;
    this.material.uniforms.tTransparent.value = t.renderPass.preserveTransparentTarget && ((i = t.renderPass.transparentTarget) == null ? void 0 : i.texture) || null, this.material.defines.HAS_TRANSPARENT_TARGET = this.material.uniforms.tTransparent.value ? 1 : void 0, this.material.defines.HAS_TRANSPARENT_TARGET || delete this.material.defines.HAS_TRANSPARENT_TARGET;
  }
  setDirty() {
    super.setDirty(), this._needsReRender = !0;
  }
};
nf([
  er("Output Color Space", hE.ColorSpace.uiConfig, (s) => ({ onChange: s.setDirty }))
], La.prototype, "outputColorSpace", 2);
nf([
  Yp("CLIP_BACKGROUND_FORCE", void 0, void 0, La.prototype.setDirty, !0)
], La.prototype, "clipBackgroundForce", 2);
nf([
  Yp("CLIP_BACKGROUND", void 0, void 0, La.prototype.setDirty),
  ue()
], La.prototype, "clipBackground", 2);
La = nf([
  Lt("Screen Pass")
], La);
function AU(s) {
  return {
    ...rc,
    fragmentShader: Ct(
      Ct(
        fU,
        "void main()",
        (Array.isArray(s) ? s[0] : (s == null ? void 0 : s.pars) || "") + `
`,
        { prepend: !0 }
      ),
      "#glMarker",
      (Array.isArray(s) ? s[1] : typeof s == "string" ? s : (s == null ? void 0 : s.main) || "") + `
`,
      { prepend: !0 }
    ),
    uniforms: {
      tDiffuse: { value: null },
      tTransparent: { value: null }
    },
    transparent: !0,
    blending: _n,
    side: $n
  };
}
function yU(s) {
  const e = [], t = {};
  for (const i of s)
    i.passId && (t[i.passId] = {
      after: i.after ?? [],
      before: i.before ?? [],
      dependencies: new Set(i.required ?? [])
    });
  for (const [i, n] of Object.entries(t)) {
    const r = /* @__PURE__ */ new Set([...n.after, ...n.before]);
    n.dependencies.forEach((a) => r.has(a) && r.delete(a)), r.forEach((a) => {
      const o = t[a];
      if (o) {
        if (o.dependencies.has(i))
          throw console.error("cyclic", i, a), "Cyclic dependency";
        n.dependencies.add(a);
      }
    });
  }
  for (; ; ) {
    let i = !1;
    const n = [...Object.entries(t)];
    for (const [r, a] of n)
      if (!e.includes(r) && ZR(e, a.dependencies.values())) {
        const o = Math.max(-1, ...a.after.map((c) => e.indexOf(c))), l = Math.min(e.length, ...a.before.map((c) => {
          const h = e.indexOf(c);
          return h < 0 ? e.length : h;
        }));
        if (o >= l)
          throw console.error(a, s, e, o, l), "Not possible";
        e.splice(a.after.length > 0 ? o + 1 : l, 0, r), i = !0, delete t[r];
      }
    if (Object.keys(t).length < 1) break;
    if (!i)
      throw console.error(n, t, e), "Not possible 2";
  }
  return e;
}
class q_ extends tf {
  constructor(e, t) {
    super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, t, i) {
    const n = e.getContext(), r = e.state;
    r.buffers.color.setMask(!1), r.buffers.depth.setMask(!1), r.buffers.color.setLocked(!0), r.buffers.depth.setLocked(!0);
    let a, o;
    this.inverse ? (a = 0, o = 1) : (a = 1, o = 0), r.buffers.stencil.setTest(!0), r.buffers.stencil.setOp(n.REPLACE, n.REPLACE, n.REPLACE), r.buffers.stencil.setFunc(n.ALWAYS, a, 4294967295), r.buffers.stencil.setClear(o), r.buffers.stencil.setLocked(!0), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), r.buffers.color.setLocked(!1), r.buffers.depth.setLocked(!1), r.buffers.color.setMask(!0), r.buffers.depth.setMask(!0), r.buffers.stencil.setLocked(!1), r.buffers.stencil.setFunc(n.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(n.KEEP, n.KEEP, n.KEEP), r.buffers.stencil.setLocked(!0);
  }
}
class vU extends tf {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class _U {
  constructor(e, t) {
    if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), t === void 0) {
      const i = e.getSize(new ie());
      this._width = i.width, this._height = i.height, t = new Zn(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: Qt }), t.texture.name = "EffectComposer.rt1";
    } else
      this._width = t.width, this._height = t.height;
    this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new rb(rc), this.copyPass.material.blending = _n, this.clock = new NA();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, t) {
    this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const t = this.passes.indexOf(e);
    t !== -1 && this.passes.splice(t, 1);
  }
  isLastEnabledPass(e) {
    for (let t = e + 1; t < this.passes.length; t++)
      if (this.passes[t].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const t = this.renderer.getRenderTarget();
    let i = !1;
    for (let n = 0, r = this.passes.length; n < r; n++) {
      const a = this.passes[n];
      if (a.enabled !== !1) {
        if (a.renderToScreen = this.renderToScreen && this.isLastEnabledPass(n), a.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), a.needsSwap) {
          if (i) {
            const o = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
            l.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), l.setFunc(o.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        q_ !== void 0 && (a instanceof q_ ? i = !0 : a instanceof vU && (i = !1));
      }
    }
    this.renderer.setRenderTarget(t);
  }
  reset(e) {
    if (e === void 0) {
      const t = this.renderer.getSize(new ie());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, t) {
    this._width = e, this._height = t;
    const i = this._width * this._pixelRatio, n = this._height * this._pixelRatio;
    this.renderTarget1.setSize(i, n), this.renderTarget2.setSize(i, n);
    for (let r = 0; r < this.passes.length; r++)
      this.passes[r].setSize(i, n);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class xU extends _U {
  constructor(e, t) {
    super(e, t), this.copyPass2 = new ob();
  }
  setPixelRatio(e, t = !0) {
    const i = this.setSize;
    t || (this.setSize = () => {
    }), super.setPixelRatio(e), t || (this.setSize = i);
  }
}
function wU(s = {}) {
  var e, t;
  return [s.sizeMultiplier, s.samples, s.colorSpace, s.type, s.format, s.depthBuffer, s.depthTexture, s.textureCount, (e = s.size) == null ? void 0 : e.width, (t = s.size) == null ? void 0 : t.height].join(";");
}
class EU extends Vi {
  constructor() {
    super(), this._trackedTargets = [], this._trackedTempTargets = [], this._releasedTempTargets = {}, this.maxTempPerKey = 5, this._processNewTarget = this._processNewTarget.bind(this), this._processNewTempTarget = this._processNewTempTarget.bind(this), this.trackTarget = this.trackTarget.bind(this), this.disposeTarget = this.disposeTarget.bind(this), this.createTarget = this.createTarget.bind(this), this.createTargetCustom = this.createTargetCustom.bind(this);
  }
  trackTarget(e) {
    this._trackedTargets.push(e);
  }
  removeTrackedTarget(e) {
    const t = this._trackedTargets.indexOf(e);
    t >= 0 && this._trackedTargets.splice(t, 1);
  }
  createTarget({
    sizeMultiplier: e = void 0,
    samples: t = 0,
    colorSpace: i = Wt,
    type: n = Ft,
    format: r = ei,
    depthBuffer: a = !0,
    depthTexture: o = !1,
    depthTextureType: l = qs,
    depthTextureFormat: c = Ea,
    size: h = void 0,
    textureCount: u = 1,
    ...d
  } = {}, p = !0) {
    this.isWebGL2 || (t = 0), e !== void 0 && h !== void 0 && console.error("Both sizeMultiplier and size are defined. sizeMultiplier will be ignored."), h = h || this.renderSize.clone().multiplyScalar(this.renderScale * (e = e || 1)), h.width = Math.floor(h.width), h.height = Math.floor(h.height);
    const f = o ? new bw(h.width, h.height, l) : null;
    f && (f.format = c);
    const y = this.createTargetCustom(
      u > 1 ? {
        width: h.width,
        height: h.height,
        count: u
      } : h,
      { samples: t, colorSpace: i, type: n, format: r, depthBuffer: a, depthTexture: f },
      u > 1 ? gC : Zn
    );
    return this._processNewTarget(y, e, p), this._setTargetOptions(y, d), y;
  }
  /**
   * Dispose and remove tracked target. Release target in-case of temporary target.
   * To just dispose from the GPU memory and keep reference, call `target.dispose()` or `target.dispose(false)`
   * @param target
   * @param remove
   */
  disposeTarget(e, t = !0) {
    if (e) {
      if (e.isTemporary) return this.releaseTempTarget(e);
      t && this.removeTrackedTarget(e), e.dispose(!1);
    }
  }
  getTempTarget(e = {}) {
    var n;
    const t = wU(e);
    let i;
    return (n = this._releasedTempTargets[t]) != null && n.length && (i = this._releasedTempTargets[t].pop()), i ? this._setTargetOptions(i, e) : (i = this.createTarget(e), this._processNewTempTarget(i, t)), i;
  }
  releaseTempTarget(e) {
    const t = e.targetKey;
    if (!t || !e.isTemporary)
      throw "Not a temp target";
    this._releasedTempTargets[t].length > this.maxTempPerKey ? (this.removeTrackedTarget(e), e.dispose()) : this._releasedTempTargets[t].push(e);
  }
  createTargetCustom({
    width: e,
    height: t,
    count: i
  }, n = {}, r) {
    let a = [e, t];
    if (i && i > 1 && a.push(i), (r == null ? void 0 : r.prototype) === Aw.prototype) {
      if (e !== t) throw "Width and height of cube render target must be equal";
      a = [e];
    }
    return this._createTargetClass(r ?? Zn, a, {
      format: ei,
      minFilter: tt,
      magFilter: tt,
      generateMipmaps: !1,
      type: Ft,
      colorSpace: Wt,
      ...n
    });
  }
  dispose(e = !0) {
    this._trackedTargets.forEach((t) => t.dispose()), Object.values(this._trackedTempTargets).forEach((t) => t.dispose()), e && (this._trackedTargets = [], this._releasedTempTargets = {}, this._trackedTempTargets = []);
  }
  /**
   * Resizes all tracked targets with a sizeMultiplier based on the current renderSize and renderScale.
   * This must be automatically called by the renderer on resize, and manually when sizeMultiplier of a target changes.
   */
  resizeTrackedTargets() {
    for (const e of this._trackedTargets) this.resizeTrackedTarget(e);
  }
  resizeTrackedTarget(e) {
    const t = e.sizeMultiplier;
    if (t) {
      const i = this.renderSize.clone().multiplyScalar(this.renderScale * t);
      e.setSize(Math.floor(i.width), Math.floor(i.height));
    }
  }
  _processNewTempTarget(e, t) {
    return e.isTemporary = !0, e.targetKey = t, this._releasedTempTargets[t] === void 0 && (this._releasedTempTargets[t] = []), this._trackedTempTargets.push(e), e;
  }
  _setTargetOptions(e, t) {
    const i = e.texture;
    for (const n of Array.isArray(i) ? i : [i])
      this._setTargetTextureOptions(n, t);
  }
  _setTargetTextureOptions(e, t) {
    e.minFilter = t.minFilter ?? tt, e.magFilter = t.magFilter ?? tt, e.wrapS = t.wrapS ?? Zt, e.wrapT = t.wrapT ?? Zt, e.generateMipmaps = t.generateMipmaps ?? !1, e.generateMipmaps && e.minFilter === tt && (e.minFilter = Jy), !e.generateMipmaps && e.minFilter === Jy && (e.minFilter = tt);
  }
  _processNewTarget(e, t, i) {
    return t !== void 0 && (e.sizeMultiplier = t), i && this.trackTarget(e), e;
  }
}
class $i {
  constructor(e, t, i, n, r) {
    this.extensions = [], this.cls = e, this.ext = t.filter(Boolean).map((a) => a.toLowerCase()), this.mime = i.filter(Boolean).map((a) => a.toLowerCase()), this.root = n, this.onCtor = r;
  }
  ctor(e) {
    const t = this.cls && new this.cls(e.loadingManager);
    return typeof this.onCtor == "function" ? this.onCtor(t, e, this) : t;
  }
}
class cb extends ti {
  load(e, t, i, n) {
    return super.load(e, (r) => {
      try {
        if (typeof r == "string")
          t == null || t(JSON.parse(r));
        else
          throw new Error("Invalid JSON");
      } catch (a) {
        n == null || n(a);
      }
    }, i, n);
  }
}
class Ap extends cb {
  async loadAsync(e, t) {
    if (!this.viewer) throw "Viewer not set in JSONMaterialLoader.";
    const i = await super.loadAsync(e, t);
    return await Ap.DeserializeMaterialJSON(i, this.viewer);
  }
  static async DeserializeMaterialJSON(e, t, i, n) {
    i = i || Sa();
    const r = { ...e };
    e.images && (Array.isArray(e.images) ? i.images = Object.fromEntries(e.images.map((o) => [o.uuid, o])) : i.images = e.images, delete r.images), e.textures && (Array.isArray(e.textures) ? i.textures = Object.fromEntries(e.textures.map((o) => [o.uuid, o])) : i.textures = e.textures, delete r.textures), e.materials && (Array.isArray(e.materials) ? i.materials = Object.fromEntries(e.materials.map((o) => [o.uuid, o])) : i.materials = e.materials, delete r.materials);
    const a = await t.loadConfigResources(i);
    return mt.Deserialize(r, n || void 0, a);
  }
}
class hb extends ui {
  constructor(e) {
    super(e);
  }
  /**
   * Loads and parses a MTL asset from a URL.
   *
   * @param {String} url - URL to the MTL file.
   * @param {Function} [onLoad] - Callback invoked with the loaded object.
   * @param {Function} [onProgress] - Callback for download progress.
   * @param {Function} [onError] - Callback for download errors.
   *
   * {@link setPath} {@link setResourcePath}
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setResourcePath() explicitly prior to load.
   */
  load(e, t, i, n) {
    const r = this, a = this.path === "" ? hr.extractUrlBase(e) : this.path, o = new ti(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
      try {
        t(r.parse(l, a));
      } catch (c) {
        n ? n(c) : console.error(c), r.manager.itemError(e);
      }
    }, i, n);
  }
  setMaterialOptions(e) {
    return this.materialOptions = e, this;
  }
  /**
   * Parses a MTL file.
   *
   * @param {String} text - Content of MTL file
   * @return {MaterialCreator}
   *
   * {@link setPath} {@link setResourcePath}
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setResourcePath() explicitly prior to parse.
   */
  parse(e, t) {
    const i = e.split(`
`);
    let n = {};
    const r = /\s+/, a = {};
    for (let l = 0; l < i.length; l++) {
      let c = i[l];
      if (c = c.trim(), c.length === 0 || c.charAt(0) === "#")
        continue;
      const h = c.indexOf(" ");
      let u = h >= 0 ? c.substring(0, h) : c;
      u = u.toLowerCase();
      let d = h >= 0 ? c.substring(h + 1) : "";
      if (d = d.trim(), u === "newmtl")
        n = { name: d }, a[d] = n;
      else if (u === "ka" || u === "kd" || u === "ks" || u === "ke") {
        const p = d.split(r, 3);
        n[u] = [parseFloat(p[0]), parseFloat(p[1]), parseFloat(p[2])];
      } else
        n[u] = d;
    }
    const o = new bU(this.resourcePath || t, this.materialOptions);
    return o.setCrossOrigin(this.crossOrigin), o.setManager(this.manager), o.setMaterials(a), o;
  }
}
class bU {
  constructor(e = "", t = {}) {
    this.baseUrl = e, this.options = t, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = this.options.side !== void 0 ? this.options.side : $n, this.wrap = this.options.wrap !== void 0 ? this.options.wrap : xn;
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setManager(e) {
    this.manager = e;
  }
  setMaterials(e) {
    this.materialsInfo = this.convert(e), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
  }
  convert(e) {
    if (!this.options) return e;
    const t = {};
    for (const i in e) {
      const n = e[i], r = {};
      t[i] = r;
      for (const a in n) {
        let o = !0, l = n[a];
        const c = a.toLowerCase();
        switch (c) {
          case "kd":
          case "ka":
          case "ks":
            this.options && this.options.normalizeRGB && (l = [l[0] / 255, l[1] / 255, l[2] / 255]), this.options && this.options.ignoreZeroRGBs && l[0] === 0 && l[1] === 0 && l[2] === 0 && (o = !1);
            break;
        }
        o && (r[c] = l);
      }
    }
    return t;
  }
  async preload() {
    for (const e in this.materialsInfo)
      await this.create(e);
  }
  getIndex(e) {
    return this.nameLookup[e];
  }
  async getAsArray() {
    let e = 0;
    for (const t in this.materialsInfo)
      this.materialsArray[e] = await this.create(t), this.nameLookup[t] = e, e++;
    return this.materialsArray;
  }
  async create(e) {
    return this.materials[e] === void 0 && await this.createMaterial_(e), this.materials[e];
  }
  async createMaterial_(e) {
    const t = this, i = this.materialsInfo[e], n = {
      name: e,
      side: this.side
    };
    function r(c, h) {
      return typeof h != "string" || h === "" ? "" : /^https?:\/\//i.test(h) ? h : c + h;
    }
    async function a(c, h) {
      if (n[c]) return;
      const u = t.getTextureParams(h, n);
      return new Promise((d, p) => {
        let f = !1, y = () => !f && (f = !0) && d();
        const A = t.loadTexture(r(t.baseUrl, u.url), void 0, (m) => {
          n[c] = m, y();
        }, void 0, y);
        setTimeout(y, 50), A.repeat.copy(u.scale), A.offset.copy(u.offset), A.wrapS = t.wrap, A.wrapT = t.wrap, (c === "map" || c === "emissiveMap") && (A.colorSpace = dt);
      });
    }
    const o = Array.from(Object.keys(i || {}));
    let l = o.includes("d") || o.includes("D");
    for (const c of o) {
      const h = i[c];
      let u;
      if (h !== "")
        switch (c.toLowerCase()) {
          // Ns is material specular exponent
          case "kd":
            n.color = new se().fromArray(h).convertSRGBToLinear();
            break;
          case "ks":
            n.specular = new se().fromArray(h).convertSRGBToLinear();
            break;
          case "ke":
            n.emissive = new se().fromArray(h).convertSRGBToLinear();
            break;
          case "map_kd":
            await a("map", h);
            break;
          case "map_ks":
            await a("specularMap", h);
            break;
          case "map_ke":
            await a("emissiveMap", h);
            break;
          case "norm":
            await a("normalMap", h);
            break;
          case "map_bump":
          case "bump":
            await a("bumpMap", h);
            break;
          case "map_d":
            await a("alphaMap", h), n.transparent = !0;
            break;
          case "ns":
            n.shininess = parseFloat(h);
            break;
          case "d":
            u = parseFloat(h), u < 1 && (n.opacity = u, n.transparent = !0);
            break;
          case "tr":
            if (l) break;
            u = parseFloat(h), this.options && this.options.invertTrProperty && (u = 1 - u), u > 0 && (n.opacity = 1 - u, n.transparent = !0);
            break;
        }
    }
    return this.materials[e] = new Hl(n), this.materials[e];
  }
  getTextureParams(e, t) {
    const i = {
      scale: new ie(1, 1),
      offset: new ie(0, 0)
    }, n = e.split(/\s+/);
    let r;
    return r = n.indexOf("-bm"), r >= 0 && (t.bumpScale = parseFloat(n[r + 1]), n.splice(r, 2)), r = n.indexOf("-s"), r >= 0 && (i.scale.set(parseFloat(n[r + 1]), parseFloat(n[r + 2])), n.splice(r, 4)), r = n.indexOf("-o"), r >= 0 && (i.offset.set(parseFloat(n[r + 1]), parseFloat(n[r + 2])), n.splice(r, 4)), i.url = n.join(" ").trim(), i;
  }
  loadTexture(e, t, i, n, r) {
    const a = this.manager !== void 0 ? this.manager : zw;
    let o = a.getHandler(e);
    o === null && (o = new xo(a)), o.setCrossOrigin && o.setCrossOrigin(this.crossOrigin);
    const l = o.load(e, i, n, r);
    return t !== void 0 && (l.mapping = t), l;
  }
}
const SU = /^[og]\s*(.+)?/, CU = /^mtllib /, MU = /^usemtl /, TU = /^usemap /, X_ = /\s+/, Y_ = new M(), dm = new M(), K_ = new M(), J_ = new M(), _s = new M(), bd = new se();
function IU() {
  const s = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function(e, t) {
      if (this.object && this.object.fromDeclaration === !1) {
        this.object.name = e, this.object.fromDeclaration = t !== !1;
        return;
      }
      const i = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this.object = {
        name: e || "",
        fromDeclaration: t !== !1,
        geometry: {
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          hasUVIndices: !1
        },
        materials: [],
        smooth: !0,
        startMaterial: function(n, r) {
          const a = this._finalize(!1);
          a && (a.inherited || a.groupCount <= 0) && this.materials.splice(a.index, 1);
          const o = {
            index: this.materials.length,
            name: n || "",
            mtllib: Array.isArray(r) && r.length > 0 ? r[r.length - 1] : "",
            smooth: a !== void 0 ? a.smooth : this.smooth,
            groupStart: a !== void 0 ? a.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: !1,
            clone: function(l) {
              const c = {
                index: typeof l == "number" ? l : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: !1
              };
              return c.clone = this.clone.bind(c), c;
            }
          };
          return this.materials.push(o), o;
        },
        currentMaterial: function() {
          if (this.materials.length > 0)
            return this.materials[this.materials.length - 1];
        },
        _finalize: function(n) {
          const r = this.currentMaterial();
          if (r && r.groupEnd === -1 && (r.groupEnd = this.geometry.vertices.length / 3, r.groupCount = r.groupEnd - r.groupStart, r.inherited = !1), n && this.materials.length > 1)
            for (let a = this.materials.length - 1; a >= 0; a--)
              this.materials[a].groupCount <= 0 && this.materials.splice(a, 1);
          return n && this.materials.length === 0 && this.materials.push({
            name: "",
            smooth: this.smooth
          }), r;
        }
      }, i && i.name && typeof i.clone == "function") {
        const n = i.clone(0);
        n.inherited = !0, this.object.materials.push(n);
      }
      this.objects.push(this.object);
    },
    finalize: function() {
      this.object && typeof this.object._finalize == "function" && this.object._finalize(!0);
    },
    parseVertexIndex: function(e, t) {
      const i = parseInt(e, 10);
      return (i >= 0 ? i - 1 : i + t / 3) * 3;
    },
    parseNormalIndex: function(e, t) {
      const i = parseInt(e, 10);
      return (i >= 0 ? i - 1 : i + t / 3) * 3;
    },
    parseUVIndex: function(e, t) {
      const i = parseInt(e, 10);
      return (i >= 0 ? i - 1 : i + t / 2) * 2;
    },
    addVertex: function(e, t, i) {
      const n = this.vertices, r = this.object.geometry.vertices;
      r.push(n[e + 0], n[e + 1], n[e + 2]), r.push(n[t + 0], n[t + 1], n[t + 2]), r.push(n[i + 0], n[i + 1], n[i + 2]);
    },
    addVertexPoint: function(e) {
      const t = this.vertices;
      this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
    },
    addVertexLine: function(e) {
      const t = this.vertices;
      this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
    },
    addNormal: function(e, t, i) {
      const n = this.normals, r = this.object.geometry.normals;
      r.push(n[e + 0], n[e + 1], n[e + 2]), r.push(n[t + 0], n[t + 1], n[t + 2]), r.push(n[i + 0], n[i + 1], n[i + 2]);
    },
    addFaceNormal: function(e, t, i) {
      const n = this.vertices, r = this.object.geometry.normals;
      Y_.fromArray(n, e), dm.fromArray(n, t), K_.fromArray(n, i), _s.subVectors(K_, dm), J_.subVectors(Y_, dm), _s.cross(J_), _s.normalize(), r.push(_s.x, _s.y, _s.z), r.push(_s.x, _s.y, _s.z), r.push(_s.x, _s.y, _s.z);
    },
    addColor: function(e, t, i) {
      const n = this.colors, r = this.object.geometry.colors;
      n[e] !== void 0 && r.push(n[e + 0], n[e + 1], n[e + 2]), n[t] !== void 0 && r.push(n[t + 0], n[t + 1], n[t + 2]), n[i] !== void 0 && r.push(n[i + 0], n[i + 1], n[i + 2]);
    },
    addUV: function(e, t, i) {
      const n = this.uvs, r = this.object.geometry.uvs;
      r.push(n[e + 0], n[e + 1]), r.push(n[t + 0], n[t + 1]), r.push(n[i + 0], n[i + 1]);
    },
    addDefaultUV: function() {
      const e = this.object.geometry.uvs;
      e.push(0, 0), e.push(0, 0), e.push(0, 0);
    },
    addUVLine: function(e) {
      const t = this.uvs;
      this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
    },
    addFace: function(e, t, i, n, r, a, o, l, c) {
      const h = this.vertices.length;
      let u = this.parseVertexIndex(e, h), d = this.parseVertexIndex(t, h), p = this.parseVertexIndex(i, h);
      if (this.addVertex(u, d, p), this.addColor(u, d, p), o !== void 0 && o !== "") {
        const f = this.normals.length;
        u = this.parseNormalIndex(o, f), d = this.parseNormalIndex(l, f), p = this.parseNormalIndex(c, f), this.addNormal(u, d, p);
      } else
        this.addFaceNormal(u, d, p);
      if (n !== void 0 && n !== "") {
        const f = this.uvs.length;
        u = this.parseUVIndex(n, f), d = this.parseUVIndex(r, f), p = this.parseUVIndex(a, f), this.addUV(u, d, p), this.object.geometry.hasUVIndices = !0;
      } else
        this.addDefaultUV();
    },
    addPointGeometry: function(e) {
      this.object.geometry.type = "Points";
      const t = this.vertices.length;
      for (let i = 0, n = e.length; i < n; i++) {
        const r = this.parseVertexIndex(e[i], t);
        this.addVertexPoint(r), this.addColor(r);
      }
    },
    addLineGeometry: function(e, t) {
      this.object.geometry.type = "Line";
      const i = this.vertices.length, n = this.uvs.length;
      for (let r = 0, a = e.length; r < a; r++)
        this.addVertexLine(this.parseVertexIndex(e[r], i));
      for (let r = 0, a = t.length; r < a; r++)
        this.addUVLine(this.parseUVIndex(t[r], n));
    }
  };
  return s.startObject("", !1), s;
}
class DU extends ui {
  constructor(e) {
    super(e), this.materials = null;
  }
  load(e, t, i, n) {
    const r = this, a = new ti(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), r.currentUrl = e, a.load(e, async function(o) {
      try {
        t(await r.parse(o));
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
      r.currentUrl = void 0;
    }, i, n);
  }
  setMaterials(e) {
    return this.materials = e, this;
  }
  async parse(e) {
    const t = new IU();
    e.indexOf(`\r
`) !== -1 && (e = e.replace(/\r\n/g, `
`)), e.indexOf(`\\
`) !== -1 && (e = e.replace(/\\\n/g, ""));
    const i = e.split(`
`);
    let n = [];
    for (let o = 0, l = i.length; o < l; o++) {
      const c = i[o].trimStart();
      if (c.length === 0) continue;
      const h = c.charAt(0);
      if (h !== "#")
        if (h === "v") {
          const u = c.split(X_);
          switch (u[0]) {
            case "v":
              t.vertices.push(
                parseFloat(u[1]),
                parseFloat(u[2]),
                parseFloat(u[3])
              ), u.length >= 7 ? (bd.setRGB(
                parseFloat(u[4]),
                parseFloat(u[5]),
                parseFloat(u[6])
              ).convertSRGBToLinear(), t.colors.push(bd.r, bd.g, bd.b)) : t.colors.push(void 0, void 0, void 0);
              break;
            case "vn":
              t.normals.push(
                parseFloat(u[1]),
                parseFloat(u[2]),
                parseFloat(u[3])
              );
              break;
            case "vt":
              t.uvs.push(
                parseFloat(u[1]),
                parseFloat(u[2])
              );
              break;
          }
        } else if (h === "f") {
          const d = c.slice(1).trim().split(X_), p = [];
          for (let y = 0, A = d.length; y < A; y++) {
            const m = d[y];
            if (m.length > 0) {
              const v = m.split("/");
              p.push(v);
            }
          }
          const f = p[0];
          for (let y = 1, A = p.length - 1; y < A; y++) {
            const m = p[y], v = p[y + 1];
            t.addFace(
              f[0],
              m[0],
              v[0],
              f[1],
              m[1],
              v[1],
              f[2],
              m[2],
              v[2]
            );
          }
        } else if (h === "l") {
          const u = c.substring(1).trim().split(" ");
          let d = [];
          const p = [];
          if (c.indexOf("/") === -1)
            d = u;
          else
            for (let f = 0, y = u.length; f < y; f++) {
              const A = u[f].split("/");
              A[0] !== "" && d.push(A[0]), A[1] !== "" && p.push(A[1]);
            }
          t.addLineGeometry(d, p);
        } else if (h === "p") {
          const d = c.slice(1).trim().split(" ");
          t.addPointGeometry(d);
        } else if ((n = SU.exec(c)) !== null) {
          const u = (" " + n[0].slice(1).trim()).slice(1);
          t.startObject(u);
        } else if (MU.test(c))
          t.object.startMaterial(c.substring(7).trim(), t.materialLibraries);
        else if (CU.test(c)) {
          t.materialLibraries.push(c.substring(7).trim());
          let u = c.substring(7).trim(), d = this.manager.getHandler(u);
          if (!d && u.trim().split("?")[0].endsWith(".mtl") && (d = new hb(this.manager), d.setPath(this.path), d.setWithCredentials(this.withCredentials), d.setRequestHeader(this.requestHeader), d.setResourcePath(this.resourcePath), d.setCrossOrigin(this.crossOrigin)), this.currentUrl.startsWith("http") && !u.startsWith("http") && (u = this.currentUrl.substring(0, this.currentUrl.lastIndexOf("/") + 1) + u), !d)
            console.warn("OBJLoader2: Regiser MTLLoader2 or any other material loader to loading manager to load the material file:", u);
          else {
            const p = await d.loadAsync(u).catch((f) => {
              console.warn(f);
            });
            p && this.setMaterials(p);
          }
        } else if (TU.test(c))
          console.warn('OBJLoader2: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
        else if (h === "s") {
          if (n = c.split(" "), n.length > 1) {
            const d = n[1].trim().toLowerCase();
            t.object.smooth = d !== "0" && d !== "off";
          } else
            t.object.smooth = !0;
          const u = t.object.currentMaterial();
          u && (u.smooth = t.object.smooth);
        } else {
          if (c === "\0") continue;
          console.warn('THREE.OBJLoader: Unexpected line: "' + c + '"');
        }
    }
    t.finalize();
    const r = new Kn();
    if (r.materialLibraries = [].concat(t.materialLibraries), !(t.objects.length === 1 && t.objects[0].geometry.vertices.length === 0) === !0)
      for (let o = 0, l = t.objects.length; o < l; o++) {
        const c = t.objects[o], h = c.geometry, u = c.materials, d = h.type === "Line", p = h.type === "Points";
        let f = !1;
        if (h.vertices.length === 0) continue;
        const y = new Ze();
        y.setAttribute("position", new Te(h.vertices, 3)), h.normals.length > 0 && y.setAttribute("normal", new Te(h.normals, 3)), h.colors.length > 0 && (f = !0, y.setAttribute("color", new Te(h.colors, 3))), h.hasUVIndices === !0 && y.setAttribute("uv", new Te(h.uvs, 2));
        const A = [];
        for (let v = 0, g = u.length; v < g; v++) {
          const _ = u[v], w = _.name + "_" + _.smooth + "_" + f;
          let S = t.materials[w];
          if (this.materials !== null) {
            if (S = await this.materials.create(_.name), d && S && !(S instanceof Ri)) {
              const C = new Ri();
              Yi.prototype.copy.call(C, S), C.color.copy(S.color), S = C;
            } else if (p && S && !(S instanceof Qr)) {
              const C = new Qr({ size: 10, sizeAttenuation: !1 });
              Yi.prototype.copy.call(C, S), C.color.copy(S.color), C.map = S.map, S = C;
            }
          }
          S === void 0 && (d ? S = new Ri() : p ? S = new Qr({ size: 1, sizeAttenuation: !1 }) : S = new Go(), S.name = _.name, S.flatShading = !_.smooth, S.vertexColors = f, t.materials[w] = S), A.push(S);
        }
        let m;
        if (A.length > 1) {
          for (let v = 0, g = u.length; v < g; v++) {
            const _ = u[v];
            y.addGroup(_.groupStart, _.groupCount, v);
          }
          d ? m = new Is(y, A) : p ? m = new zl(y, A) : m = new Se(y, A);
        } else
          d ? m = new Is(y, A[0]) : p ? m = new zl(y, A[0]) : m = new Se(y, A[0]);
        m.name = c.name, r.add(m);
      }
    else if (t.vertices.length > 0) {
      const o = new Qr({ size: 1, sizeAttenuation: !1 }), l = new Ze();
      l.setAttribute("position", new Te(t.vertices, 3)), t.colors.length > 0 && t.colors[0] !== void 0 && (l.setAttribute("color", new Te(t.colors, 3)), o.vertexColors = !0);
      const c = new zl(l, o);
      r.add(c);
    }
    return r;
  }
}
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var $_ = {}, Mg = function(s) {
  return URL.createObjectURL(new Blob([s], { type: "text/javascript" }));
}, ub = function(s) {
  return new Worker(s);
};
try {
  URL.revokeObjectURL(Mg(""));
} catch {
  Mg = function(e) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(e);
  }, ub = function(e) {
    return new Worker(e, { type: "module" });
  };
}
var RU = function(s, e, t, i, n) {
  var r = ub($_[e] || ($_[e] = Mg(s)));
  return r.onerror = function(a) {
    return n(a.error, null);
  }, r.onmessage = function(a) {
    return n(null, a.data);
  }, r.postMessage(t, i), r;
}, Bt = Uint8Array, on = Uint16Array, Jr = Uint32Array, Bc = new Bt([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Pc = new Bt([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Wh = new Bt([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), db = function(s, e) {
  for (var t = new on(31), i = 0; i < 31; ++i)
    t[i] = e += 1 << s[i - 1];
  for (var n = new Jr(t[30]), i = 1; i < 30; ++i)
    for (var r = t[i]; r < t[i + 1]; ++r)
      n[r] = r - t[i] << 5 | i;
  return [t, n];
}, pb = db(Bc, 2), oy = pb[0], yp = pb[1];
oy[28] = 258, yp[258] = 28;
var fb = db(Pc, 0), mb = fb[0], Tg = fb[1], jh = new on(32768);
for (var Ai = 0; Ai < 32768; ++Ai) {
  var da = (Ai & 43690) >>> 1 | (Ai & 21845) << 1;
  da = (da & 52428) >>> 2 | (da & 13107) << 2, da = (da & 61680) >>> 4 | (da & 3855) << 4, jh[Ai] = ((da & 65280) >>> 8 | (da & 255) << 8) >>> 1;
}
var Cs = function(s, e, t) {
  for (var i = s.length, n = 0, r = new on(e); n < i; ++n)
    ++r[s[n] - 1];
  var a = new on(e);
  for (n = 0; n < e; ++n)
    a[n] = a[n - 1] + r[n - 1] << 1;
  var o;
  if (t) {
    o = new on(1 << e);
    var l = 15 - e;
    for (n = 0; n < i; ++n)
      if (s[n])
        for (var c = n << 4 | s[n], h = e - s[n], u = a[s[n] - 1]++ << h, d = u | (1 << h) - 1; u <= d; ++u)
          o[jh[u] >>> l] = c;
  } else
    for (o = new on(i), n = 0; n < i; ++n)
      s[n] && (o[n] = jh[a[s[n] - 1]++] >>> 15 - s[n]);
  return o;
}, $r = new Bt(288);
for (var Ai = 0; Ai < 144; ++Ai)
  $r[Ai] = 8;
for (var Ai = 144; Ai < 256; ++Ai)
  $r[Ai] = 9;
for (var Ai = 256; Ai < 280; ++Ai)
  $r[Ai] = 7;
for (var Ai = 280; Ai < 288; ++Ai)
  $r[Ai] = 8;
var ac = new Bt(32);
for (var Ai = 0; Ai < 32; ++Ai)
  ac[Ai] = 5;
var gb = /* @__PURE__ */ Cs($r, 9, 0), Ab = /* @__PURE__ */ Cs($r, 9, 1), yb = /* @__PURE__ */ Cs(ac, 5, 0), vb = /* @__PURE__ */ Cs(ac, 5, 1), Qd = function(s) {
  for (var e = s[0], t = 1; t < s.length; ++t)
    s[t] > e && (e = s[t]);
  return e;
}, xs = function(s, e, t) {
  var i = e / 8 | 0;
  return (s[i] | s[i + 1] << 8) >> (e & 7) & t;
}, Hd = function(s, e) {
  var t = e / 8 | 0;
  return (s[t] | s[t + 1] << 8 | s[t + 2] << 16) >> (e & 7);
}, Au = function(s) {
  return (s / 8 | 0) + (s & 7 && 1);
}, Ms = function(s, e, t) {
  (e == null || e < 0) && (e = 0), (t == null || t > s.length) && (t = s.length);
  var i = new (s instanceof on ? on : s instanceof Jr ? Jr : Bt)(t - e);
  return i.set(s.subarray(e, t)), i;
}, yu = function(s, e, t) {
  var i = s.length;
  if (!i || t && !t.l && i < 5)
    return e || new Bt(0);
  var n = !e || t, r = !t || t.i;
  t || (t = {}), e || (e = new Bt(i * 3));
  var a = function(_e) {
    var ze = e.length;
    if (_e > ze) {
      var Qe = new Bt(Math.max(ze * 2, _e));
      Qe.set(e), e = Qe;
    }
  }, o = t.f || 0, l = t.p || 0, c = t.b || 0, h = t.l, u = t.d, d = t.m, p = t.n, f = i * 8;
  do {
    if (!h) {
      t.f = o = xs(s, l, 1);
      var y = xs(s, l + 1, 3);
      if (l += 3, y)
        if (y == 1)
          h = Ab, u = vb, d = 9, p = 5;
        else if (y == 2) {
          var g = xs(s, l, 31) + 257, _ = xs(s, l + 10, 15) + 4, w = g + xs(s, l + 5, 31) + 1;
          l += 14;
          for (var S = new Bt(w), C = new Bt(19), E = 0; E < _; ++E)
            C[Wh[E]] = xs(s, l + E * 3, 7);
          l += _ * 3;
          for (var x = Qd(C), b = (1 << x) - 1, D = Cs(C, x, 1), E = 0; E < w; ) {
            var O = D[xs(s, l, b)];
            l += O & 15;
            var A = O >>> 4;
            if (A < 16)
              S[E++] = A;
            else {
              var Y = 0, B = 0;
              for (A == 16 ? (B = 3 + xs(s, l, 3), l += 2, Y = S[E - 1]) : A == 17 ? (B = 3 + xs(s, l, 7), l += 3) : A == 18 && (B = 11 + xs(s, l, 127), l += 7); B--; )
                S[E++] = Y;
            }
          }
          var Q = S.subarray(0, g), j = S.subarray(g);
          d = Qd(Q), p = Qd(j), h = Cs(Q, d, 1), u = Cs(j, p, 1);
        } else
          throw "invalid block type";
      else {
        var A = Au(l) + 4, m = s[A - 4] | s[A - 3] << 8, v = A + m;
        if (v > i) {
          if (r)
            throw "unexpected EOF";
          break;
        }
        n && a(c + m), e.set(s.subarray(A, v), c), t.b = c += m, t.p = l = v * 8;
        continue;
      }
      if (l > f) {
        if (r)
          throw "unexpected EOF";
        break;
      }
    }
    n && a(c + 131072);
    for (var X = (1 << d) - 1, Z = (1 << p) - 1, ee = l; ; ee = l) {
      var Y = h[Hd(s, l) & X], J = Y >>> 4;
      if (l += Y & 15, l > f) {
        if (r)
          throw "unexpected EOF";
        break;
      }
      if (!Y)
        throw "invalid length/literal";
      if (J < 256)
        e[c++] = J;
      else if (J == 256) {
        ee = l, h = null;
        break;
      } else {
        var W = J - 254;
        if (J > 264) {
          var E = J - 257, K = Bc[E];
          W = xs(s, l, (1 << K) - 1) + oy[E], l += K;
        }
        var ce = u[Hd(s, l) & Z], fe = ce >>> 4;
        if (!ce)
          throw "invalid distance";
        l += ce & 15;
        var j = mb[fe];
        if (fe > 3) {
          var K = Pc[fe];
          j += Hd(s, l) & (1 << K) - 1, l += K;
        }
        if (l > f) {
          if (r)
            throw "unexpected EOF";
          break;
        }
        n && a(c + 131072);
        for (var ve = c + W; c < ve; c += 4)
          e[c] = e[c - j], e[c + 1] = e[c + 1 - j], e[c + 2] = e[c + 2 - j], e[c + 3] = e[c + 3 - j];
        c = ve;
      }
    }
    t.l = h, t.p = ee, t.b = c, h && (o = 1, t.m = d, t.d = u, t.n = p);
  } while (!o);
  return c == e.length ? e : Ms(e, 0, c);
}, ar = function(s, e, t) {
  t <<= e & 7;
  var i = e / 8 | 0;
  s[i] |= t, s[i + 1] |= t >>> 8;
}, wl = function(s, e, t) {
  t <<= e & 7;
  var i = e / 8 | 0;
  s[i] |= t, s[i + 1] |= t >>> 8, s[i + 2] |= t >>> 16;
}, Vd = function(s, e) {
  for (var t = [], i = 0; i < s.length; ++i)
    s[i] && t.push({ s: i, f: s[i] });
  var n = t.length, r = t.slice();
  if (!n)
    return [Hr, 0];
  if (n == 1) {
    var a = new Bt(t[0].s + 1);
    return a[t[0].s] = 1, [a, 1];
  }
  t.sort(function(w, S) {
    return w.f - S.f;
  }), t.push({ s: -1, f: 25001 });
  var o = t[0], l = t[1], c = 0, h = 1, u = 2;
  for (t[0] = { s: -1, f: o.f + l.f, l: o, r: l }; h != n - 1; )
    o = t[t[c].f < t[u].f ? c++ : u++], l = t[c != h && t[c].f < t[u].f ? c++ : u++], t[h++] = { s: -1, f: o.f + l.f, l: o, r: l };
  for (var d = r[0].s, i = 1; i < n; ++i)
    r[i].s > d && (d = r[i].s);
  var p = new on(d + 1), f = vp(t[h - 1], p, 0);
  if (f > e) {
    var i = 0, y = 0, A = f - e, m = 1 << A;
    for (r.sort(function(S, C) {
      return p[C.s] - p[S.s] || S.f - C.f;
    }); i < n; ++i) {
      var v = r[i].s;
      if (p[v] > e)
        y += m - (1 << f - p[v]), p[v] = e;
      else
        break;
    }
    for (y >>>= A; y > 0; ) {
      var g = r[i].s;
      p[g] < e ? y -= 1 << e - p[g]++ - 1 : ++i;
    }
    for (; i >= 0 && y; --i) {
      var _ = r[i].s;
      p[_] == e && (--p[_], ++y);
    }
    f = e;
  }
  return [new Bt(p), f];
}, vp = function(s, e, t) {
  return s.s == -1 ? Math.max(vp(s.l, e, t + 1), vp(s.r, e, t + 1)) : e[s.s] = t;
}, Ig = function(s) {
  for (var e = s.length; e && !s[--e]; )
    ;
  for (var t = new on(++e), i = 0, n = s[0], r = 1, a = function(l) {
    t[i++] = l;
  }, o = 1; o <= e; ++o)
    if (s[o] == n && o != e)
      ++r;
    else {
      if (!n && r > 2) {
        for (; r > 138; r -= 138)
          a(32754);
        r > 2 && (a(r > 10 ? r - 11 << 5 | 28690 : r - 3 << 5 | 12305), r = 0);
      } else if (r > 3) {
        for (a(n), --r; r > 6; r -= 6)
          a(8304);
        r > 2 && (a(r - 3 << 5 | 8208), r = 0);
      }
      for (; r--; )
        a(n);
      r = 1, n = s[o];
    }
  return [t.subarray(0, i), e];
}, El = function(s, e) {
  for (var t = 0, i = 0; i < e.length; ++i)
    t += s[i] * e[i];
  return t;
}, Ih = function(s, e, t) {
  var i = t.length, n = Au(e + 2);
  s[n] = i & 255, s[n + 1] = i >>> 8, s[n + 2] = s[n] ^ 255, s[n + 3] = s[n + 1] ^ 255;
  for (var r = 0; r < i; ++r)
    s[n + r + 4] = t[r];
  return (n + 4 + i) * 8;
}, Dg = function(s, e, t, i, n, r, a, o, l, c, h) {
  ar(e, h++, t), ++n[256];
  for (var u = Vd(n, 15), d = u[0], p = u[1], f = Vd(r, 15), y = f[0], A = f[1], m = Ig(d), v = m[0], g = m[1], _ = Ig(y), w = _[0], S = _[1], C = new on(19), E = 0; E < v.length; ++E)
    C[v[E] & 31]++;
  for (var E = 0; E < w.length; ++E)
    C[w[E] & 31]++;
  for (var x = Vd(C, 7), b = x[0], D = x[1], O = 19; O > 4 && !b[Wh[O - 1]]; --O)
    ;
  var Y = c + 5 << 3, B = El(n, $r) + El(r, ac) + a, Q = El(n, d) + El(r, y) + a + 14 + 3 * O + El(C, b) + (2 * C[16] + 3 * C[17] + 7 * C[18]);
  if (Y <= B && Y <= Q)
    return Ih(e, h, s.subarray(l, l + c));
  var j, X, Z, ee;
  if (ar(e, h, 1 + (Q < B)), h += 2, Q < B) {
    j = Cs(d, p, 0), X = d, Z = Cs(y, A, 0), ee = y;
    var J = Cs(b, D, 0);
    ar(e, h, g - 257), ar(e, h + 5, S - 1), ar(e, h + 10, O - 4), h += 14;
    for (var E = 0; E < O; ++E)
      ar(e, h + 3 * E, b[Wh[E]]);
    h += 3 * O;
    for (var W = [v, w], K = 0; K < 2; ++K)
      for (var ce = W[K], E = 0; E < ce.length; ++E) {
        var fe = ce[E] & 31;
        ar(e, h, J[fe]), h += b[fe], fe > 15 && (ar(e, h, ce[E] >>> 5 & 127), h += ce[E] >>> 12);
      }
  } else
    j = gb, X = $r, Z = yb, ee = ac;
  for (var E = 0; E < o; ++E)
    if (i[E] > 255) {
      var fe = i[E] >>> 18 & 31;
      wl(e, h, j[fe + 257]), h += X[fe + 257], fe > 7 && (ar(e, h, i[E] >>> 23 & 31), h += Bc[fe]);
      var ve = i[E] & 31;
      wl(e, h, Z[ve]), h += ee[ve], ve > 3 && (wl(e, h, i[E] >>> 5 & 8191), h += Pc[ve]);
    } else
      wl(e, h, j[i[E]]), h += X[i[E]];
  return wl(e, h, j[256]), h + X[256];
}, _b = /* @__PURE__ */ new Jr([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), Hr = /* @__PURE__ */ new Bt(0), xb = function(s, e, t, i, n, r) {
  var a = s.length, o = new Bt(i + a + 5 * (1 + Math.ceil(a / 7e3)) + n), l = o.subarray(i, o.length - n), c = 0;
  if (!e || a < 8)
    for (var h = 0; h <= a; h += 65535) {
      var u = h + 65535;
      u < a ? c = Ih(l, c, s.subarray(h, u)) : (l[h] = r, c = Ih(l, c, s.subarray(h, a)));
    }
  else {
    for (var d = _b[e - 1], p = d >>> 13, f = d & 8191, y = (1 << t) - 1, A = new on(32768), m = new on(y + 1), v = Math.ceil(t / 3), g = 2 * v, _ = function(oe) {
      return (s[oe] ^ s[oe + 1] << v ^ s[oe + 2] << g) & y;
    }, w = new Jr(25e3), S = new on(288), C = new on(32), E = 0, x = 0, h = 0, b = 0, D = 0, O = 0; h < a; ++h) {
      var Y = _(h), B = h & 32767, Q = m[Y];
      if (A[B] = Q, m[Y] = B, D <= h) {
        var j = a - h;
        if ((E > 7e3 || b > 24576) && j > 423) {
          c = Dg(s, l, 0, w, S, C, x, b, O, h - O, c), b = E = x = 0, O = h;
          for (var X = 0; X < 286; ++X)
            S[X] = 0;
          for (var X = 0; X < 30; ++X)
            C[X] = 0;
        }
        var Z = 2, ee = 0, J = f, W = B - Q & 32767;
        if (j > 2 && Y == _(h - W))
          for (var K = Math.min(p, j) - 1, ce = Math.min(32767, h), fe = Math.min(258, j); W <= ce && --J && B != Q; ) {
            if (s[h + Z] == s[h + Z - W]) {
              for (var ve = 0; ve < fe && s[h + ve] == s[h + ve - W]; ++ve)
                ;
              if (ve > Z) {
                if (Z = ve, ee = W, ve > K)
                  break;
                for (var _e = Math.min(W, ve - 2), ze = 0, X = 0; X < _e; ++X) {
                  var Qe = h - W + X + 32768 & 32767, ot = A[Qe], ht = Qe - ot + 32768 & 32767;
                  ht > ze && (ze = ht, Q = Qe);
                }
              }
            }
            B = Q, Q = A[B], W += B - Q + 32768 & 32767;
          }
        if (ee) {
          w[b++] = 268435456 | yp[Z] << 18 | Tg[ee];
          var Xe = yp[Z] & 31, G = Tg[ee] & 31;
          x += Bc[Xe] + Pc[G], ++S[257 + Xe], ++C[G], D = h + Z, ++E;
        } else
          w[b++] = s[h], ++S[s[h]];
      }
    }
    c = Dg(s, l, r, w, S, C, x, b, O, h - O, c), !r && c & 7 && (c = Ih(l, c + 1, Hr));
  }
  return Ms(o, 0, i + Au(c) + n);
}, wb = /* @__PURE__ */ function() {
  for (var s = new Jr(256), e = 0; e < 256; ++e) {
    for (var t = e, i = 9; --i; )
      t = (t & 1 && 3988292384) ^ t >>> 1;
    s[e] = t;
  }
  return s;
}(), Lc = function() {
  var s = -1;
  return {
    p: function(e) {
      for (var t = s, i = 0; i < e.length; ++i)
        t = wb[t & 255 ^ e[i]] ^ t >>> 8;
      s = t;
    },
    d: function() {
      return ~s;
    }
  };
}, ly = function() {
  var s = 1, e = 0;
  return {
    p: function(t) {
      for (var i = s, n = e, r = t.length, a = 0; a != r; ) {
        for (var o = Math.min(a + 2655, r); a < o; ++a)
          n += i += t[a];
        i = (i & 65535) + 15 * (i >> 16), n = (n & 65535) + 15 * (n >> 16);
      }
      s = i, e = n;
    },
    d: function() {
      return s %= 65521, e %= 65521, (s & 255) << 24 | s >>> 8 << 16 | (e & 255) << 8 | e >>> 8;
    }
  };
}, jo = function(s, e, t, i, n) {
  return xb(s, e.level == null ? 6 : e.level, e.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(s.length))) * 1.5) : 12 + e.mem, t, i, !n);
}, vu = function(s, e) {
  var t = {};
  for (var i in s)
    t[i] = s[i];
  for (var i in e)
    t[i] = e[i];
  return t;
}, Z_ = function(s, e, t) {
  for (var i = s(), n = s.toString(), r = n.slice(n.indexOf("[") + 1, n.lastIndexOf("]")).replace(/ /g, "").split(","), a = 0; a < i.length; ++a) {
    var o = i[a], l = r[a];
    if (typeof o == "function") {
      e += ";" + l + "=";
      var c = o.toString();
      if (o.prototype)
        if (c.indexOf("[native code]") != -1) {
          var h = c.indexOf(" ", 8) + 1;
          e += c.slice(h, c.indexOf("(", h));
        } else {
          e += c;
          for (var u in o.prototype)
            e += ";" + l + ".prototype." + u + "=" + o.prototype[u].toString();
        }
      else
        e += c;
    } else
      t[l] = o;
  }
  return [e, t];
}, Sd = [], BU = function(s) {
  var e = [];
  for (var t in s)
    (s[t] instanceof Bt || s[t] instanceof on || s[t] instanceof Jr) && e.push((s[t] = new s[t].constructor(s[t])).buffer);
  return e;
}, Eb = function(s, e, t, i) {
  var n;
  if (!Sd[t]) {
    for (var r = "", a = {}, o = s.length - 1, l = 0; l < o; ++l)
      n = Z_(s[l], r, a), r = n[0], a = n[1];
    Sd[t] = Z_(s[o], r, a);
  }
  var c = vu({}, Sd[t][1]);
  return RU(Sd[t][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + e.toString() + "}", t, c, BU(c), i);
}, Uc = function() {
  return [Bt, on, Jr, Bc, Pc, Wh, oy, mb, Ab, vb, jh, Cs, Qd, xs, Hd, Au, Ms, yu, _u, ka, cy];
}, Fc = function() {
  return [Bt, on, Jr, Bc, Pc, Wh, yp, Tg, gb, $r, yb, ac, jh, _b, Hr, Cs, ar, wl, Vd, vp, Ig, El, Ih, Dg, Au, Ms, xb, jo, sf, ka];
}, bb = function() {
  return [hy, dy, Jt, Lc, wb];
}, Sb = function() {
  return [uy, Tb];
}, Cb = function() {
  return [py, Jt, ly];
}, Mb = function() {
  return [Ib];
}, ka = function(s) {
  return postMessage(s, [s.buffer]);
}, cy = function(s) {
  return s && s.size && new Bt(s.size);
}, Oc = function(s, e, t, i, n, r) {
  var a = Eb(t, i, n, function(o, l) {
    a.terminate(), r(o, l);
  });
  return a.postMessage([s, e], e.consume ? [s.buffer] : []), function() {
    a.terminate();
  };
}, Rs = function(s) {
  return s.ondata = function(e, t) {
    return postMessage([e, t], [e.buffer]);
  }, function(e) {
    return s.push(e.data[0], e.data[1]);
  };
}, Nc = function(s, e, t, i, n) {
  var r, a = Eb(s, i, n, function(o, l) {
    o ? (a.terminate(), e.ondata.call(e, o)) : (l[1] && a.terminate(), e.ondata.call(e, o, l[0], l[1]));
  });
  a.postMessage(t), e.push = function(o, l) {
    if (r)
      throw "stream finished";
    if (!e.ondata)
      throw "no stream handler";
    a.postMessage([o, r = l], [o.buffer]);
  }, e.terminate = function() {
    a.terminate();
  };
}, kn = function(s, e) {
  return s[e] | s[e + 1] << 8;
}, Gi = function(s, e) {
  return (s[e] | s[e + 1] << 8 | s[e + 2] << 16 | s[e + 3] << 24) >>> 0;
}, pm = function(s, e) {
  return Gi(s, e) + Gi(s, e + 4) * 4294967296;
}, Jt = function(s, e, t) {
  for (; t; ++e)
    s[e] = t, t >>>= 8;
}, hy = function(s, e) {
  var t = e.filename;
  if (s[0] = 31, s[1] = 139, s[2] = 8, s[8] = e.level < 2 ? 4 : e.level == 9 ? 2 : 0, s[9] = 3, e.mtime != 0 && Jt(s, 4, Math.floor(new Date(e.mtime || Date.now()) / 1e3)), t) {
    s[3] = 8;
    for (var i = 0; i <= t.length; ++i)
      s[i + 10] = t.charCodeAt(i);
  }
}, uy = function(s) {
  if (s[0] != 31 || s[1] != 139 || s[2] != 8)
    throw "invalid gzip data";
  var e = s[3], t = 10;
  e & 4 && (t += s[10] | (s[11] << 8) + 2);
  for (var i = (e >> 3 & 1) + (e >> 4 & 1); i > 0; i -= !s[t++])
    ;
  return t + (e & 2);
}, Tb = function(s) {
  var e = s.length;
  return (s[e - 4] | s[e - 3] << 8 | s[e - 2] << 16 | s[e - 1] << 24) >>> 0;
}, dy = function(s) {
  return 10 + (s.filename && s.filename.length + 1 || 0);
}, py = function(s, e) {
  var t = e.level, i = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2;
  s[0] = 120, s[1] = i << 6 | (i ? 32 - 2 * i : 1);
}, Ib = function(s) {
  if ((s[0] & 15) != 8 || s[0] >>> 4 > 7 || (s[0] << 8 | s[1]) % 31)
    throw "invalid zlib data";
  if (s[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function fy(s, e) {
  return !e && typeof s == "function" && (e = s, s = {}), this.ondata = e, s;
}
var Zr = /* @__PURE__ */ function() {
  function s(e, t) {
    !t && typeof e == "function" && (t = e, e = {}), this.ondata = t, this.o = e || {};
  }
  return s.prototype.p = function(e, t) {
    this.ondata(jo(e, this.o, 0, 0, !t), t);
  }, s.prototype.push = function(e, t) {
    if (this.d)
      throw "stream finished";
    if (!this.ondata)
      throw "no stream handler";
    this.d = t, this.p(e, t || !1);
  }, s;
}(), PU = /* @__PURE__ */ function() {
  function s(e, t) {
    Nc([
      Fc,
      function() {
        return [Rs, Zr];
      }
    ], this, fy.call(this, e, t), function(i) {
      var n = new Zr(i.data);
      onmessage = Rs(n);
    }, 6);
  }
  return s;
}();
function LU(s, e, t) {
  if (t || (t = e, e = {}), typeof t != "function")
    throw "no callback";
  return Oc(s, e, [
    Fc
  ], function(i) {
    return ka(sf(i.data[0], i.data[1]));
  }, 0, t);
}
function sf(s, e) {
  return jo(s, e || {}, 0, 0);
}
var fs = /* @__PURE__ */ function() {
  function s(e) {
    this.s = {}, this.p = new Bt(0), this.ondata = e;
  }
  return s.prototype.e = function(e) {
    if (this.d)
      throw "stream finished";
    if (!this.ondata)
      throw "no stream handler";
    var t = this.p.length, i = new Bt(t + e.length);
    i.set(this.p), i.set(e, t), this.p = i;
  }, s.prototype.c = function(e) {
    this.d = this.s.i = e || !1;
    var t = this.s.b, i = yu(this.p, this.o, this.s);
    this.ondata(Ms(i, t, this.s.b), this.d), this.o = Ms(i, this.s.b - 32768), this.s.b = this.o.length, this.p = Ms(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  }, s.prototype.push = function(e, t) {
    this.e(e), this.c(t);
  }, s;
}(), Db = /* @__PURE__ */ function() {
  function s(e) {
    this.ondata = e, Nc([
      Uc,
      function() {
        return [Rs, fs];
      }
    ], this, 0, function() {
      var t = new fs();
      onmessage = Rs(t);
    }, 7);
  }
  return s;
}();
function Rb(s, e, t) {
  if (t || (t = e, e = {}), typeof t != "function")
    throw "no callback";
  return Oc(s, e, [
    Uc
  ], function(i) {
    return ka(_u(i.data[0], cy(i.data[1])));
  }, 1, t);
}
function _u(s, e) {
  return yu(s, e);
}
var ex = /* @__PURE__ */ function() {
  function s(e, t) {
    this.c = Lc(), this.l = 0, this.v = 1, Zr.call(this, e, t);
  }
  return s.prototype.push = function(e, t) {
    Zr.prototype.push.call(this, e, t);
  }, s.prototype.p = function(e, t) {
    this.c.p(e), this.l += e.length;
    var i = jo(e, this.o, this.v && dy(this.o), t && 8, !t);
    this.v && (hy(i, this.o), this.v = 0), t && (Jt(i, i.length - 8, this.c.d()), Jt(i, i.length - 4, this.l)), this.ondata(i, t);
  }, s;
}(), qz = /* @__PURE__ */ function() {
  function s(e, t) {
    Nc([
      Fc,
      bb,
      function() {
        return [Rs, Zr, ex];
      }
    ], this, fy.call(this, e, t), function(i) {
      var n = new ex(i.data);
      onmessage = Rs(n);
    }, 8);
  }
  return s;
}();
function Xz(s, e, t) {
  if (t || (t = e, e = {}), typeof t != "function")
    throw "no callback";
  return Oc(s, e, [
    Fc,
    bb,
    function() {
      return [tx];
    }
  ], function(i) {
    return ka(tx(i.data[0], i.data[1]));
  }, 2, t);
}
function tx(s, e) {
  e || (e = {});
  var t = Lc(), i = s.length;
  t.p(s);
  var n = jo(s, e, dy(e), 8), r = n.length;
  return hy(n, e), Jt(n, r - 8, t.d()), Jt(n, r - 4, i), n;
}
var Rg = /* @__PURE__ */ function() {
  function s(e) {
    this.v = 1, fs.call(this, e);
  }
  return s.prototype.push = function(e, t) {
    if (fs.prototype.e.call(this, e), this.v) {
      var i = this.p.length > 3 ? uy(this.p) : 4;
      if (i >= this.p.length && !t)
        return;
      this.p = this.p.subarray(i), this.v = 0;
    }
    if (t) {
      if (this.p.length < 8)
        throw "invalid gzip stream";
      this.p = this.p.subarray(0, -8);
    }
    fs.prototype.c.call(this, t);
  }, s;
}(), UU = /* @__PURE__ */ function() {
  function s(e) {
    this.ondata = e, Nc([
      Uc,
      Sb,
      function() {
        return [Rs, fs, Rg];
      }
    ], this, 0, function() {
      var t = new Rg();
      onmessage = Rs(t);
    }, 9);
  }
  return s;
}();
function FU(s, e, t) {
  if (t || (t = e, e = {}), typeof t != "function")
    throw "no callback";
  return Oc(s, e, [
    Uc,
    Sb,
    function() {
      return [Bg];
    }
  ], function(i) {
    return ka(Bg(i.data[0]));
  }, 3, t);
}
function Bg(s, e) {
  return yu(s.subarray(uy(s), -8), e || new Bt(Tb(s)));
}
var ix = /* @__PURE__ */ function() {
  function s(e, t) {
    this.c = ly(), this.v = 1, Zr.call(this, e, t);
  }
  return s.prototype.push = function(e, t) {
    Zr.prototype.push.call(this, e, t);
  }, s.prototype.p = function(e, t) {
    this.c.p(e);
    var i = jo(e, this.o, this.v && 2, t && 4, !t);
    this.v && (py(i, this.o), this.v = 0), t && Jt(i, i.length - 4, this.c.d()), this.ondata(i, t);
  }, s;
}(), Yz = /* @__PURE__ */ function() {
  function s(e, t) {
    Nc([
      Fc,
      Cb,
      function() {
        return [Rs, Zr, ix];
      }
    ], this, fy.call(this, e, t), function(i) {
      var n = new ix(i.data);
      onmessage = Rs(n);
    }, 10);
  }
  return s;
}();
function Kz(s, e, t) {
  if (t || (t = e, e = {}), typeof t != "function")
    throw "no callback";
  return Oc(s, e, [
    Fc,
    Cb,
    function() {
      return [Pg];
    }
  ], function(i) {
    return ka(Pg(i.data[0], i.data[1]));
  }, 4, t);
}
function Pg(s, e) {
  e || (e = {});
  var t = ly();
  t.p(s);
  var i = jo(s, e, 2, 4);
  return py(i, e), Jt(i, i.length - 4, t.d()), i;
}
var Lg = /* @__PURE__ */ function() {
  function s(e) {
    this.v = 1, fs.call(this, e);
  }
  return s.prototype.push = function(e, t) {
    if (fs.prototype.e.call(this, e), this.v) {
      if (this.p.length < 2 && !t)
        return;
      this.p = this.p.subarray(2), this.v = 0;
    }
    if (t) {
      if (this.p.length < 4)
        throw "invalid zlib stream";
      this.p = this.p.subarray(0, -4);
    }
    fs.prototype.c.call(this, t);
  }, s;
}(), OU = /* @__PURE__ */ function() {
  function s(e) {
    this.ondata = e, Nc([
      Uc,
      Mb,
      function() {
        return [Rs, fs, Lg];
      }
    ], this, 0, function() {
      var t = new Lg();
      onmessage = Rs(t);
    }, 11);
  }
  return s;
}();
function NU(s, e, t) {
  if (t || (t = e, e = {}), typeof t != "function")
    throw "no callback";
  return Oc(s, e, [
    Uc,
    Mb,
    function() {
      return [xa];
    }
  ], function(i) {
    return ka(xa(i.data[0], cy(i.data[1])));
  }, 5, t);
}
function xa(s, e) {
  return yu((Ib(s), s.subarray(2, -4)), e);
}
var kU = /* @__PURE__ */ function() {
  function s(e) {
    this.G = Rg, this.I = fs, this.Z = Lg, this.ondata = e;
  }
  return s.prototype.push = function(e, t) {
    if (!this.ondata)
      throw "no stream handler";
    if (this.s)
      this.s.push(e, t);
    else {
      if (this.p && this.p.length) {
        var i = new Bt(this.p.length + e.length);
        i.set(this.p), i.set(e, this.p.length);
      } else
        this.p = e;
      if (this.p.length > 2) {
        var n = this, r = function() {
          n.ondata.apply(n, arguments);
        };
        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(r) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(r) : new this.Z(r), this.s.push(this.p, t), this.p = null;
      }
    }
  }, s;
}(), Jz = /* @__PURE__ */ function() {
  function s(e) {
    this.G = UU, this.I = Db, this.Z = OU, this.ondata = e;
  }
  return s.prototype.push = function(e, t) {
    kU.prototype.push.call(this, e, t);
  }, s;
}();
function $z(s, e, t) {
  if (t || (t = e, e = {}), typeof t != "function")
    throw "no callback";
  return s[0] == 31 && s[1] == 139 && s[2] == 8 ? FU(s, e, t) : (s[0] & 15) != 8 || s[0] >> 4 > 7 || (s[0] << 8 | s[1]) % 31 ? Rb(s, e, t) : NU(s, e, t);
}
function Zz(s, e) {
  return s[0] == 31 && s[1] == 139 && s[2] == 8 ? Bg(s, e) : (s[0] & 15) != 8 || s[0] >> 4 > 7 || (s[0] << 8 | s[1]) % 31 ? _u(s, e) : xa(s, e);
}
var my = function(s, e, t, i) {
  for (var n in s) {
    var r = s[n], a = e + n;
    r instanceof Bt ? t[a] = [r, i] : Array.isArray(r) ? t[a] = [r[0], vu(i, r[1])] : my(r, a + "/", t, i);
  }
}, nx = typeof TextEncoder < "u" && /* @__PURE__ */ new TextEncoder(), Ug = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), Bb = 0;
try {
  Ug.decode(Hr, { stream: !0 }), Bb = 1;
} catch {
}
var Pb = function(s) {
  for (var e = "", t = 0; ; ) {
    var i = s[t++], n = (i > 127) + (i > 223) + (i > 239);
    if (t + n > s.length)
      return [e, Ms(s, t - 1)];
    n ? n == 3 ? (i = ((i & 15) << 18 | (s[t++] & 63) << 12 | (s[t++] & 63) << 6 | s[t++] & 63) - 65536, e += String.fromCharCode(55296 | i >> 10, 56320 | i & 1023)) : n & 1 ? e += String.fromCharCode((i & 31) << 6 | s[t++] & 63) : e += String.fromCharCode((i & 15) << 12 | (s[t++] & 63) << 6 | s[t++] & 63) : e += String.fromCharCode(i);
  }
}, eQ = /* @__PURE__ */ function() {
  function s(e) {
    this.ondata = e, Bb ? this.t = new TextDecoder() : this.p = Hr;
  }
  return s.prototype.push = function(e, t) {
    if (!this.ondata)
      throw "no callback";
    if (t = !!t, this.t) {
      if (this.ondata(this.t.decode(e, { stream: !0 }), t), t) {
        if (this.t.decode().length)
          throw "invalid utf-8 data";
        this.t = null;
      }
      return;
    }
    if (!this.p)
      throw "stream finished";
    var i = new Bt(this.p.length + e.length);
    i.set(this.p), i.set(e, this.p.length);
    var n = Pb(i), r = n[0], a = n[1];
    if (t) {
      if (a.length)
        throw "invalid utf-8 data";
      this.p = null;
    } else
      this.p = a;
    this.ondata(r, t);
  }, s;
}(), tQ = /* @__PURE__ */ function() {
  function s(e) {
    this.ondata = e;
  }
  return s.prototype.push = function(e, t) {
    if (!this.ondata)
      throw "no callback";
    if (this.d)
      throw "stream finished";
    this.ondata(Io(e), this.d = t || !1);
  }, s;
}();
function Io(s, e) {
  if (e) {
    for (var t = new Bt(s.length), i = 0; i < s.length; ++i)
      t[i] = s.charCodeAt(i);
    return t;
  }
  if (nx)
    return nx.encode(s);
  for (var n = s.length, r = new Bt(s.length + (s.length >> 1)), a = 0, o = function(h) {
    r[a++] = h;
  }, i = 0; i < n; ++i) {
    if (a + 5 > r.length) {
      var l = new Bt(a + 8 + (n - i << 1));
      l.set(r), r = l;
    }
    var c = s.charCodeAt(i);
    c < 128 || e ? o(c) : c < 2048 ? (o(192 | c >> 6), o(128 | c & 63)) : c > 55295 && c < 57344 ? (c = 65536 + (c & 1047552) | s.charCodeAt(++i) & 1023, o(240 | c >> 18), o(128 | c >> 12 & 63), o(128 | c >> 6 & 63), o(128 | c & 63)) : (o(224 | c >> 12), o(128 | c >> 6 & 63), o(128 | c & 63));
  }
  return Ms(r, 0, a);
}
function _p(s, e) {
  if (e) {
    for (var t = "", i = 0; i < s.length; i += 16384)
      t += String.fromCharCode.apply(null, s.subarray(i, i + 16384));
    return t;
  } else {
    if (Ug)
      return Ug.decode(s);
    var n = Pb(s), r = n[0], a = n[1];
    if (a.length)
      throw "invalid utf-8 data";
    return r;
  }
}
var Lb = function(s) {
  return s == 1 ? 3 : s < 6 ? 2 : s == 9 ? 1 : 0;
}, Ub = function(s, e) {
  return e + 30 + kn(s, e + 26) + kn(s, e + 28);
}, Fb = function(s, e, t) {
  var i = kn(s, e + 28), n = _p(s.subarray(e + 46, e + 46 + i), !(kn(s, e + 8) & 2048)), r = e + 46 + i, a = Gi(s, e + 20), o = t && a == 4294967295 ? Ob(s, r) : [a, Gi(s, e + 24), Gi(s, e + 42)], l = o[0], c = o[1], h = o[2];
  return [kn(s, e + 10), l, c, n, r + kn(s, e + 30) + kn(s, e + 32), h];
}, Ob = function(s, e) {
  for (; kn(s, e) != 1; e += 4 + kn(s, e + 2))
    ;
  return [pm(s, e + 12), pm(s, e + 4), pm(s, e + 20)];
}, Ca = function(s) {
  var e = 0;
  if (s)
    for (var t in s) {
      var i = s[t].length;
      if (i > 65535)
        throw "extra field too long";
      e += i + 4;
    }
  return e;
}, oc = function(s, e, t, i, n, r, a, o) {
  var l = i.length, c = t.extra, h = o && o.length, u = Ca(c);
  Jt(s, e, a != null ? 33639248 : 67324752), e += 4, a != null && (s[e++] = 20, s[e++] = t.os), s[e] = 20, e += 2, s[e++] = t.flag << 1 | (r == null && 8), s[e++] = n && 8, s[e++] = t.compression & 255, s[e++] = t.compression >> 8;
  var d = new Date(t.mtime == null ? Date.now() : t.mtime), p = d.getFullYear() - 1980;
  if (p < 0 || p > 119)
    throw "date not in range 1980-2099";
  if (Jt(s, e, p << 25 | d.getMonth() + 1 << 21 | d.getDate() << 16 | d.getHours() << 11 | d.getMinutes() << 5 | d.getSeconds() >>> 1), e += 4, r != null && (Jt(s, e, t.crc), Jt(s, e + 4, r), Jt(s, e + 8, t.size)), Jt(s, e + 12, l), Jt(s, e + 14, u), e += 16, a != null && (Jt(s, e, h), Jt(s, e + 6, t.attrs), Jt(s, e + 10, a), e += 14), s.set(i, e), e += l, u)
    for (var f in c) {
      var y = c[f], A = y.length;
      Jt(s, e, +f), Jt(s, e + 2, A), s.set(y, e + 4), e += 4 + A;
    }
  return h && (s.set(o, e), e += h), e;
}, gy = function(s, e, t, i, n) {
  Jt(s, e, 101010256), Jt(s, e + 8, t), Jt(s, e + 10, t), Jt(s, e + 12, i), Jt(s, e + 16, n);
}, xp = /* @__PURE__ */ function() {
  function s(e) {
    this.filename = e, this.c = Lc(), this.size = 0, this.compression = 0;
  }
  return s.prototype.process = function(e, t) {
    this.ondata(null, e, t);
  }, s.prototype.push = function(e, t) {
    if (!this.ondata)
      throw "no callback - add to ZIP archive before pushing";
    this.c.p(e), this.size += e.length, t && (this.crc = this.c.d()), this.process(e, t || !1);
  }, s;
}(), iQ = /* @__PURE__ */ function() {
  function s(e, t) {
    var i = this;
    t || (t = {}), xp.call(this, e), this.d = new Zr(t, function(n, r) {
      i.ondata(null, n, r);
    }), this.compression = 8, this.flag = Lb(t.level);
  }
  return s.prototype.process = function(e, t) {
    try {
      this.d.push(e, t);
    } catch (i) {
      this.ondata(i, null, t);
    }
  }, s.prototype.push = function(e, t) {
    xp.prototype.push.call(this, e, t);
  }, s;
}(), nQ = /* @__PURE__ */ function() {
  function s(e, t) {
    var i = this;
    t || (t = {}), xp.call(this, e), this.d = new PU(t, function(n, r, a) {
      i.ondata(n, r, a);
    }), this.compression = 8, this.flag = Lb(t.level), this.terminate = this.d.terminate;
  }
  return s.prototype.process = function(e, t) {
    this.d.push(e, t);
  }, s.prototype.push = function(e, t) {
    xp.prototype.push.call(this, e, t);
  }, s;
}(), sQ = /* @__PURE__ */ function() {
  function s(e) {
    this.ondata = e, this.u = [], this.d = 1;
  }
  return s.prototype.add = function(e) {
    var t = this;
    if (this.d & 2)
      throw "stream finished";
    var i = Io(e.filename), n = i.length, r = e.comment, a = r && Io(r), o = n != e.filename.length || a && r.length != a.length, l = n + Ca(e.extra) + 30;
    if (n > 65535)
      throw "filename too long";
    var c = new Bt(l);
    oc(c, 0, e, i, o);
    var h = [c], u = function() {
      for (var A = 0, m = h; A < m.length; A++) {
        var v = m[A];
        t.ondata(null, v, !1);
      }
      h = [];
    }, d = this.d;
    this.d = 0;
    var p = this.u.length, f = vu(e, {
      f: i,
      u: o,
      o: a,
      t: function() {
        e.terminate && e.terminate();
      },
      r: function() {
        if (u(), d) {
          var A = t.u[p + 1];
          A ? A.r() : t.d = 1;
        }
        d = 1;
      }
    }), y = 0;
    e.ondata = function(A, m, v) {
      if (A)
        t.ondata(A, m, v), t.terminate();
      else if (y += m.length, h.push(m), v) {
        var g = new Bt(16);
        Jt(g, 0, 134695760), Jt(g, 4, e.crc), Jt(g, 8, y), Jt(g, 12, e.size), h.push(g), f.c = y, f.b = l + y + 16, f.crc = e.crc, f.size = e.size, d && f.r(), d = 1;
      } else d && u();
    }, this.u.push(f);
  }, s.prototype.end = function() {
    var e = this;
    if (this.d & 2)
      throw this.d & 1 ? "stream finishing" : "stream finished";
    this.d ? this.e() : this.u.push({
      r: function() {
        e.d & 1 && (e.u.splice(-1, 1), e.e());
      },
      t: function() {
      }
    }), this.d = 3;
  }, s.prototype.e = function() {
    for (var e = 0, t = 0, i = 0, n = 0, r = this.u; n < r.length; n++) {
      var a = r[n];
      i += 46 + a.f.length + Ca(a.extra) + (a.o ? a.o.length : 0);
    }
    for (var o = new Bt(i + 22), l = 0, c = this.u; l < c.length; l++) {
      var a = c[l];
      oc(o, e, a, a.f, a.u, a.c, t, a.o), e += 46 + a.f.length + Ca(a.extra) + (a.o ? a.o.length : 0), t += a.b;
    }
    gy(o, e, this.u.length, i, t), this.ondata(null, o, !0), this.d = 2;
  }, s.prototype.terminate = function() {
    for (var e = 0, t = this.u; e < t.length; e++) {
      var i = t[e];
      i.t();
    }
    this.d = 2;
  }, s;
}();
function rQ(s, e, t) {
  if (t || (t = e, e = {}), typeof t != "function")
    throw "no callback";
  var i = {};
  my(s, "", i, e);
  var n = Object.keys(i), r = n.length, a = 0, o = 0, l = r, c = new Array(r), h = [], u = function() {
    for (var y = 0; y < h.length; ++y)
      h[y]();
  }, d = function() {
    var y = new Bt(o + 22), A = a, m = o - a;
    o = 0;
    for (var v = 0; v < l; ++v) {
      var g = c[v];
      try {
        var _ = g.c.length;
        oc(y, o, g, g.f, g.u, _);
        var w = 30 + g.f.length + Ca(g.extra), S = o + w;
        y.set(g.c, S), oc(y, a, g, g.f, g.u, _, o, g.m), a += 16 + w + (g.m ? g.m.length : 0), o = S + _;
      } catch (C) {
        return t(C, null);
      }
    }
    gy(y, a, c.length, m, A), t(null, y);
  };
  r || d();
  for (var p = function(y) {
    var A = n[y], m = i[A], v = m[0], g = m[1], _ = Lc(), w = v.length;
    _.p(v);
    var S = Io(A), C = S.length, E = g.comment, x = E && Io(E), b = x && x.length, D = Ca(g.extra), O = g.level == 0 ? 0 : 8, Y = function(B, Q) {
      if (B)
        u(), t(B, null);
      else {
        var j = Q.length;
        c[y] = vu(g, {
          size: w,
          crc: _.d(),
          c: Q,
          f: S,
          m: x,
          u: C != A.length || x && E.length != b,
          compression: O
        }), a += 30 + C + D + j, o += 76 + 2 * (C + D) + (b || 0) + j, --r || d();
      }
    };
    if (C > 65535 && Y("filename too long", null), !O)
      Y(null, v);
    else if (w < 16e4)
      try {
        Y(null, sf(v, g));
      } catch (B) {
        Y(B, null);
      }
    else
      h.push(LU(v, g, Y));
  }, f = 0; f < l; ++f)
    p(f);
  return u;
}
function Nb(s, e) {
  e || (e = {});
  var t = {}, i = [];
  my(s, "", t, e);
  var n = 0, r = 0;
  for (var a in t) {
    var o = t[a], l = o[0], c = o[1], h = c.level == 0 ? 0 : 8, u = Io(a), d = u.length, p = c.comment, f = p && Io(p), y = f && f.length, A = Ca(c.extra);
    if (d > 65535)
      throw "filename too long";
    var m = h ? sf(l, c) : l, v = m.length, g = Lc();
    g.p(l), i.push(vu(c, {
      size: l.length,
      crc: g.d(),
      c: m,
      f: u,
      m: f,
      u: d != a.length || f && p.length != y,
      o: n,
      compression: h
    })), n += 30 + d + A + v, r += 76 + 2 * (d + A) + (y || 0) + v;
  }
  for (var _ = new Bt(r + 22), w = n, S = r - n, C = 0; C < i.length; ++C) {
    var u = i[C];
    oc(_, u.o, u, u.f, u.u, u.c.length);
    var E = 30 + u.f.length + Ca(u.extra);
    _.set(u.c, u.o + E), oc(_, n, u, u.f, u.u, u.c.length, u.o, u.m), n += 16 + E + (u.m ? u.m.length : 0);
  }
  return gy(_, n, i.length, S, w), _;
}
var GU = /* @__PURE__ */ function() {
  function s() {
  }
  return s.prototype.push = function(e, t) {
    this.ondata(null, e, t);
  }, s.compression = 0, s;
}(), aQ = /* @__PURE__ */ function() {
  function s() {
    var e = this;
    this.i = new fs(function(t, i) {
      e.ondata(null, t, i);
    });
  }
  return s.prototype.push = function(e, t) {
    try {
      this.i.push(e, t);
    } catch (i) {
      this.ondata(i, e, t);
    }
  }, s.compression = 8, s;
}(), oQ = /* @__PURE__ */ function() {
  function s(e, t) {
    var i = this;
    t < 32e4 ? this.i = new fs(function(n, r) {
      i.ondata(null, n, r);
    }) : (this.i = new Db(function(n, r, a) {
      i.ondata(n, r, a);
    }), this.terminate = this.i.terminate);
  }
  return s.prototype.push = function(e, t) {
    this.i.terminate && (e = Ms(e, 0)), this.i.push(e, t);
  }, s.compression = 8, s;
}(), lQ = /* @__PURE__ */ function() {
  function s(e) {
    this.onfile = e, this.k = [], this.o = {
      0: GU
    }, this.p = Hr;
  }
  return s.prototype.push = function(e, t) {
    var i = this;
    if (!this.onfile)
      throw "no callback";
    if (!this.p)
      throw "stream finished";
    if (this.c > 0) {
      var n = Math.min(this.c, e.length), r = e.subarray(0, n);
      if (this.c -= n, this.d ? this.d.push(r, !this.c) : this.k[0].push(r), e = e.subarray(n), e.length)
        return this.push(e, t);
    } else {
      var a = 0, o = 0, l = void 0, c = void 0;
      this.p.length ? e.length ? (c = new Bt(this.p.length + e.length), c.set(this.p), c.set(e, this.p.length)) : c = this.p : c = e;
      for (var h = c.length, u = this.c, d = u && this.d, p = function() {
        var m, v = Gi(c, o);
        if (v == 67324752) {
          a = 1, l = o, f.d = null, f.c = 0;
          var g = kn(c, o + 6), _ = kn(c, o + 8), w = g & 2048, S = g & 8, C = kn(c, o + 26), E = kn(c, o + 28);
          if (h > o + 30 + C + E) {
            var x = [];
            f.k.unshift(x), a = 2;
            var b = Gi(c, o + 18), D = Gi(c, o + 22), O = _p(c.subarray(o + 30, o += 30 + C), !w);
            b == 4294967295 ? (m = S ? [-2] : Ob(c, o), b = m[0], D = m[1]) : S && (b = -1), o += E, f.c = b;
            var Y, B = {
              name: O,
              compression: _,
              start: function() {
                if (!B.ondata)
                  throw "no callback";
                if (!b)
                  B.ondata(null, Hr, !0);
                else {
                  var Q = i.o[_];
                  if (!Q)
                    throw "unknown compression type " + _;
                  Y = b < 0 ? new Q(O) : new Q(O, b, D), Y.ondata = function(ee, J, W) {
                    B.ondata(ee, J, W);
                  };
                  for (var j = 0, X = x; j < X.length; j++) {
                    var Z = X[j];
                    Y.push(Z, !1);
                  }
                  i.k[0] == x && i.c ? i.d = Y : Y.push(Hr, !0);
                }
              },
              terminate: function() {
                Y && Y.terminate && Y.terminate();
              }
            };
            b >= 0 && (B.size = b, B.originalSize = D), f.onfile(B);
          }
          return "break";
        } else if (u) {
          if (v == 134695760)
            return l = o += 12 + (u == -2 && 8), a = 3, f.c = 0, "break";
          if (v == 33639248)
            return l = o -= 4, a = 3, f.c = 0, "break";
        }
      }, f = this; o < h - 4; ++o) {
        var y = p();
        if (y === "break")
          break;
      }
      if (this.p = Hr, u < 0) {
        var A = a ? c.subarray(0, l - 12 - (u == -2 && 8) - (Gi(c, l - 16) == 134695760 && 4)) : c.subarray(0, o);
        d ? d.push(A, !!a) : this.k[+(a == 2)].push(A);
      }
      if (a & 2)
        return this.push(c.subarray(o), t);
      this.p = c.subarray(o);
    }
    if (t) {
      if (this.c)
        throw "invalid zip file";
      this.p = null;
    }
  }, s.prototype.register = function(e) {
    this.o[e.compression] = e;
  }, s;
}();
function cQ(s, e) {
  if (typeof e != "function")
    throw "no callback";
  for (var t = [], i = function() {
    for (var d = 0; d < t.length; ++d)
      t[d]();
  }, n = {}, r = s.length - 22; Gi(s, r) != 101010256; --r)
    if (!r || s.length - r > 65558) {
      e("invalid zip file", null);
      return;
    }
  var a = kn(s, r + 8);
  a || e(null, {});
  var o = a, l = Gi(s, r + 16), c = l == 4294967295;
  if (c) {
    if (r = Gi(s, r - 12), Gi(s, r) != 101075792) {
      e("invalid zip file", null);
      return;
    }
    o = a = Gi(s, r + 32), l = Gi(s, r + 48);
  }
  for (var h = function(d) {
    var p = Fb(s, l, c), f = p[0], y = p[1], A = p[2], m = p[3], v = p[4], g = p[5], _ = Ub(s, g);
    l = v;
    var w = function(C, E) {
      C ? (i(), e(C, null)) : (n[m] = E, --a || e(null, n));
    };
    if (!f)
      w(null, Ms(s, _, _ + y));
    else if (f == 8) {
      var S = s.subarray(_, _ + y);
      if (y < 32e4)
        try {
          w(null, _u(S, new Bt(A)));
        } catch (C) {
          w(C, null);
        }
      else
        t.push(Rb(S, { size: A }, w));
    } else
      w("unknown compression type " + f, null);
  }, u = 0; u < o; ++u)
    h();
  return i;
}
function kb(s) {
  for (var e = {}, t = s.length - 22; Gi(s, t) != 101010256; --t)
    if (!t || s.length - t > 65558)
      throw "invalid zip file";
  var i = kn(s, t + 8);
  if (!i)
    return {};
  var n = Gi(s, t + 16), r = n == 4294967295;
  if (r) {
    if (t = Gi(s, t - 12), Gi(s, t) != 101075792)
      throw "invalid zip file";
    i = Gi(s, t + 32), n = Gi(s, t + 48);
  }
  for (var a = 0; a < i; ++a) {
    var o = Fb(s, n, r), l = o[0], c = o[1], h = o[2], u = o[3], d = o[4], p = o[5], f = Ub(s, p);
    if (n = d, !l)
      e[u] = Ms(s, f, f + c);
    else if (l == 8)
      e[u] = _u(s.subarray(f, f + c), new Bt(h));
    else
      throw "unknown compression type " + l;
  }
  return e;
}
function Gb(s, e, t) {
  const i = t.length - s - 1;
  if (e >= t[i])
    return i - 1;
  if (e <= t[s])
    return s;
  let n = s, r = i, a = Math.floor((n + r) / 2);
  for (; e < t[a] || e >= t[a + 1]; )
    e < t[a] ? r = a : n = a, a = Math.floor((n + r) / 2);
  return a;
}
function zU(s, e, t, i) {
  const n = [], r = [], a = [];
  n[0] = 1;
  for (let o = 1; o <= t; ++o) {
    r[o] = e - i[s + 1 - o], a[o] = i[s + o] - e;
    let l = 0;
    for (let c = 0; c < o; ++c) {
      const h = a[c + 1], u = r[o - c], d = n[c] / (h + u);
      n[c] = l + h * d, l = u * d;
    }
    n[o] = l;
  }
  return n;
}
function QU(s, e, t, i) {
  const n = Gb(s, i, e), r = zU(n, i, s, e), a = new it(0, 0, 0, 0);
  for (let o = 0; o <= s; ++o) {
    const l = t[n - s + o], c = r[o], h = l.w * c;
    a.x += l.x * h, a.y += l.y * h, a.z += l.z * h, a.w += l.w * c;
  }
  return a;
}
function HU(s, e, t, i, n) {
  const r = [];
  for (let u = 0; u <= t; ++u)
    r[u] = 0;
  const a = [];
  for (let u = 0; u <= i; ++u)
    a[u] = r.slice(0);
  const o = [];
  for (let u = 0; u <= t; ++u)
    o[u] = r.slice(0);
  o[0][0] = 1;
  const l = r.slice(0), c = r.slice(0);
  for (let u = 1; u <= t; ++u) {
    l[u] = e - n[s + 1 - u], c[u] = n[s + u] - e;
    let d = 0;
    for (let p = 0; p < u; ++p) {
      const f = c[p + 1], y = l[u - p];
      o[u][p] = f + y;
      const A = o[p][u - 1] / o[u][p];
      o[p][u] = d + f * A, d = y * A;
    }
    o[u][u] = d;
  }
  for (let u = 0; u <= t; ++u)
    a[0][u] = o[u][t];
  for (let u = 0; u <= t; ++u) {
    let d = 0, p = 1;
    const f = [];
    for (let y = 0; y <= t; ++y)
      f[y] = r.slice(0);
    f[0][0] = 1;
    for (let y = 1; y <= i; ++y) {
      let A = 0;
      const m = u - y, v = t - y;
      u >= y && (f[p][0] = f[d][0] / o[v + 1][m], A = f[p][0] * o[m][v]);
      const g = m >= -1 ? 1 : -m, _ = u - 1 <= v ? y - 1 : t - u;
      for (let S = g; S <= _; ++S)
        f[p][S] = (f[d][S] - f[d][S - 1]) / o[v + 1][m + S], A += f[p][S] * o[m + S][v];
      u <= v && (f[p][y] = -f[d][y - 1] / o[v + 1][u], A += f[p][y] * o[u][v]), a[y][u] = A;
      const w = d;
      d = p, p = w;
    }
  }
  let h = t;
  for (let u = 1; u <= i; ++u) {
    for (let d = 0; d <= t; ++d)
      a[u][d] *= h;
    h *= t - u;
  }
  return a;
}
function VU(s, e, t, i, n) {
  const r = n < s ? n : s, a = [], o = Gb(s, i, e), l = HU(o, i, s, r, e), c = [];
  for (let h = 0; h < t.length; ++h) {
    const u = t[h].clone(), d = u.w;
    u.x *= d, u.y *= d, u.z *= d, c[h] = u;
  }
  for (let h = 0; h <= r; ++h) {
    const u = c[o - s].clone().multiplyScalar(l[h][0]);
    for (let d = 1; d <= s; ++d)
      u.add(c[o - s + d].clone().multiplyScalar(l[h][d]));
    a[h] = u;
  }
  for (let h = r + 1; h <= n + 1; ++h)
    a[h] = new it(0, 0, 0);
  return a;
}
function WU(s, e) {
  let t = 1;
  for (let n = 2; n <= s; ++n)
    t *= n;
  let i = 1;
  for (let n = 2; n <= e; ++n)
    i *= n;
  for (let n = 2; n <= s - e; ++n)
    i *= n;
  return t / i;
}
function jU(s) {
  const e = s.length, t = [], i = [];
  for (let r = 0; r < e; ++r) {
    const a = s[r];
    t[r] = new M(a.x, a.y, a.z), i[r] = a.w;
  }
  const n = [];
  for (let r = 0; r < e; ++r) {
    const a = t[r].clone();
    for (let o = 1; o <= r; ++o)
      a.sub(n[r - o].clone().multiplyScalar(WU(r, o) * i[o]));
    n[r] = a.divideScalar(i[0]);
  }
  return n;
}
function qU(s, e, t, i, n) {
  const r = VU(s, e, t, i, n);
  return jU(r);
}
class XU extends Zs {
  constructor(e, t, i, n, r) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = n || 0, this.endKnot = r || this.knots.length - 1;
    for (let a = 0; a < i.length; ++a) {
      const o = i[a];
      this.controlPoints[a] = new it(o.x, o.y, o.z, o.w);
    }
  }
  getPoint(e, t = new M()) {
    const i = t, n = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), r = QU(this.degree, this.knots, this.controlPoints, n);
    return r.w !== 1 && r.divideScalar(r.w), i.set(r.x, r.y, r.z);
  }
  getTangent(e, t = new M()) {
    const i = t, n = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), r = qU(this.degree, this.knots, this.controlPoints, n, 1);
    return i.copy(r[1]).normalize(), i;
  }
}
let St, Ii, On;
class YU extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, a = r.path === "" ? hr.extractUrlBase(e) : r.path, o = new ti(this.manager);
    o.setPath(r.path), o.setResponseType("arraybuffer"), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(e, function(l) {
      try {
        t(r.parse(l, a));
      } catch (c) {
        n ? n(c) : console.error(c), r.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e, t) {
    if (tF(e))
      St = new eF().parse(e);
    else {
      const r = Vb(e);
      if (!iF(r))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (rx(r) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + rx(r));
      St = new ZU().parse(r);
    }
    const i = new xo(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin), n = new KU(i, this.manager).parse(St);
    return St = null, Ii = null, On = null, n;
  }
}
class KU {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    Ii = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), i = this.parseMaterials(t), n = this.parseDeformers(), r = new JU().parse(n);
    return this.parseScene(n, r, i), On;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in St && St.Connections.connections.forEach(function(i) {
      const n = i[0], r = i[1], a = i[2];
      e.has(n) || e.set(n, {
        parents: [],
        children: []
      });
      const o = { ID: r, relationship: a };
      e.get(n).parents.push(o), e.has(r) || e.set(r, {
        parents: [],
        children: []
      });
      const l = { ID: n, relationship: a };
      e.get(r).children.push(l);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in St.Objects) {
      const i = St.Objects.Video;
      for (const n in i) {
        const r = i[n], a = parseInt(n);
        if (e[a] = r.RelativeFilename || r.Filename, "Content" in r) {
          const o = r.Content instanceof ArrayBuffer && r.Content.byteLength > 0, l = typeof r.Content == "string" && r.Content !== "";
          if (o || l) {
            const c = this.parseImage(i[n]);
            t[r.RelativeFilename || r.Filename] = c;
          }
        }
      }
    }
    for (const i in e) {
      const n = e[i];
      t[n] !== void 0 ? e[i] = t[n] : e[i] = e[i].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, i = e.RelativeFilename || e.Filename, n = i.slice(i.lastIndexOf(".") + 1).toLowerCase();
    let r;
    switch (n) {
      case "bmp":
        r = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        r = "image/jpeg";
        break;
      case "png":
        r = "image/png";
        break;
      case "tif":
        r = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", i), r = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + n + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + r + ";base64," + t;
    {
      const a = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([a], { type: r }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in St.Objects) {
      const i = St.Objects.Texture;
      for (const n in i) {
        const r = this.parseTexture(i[n], e);
        t.set(parseInt(n), r);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const i = this.loadTexture(e, t);
    i.ID = e.id, i.name = e.attrName;
    const n = e.WrapModeU, r = e.WrapModeV, a = n !== void 0 ? n.value : 0, o = r !== void 0 ? r.value : 0;
    if (i.wrapS = a === 0 ? xn : Zt, i.wrapT = o === 0 ? xn : Zt, "Scaling" in e) {
      const l = e.Scaling.value;
      i.repeat.x = l[0], i.repeat.y = l[1];
    }
    if ("Translation" in e) {
      const l = e.Translation.value;
      i.offset.x = l[0], i.offset.y = l[1];
    }
    return i;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    let i;
    const n = this.textureLoader.path, r = Ii.get(e.id).children;
    r !== void 0 && r.length > 0 && t[r[0].ID] !== void 0 && (i = t[r[0].ID], (i.indexOf("blob:") === 0 || i.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let a;
    const o = e.FileName.slice(-3).toLowerCase();
    if (o === "tga") {
      const l = this.manager.getHandler(".tga");
      l === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), a = new Nt()) : (l.setPath(this.textureLoader.path), a = l.load(i));
    } else o === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), a = new Nt()) : a = this.textureLoader.load(i);
    return this.textureLoader.setPath(n), a;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in St.Objects) {
      const i = St.Objects.Material;
      for (const n in i) {
        const r = this.parseMaterial(i[n], e);
        r !== null && t.set(parseInt(n), r);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const i = e.id, n = e.attrName;
    let r = e.ShadingModel;
    if (typeof r == "object" && (r = r.value), !Ii.has(i)) return null;
    const a = this.parseParameters(e, t, i);
    let o;
    switch (r.toLowerCase()) {
      case "phong":
        o = new Hl();
        break;
      case "lambert":
        o = new Fw();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', r), o = new Hl();
        break;
    }
    return o.setValues(a), o.name = n, o;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, i) {
    const n = {};
    e.BumpFactor && (n.bumpScale = e.BumpFactor.value), e.Diffuse ? n.color = new se().fromArray(e.Diffuse.value).convertSRGBToLinear() : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (n.color = new se().fromArray(e.DiffuseColor.value).convertSRGBToLinear()), e.DisplacementFactor && (n.displacementScale = e.DisplacementFactor.value), e.Emissive ? n.emissive = new se().fromArray(e.Emissive.value).convertSRGBToLinear() : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (n.emissive = new se().fromArray(e.EmissiveColor.value).convertSRGBToLinear()), e.EmissiveFactor && (n.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (n.opacity = parseFloat(e.Opacity.value)), n.opacity < 1 && (n.transparent = !0), e.ReflectionFactor && (n.reflectivity = e.ReflectionFactor.value), e.Shininess && (n.shininess = e.Shininess.value), e.Specular ? n.specular = new se().fromArray(e.Specular.value).convertSRGBToLinear() : e.SpecularColor && e.SpecularColor.type === "Color" && (n.specular = new se().fromArray(e.SpecularColor.value).convertSRGBToLinear());
    const r = this;
    return Ii.get(i).children.forEach(function(a) {
      const o = a.relationship;
      switch (o) {
        case "Bump":
          n.bumpMap = r.getTexture(t, a.ID);
          break;
        case "Maya|TEX_ao_map":
          n.aoMap = r.getTexture(t, a.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          n.map = r.getTexture(t, a.ID), n.map !== void 0 && (n.map.colorSpace = dt);
          break;
        case "DisplacementColor":
          n.displacementMap = r.getTexture(t, a.ID);
          break;
        case "EmissiveColor":
          n.emissiveMap = r.getTexture(t, a.ID), n.emissiveMap !== void 0 && (n.emissiveMap.colorSpace = dt);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          n.normalMap = r.getTexture(t, a.ID);
          break;
        case "ReflectionColor":
          n.envMap = r.getTexture(t, a.ID), n.envMap !== void 0 && (n.envMap.mapping = Ia, n.envMap.colorSpace = dt);
          break;
        case "SpecularColor":
          n.specularMap = r.getTexture(t, a.ID), n.specularMap !== void 0 && (n.specularMap.colorSpace = dt);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          n.alphaMap = r.getTexture(t, a.ID), n.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        // AKA glossiness map
        case "SpecularFactor":
        // AKA specularLevel
        case "VectorDisplacementColor":
        // NOTE: Seems to be a copy of DisplacementColor
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", o);
          break;
      }
    }), n;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in St.Objects && t in St.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = Ii.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in St.Objects) {
      const i = St.Objects.Deformer;
      for (const n in i) {
        const r = i[n], a = Ii.get(parseInt(n));
        if (r.attrType === "Skin") {
          const o = this.parseSkeleton(a, i);
          o.ID = n, a.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), o.geometryID = a.parents[0].ID, e[n] = o;
        } else if (r.attrType === "BlendShape") {
          const o = {
            id: n
          };
          o.rawTargets = this.parseMorphTargets(a, i), o.id = n, a.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[n] = o;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const i = [];
    return e.children.forEach(function(n) {
      const r = t[n.ID];
      if (r.attrType !== "Cluster") return;
      const a = {
        ID: n.ID,
        indices: [],
        weights: [],
        transformLink: new Ue().fromArray(r.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in r && (a.indices = r.Indexes.a, a.weights = r.Weights.a), i.push(a);
    }), {
      rawBones: i,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const i = [];
    for (let n = 0; n < e.children.length; n++) {
      const r = e.children[n], a = t[r.ID], o = {
        name: a.attrName,
        initialWeight: a.DeformPercent,
        id: a.id,
        fullWeights: a.FullWeights.a
      };
      if (a.attrType !== "BlendShapeChannel") return;
      o.geoID = Ii.get(parseInt(r.ID)).children.filter(function(l) {
        return l.relationship === void 0;
      })[0].ID, i.push(o);
    }
    return i;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, i) {
    On = new Kn();
    const n = this.parseModels(e.skeletons, t, i), r = St.Objects.Model, a = this;
    n.forEach(function(l) {
      const c = r[l.ID];
      a.setLookAtProperties(l, c), Ii.get(l.ID).parents.forEach(function(u) {
        const d = n.get(u.ID);
        d !== void 0 && d.add(l);
      }), l.parent === null && On.add(l);
    }), this.bindSkeleton(e.skeletons, t, n), this.createAmbientLight(), On.traverse(function(l) {
      if (l.userData.transformData) {
        l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix, l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
        const c = Qb(l.userData.transformData);
        l.applyMatrix4(c), l.updateWorldMatrix();
      }
    });
    const o = new $U().parse();
    On.children.length === 1 && On.children[0].isGroup && (On.children[0].animations = o, On = On.children[0]), On.animations = o;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, i) {
    const n = /* @__PURE__ */ new Map(), r = St.Objects.Model;
    for (const a in r) {
      const o = parseInt(a), l = r[a], c = Ii.get(o);
      let h = this.buildSkeleton(c, e, o, l.attrName);
      if (!h) {
        switch (l.attrType) {
          case "Camera":
            h = this.createCamera(c);
            break;
          case "Light":
            h = this.createLight(c);
            break;
          case "Mesh":
            h = this.createMesh(c, t, i);
            break;
          case "NurbsCurve":
            h = this.createCurve(c, t);
            break;
          case "LimbNode":
          case "Root":
            h = new Uh();
            break;
          case "Null":
          default:
            h = new Kn();
            break;
        }
        h.name = l.attrName ? _t.sanitizeNodeName(l.attrName) : "", h.userData.originalName = l.attrName, h.ID = o;
      }
      this.getTransformData(h, l), n.set(o, h);
    }
    return n;
  }
  buildSkeleton(e, t, i, n) {
    let r = null;
    return e.parents.forEach(function(a) {
      for (const o in t) {
        const l = t[o];
        l.rawBones.forEach(function(c, h) {
          if (c.ID === a.ID) {
            const u = r;
            r = new Uh(), r.matrixWorld.copy(c.transformLink), r.name = n ? _t.sanitizeNodeName(n) : "", r.userData.originalName = n, r.ID = i, l.bones[h] = r, u !== null && r.add(u);
          }
        });
      }
    }), r;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, i;
    if (e.children.forEach(function(n) {
      const r = St.Objects.NodeAttribute[n.ID];
      r !== void 0 && (i = r);
    }), i === void 0)
      t = new ut();
    else {
      let n = 0;
      i.CameraProjectionType !== void 0 && i.CameraProjectionType.value === 1 && (n = 1);
      let r = 1;
      i.NearPlane !== void 0 && (r = i.NearPlane.value / 1e3);
      let a = 1e3;
      i.FarPlane !== void 0 && (a = i.FarPlane.value / 1e3);
      let o = window.innerWidth, l = window.innerHeight;
      i.AspectWidth !== void 0 && i.AspectHeight !== void 0 && (o = i.AspectWidth.value, l = i.AspectHeight.value);
      const c = o / l;
      let h = 45;
      i.FieldOfView !== void 0 && (h = i.FieldOfView.value);
      const u = i.FocalLength ? i.FocalLength.value : null;
      switch (n) {
        case 0:
          t = new ki(h, c, r, a), u !== null && t.setFocalLength(u);
          break;
        case 1:
          t = new _r(-o / 2, o / 2, l / 2, -l / 2, r, a);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + n + "."), t = new ut();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, i;
    if (e.children.forEach(function(n) {
      const r = St.Objects.NodeAttribute[n.ID];
      r !== void 0 && (i = r);
    }), i === void 0)
      t = new ut();
    else {
      let n;
      i.LightType === void 0 ? n = 0 : n = i.LightType.value;
      let r = 16777215;
      i.Color !== void 0 && (r = new se().fromArray(i.Color.value).convertSRGBToLinear());
      let a = i.Intensity === void 0 ? 1 : i.Intensity.value / 100;
      i.CastLightOnObject !== void 0 && i.CastLightOnObject.value === 0 && (a = 0);
      let o = 0;
      i.FarAttenuationEnd !== void 0 && (i.EnableFarAttenuation !== void 0 && i.EnableFarAttenuation.value === 0 ? o = 0 : o = i.FarAttenuationEnd.value);
      const l = 1;
      switch (n) {
        case 0:
          t = new nc(r, a, o, l);
          break;
        case 1:
          t = new hu(r, a);
          break;
        case 2:
          let c = Math.PI / 3;
          i.InnerAngle !== void 0 && (c = ri.degToRad(i.InnerAngle.value));
          let h = 0;
          i.OuterAngle !== void 0 && (h = ri.degToRad(i.OuterAngle.value), h = Math.max(h, 1)), t = new cu(r, a, o, c, h, l);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + i.LightType.value + ", defaulting to a PointLight."), t = new nc(r, a);
          break;
      }
      i.CastShadows !== void 0 && i.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, i) {
    let n, r = null, a = null;
    const o = [];
    return e.children.forEach(function(l) {
      t.has(l.ID) && (r = t.get(l.ID)), i.has(l.ID) && o.push(i.get(l.ID));
    }), o.length > 1 ? a = o : o.length > 0 ? a = o[0] : (a = new Hl({
      name: ui.DEFAULT_MATERIAL_NAME,
      color: 13421772
    }), o.push(a)), "color" in r.attributes && o.forEach(function(l) {
      l.vertexColors = !0;
    }), r.FBX_Deformer ? (n = new gA(r, a), n.normalizeSkinWeights()) : n = new Se(r, a), n;
  }
  createCurve(e, t) {
    const i = e.children.reduce(function(r, a) {
      return t.has(a.ID) && (r = t.get(a.ID)), r;
    }, null), n = new Ri({
      name: ui.DEFAULT_MATERIAL_NAME,
      color: 3342591,
      linewidth: 1
    });
    return new an(i, n);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const i = {};
    "InheritType" in t && (i.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? i.eulerOrder = Hb(t.RotationOrder.value) : i.eulerOrder = "ZYX", "Lcl_Translation" in t && (i.translation = t.Lcl_Translation.value), "PreRotation" in t && (i.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (i.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (i.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (i.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (i.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (i.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (i.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (i.rotationPivot = t.RotationPivot.value), e.userData.transformData = i;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && Ii.get(e.ID).children.forEach(function(n) {
      if (n.relationship === "LookAtProperty") {
        const r = St.Objects.Model[n.ID];
        if ("Lcl_Translation" in r) {
          const a = r.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(a), On.add(e.target)) : e.lookAt(new M().fromArray(a));
        }
      }
    });
  }
  bindSkeleton(e, t, i) {
    const n = this.parsePoseNodes();
    for (const r in e) {
      const a = e[r];
      Ii.get(parseInt(a.ID)).parents.forEach(function(l) {
        if (t.has(l.ID)) {
          const c = l.ID;
          Ii.get(c).parents.forEach(function(u) {
            i.has(u.ID) && i.get(u.ID).bind(new ou(a.bones), n[u.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in St.Objects) {
      const t = St.Objects.Pose;
      for (const i in t)
        if (t[i].attrType === "BindPose" && t[i].NbPoseNodes > 0) {
          const n = t[i].PoseNode;
          Array.isArray(n) ? n.forEach(function(r) {
            e[r.Node] = new Ue().fromArray(r.Matrix.a);
          }) : e[n.Node] = new Ue().fromArray(n.Matrix.a);
        }
    }
    return e;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in St && "AmbientColor" in St.GlobalSettings) {
      const e = St.GlobalSettings.AmbientColor.value, t = e[0], i = e[1], n = e[2];
      if (t !== 0 || i !== 0 || n !== 0) {
        const r = new se(t, i, n).convertSRGBToLinear();
        On.add(new UA(r, 1));
      }
    }
  }
}
class JU {
  constructor() {
    this.negativeMaterialIndices = !1;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in St.Objects) {
      const i = St.Objects.Geometry;
      for (const n in i) {
        const r = Ii.get(parseInt(n)), a = this.parseGeometry(r, i[n], e);
        t.set(parseInt(n), a);
      }
    }
    return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, i) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, i);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, i) {
    const n = i.skeletons, r = [], a = e.parents.map(function(u) {
      return St.Objects.Model[u.ID];
    });
    if (a.length === 0) return;
    const o = e.children.reduce(function(u, d) {
      return n[d.ID] !== void 0 && (u = n[d.ID]), u;
    }, null);
    e.children.forEach(function(u) {
      i.morphTargets[u.ID] !== void 0 && r.push(i.morphTargets[u.ID]);
    });
    const l = a[0], c = {};
    "RotationOrder" in l && (c.eulerOrder = Hb(l.RotationOrder.value)), "InheritType" in l && (c.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (c.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (c.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (c.scale = l.GeometricScaling.value);
    const h = Qb(c);
    return this.genGeometry(t, o, r, h);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, i, n) {
    const r = new Ze();
    e.attrName && (r.name = e.attrName);
    const a = this.parseGeoNode(e, t), o = this.genBuffers(a), l = new Te(o.vertex, 3);
    if (l.applyMatrix4(n), r.setAttribute("position", l), o.colors.length > 0 && r.setAttribute("color", new Te(o.colors, 3)), t && (r.setAttribute("skinIndex", new hA(o.weightsIndices, 4)), r.setAttribute("skinWeight", new Te(o.vertexWeights, 4)), r.FBX_Deformer = t), o.normal.length > 0) {
      const c = new yt().getNormalMatrix(n), h = new Te(o.normal, 3);
      h.applyNormalMatrix(c), r.setAttribute("normal", h);
    }
    if (o.uvs.forEach(function(c, h) {
      const u = h === 0 ? "uv" : `uv${h}`;
      r.setAttribute(u, new Te(o.uvs[h], 2));
    }), a.material && a.material.mappingType !== "AllSame") {
      let c = o.materialIndex[0], h = 0;
      if (o.materialIndex.forEach(function(u, d) {
        u !== c && (r.addGroup(h, d - h, c), c = u, h = d);
      }), r.groups.length > 0) {
        const u = r.groups[r.groups.length - 1], d = u.start + u.count;
        d !== o.materialIndex.length && r.addGroup(d, o.materialIndex.length - d, c);
      }
      r.groups.length === 0 && r.addGroup(0, o.materialIndex.length, o.materialIndex[0]);
    }
    return this.addMorphTargets(r, e, i, n), r;
  }
  parseGeoNode(e, t) {
    const i = {};
    if (i.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], i.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (i.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (i.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (i.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      i.uv = [];
      let n = 0;
      for (; e.LayerElementUV[n]; )
        e.LayerElementUV[n].UV && i.uv.push(this.parseUVs(e.LayerElementUV[n])), n++;
    }
    return i.weightTable = {}, t !== null && (i.skeleton = t, t.rawBones.forEach(function(n, r) {
      n.indices.forEach(function(a, o) {
        i.weightTable[a] === void 0 && (i.weightTable[a] = []), i.weightTable[a].push({
          id: r,
          weight: n.weights[o]
        });
      });
    })), i;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let i = 0, n = 0, r = !1, a = [], o = [], l = [], c = [], h = [], u = [];
    const d = this;
    return e.vertexIndices.forEach(function(p, f) {
      let y, A = !1;
      p < 0 && (p = p ^ -1, A = !0);
      let m = [], v = [];
      if (a.push(p * 3, p * 3 + 1, p * 3 + 2), e.color) {
        const g = Cd(f, i, p, e.color);
        l.push(g[0], g[1], g[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[p] !== void 0 && e.weightTable[p].forEach(function(g) {
          v.push(g.weight), m.push(g.id);
        }), v.length > 4) {
          r || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), r = !0);
          const g = [0, 0, 0, 0], _ = [0, 0, 0, 0];
          v.forEach(function(w, S) {
            let C = w, E = m[S];
            _.forEach(function(x, b, D) {
              if (C > x) {
                D[b] = C, C = x;
                const O = g[b];
                g[b] = E, E = O;
              }
            });
          }), m = g, v = _;
        }
        for (; v.length < 4; )
          v.push(0), m.push(0);
        for (let g = 0; g < 4; ++g)
          h.push(v[g]), u.push(m[g]);
      }
      if (e.normal) {
        const g = Cd(f, i, p, e.normal);
        o.push(g[0], g[1], g[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (y = Cd(f, i, p, e.material)[0], y < 0 && (d.negativeMaterialIndices = !0, y = 0)), e.uv && e.uv.forEach(function(g, _) {
        const w = Cd(f, i, p, g);
        c[_] === void 0 && (c[_] = []), c[_].push(w[0]), c[_].push(w[1]);
      }), n++, A && (n > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."), d.genFace(t, e, a, y, o, l, c, h, u, n), i++, n = 0, a = [], o = [], l = [], c = [], h = [], u = []);
    }), t;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, i, n, r, a, o, l, c, h) {
    for (let u = 2; u < h; u++)
      e.vertex.push(t.vertexPositions[i[0]]), e.vertex.push(t.vertexPositions[i[1]]), e.vertex.push(t.vertexPositions[i[2]]), e.vertex.push(t.vertexPositions[i[(u - 1) * 3]]), e.vertex.push(t.vertexPositions[i[(u - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[i[(u - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[i[u * 3]]), e.vertex.push(t.vertexPositions[i[u * 3 + 1]]), e.vertex.push(t.vertexPositions[i[u * 3 + 2]]), t.skeleton && (e.vertexWeights.push(l[0]), e.vertexWeights.push(l[1]), e.vertexWeights.push(l[2]), e.vertexWeights.push(l[3]), e.vertexWeights.push(l[(u - 1) * 4]), e.vertexWeights.push(l[(u - 1) * 4 + 1]), e.vertexWeights.push(l[(u - 1) * 4 + 2]), e.vertexWeights.push(l[(u - 1) * 4 + 3]), e.vertexWeights.push(l[u * 4]), e.vertexWeights.push(l[u * 4 + 1]), e.vertexWeights.push(l[u * 4 + 2]), e.vertexWeights.push(l[u * 4 + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[(u - 1) * 4]), e.weightsIndices.push(c[(u - 1) * 4 + 1]), e.weightsIndices.push(c[(u - 1) * 4 + 2]), e.weightsIndices.push(c[(u - 1) * 4 + 3]), e.weightsIndices.push(c[u * 4]), e.weightsIndices.push(c[u * 4 + 1]), e.weightsIndices.push(c[u * 4 + 2]), e.weightsIndices.push(c[u * 4 + 3])), t.color && (e.colors.push(a[0]), e.colors.push(a[1]), e.colors.push(a[2]), e.colors.push(a[(u - 1) * 3]), e.colors.push(a[(u - 1) * 3 + 1]), e.colors.push(a[(u - 1) * 3 + 2]), e.colors.push(a[u * 3]), e.colors.push(a[u * 3 + 1]), e.colors.push(a[u * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(n), e.materialIndex.push(n), e.materialIndex.push(n)), t.normal && (e.normal.push(r[0]), e.normal.push(r[1]), e.normal.push(r[2]), e.normal.push(r[(u - 1) * 3]), e.normal.push(r[(u - 1) * 3 + 1]), e.normal.push(r[(u - 1) * 3 + 2]), e.normal.push(r[u * 3]), e.normal.push(r[u * 3 + 1]), e.normal.push(r[u * 3 + 2])), t.uv && t.uv.forEach(function(d, p) {
        e.uvs[p] === void 0 && (e.uvs[p] = []), e.uvs[p].push(o[p][0]), e.uvs[p].push(o[p][1]), e.uvs[p].push(o[p][(u - 1) * 2]), e.uvs[p].push(o[p][(u - 1) * 2 + 1]), e.uvs[p].push(o[p][u * 2]), e.uvs[p].push(o[p][u * 2 + 1]);
      });
  }
  addMorphTargets(e, t, i, n) {
    if (i.length === 0) return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const r = this;
    i.forEach(function(a) {
      a.rawTargets.forEach(function(o) {
        const l = St.Objects.Geometry[o.geoID];
        l !== void 0 && r.genMorphGeometry(e, t, l, n, o.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, i, n, r) {
    const a = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], o = i.Vertices !== void 0 ? i.Vertices.a : [], l = i.Indexes !== void 0 ? i.Indexes.a : [], c = e.attributes.position.count * 3, h = new Float32Array(c);
    for (let f = 0; f < l.length; f++) {
      const y = l[f] * 3;
      h[y] = o[f * 3], h[y + 1] = o[f * 3 + 1], h[y + 2] = o[f * 3 + 2];
    }
    const u = {
      vertexIndices: a,
      vertexPositions: h
    }, d = this.genBuffers(u), p = new Te(d.vertex, 3);
    p.name = r || i.attrName, p.applyMatrix4(n), e.morphAttributes.position.push(p);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, i = e.ReferenceInformationType, n = e.Normals.a;
    let r = [];
    return i === "IndexToDirect" && ("NormalIndex" in e ? r = e.NormalIndex.a : "NormalsIndex" in e && (r = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: n,
      indices: r,
      mappingType: t,
      referenceType: i
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, i = e.ReferenceInformationType, n = e.UV.a;
    let r = [];
    return i === "IndexToDirect" && (r = e.UVIndex.a), {
      dataSize: 2,
      buffer: n,
      indices: r,
      mappingType: t,
      referenceType: i
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    const t = e.MappingInformationType, i = e.ReferenceInformationType, n = e.Colors.a;
    let r = [];
    i === "IndexToDirect" && (r = e.ColorIndex.a);
    for (let a = 0, o = new se(); a < n.length; a += 4)
      o.fromArray(n, a).convertSRGBToLinear().toArray(n, a);
    return {
      dataSize: 4,
      buffer: n,
      indices: r,
      mappingType: t,
      referenceType: i
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, i = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: i
      };
    const n = e.Materials.a, r = [];
    for (let a = 0; a < n.length; ++a)
      r.push(a);
    return {
      dataSize: 1,
      buffer: n,
      indices: r,
      mappingType: t,
      referenceType: i
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new Ze();
    const i = t - 1, n = e.KnotVector.a, r = [], a = e.Points.a;
    for (let u = 0, d = a.length; u < d; u += 4)
      r.push(new it().fromArray(a, u));
    let o, l;
    if (e.Form === "Closed")
      r.push(r[0]);
    else if (e.Form === "Periodic") {
      o = i, l = n.length - 1 - o;
      for (let u = 0; u < i; ++u)
        r.push(r[u]);
    }
    const h = new XU(i, n, r, o, l).getPoints(r.length * 12);
    return new Ze().setFromPoints(h);
  }
}
class $U {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const i in t) {
        const n = t[i], r = this.addClip(n);
        e.push(r);
      }
    return e;
  }
  parseClips() {
    if (St.Objects.AnimationCurve === void 0) return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = St.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const i in e) {
      const n = e[i];
      if (n.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const r = {
          id: n.id,
          attr: n.attrName,
          curves: {}
        };
        t.set(r.id, r);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = St.Objects.AnimationCurve;
    for (const i in t) {
      const n = {
        id: t[i].id,
        times: t[i].KeyTime.a.map(nF),
        values: t[i].KeyValueFloat.a
      }, r = Ii.get(n.id);
      if (r !== void 0) {
        const a = r.parents[0].ID, o = r.parents[0].relationship;
        o.match(/X/) ? e.get(a).curves.x = n : o.match(/Y/) ? e.get(a).curves.y = n : o.match(/Z/) ? e.get(a).curves.z = n : o.match(/DeformPercent/) && e.has(a) && (e.get(a).curves.morph = n);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = St.Objects.AnimationLayer, i = /* @__PURE__ */ new Map();
    for (const n in t) {
      const r = [], a = Ii.get(parseInt(n));
      a !== void 0 && (a.children.forEach(function(l, c) {
        if (e.has(l.ID)) {
          const h = e.get(l.ID);
          if (h.curves.x !== void 0 || h.curves.y !== void 0 || h.curves.z !== void 0) {
            if (r[c] === void 0) {
              const u = Ii.get(l.ID).parents.filter(function(d) {
                return d.relationship !== void 0;
              })[0].ID;
              if (u !== void 0) {
                const d = St.Objects.Model[u.toString()];
                if (d === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", l);
                  return;
                }
                const p = {
                  modelName: d.attrName ? _t.sanitizeNodeName(d.attrName) : "",
                  ID: d.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                On.traverse(function(f) {
                  f.ID === d.id && (p.transform = f.matrix, f.userData.transformData && (p.eulerOrder = f.userData.transformData.eulerOrder));
                }), p.transform || (p.transform = new Ue()), "PreRotation" in d && (p.preRotation = d.PreRotation.value), "PostRotation" in d && (p.postRotation = d.PostRotation.value), r[c] = p;
              }
            }
            r[c] && (r[c][h.attr] = h);
          } else if (h.curves.morph !== void 0) {
            if (r[c] === void 0) {
              const u = Ii.get(l.ID).parents.filter(function(m) {
                return m.relationship !== void 0;
              })[0].ID, d = Ii.get(u).parents[0].ID, p = Ii.get(d).parents[0].ID, f = Ii.get(p).parents[0].ID, y = St.Objects.Model[f], A = {
                modelName: y.attrName ? _t.sanitizeNodeName(y.attrName) : "",
                morphName: St.Objects.Deformer[u].attrName
              };
              r[c] = A;
            }
            r[c][h.attr] = h;
          }
        }
      }), i.set(parseInt(n), r));
    }
    return i;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = St.Objects.AnimationStack, i = {};
    for (const n in t) {
      const r = Ii.get(parseInt(n)).children;
      r.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      const a = e.get(r[0].ID);
      i[n] = {
        name: t[n].attrName,
        layer: a
      };
    }
    return i;
  }
  addClip(e) {
    let t = [];
    const i = this;
    return e.layer.forEach(function(n) {
      t = t.concat(i.generateTracks(n));
    }), new ic(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let i = new M(), n = new rt(), r = new M();
    if (e.transform && e.transform.decompose(i, n, r), i = i.toArray(), n = new xi().setFromQuaternion(n, e.eulerOrder).toArray(), r = r.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const a = this.generateVectorTrack(e.modelName, e.T.curves, i, "position");
      a !== void 0 && t.push(a);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const a = this.generateRotationTrack(e.modelName, e.R.curves, n, e.preRotation, e.postRotation, e.eulerOrder);
      a !== void 0 && t.push(a);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const a = this.generateVectorTrack(e.modelName, e.S.curves, r, "scale");
      a !== void 0 && t.push(a);
    }
    if (e.DeformPercent !== void 0) {
      const a = this.generateMorphTrack(e);
      a !== void 0 && t.push(a);
    }
    return t;
  }
  generateVectorTrack(e, t, i, n) {
    const r = this.getTimesForAllAxes(t), a = this.getKeyframeTrackValues(r, t, i);
    return new _o(e + "." + n, r, a);
  }
  generateRotationTrack(e, t, i, n, r, a) {
    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(ri.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(ri.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(ri.degToRad));
    const o = this.getTimesForAllAxes(t), l = this.getKeyframeTrackValues(o, t, i);
    n !== void 0 && (n = n.map(ri.degToRad), n.push(a), n = new xi().fromArray(n), n = new rt().setFromEuler(n)), r !== void 0 && (r = r.map(ri.degToRad), r.push(a), r = new xi().fromArray(r), r = new rt().setFromEuler(r).invert());
    const c = new rt(), h = new xi(), u = [];
    for (let d = 0; d < l.length; d += 3)
      h.set(l[d], l[d + 1], l[d + 2], a), c.setFromEuler(h), n !== void 0 && c.premultiply(n), r !== void 0 && c.multiply(r), c.toArray(u, d / 3 * 4);
    return new Ra(e + ".quaternion", o, u);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, i = t.values.map(function(r) {
      return r / 100;
    }), n = On.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new vo(e.modelName + ".morphTargetInfluences[" + n + "]", t.times, i);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(i, n) {
      return i - n;
    }), t.length > 1) {
      let i = 1, n = t[0];
      for (let r = 1; r < t.length; r++) {
        const a = t[r];
        a !== n && (t[i] = a, n = a, i++);
      }
      t = t.slice(0, i);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, i) {
    const n = i, r = [];
    let a = -1, o = -1, l = -1;
    return e.forEach(function(c) {
      if (t.x && (a = t.x.times.indexOf(c)), t.y && (o = t.y.times.indexOf(c)), t.z && (l = t.z.times.indexOf(c)), a !== -1) {
        const h = t.x.values[a];
        r.push(h), n[0] = h;
      } else
        r.push(n[0]);
      if (o !== -1) {
        const h = t.y.values[o];
        r.push(h), n[1] = h;
      } else
        r.push(n[1]);
      if (l !== -1) {
        const h = t.z.values[l];
        r.push(h), n[2] = h;
      } else
        r.push(n[2]);
    }), r;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const i = e.values[t - 1], n = e.values[t] - i, r = Math.abs(n);
      if (r >= 180) {
        const a = r / 180, o = n / a;
        let l = i + o;
        const c = e.times[t - 1], u = (e.times[t] - c) / a;
        let d = c + u;
        const p = [], f = [];
        for (; d < e.times[t]; )
          p.push(d), d += u, f.push(l), l += o;
        e.times = ax(e.times, t, p), e.values = ax(e.values, t, f);
      }
    }
  }
}
class ZU {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new zb(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, i = e.split(/[\r\n]+/);
    return i.forEach(function(n, r) {
      const a = n.match(/^[\s\t]*;/), o = n.match(/^[\s\t]*$/);
      if (a || o) return;
      const l = n.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), c = n.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), h = n.match("^\\t{" + (t.currentIndent - 1) + "}}");
      l ? t.parseNodeBegin(n, l) : c ? t.parseNodeProperty(n, c, i[++r]) : h ? t.popStack() : n.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(n);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const i = t[1].trim().replace(/^"/, "").replace(/"$/, ""), n = t[2].split(",").map(function(l) {
      return l.trim().replace(/^"/, "").replace(/"$/, "");
    }), r = { name: i }, a = this.parseNodeAttr(n), o = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(i, r) : i in o ? (i === "PoseNode" ? o.PoseNode.push(r) : o[i].id !== void 0 && (o[i] = {}, o[i][o[i].id] = o[i]), a.id !== "" && (o[i][a.id] = r)) : typeof a.id == "number" ? (o[i] = {}, o[i][a.id] = r) : i !== "Properties70" && (i === "PoseNode" ? o[i] = [r] : o[i] = r), typeof a.id == "number" && (r.id = a.id), a.name !== "" && (r.attrName = a.name), a.type !== "" && (r.attrType = a.type), this.pushStack(r);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let i = "", n = "";
    return e.length > 1 && (i = e[1].replace(/^(\w+)::/, ""), n = e[2]), { id: t, name: i, type: n };
  }
  parseNodeProperty(e, t, i) {
    let n = t[1].replace(/^"/, "").replace(/"$/, "").trim(), r = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    n === "Content" && r === "," && (r = i.replace(/"/g, "").replace(/,$/, "").trim());
    const a = this.getCurrentNode();
    if (a.name === "Properties70") {
      this.parseNodeSpecialProperty(e, n, r);
      return;
    }
    if (n === "C") {
      const l = r.split(",").slice(1), c = parseInt(l[0]), h = parseInt(l[1]);
      let u = r.split(",").slice(3);
      u = u.map(function(d) {
        return d.trim().replace(/^"/, "");
      }), n = "connections", r = [c, h], rF(r, u), a[n] === void 0 && (a[n] = []);
    }
    n === "Node" && (a.id = r), n in a && Array.isArray(a[n]) ? a[n].push(r) : n !== "a" ? a[n] = r : a.a = r, this.setCurrentProp(a, n), n === "a" && r.slice(-1) !== "," && (a.a = mm(r));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = mm(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, i) {
    const n = i.split('",').map(function(h) {
      return h.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), r = n[0], a = n[1], o = n[2], l = n[3];
    let c = n[4];
    switch (a) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        c = parseFloat(c);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        c = mm(c);
        break;
    }
    this.getPrevNode()[r] = {
      type: a,
      type2: o,
      flag: l,
      value: c
    }, this.setCurrentProp(this.getPrevNode(), r);
  }
}
class eF {
  parse(e) {
    const t = new sx(e);
    t.skip(23);
    const i = t.getUint32();
    if (i < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + i);
    const n = new zb();
    for (; !this.endOfContent(t); ) {
      const r = this.parseNode(t, i);
      r !== null && n.add(r.name, r);
    }
    return n;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const i = {}, n = t >= 7500 ? e.getUint64() : e.getUint32(), r = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const a = e.getUint8(), o = e.getString(a);
    if (n === 0) return null;
    const l = [];
    for (let d = 0; d < r; d++)
      l.push(this.parseProperty(e));
    const c = l.length > 0 ? l[0] : "", h = l.length > 1 ? l[1] : "", u = l.length > 2 ? l[2] : "";
    for (i.singleProperty = r === 1 && e.getOffset() === n; n > e.getOffset(); ) {
      const d = this.parseNode(e, t);
      d !== null && this.parseSubNode(o, i, d);
    }
    return i.propertyList = l, typeof c == "number" && (i.id = c), h !== "" && (i.attrName = h), u !== "" && (i.attrType = u), o !== "" && (i.name = o), i;
  }
  parseSubNode(e, t, i) {
    if (i.singleProperty === !0) {
      const n = i.propertyList[0];
      Array.isArray(n) ? (t[i.name] = i, i.a = n) : t[i.name] = n;
    } else if (e === "Connections" && i.name === "C") {
      const n = [];
      i.propertyList.forEach(function(r, a) {
        a !== 0 && n.push(r);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(n);
    } else if (i.name === "Properties70")
      Object.keys(i).forEach(function(r) {
        t[r] = i[r];
      });
    else if (e === "Properties70" && i.name === "P") {
      let n = i.propertyList[0], r = i.propertyList[1];
      const a = i.propertyList[2], o = i.propertyList[3];
      let l;
      n.indexOf("Lcl ") === 0 && (n = n.replace("Lcl ", "Lcl_")), r.indexOf("Lcl ") === 0 && (r = r.replace("Lcl ", "Lcl_")), r === "Color" || r === "ColorRGB" || r === "Vector" || r === "Vector3D" || r.indexOf("Lcl_") === 0 ? l = [
        i.propertyList[4],
        i.propertyList[5],
        i.propertyList[6]
      ] : l = i.propertyList[4], t[n] = {
        type: r,
        type2: a,
        flag: o,
        value: l
      };
    } else t[i.name] === void 0 ? typeof i.id == "number" ? (t[i.name] = {}, t[i.name][i.id] = i) : t[i.name] = i : i.name === "PoseNode" ? (Array.isArray(t[i.name]) || (t[i.name] = [t[i.name]]), t[i.name].push(i)) : t[i.name][i.id] === void 0 && (t[i.name][i.id] = i);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let i;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return i = e.getUint32(), e.getArrayBuffer(i);
      case "S":
        return i = e.getUint32(), e.getString(i);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const n = e.getUint32(), r = e.getUint32(), a = e.getUint32();
        if (r === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(n);
            case "d":
              return e.getFloat64Array(n);
            case "f":
              return e.getFloat32Array(n);
            case "i":
              return e.getInt32Array(n);
            case "l":
              return e.getInt64Array(n);
          }
        const o = xa(new Uint8Array(e.getArrayBuffer(a))), l = new sx(o.buffer);
        switch (t) {
          case "b":
          case "c":
            return l.getBooleanArray(n);
          case "d":
            return l.getFloat64Array(n);
          case "f":
            return l.getFloat32Array(n);
          case "i":
            return l.getInt32Array(n);
          case "l":
            return l.getInt64Array(n);
        }
        break;
      // cannot happen but is required by the DeepScan
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class sx {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0, this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    const t = this.offset;
    let i = new Uint8Array(this.dv.buffer, t, e);
    this.skip(e);
    const n = i.indexOf(0);
    return n >= 0 && (i = new Uint8Array(this.dv.buffer, t, n)), this._textDecoder.decode(i);
  }
}
class zb {
  add(e, t) {
    this[e] = t;
  }
}
function tF(s) {
  const e = "Kaydara FBX Binary  \0";
  return s.byteLength >= e.length && e === Vb(s, 0, e.length);
}
function iF(s) {
  const e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let t = 0;
  function i(n) {
    const r = s[n - 1];
    return s = s.slice(t + n), t++, r;
  }
  for (let n = 0; n < e.length; ++n)
    if (i(1) === e[n])
      return !1;
  return !0;
}
function rx(s) {
  const e = /FBXVersion: (\d+)/, t = s.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function nF(s) {
  return s / 46186158e3;
}
const sF = [];
function Cd(s, e, t, i) {
  let n;
  switch (i.mappingType) {
    case "ByPolygonVertex":
      n = s;
      break;
    case "ByPolygon":
      n = e;
      break;
    case "ByVertice":
      n = t;
      break;
    case "AllSame":
      n = i.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + i.mappingType);
  }
  i.referenceType === "IndexToDirect" && (n = i.indices[n]);
  const r = n * i.dataSize, a = r + i.dataSize;
  return aF(sF, i.buffer, r, a);
}
const fm = new xi(), _l = new M();
function Qb(s) {
  const e = new Ue(), t = new Ue(), i = new Ue(), n = new Ue(), r = new Ue(), a = new Ue(), o = new Ue(), l = new Ue(), c = new Ue(), h = new Ue(), u = new Ue(), d = new Ue(), p = s.inheritType ? s.inheritType : 0;
  if (s.translation && e.setPosition(_l.fromArray(s.translation)), s.preRotation) {
    const b = s.preRotation.map(ri.degToRad);
    b.push(s.eulerOrder || xi.DEFAULT_ORDER), t.makeRotationFromEuler(fm.fromArray(b));
  }
  if (s.rotation) {
    const b = s.rotation.map(ri.degToRad);
    b.push(s.eulerOrder || xi.DEFAULT_ORDER), i.makeRotationFromEuler(fm.fromArray(b));
  }
  if (s.postRotation) {
    const b = s.postRotation.map(ri.degToRad);
    b.push(s.eulerOrder || xi.DEFAULT_ORDER), n.makeRotationFromEuler(fm.fromArray(b)), n.invert();
  }
  s.scale && r.scale(_l.fromArray(s.scale)), s.scalingOffset && o.setPosition(_l.fromArray(s.scalingOffset)), s.scalingPivot && a.setPosition(_l.fromArray(s.scalingPivot)), s.rotationOffset && l.setPosition(_l.fromArray(s.rotationOffset)), s.rotationPivot && c.setPosition(_l.fromArray(s.rotationPivot)), s.parentMatrixWorld && (u.copy(s.parentMatrix), h.copy(s.parentMatrixWorld));
  const f = t.clone().multiply(i).multiply(n), y = new Ue();
  y.extractRotation(h);
  const A = new Ue();
  A.copyPosition(h);
  const m = A.clone().invert().multiply(h), v = y.clone().invert().multiply(m), g = r, _ = new Ue();
  if (p === 0)
    _.copy(y).multiply(f).multiply(v).multiply(g);
  else if (p === 1)
    _.copy(y).multiply(v).multiply(f).multiply(g);
  else {
    const D = new Ue().scale(new M().setFromMatrixScale(u)).clone().invert(), O = v.clone().multiply(D);
    _.copy(y).multiply(f).multiply(O).multiply(g);
  }
  const w = c.clone().invert(), S = a.clone().invert();
  let C = e.clone().multiply(l).multiply(c).multiply(t).multiply(i).multiply(n).multiply(w).multiply(o).multiply(a).multiply(r).multiply(S);
  const E = new Ue().copyPosition(C), x = h.clone().multiply(E);
  return d.copyPosition(x), C = d.clone().multiply(_), C.premultiply(h.invert()), C;
}
function Hb(s) {
  s = s || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return s === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[s];
}
function mm(s) {
  return s.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function Vb(s, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = s.byteLength), new TextDecoder().decode(new Uint8Array(s, e, t));
}
function rF(s, e) {
  for (let t = 0, i = s.length, n = e.length; t < n; t++, i++)
    s[i] = e[t];
}
function aF(s, e, t, i) {
  for (let n = t, r = 0; n < i; n++, r++)
    s[r] = e[n];
  return s;
}
function ax(s, e, t) {
  return s.slice(0, e).concat(t).concat(s.slice(e));
}
class oF extends YU {
  async loadAsync(e, t) {
    const i = Nt.DEFAULT_IMAGE;
    Nt.DEFAULT_IMAGE || (Nt.DEFAULT_IMAGE = qh.WHITE_IMAGE_DATA);
    const n = await super.loadAsync(e, t);
    return Nt.DEFAULT_IMAGE = i, n;
  }
}
class lF extends ti {
  load(e, t, i, n) {
    return this.setResponseType("arraybuffer"), super.load(e, (r) => {
      const a = kb(new Uint8Array(r)), o = new Map(Object.entries(a).map(([l, c]) => [l, new File([c], l)]));
      t == null || t(o);
    }, i, n);
  }
}
class zt extends ui {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new pF(t);
    }), this.register(function(t) {
      return new xF(t);
    }), this.register(function(t) {
      return new wF(t);
    }), this.register(function(t) {
      return new EF(t);
    }), this.register(function(t) {
      return new mF(t);
    }), this.register(function(t) {
      return new gF(t);
    }), this.register(function(t) {
      return new AF(t);
    }), this.register(function(t) {
      return new yF(t);
    }), this.register(function(t) {
      return new dF(t);
    }), this.register(function(t) {
      return new vF(t);
    }), this.register(function(t) {
      return new fF(t);
    }), this.register(function(t) {
      return new _F(t);
    }), this.register(function(t) {
      return new hF(t);
    }), this.register(function(t) {
      return new bF(t);
    }), this.register(function(t) {
      return new SF(t);
    });
  }
  load(e, t, i, n) {
    const r = this;
    let a;
    this.resourcePath !== "" ? a = this.resourcePath : this.path !== "" ? a = this.path : a = hr.extractUrlBase(e), this.manager.itemStart(e);
    const o = function(c) {
      n ? n(c) : console.error(c), r.manager.itemError(e), r.manager.itemEnd(e);
    }, l = new ti(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
      try {
        r.parse(c, a, function(h) {
          t(h), r.manager.itemEnd(e);
        }, o, e);
      } catch (h) {
        o(h);
      }
    }, i, o);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, i, n, r) {
    let a;
    const o = {}, l = {}, c = new TextDecoder();
    if (typeof e == "string")
      a = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (c.decode(new Uint8Array(e, 0, 4)) === Wb) {
        try {
          o[Ot.KHR_BINARY_GLTF] = new jb(e);
        } catch (d) {
          n && n(d);
          return;
        }
        a = JSON.parse(o[Ot.KHR_BINARY_GLTF].content);
      } else
        a = JSON.parse(c.decode(e));
    else
      a = e;
    if (a.asset === void 0 || a.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const h = new NF(a, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    h.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const d = this.pluginCallbacks[u](h);
      d.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), l[d.name] = d, o[d.name] = !0;
    }
    if (a.extensionsUsed)
      for (let u = 0; u < a.extensionsUsed.length; ++u) {
        const d = a.extensionsUsed[u], p = a.extensionsRequired || [];
        switch (d) {
          case Ot.KHR_MATERIALS_UNLIT:
            o[d] = new uF();
            break;
          case Ot.KHR_DRACO_MESH_COMPRESSION:
            o[d] = new CF(a, this.dracoLoader);
            break;
          case Ot.KHR_TEXTURE_TRANSFORM:
            o[d] = new MF();
            break;
          case Ot.KHR_MESH_QUANTIZATION:
            o[d] = new TF();
            break;
          default:
            p.indexOf(d) >= 0 && l[d] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".');
        }
      }
    h.setExtensions(o), h.setPlugins(l), h.parse(i, n);
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function(n, r) {
      i.parse(e, t, n, r);
    });
  }
}
zt.ObjectConstructors = {
  DirectionalLight: hu,
  PointLight: nc,
  SpotLight: cu,
  MeshStandardMaterial: Go,
  MeshBasicMaterial: $s,
  MeshPhysicalMaterial: Sc,
  LineBasicMaterial: Ri,
  PointsMaterial: Qr,
  PerspectiveCamera: ki,
  OrthographicCamera: _r
};
function cF() {
  let s = {};
  return {
    get: function(e) {
      return s[e];
    },
    add: function(e, t) {
      s[e] = t;
    },
    remove: function(e) {
      delete s[e];
    },
    removeAll: function() {
      s = {};
    }
  };
}
const Ot = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class hF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, i = "light:" + e;
    let n = t.cache.get(i);
    if (n) return n;
    const r = t.json, l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
    let c;
    const h = new se(16777215);
    l.color !== void 0 && h.setRGB(l.color[0], l.color[1], l.color[2], Mt);
    const u = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        c = new zt.ObjectConstructors.DirectionalLight(h), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new zt.ObjectConstructors.PointLight(h), c.distance = u;
        break;
      case "spot":
        c = new zt.ObjectConstructors.SpotLight(h), c.distance = u, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, Fr(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), n = Promise.resolve(c), t.cache.add(i, n), n;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, i = this.parser, r = i.json.nodes[e], o = (r.extensions && r.extensions[this.name] || {}).light;
    return o === void 0 ? null : this._loadLight(o).then(function(l) {
      return i._getNodeRef(t.cache, o, l);
    });
  }
}
let uF = class {
  constructor() {
    this.name = Ot.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return zt.ObjectConstructors.MeshBasicMaterial;
  }
  extendParams(e, t, i) {
    const n = [];
    e.color = new se(1, 1, 1), e.opacity = 1;
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const a = r.baseColorFactor;
        e.color.setRGB(a[0], a[1], a[2], Mt), e.opacity = a[3];
      }
      r.baseColorTexture !== void 0 && n.push(i.assignTexture(e, "map", r.baseColorTexture, dt));
    }
    return Promise.all(n);
  }
}, dF = class {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = n.extensions[this.name].emissiveStrength;
    return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
  }
}, pF = class {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zt.ObjectConstructors.MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], a = n.extensions[this.name];
    if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (r.push(i.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
      const o = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new ie(o, o);
    }
    return Promise.all(r);
  }
}, fF = class {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zt.ObjectConstructors.MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], a = n.extensions[this.name];
    return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && r.push(i.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && r.push(i.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(r);
  }
}, mF = class {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zt.ObjectConstructors.MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [];
    t.sheenColor = new se(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const a = n.extensions[this.name];
    if (a.sheenColorFactor !== void 0) {
      const o = a.sheenColorFactor;
      t.sheenColor.setRGB(o[0], o[1], o[2], Mt);
    }
    return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && r.push(i.assignTexture(t, "sheenColorMap", a.sheenColorTexture, dt)), a.sheenRoughnessTexture !== void 0 && r.push(i.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), n.extras && n.extras.sheenFactor !== void 0 && (t.sheen = n.extras.sheenFactor, delete n.extras.sheenFactor), Promise.all(r);
  }
}, gF = class {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zt.ObjectConstructors.MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], a = n.extensions[this.name];
    return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && r.push(i.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(r);
  }
}, AF = class {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zt.ObjectConstructors.MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], a = n.extensions[this.name];
    t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && r.push(i.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
    const o = a.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new se().setRGB(o[0], o[1], o[2], Mt), Promise.all(r);
  }
}, yF = class {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zt.ObjectConstructors.MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = n.extensions[this.name];
    return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
  }
}, vF = class {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zt.ObjectConstructors.MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], a = n.extensions[this.name];
    t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && r.push(i.assignTexture(t, "specularIntensityMap", a.specularTexture));
    const o = a.specularColorFactor || [1, 1, 1];
    return t.specularColor = new se().setRGB(o[0], o[1], o[2], Mt), a.specularColorTexture !== void 0 && r.push(i.assignTexture(t, "specularColorMap", a.specularColorTexture, dt)), Promise.all(r);
  }
}, _F = class {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Sc;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], a = n.extensions[this.name];
    return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && r.push(i.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(r);
  }
};
class xF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, i = t.json, n = i.textures[e];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const r = n.extensions[this.name], a = t.options.ktx2Loader;
    if (!a) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, r.source, a);
  }
}
class wF {
  constructor(e) {
    this.parser = e, this.name = Ot.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, i = this.parser, n = i.json, r = n.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const a = r.extensions[t], o = n.images[a.source];
    let l = i.textureLoader;
    if (o.uri) {
      const c = i.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return i.loadTextureImage(e, a.source, l);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class EF {
  constructor(e) {
    this.parser = e, this.name = Ot.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, i = this.parser, n = i.json, r = n.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const a = r.extensions[t], o = n.images[a.source];
    let l = i.textureLoader;
    if (o.uri) {
      const c = i.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return i.loadTextureImage(e, a.source, l);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class bF {
  constructor(e) {
    this.name = Ot.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const n = i.extensions[this.name], r = this.parser.getDependency("buffer", n.buffer), a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return r.then(function(o) {
        const l = n.byteOffset || 0, c = n.byteLength || 0, h = n.count, u = n.byteStride, d = new Uint8Array(o, l, c);
        return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(h, u, d, n.mode, n.filter).then(function(p) {
          return p.buffer;
        }) : a.ready.then(function() {
          const p = new ArrayBuffer(h * u);
          return a.decodeGltfBuffer(new Uint8Array(p), h, u, d, n.mode, n.filter), p;
        });
      });
    } else
      return null;
  }
}
let SF = class {
  constructor(e) {
    this.name = Ot.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, i = t.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
      return null;
    const n = t.meshes[i.mesh];
    for (const c of n.primitives)
      if (c.mode !== ws.TRIANGLES && c.mode !== ws.TRIANGLE_STRIP && c.mode !== ws.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const a = i.extensions[this.name].attributes, o = [], l = {};
    for (const c in a)
      o.push(this.parser.getDependency("accessor", a[c]).then((h) => (l[c] = h, l[c])));
    return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then((c) => {
      const h = c.pop(), u = h.isGroup ? h.children : [h], d = c[0].count, p = [];
      for (const f of u) {
        const y = new Ue(), A = new M(), m = new rt(), v = new M(1, 1, 1), g = new zp(f.geometry, f.material, d);
        for (let _ = 0; _ < d; _++)
          l.TRANSLATION && A.fromBufferAttribute(l.TRANSLATION, _), l.ROTATION && m.fromBufferAttribute(l.ROTATION, _), l.SCALE && v.fromBufferAttribute(l.SCALE, _), g.setMatrixAt(_, y.compose(A, m, v));
        g.sourceTrs = l;
        for (const _ in l)
          if (_ === "_COLOR_0") {
            const w = l[_];
            g.instanceColor = new Da(w.array, w.itemSize, w.normalized);
          } else _ !== "TRANSLATION" && _ !== "ROTATION" && _ !== "SCALE" && f.geometry.setAttribute(_, l[_]);
        ut.prototype.copy.call(g, f), this.parser.assignFinalMaterial(g), p.push(g);
      }
      return h.isGroup ? (h.clear(), h.add(...p), h) : p[0];
    }));
  }
};
const Wb = "glTF", oh = 12, ox = { JSON: 1313821514, BIN: 5130562 };
class jb {
  constructor(e) {
    this.name = Ot.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, oh), i = new TextDecoder();
    if (this.header = {
      magic: i.decode(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== Wb)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - oh, r = new DataView(e, oh);
    let a = 0;
    for (; a < n; ) {
      const o = r.getUint32(a, !0);
      a += 4;
      const l = r.getUint32(a, !0);
      if (a += 4, l === ox.JSON) {
        const c = new Uint8Array(e, oh + a, o);
        this.content = i.decode(c);
      } else if (l === ox.BIN) {
        const c = oh + a;
        this.body = e.slice(c, c + o);
      }
      a += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class CF {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Ot.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const i = this.json, n = this.dracoLoader, r = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, l = {}, c = {};
    for (const h in a) {
      const u = Fg[h] || h.toLowerCase();
      o[u] = a[h];
    }
    for (const h in e.attributes) {
      const u = Fg[h] || h.toLowerCase();
      if (a[h] !== void 0) {
        const d = i.accessors[e.attributes[h]], p = Vl[d.componentType];
        c[u] = p.name, l[u] = d.normalized === !0;
      }
    }
    return t.getDependency("bufferView", r).then(function(h) {
      return new Promise(function(u) {
        n.decodeDracoFile(h, function(d) {
          for (const p in d.attributes) {
            const f = d.attributes[p], y = l[p];
            y !== void 0 && (f.normalized = y);
          }
          u(d);
        }, o, c);
      });
    });
  }
}
class MF {
  constructor() {
    this.name = Ot.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e.__hasGLTFUuid || (e = e.clone()), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class TF {
  constructor() {
    this.name = Ot.KHR_MESH_QUANTIZATION;
  }
}
class qb extends lu {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n * 3 + n;
    for (let a = 0; a !== n; a++)
      t[a] = i[r + a];
    return t;
  }
  interpolate_(e, t, i, n) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = o * 2, c = o * 3, h = n - t, u = (i - t) / h, d = u * u, p = d * u, f = e * c, y = f - c, A = -2 * p + 3 * d, m = p - d, v = 1 - A, g = m - d + u;
    for (let _ = 0; _ !== o; _++) {
      const w = a[y + _ + o], S = a[y + _ + l] * h, C = a[f + _ + o], E = a[f + _] * h;
      r[_] = v * w + g * S + A * C + m * E;
    }
    return r;
  }
}
const IF = new rt();
class DF extends qb {
  interpolate_(e, t, i, n) {
    const r = super.interpolate_(e, t, i, n);
    return IF.fromArray(r).normalize().toArray(r), r;
  }
}
const ws = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
}, Vl = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, lx = {
  9728: pi,
  9729: tt,
  9984: Jl,
  9985: nu,
  9986: co,
  9987: Qn
}, cx = {
  33071: Zt,
  33648: Xr,
  10497: xn
}, gm = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Fg = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, pa = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, RF = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: Ao,
  STEP: Zl
}, Am = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function BF(s) {
  return s.DefaultMaterial === void 0 && (s.DefaultMaterial = new zt.ObjectConstructors.MeshStandardMaterial({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: $n
  })), s.DefaultMaterial;
}
function Pr(s, e, t) {
  for (const i in t.extensions)
    s[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = t.extensions[i]);
}
function Fr(s, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(s.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function PF(s, e, t) {
  let i = !1, n = !1, r = !1;
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (u.POSITION !== void 0 && (i = !0), u.NORMAL !== void 0 && (n = !0), u.COLOR_0 !== void 0 && (r = !0), i && n && r) break;
  }
  if (!i && !n && !r) return Promise.resolve(s);
  const a = [], o = [], l = [];
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (i) {
      const d = u.POSITION !== void 0 ? t.getDependency("accessor", u.POSITION) : s.attributes.position;
      a.push(d);
    }
    if (n) {
      const d = u.NORMAL !== void 0 ? t.getDependency("accessor", u.NORMAL) : s.attributes.normal;
      o.push(d);
    }
    if (r) {
      const d = u.COLOR_0 !== void 0 ? t.getDependency("accessor", u.COLOR_0) : s.attributes.color;
      l.push(d);
    }
  }
  return Promise.all([
    Promise.all(a),
    Promise.all(o),
    Promise.all(l)
  ]).then(function(c) {
    const h = c[0], u = c[1], d = c[2];
    return i && (s.morphAttributes.position = h), n && (s.morphAttributes.normal = u), r && (s.morphAttributes.color = d), s.morphTargetsRelative = !0, s;
  });
}
function LF(s, e) {
  if (s.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, i = e.weights.length; t < i; t++)
      s.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (s.morphTargetInfluences.length === t.length) {
      s.morphTargetDictionary = {};
      for (let i = 0, n = t.length; i < n; i++)
        s.morphTargetDictionary[t[i]] = i;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function UF(s) {
  let e;
  const t = s.extensions && s.extensions[Ot.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + ym(t.attributes) : e = s.indices + ":" + ym(s.attributes) + ":" + s.mode, s.targets !== void 0)
    for (let i = 0, n = s.targets.length; i < n; i++)
      e += ":" + ym(s.targets[i]);
  return e;
}
function ym(s) {
  let e = "";
  const t = Object.keys(s).sort();
  for (let i = 0, n = t.length; i < n; i++)
    e += t[i] + ":" + s[t[i]] + ";";
  return e;
}
function Og(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function FF(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const OF = new Ue();
class NF {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new cF(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let i = !1, n = !1, r = -1;
    typeof navigator < "u" && (i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, n = navigator.userAgent.indexOf("Firefox") > -1, r = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || i || n && r < 98 ? this.textureLoader = new xo(this.options.manager) : this.textureLoader = new AR(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ti(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this, n = this.json, r = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
      return a._markDefs && a._markDefs();
    }), Promise.all(this._invokeAll(function(a) {
      return a.beforeRoot && a.beforeRoot();
    })).then(function() {
      return Promise.all([
        i.getDependencies("scene"),
        i.getDependencies("animation"),
        i.getDependencies("camera")
      ]);
    }).then(function(a) {
      const o = {
        scene: a[0][n.scene || 0],
        scenes: a[0],
        animations: a[1],
        cameras: a[2],
        asset: n.asset,
        parser: i,
        userData: {}
      };
      return Pr(r, o, n), Fr(o, n), Promise.all(i._invokeAll(function(l) {
        return l.afterRoot && l.afterRoot(o);
      })).then(function() {
        e(o);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || [];
    for (let n = 0, r = t.length; n < r; n++) {
      const a = t[n].joints;
      for (let o = 0, l = a.length; o < l; o++)
        e[a[o]].isBone = !0;
    }
    for (let n = 0, r = e.length; n < r; n++) {
      const a = e[n];
      a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (i[a.mesh].isSkinnedMesh = !0)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const n = i.clone(), r = (a, o) => {
      const l = this.associations.get(a);
      l != null && this.associations.set(o, l);
      for (const [c, h] of a.children.entries())
        r(h, o.children[c]);
    };
    return r(i, n), n.name += "_instance_" + e.uses[t]++, n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const n = e(t[i]);
      if (n) return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let n = 0; n < t.length; n++) {
      const r = e(t[n]);
      r && i.push(r);
    }
    return i;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const i = e + ":" + t;
    let n = this.cache.get(i);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function(r) {
            return r.loadNode && r.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(r) {
            return r.loadMesh && r.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function(r) {
            return r.loadBufferView && r.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function(r) {
            return r.loadMaterial && r.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function(r) {
            return r.loadTexture && r.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function(r) {
            return r.loadAnimation && r.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (n = this._invokeOne(function(r) {
            return r != this && r.getDependency && r.getDependency(e, t);
          }), !n)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(i, n);
    }
    return n;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(n.map(function(r, a) {
        return i.getDependency(e, a);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], i = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Ot.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(r, a) {
      i.load(hr.resolveURL(t.uri, n.path), r, void 0, function() {
        a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(i) {
      const n = t.byteLength || 0, r = t.byteOffset || 0;
      return i.slice(r, r + n);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, i = this.json, n = this.json.accessors[e];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const a = gm[n.type], o = Vl[n.componentType], l = n.normalized === !0, c = new o(n.count * a);
      return Promise.resolve(new Je(c, a, l));
    }
    const r = [];
    return n.bufferView !== void 0 ? r.push(this.getDependency("bufferView", n.bufferView)) : r.push(null), n.sparse !== void 0 && (r.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(r).then(function(a) {
      const o = a[0], l = gm[n.type], c = Vl[n.componentType], h = c.BYTES_PER_ELEMENT, u = h * l, d = n.byteOffset || 0, p = n.bufferView !== void 0 ? i.bufferViews[n.bufferView].byteStride : void 0, f = n.normalized === !0;
      let y, A;
      if (p && p !== u) {
        const m = Math.floor(d / p), v = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + m + ":" + n.count;
        let g = t.cache.get(v);
        g || (y = new c(o, m * p, n.count * p / h), g = new au(y, p / h), t.cache.add(v, g)), A = new Cn(g, l, d % p / h, f);
      } else
        o === null ? y = new c(n.count * l) : y = new c(o, d, n.count * l), A = new Je(y, l, f);
      if (n.sparse !== void 0) {
        const m = gm.SCALAR, v = Vl[n.sparse.indices.componentType], g = n.sparse.indices.byteOffset || 0, _ = n.sparse.values.byteOffset || 0, w = new v(a[1], g, n.sparse.count * m), S = new c(a[2], _, n.sparse.count * l);
        o !== null && (A = new Je(A.array.slice(), A.itemSize, A.normalized));
        for (let C = 0, E = w.length; C < E; C++) {
          const x = w[C];
          if (A.setX(x, S[C * l]), l >= 2 && A.setY(x, S[C * l + 1]), l >= 3 && A.setZ(x, S[C * l + 2]), l >= 4 && A.setW(x, S[C * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return A;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, i = this.options;
    if (e < 0 || e >= t.textures.length)
      return console.warn("THREE.GLTFLoader: Invalid texture index:", e), null;
    const r = t.textures[e].source;
    if (r < 0 || r >= t.images.length)
      return console.warn("THREE.GLTFLoader: Invalid source index:", r), null;
    const a = t.images[r];
    let o = this.textureLoader;
    if (a.uri) {
      const l = i.manager.getHandler(a.uri);
      l !== null && (o = l);
    }
    return this.loadTextureImage(e, r, o);
  }
  loadTextureImage(e, t, i) {
    const n = this, r = this.json, a = r.textures[e], o = r.images[t], l = (o.uri || o.bufferView) + ":" + a.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const c = this.loadImageSource(t, i).then(function(h) {
      h.name = a.name || o.name || "", h.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (h.name = o.uri);
      const d = (r.samplers || {})[a.sampler] || {};
      return h.magFilter = lx[d.magFilter] || tt, h.minFilter = lx[d.minFilter] || Qn, h.wrapS = cx[d.wrapS] || xn, h.wrapT = cx[d.wrapT] || xn, d.extras && d.extras.uuid !== void 0 && (h.uuid = d.extras.uuid, h.__hasGLTFUuid = !0), n.associations.set(h, { textures: e }), h;
    }).catch(function() {
      return null;
    });
    return this.textureCache[l] = c, c;
  }
  // do not call this from any extension.
  loadImageSource(e, t, i = !1, n = !1) {
    const r = this, a = this.json, o = this.options;
    if (!n && this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((f) => f.clone());
    const l = a.images[e], c = self.URL || self.webkitURL;
    l.uri === void 0 && l.extras && l.extras.uri && (l.uri = l.extras.uri);
    let h = l.uri || "", u = !1, d = null;
    if (l.bufferView !== void 0 && (!i || !h))
      h = r.getDependency("bufferView", l.bufferView).then(function(f) {
        u = !0;
        const y = new Blob([f], { type: l.mimeType });
        return h = c.createObjectURL(y), d = y, h;
      });
    else if (l.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const p = Promise.resolve(h).then(function(f) {
      return new Promise(function(y, A) {
        let m = y;
        t.isImageBitmapLoader === !0 && (m = function(v) {
          const g = new Nt(v);
          g.needsUpdate = !0, y(g);
        }), t.load(hr.resolveURL(f, o.path), m, void 0, function(v) {
          t.isImageBitmapLoader === !0 ? (t = new xo(r.options.manager), m = y, t.setCrossOrigin(r.options.crossOrigin), t.setRequestHeader(r.options.requestHeader), t.load(hr.resolveURL(f, o.path), m, void 0, A)) : A(v);
        });
      });
    }).then(function(f) {
      if (u === !0 && c.revokeObjectURL(h), f.userData.mimeType = l.mimeType || FF(l.uri), f.flipY = !1, l.extras) {
        if (l.extras.flipY !== void 0) {
          if (t.isImageBitmapLoader === !0 && typeof createImageBitmap !== void 0) {
            let y = f;
            const A = l.extras.flipY && !y.flipY;
            createImageBitmap(y.source.data, {
              imageOrientation: A ? "flipY" : "none"
            }).then(function(m) {
              y._newTex && (y = y._newTex), y.source.data.close && y.source.data.close(), y.source.data = m, y.source.needsUpdate = !0, y.needsUpdate = !0;
            });
          }
          f.flipY = l.extras.flipY, f.needsUpdate = !0, delete l.extras.flipY;
        }
        l.extras.uuid !== void 0 && (f.source.uuid = l.extras.uuid), l.extras.t_uuid !== void 0 && (f.uuid = l.extras.t_uuid, f.__hasGLTFUuid = !0);
      }
      return l.uri && typeof l.uri == "string" && u === !1 && !l.uri.startsWith("/") && (f.userData.rootPath = hr.resolveURL(l.uri, o.path)), d && (f.userData.__sourceBlob = d), !i && l.uri && l.uri !== h && r.loadImageSource(e, t, !0, !0).then(function(y) {
        f.source.data && f.source.data.close && f.source.data.close(), f.dispose(), f.source = y.source, f.source.needsUpdate = !0, f.needsUpdate = !0, f.uuid = y.uuid, y.__hasGLTFUuid && (f.__hasGLTFUuid = !0), f.flipY = y.flipY, f.userData = y.userData, f.setDirty && f.setDirty(), y._newTex = f;
      }), f;
    }).catch(function(f) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", h), f;
    });
    return this.sourceCache[e] = p, p;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, i, n) {
    const r = this;
    return this.getDependency("texture", i.index).then(function(a) {
      if (!a) return null;
      if (i.texCoord !== void 0 && i.texCoord > 0 && (a = a.clone(), a.channel = i.texCoord), r.extensions[Ot.KHR_TEXTURE_TRANSFORM]) {
        const o = i.extensions !== void 0 ? i.extensions[Ot.KHR_TEXTURE_TRANSFORM] : void 0;
        if (o) {
          const l = r.associations.get(a);
          a = r.extensions[Ot.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), r.associations.set(a, l);
        }
      }
      return n !== void 0 && (a.colorSpace = n), e[t] = a, a;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const n = t.attributes.tangent === void 0, r = t.attributes.color !== void 0, a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const l = "PointsMaterial:" + i.uuid;
      let c = this.cache.get(l);
      c || (c = new zt.ObjectConstructors.PointsMaterial(), Yi.prototype.copy.call(c, i), c.color.copy(i.color), c.map = i.map, c.sizeAttenuation = !1, this.cache.add(l, c)), i = c;
    } else if (e.isLine) {
      const l = "LineBasicMaterial:" + i.uuid;
      let c = this.cache.get(l);
      c || (c = new zt.ObjectConstructors.LineBasicMaterial(), Yi.prototype.copy.call(c, i), c.color.copy(i.color), c.map = i.map, this.cache.add(l, c)), i = c;
    }
    const o = i.userData && i.userData.gltfExtensions ? !!i.userData.gltfExtensions.WEBGI_material_extras : !1;
    if ((n || r || a) && !o) {
      let l = "ClonedMaterial:" + i.uuid + ":";
      n && (l += "derivative-tangents:"), r && (l += "vertex-colors:"), a && (l += "flat-shading:");
      let c = this.cache.get(l);
      c || (c = i.clone(), r && (c.vertexColors = !0), a && (c.flatShading = !0), n && (c.normalScale && (c.normalScale.y *= -1), c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)), this.cache.add(l, c), this.associations.set(c, this.associations.get(i))), i = c;
    }
    e.material = i;
  }
  getMaterialType() {
    return zt.ObjectConstructors.MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, i = this.json, n = this.extensions, r = i.materials[e];
    let a;
    const o = {}, l = r.extensions || {}, c = [];
    if (l[Ot.KHR_MATERIALS_UNLIT]) {
      const u = n[Ot.KHR_MATERIALS_UNLIT];
      a = u.getMaterialType(), c.push(u.extendParams(o, r, t));
    } else {
      const u = r.pbrMetallicRoughness || {};
      if (o.color = new se(1, 1, 1), o.opacity = 1, Array.isArray(u.baseColorFactor)) {
        const d = u.baseColorFactor;
        o.color.setRGB(d[0], d[1], d[2], Mt), o.opacity = d[3];
      }
      u.baseColorTexture !== void 0 && c.push(t.assignTexture(o, "map", u.baseColorTexture, dt)), o.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1, o.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1, u.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(o, "metalnessMap", u.metallicRoughnessTexture)), c.push(t.assignTexture(o, "roughnessMap", u.metallicRoughnessTexture))), a = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(e);
      }), c.push(Promise.all(this._invokeAll(function(d) {
        return d.extendMaterialParams && d.extendMaterialParams(e, o);
      })));
    }
    r.doubleSided === !0 && (o.side = zi);
    const h = r.alphaMode || Am.OPAQUE;
    if (h === Am.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, h === Am.MASK && (o.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)), r.normalTexture !== void 0 && a !== zt.ObjectConstructors.MeshBasicMaterial && (c.push(t.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new ie(1, 1), r.normalTexture.scale !== void 0)) {
      const u = r.normalTexture.scale;
      o.normalScale.set(u, u);
    }
    if (r.occlusionTexture !== void 0 && a !== zt.ObjectConstructors.MeshBasicMaterial && (c.push(t.assignTexture(o, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && a !== zt.ObjectConstructors.MeshBasicMaterial) {
      const u = r.emissiveFactor;
      o.emissive = new se().setRGB(u[0], u[1], u[2], Mt);
    }
    return r.emissiveTexture !== void 0 && a !== zt.ObjectConstructors.MeshBasicMaterial && c.push(t.assignTexture(o, "emissiveMap", r.emissiveTexture, dt)), Promise.all(c).then(function() {
      const u = new a(o);
      return r.extras && r.extras.uuid && (u.uuid = r.extras.uuid), r.name && (u.name = r.name), Fr(u, r), t.associations.set(u, { materials: e }), r.extensions && Pr(n, u, r), u;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = _t.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, i = this.extensions, n = this.primitiveCache;
    function r(o) {
      return i[Ot.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(l) {
        return hx(l, o, t);
      });
    }
    const a = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o], h = UF(c), u = n[h];
      if (u)
        a.push(u.promise);
      else {
        let d;
        c.extensions && c.extensions[Ot.KHR_DRACO_MESH_COMPRESSION] ? d = r(c) : d = hx(new Ze(), c, t), n[h] = { primitive: c, promise: d }, a.push(d);
      }
    }
    return Promise.all(a);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, i = this.json, n = this.extensions, r = i.meshes[e], a = r.primitives, o = [];
    for (let l = 0, c = a.length; l < c; l++) {
      const h = a[l].material === void 0 ? BF(this.cache) : this.getDependency("material", a[l].material);
      o.push(h);
    }
    return o.push(t.loadGeometries(a)), Promise.all(o).then(function(l) {
      const c = l.slice(0, l.length - 1), h = l[l.length - 1], u = [];
      for (let p = 0, f = h.length; p < f; p++) {
        const y = h[p], A = a[p];
        let m;
        const v = c[p];
        if (A.mode === ws.TRIANGLES || A.mode === ws.TRIANGLE_STRIP || A.mode === ws.TRIANGLE_FAN || A.mode === void 0)
          m = r.isSkinnedMesh === !0 ? new gA(y, v) : new Se(y, v), m.isSkinnedMesh === !0 && m.normalizeSkinWeights(), A.mode === ws.TRIANGLE_STRIP ? m.geometry = t_(m.geometry, lw) : A.mode === ws.TRIANGLE_FAN && (m.geometry = t_(m.geometry, Xm));
        else if (A.mode === ws.LINES)
          m = new Is(y, v);
        else if (A.mode === ws.LINE_STRIP)
          m = new an(y, v);
        else if (A.mode === ws.LINE_LOOP)
          m = new Cw(y, v);
        else if (A.mode === ws.POINTS)
          m = new zl(y, v);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + A.mode);
        Object.keys(m.geometry.morphAttributes).length > 0 && LF(m, r), m.name = t.createUniqueName(r.name || "mesh_" + e), m.geometry && r.extras && r.extras.isGeometryUserData ? (Fr(m.geometry, r), A.extensions && Pr(n, m.geometry, A)) : (Fr(m, r), A.extensions && Pr(n, m, A)), t.assignFinalMaterial(m), u.push(m);
      }
      r.extensions && u.forEach((p) => Pr(n, p, r));
      for (let p = 0, f = u.length; p < f; p++)
        t.associations.set(u[p], {
          meshes: e,
          primitives: p
        });
      if (u.length === 1)
        return r.extensions && Pr(n, u[0], r), u[0];
      const d = new Kn();
      r.extensions && Pr(n, d, r), t.associations.set(d, { meshes: e });
      for (let p = 0, f = u.length; p < f; p++)
        d.add(u[p]);
      return d;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e], n = i[i.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return i.type === "perspective" ? t = new zt.ObjectConstructors.PerspectiveCamera(ri.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : i.type === "orthographic" && (t = new zt.ObjectConstructors.OrthographicCamera(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), i.name && (t.name = this.createUniqueName(i.name)), Fr(t, i), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], i = [];
    for (let n = 0, r = t.joints.length; n < r; n++)
      i.push(this._loadNodeShallow(t.joints[n]));
    return t.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", t.inverseBindMatrices)) : i.push(null), Promise.all(i).then(function(n) {
      const r = n.pop(), a = n, o = [], l = [];
      for (let c = 0, h = a.length; c < h; c++) {
        const u = a[c];
        if (u) {
          o.push(u);
          const d = new Ue();
          r !== null && d.fromArray(r.array, c * 16), l.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new ou(o, l);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, i = this, n = t.animations[e], r = n.name ? n.name : "animation_" + e, a = [], o = [], l = [], c = [], h = [];
    for (let u = 0, d = n.channels.length; u < d; u++) {
      const p = n.channels[u], f = n.samplers[p.sampler], y = p.target, A = y.node, m = n.parameters !== void 0 ? n.parameters[f.input] : f.input, v = n.parameters !== void 0 ? n.parameters[f.output] : f.output;
      y.node !== void 0 && (a.push(this.getDependency("node", A)), o.push(this.getDependency("accessor", m)), l.push(this.getDependency("accessor", v)), c.push(f), h.push(y));
    }
    return Promise.all([
      Promise.all(a),
      Promise.all(o),
      Promise.all(l),
      Promise.all(c),
      Promise.all(h)
    ]).then(function(u) {
      const d = u[0], p = u[1], f = u[2], y = u[3], A = u[4], m = [];
      for (let v = 0, g = d.length; v < g; v++) {
        const _ = d[v], w = p[v], S = f[v], C = y[v], E = A[v];
        if (_ === void 0) continue;
        _.updateMatrix && _.updateMatrix();
        const x = i._createAnimationTracks(_, w, S, C, E);
        if (x)
          for (let b = 0; b < x.length; b++)
            m.push(x[b]);
      }
      return new ic(r, void 0, m);
    });
  }
  createNodeMesh(e) {
    const t = this.json, i = this, n = t.nodes[e];
    return n.mesh === void 0 ? null : i.getDependency("mesh", n.mesh).then(function(r) {
      const a = i._getNodeRef(i.meshCache, n.mesh, r);
      return n.weights !== void 0 && a.traverse(function(o) {
        if (o.isMesh)
          for (let l = 0, c = n.weights.length; l < c; l++)
            o.morphTargetInfluences[l] = n.weights[l];
      }), a;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, i = this, n = t.nodes[e], r = i._loadNodeShallow(e), a = [], o = n.children || [];
    for (let c = 0, h = o.length; c < h; c++)
      a.push(i.getDependency("node", o[c]));
    const l = n.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", n.skin);
    return Promise.all([
      r,
      Promise.all(a),
      l
    ]).then(function(c) {
      const h = c[0], u = c[1], d = c[2];
      d !== null && h.traverse(function(p) {
        p.isSkinnedMesh && p.bind(d, OF);
      });
      for (let p = 0, f = u.length; p < f; p++)
        h.add(u[p]);
      return h;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, i = this.extensions, n = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const r = t.nodes[e], a = r.name ? n.createUniqueName(r.name) : "", o = [], l = n._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return l && o.push(l), r.camera !== void 0 && o.push(n.getDependency("camera", r.camera).then(function(c) {
      return n._getNodeRef(n.cameraCache, r.camera, c);
    })), n._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      o.push(c);
    }), this.nodeCache[e] = Promise.all(o).then(function(c) {
      let h;
      if (r.isBone === !0 ? h = new Uh() : c.length > 1 ? h = new Kn() : c.length === 1 ? h = c[0] : h = new ut(), h !== c[0])
        for (let u = 0, d = c.length; u < d; u++)
          h.add(c[u]);
      if (r.name && (h.userData.name = r.name, h.name = a), Fr(h, r), r.extensions && Pr(i, h, r), r.matrix !== void 0) {
        const u = new Ue();
        u.fromArray(r.matrix), h.applyMatrix4(u);
      } else
        r.translation !== void 0 && h.position.fromArray(r.translation), r.rotation !== void 0 && h.quaternion.fromArray(r.rotation), r.scale !== void 0 && h.scale.fromArray(r.scale);
      return n.associations.has(h) || n.associations.set(h, {}), n.associations.get(h).nodes = e, h;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, i = this.json.scenes[e], n = this, r = new Kn();
    i.name && (r.name = n.createUniqueName(i.name)), Fr(r, i), i.extensions && Pr(t, r, i);
    const a = i.nodes || [], o = [];
    for (let l = 0, c = a.length; l < c; l++)
      o.push(n.getDependency("node", a[l]));
    return Promise.all(o).then(function(l) {
      for (let h = 0, u = l.length; h < u; h++)
        r.add(l[h]);
      const c = (h) => {
        const u = /* @__PURE__ */ new Map();
        for (const [d, p] of n.associations)
          (d instanceof Yi || d instanceof Nt) && u.set(d, p);
        return h.traverse((d) => {
          const p = n.associations.get(d);
          p != null && u.set(d, p);
        }), u;
      };
      return n.associations = c(r), r;
    });
  }
  _createAnimationTracks(e, t, i, n, r) {
    const a = [], o = e.name ? e.name : e.uuid, l = [];
    pa[r.path] === pa.weights ? e.traverse(function(d) {
      d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);
    }) : l.push(o);
    let c;
    switch (pa[r.path]) {
      case pa.weights:
        c = vo;
        break;
      case pa.rotation:
        c = Ra;
        break;
      case pa.position:
      case pa.scale:
        c = _o;
        break;
      default:
        switch (i.itemSize) {
          case 1:
            c = vo;
            break;
          case 2:
          case 3:
          default:
            c = _o;
            break;
        }
        break;
    }
    const h = n.interpolation !== void 0 ? RF[n.interpolation] : Ao, u = this._getArrayFromAccessor(i);
    for (let d = 0, p = l.length; d < p; d++) {
      const f = new c(
        l[d] + "." + pa[r.path],
        t.array,
        u,
        h
      );
      n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(f), a.push(f);
    }
    return a;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const i = Og(t.constructor), n = new Float32Array(t.length);
      for (let r = 0, a = t.length; r < a; r++)
        n[r] = t[r] * i;
      t = n;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(i) {
      const n = this instanceof Ra ? DF : qb;
      return new n(this.times, this.values, this.getValueSize() / 3, i);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function kF(s, e, t) {
  const i = e.attributes, n = new is();
  if (i.POSITION !== void 0) {
    const o = t.json.accessors[i.POSITION], l = o.min, c = o.max;
    if (l !== void 0 && c !== void 0) {
      if (n.set(
        new M(l[0], l[1], l[2]),
        new M(c[0], c[1], c[2])
      ), o.normalized) {
        const h = Og(Vl[o.componentType]);
        n.min.multiplyScalar(h), n.max.multiplyScalar(h);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const r = e.targets;
  if (r !== void 0) {
    const o = new M(), l = new M();
    for (let c = 0, h = r.length; c < h; c++) {
      const u = r[c];
      if (u.POSITION !== void 0) {
        const d = t.json.accessors[u.POSITION], p = d.min, f = d.max;
        if (p !== void 0 && f !== void 0) {
          if (l.setX(Math.max(Math.abs(p[0]), Math.abs(f[0]))), l.setY(Math.max(Math.abs(p[1]), Math.abs(f[1]))), l.setZ(Math.max(Math.abs(p[2]), Math.abs(f[2]))), d.normalized) {
            const y = Og(Vl[d.componentType]);
            l.multiplyScalar(y);
          }
          o.max(l);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(o);
  }
  s.boundingBox = n;
  const a = new ns();
  n.getCenter(a.center), a.radius = n.min.distanceTo(n.max) / 2, s.boundingSphere = a;
}
function hx(s, e, t) {
  const i = e.attributes, n = [];
  function r(a, o) {
    return t.getDependency("accessor", a).then(function(l) {
      s.setAttribute(o, l);
    });
  }
  for (const a in i) {
    const o = Fg[a] || a.toLowerCase();
    o in s.attributes || n.push(r(i[a], o));
  }
  if (e.indices !== void 0 && !s.index) {
    const a = t.getDependency("accessor", e.indices).then(function(o) {
      s.setIndex(o);
    });
    n.push(a);
  }
  return Rt.workingColorSpace !== Mt && "COLOR_0" in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Rt.workingColorSpace}" not supported.`), Fr(s, e), kF(s, e, t), Promise.all(n).then(function() {
    return e.targets !== void 0 ? PF(s, e.targets, t) : s;
  });
}
const Ws = class Ws {
};
Ws.WebGiLightExtrasExtension = "WEBGI_light_extras", Ws.Import = (e) => ({
  name: "__" + Ws.WebGiLightExtrasExtension,
  // __ is prefix so that the extension is added to userdata, and we can process later in afterRoot
  afterRoot: async (t) => {
    (t.scenes || (t.scene ? [t.scene] : [])).forEach((n) => {
      n.traverse((r) => {
        var o, l;
        if (!r.isLight) return;
        const a = (l = (o = r.userData) == null ? void 0 : o.gltfExtensions) == null ? void 0 : l[Ws.WebGiLightExtrasExtension];
        a && (!r.shadow && a.shadow && console.error("Light has no shadow, cannot import", r, a), a.shadow && r.shadow && (a.shadow.bias !== void 0 && (r.shadow.bias = a.shadow.bias), a.shadow.normalBias !== void 0 && (r.shadow.normalBias = a.shadow.normalBias), a.shadow.radius !== void 0 && (r.shadow.radius = a.shadow.radius), a.shadow.mapSize !== void 0 && r.shadow.mapSize.fromArray(a.shadow.mapSize), a.shadow.camera !== void 0 && (r.shadow.camera = new OA().parseObject(a.shadow.camera, {}, {}, {}, {}))), delete r.userData.gltfExtensions[Ws.WebGiLightExtrasExtension]);
      });
    });
  }
}), Ws.Export = (e) => ({
  writeNode: (t, i) => {
    if (!(t != null && t.isLight)) return;
    i.extensions || (i.extensions = {});
    const n = {};
    t.shadow && (n.shadow = t.shadow.toJSON()), Object.keys(n).length > 0 && (i.extensions[Ws.WebGiLightExtrasExtension] = n, e.extensionsUsed[Ws.WebGiLightExtrasExtension] = !0);
  }
}), Ws.Textures = void 0;
let wp = Ws;
const Fn = class Fn {
};
Fn.WebGiMaterialExtrasExtension = "WEBGI_material_extras", Fn.Import = (e) => (t) => ({
  name: "__" + Fn.WebGiMaterialExtrasExtension,
  // __ is prefix so that the extension is added to userdata, and we can process later in afterRoot
  afterRoot: async (i) => {
    var r, a;
    const n = i.scenes || (i.scene ? [i.scene] : []);
    for (const o of n) {
      const l = (a = (r = o.userData) == null ? void 0 : r.gltfExtensions) == null ? void 0 : a[Fn.WebGiMaterialExtrasExtension], c = l != null && l.resources ? await e(l.resources) : {};
      o.traverse((h) => {
        var f, y, A, m, v, g;
        const u = h == null ? void 0 : h.material;
        if (!(u != null && u.isMaterial)) return;
        const d = (y = (f = u.userData) == null ? void 0 : f.gltfExtensions) == null ? void 0 : y[Fn.WebGiMaterialExtrasExtension];
        if (!d) return;
        d.emissiveIntensity !== void 0 && (u.emissiveIntensity = d.emissiveIntensity), d.fog !== void 0 && (u.fog = d.fog), d.flatShading !== void 0 && (u.flatShading = d.flatShading), d.blending !== void 0 && (u.blending = d.blending), d.side !== void 0 && (u.side = d.side), d.shadowSide !== void 0 && (u.shadowSide = d.shadowSide), d.depthFunc !== void 0 && (u.depthFunc = d.depthFunc), d.depthTest !== void 0 && (u.depthTest = d.depthTest), d.depthWrite !== void 0 && (u.depthWrite = d.depthWrite), d.colorWrite !== void 0 && (u.colorWrite = d.colorWrite), d.vertexColors !== void 0 && (u.vertexColors = d.vertexColors), d.alphaTest !== void 0 && (u.alphaTest = d.alphaTest), d.alphaHash !== void 0 && (u.alphaHash = d.alphaHash), d.envMapIntensity !== void 0 && (u.envMapIntensity = d.envMapIntensity), d.blendSrc !== void 0 && (u.blendSrc = d.blendSrc), d.blendDst !== void 0 && (u.blendDst = d.blendDst), d.blendEquation !== void 0 && (u.blendEquation = d.blendEquation), d.blendSrcAlpha !== void 0 && (u.blendSrcAlpha = d.blendSrcAlpha), d.blendDstAlpha !== void 0 && (u.blendDstAlpha = d.blendDstAlpha), d.blendEquationAlpha !== void 0 && (u.blendEquationAlpha = d.blendEquationAlpha), d.blendColor !== void 0 && u.blendColor !== void 0 && u.blendColor.setHex(d.blendColor), d.blendAlpha !== void 0 && (u.blendAlpha = d.blendAlpha), d.wireframe !== void 0 && (u.wireframe = d.wireframe), d.wireframeLinewidth !== void 0 && (u.wireframeLinewidth = d.wireframeLinewidth), d.wireframeLinecap !== void 0 && (u.wireframeLinecap = d.wireframeLinecap), d.wireframeLinejoin !== void 0 && (u.wireframeLinejoin = d.wireframeLinejoin), d.rotation !== void 0 && (u.rotation = d.rotation), d.polygonOffset !== void 0 && (u.polygonOffset = d.polygonOffset), d.polygonOffsetFactor !== void 0 && (u.polygonOffsetFactor = d.polygonOffsetFactor), d.polygonOffsetUnits !== void 0 && (u.polygonOffsetUnits = d.polygonOffsetUnits), d.dithering !== void 0 && (u.dithering = d.dithering), d.alphaToCoverage !== void 0 && (u.alphaToCoverage = d.alphaToCoverage), d.premultipliedAlpha !== void 0 && (u.premultipliedAlpha = d.premultipliedAlpha), d.toneMapped !== void 0 && (u.toneMapped = d.toneMapped), d.normalScale !== void 0 && u.normalScale !== void 0 && (Array.isArray(d.normalScale) ? u.normalScale.fromArray(d.normalScale) : typeof d.normalScale == "number" ? u.normalScale.set(d.normalScale, d.normalScale) : console.warn("normalScale is not an array or number", d.normalScale)), d.reflectivity !== void 0 && (u.reflectivity = d.reflectivity), Object.entries(d).forEach(([_, w]) => {
          _.startsWith("_") || w && w.resource && typeof w.resource == "string" && (u[_] = mt.Deserialize(w, u[_], c));
        }), delete u.userData.gltfExtensions[Fn.WebGiMaterialExtrasExtension];
        const p = (m = (A = t.json) == null ? void 0 : A.asset) != null && m.version ? parseFloat((g = (v = t.json) == null ? void 0 : v.asset) == null ? void 0 : g.version) : null;
        (u.userData.legacyBumpScale || p && p <= 2) && (u == null ? void 0 : u.bumpScale) !== void 0 && (u != null && u.bumpMap) && u.defines && (console.warn("MaterialManager: Old format material loaded, bump map might be incorrect.", u, u.bumpScale), u.defines.BUMP_MAP_SCALE_LEGACY = "1", u.userData.legacyBumpScale = !0, u.needsUpdate = !0);
      }), l && delete o.userData.gltfExtensions[Fn.WebGiMaterialExtrasExtension];
    }
  }
}), Fn.Export = (e) => ({
  writeMaterial(t, i) {
    if (!(t != null && t.isMaterial)) return;
    i.extensions || (i.extensions = {});
    const n = {};
    t.fog !== void 0 && (n.fog = t.fog), t.flatShading !== void 0 && (n.flatShading = t.flatShading), t.blending !== void 0 && (n.blending = t.blending), t.side !== void 0 && t.side !== zi && (n.side = t.side), t.shadowSide !== void 0 && (n.shadowSide = t.shadowSide), t.depthFunc !== void 0 && (n.depthFunc = t.depthFunc), t.depthTest !== void 0 && (n.depthTest = t.depthTest), t.depthWrite !== void 0 && (n.depthWrite = t.depthWrite), t.colorWrite !== void 0 && (n.colorWrite = t.colorWrite), t.vertexColors !== void 0 && (n.vertexColors = t.vertexColors), t.alphaTest !== void 0 && (n.alphaTest = t.alphaTest), t.alphaHash !== void 0 && (n.alphaHash = t.alphaHash), t.envMapIntensity !== void 0 && (n.envMapIntensity = t.envMapIntensity), t.blendSrc !== void 0 && (n.blendSrc = t.blendSrc), t.blendDst !== void 0 && (n.blendDst = t.blendDst), t.blendEquation !== void 0 && (n.blendEquation = t.blendEquation), t.blendSrcAlpha !== void 0 && (n.blendSrcAlpha = t.blendSrcAlpha), t.blendDstAlpha !== void 0 && (n.blendDstAlpha = t.blendDstAlpha), t.blendEquationAlpha !== void 0 && (n.blendEquationAlpha = t.blendEquationAlpha), t.blendColor !== void 0 && (n.blendColor = t.blendColor.getHex()), t.blendAlpha !== void 0 && (n.blendAlpha = t.blendAlpha), t.wireframe !== void 0 && (n.wireframe = t.wireframe), t.wireframeLinewidth !== void 0 && (n.wireframeLinewidth = t.wireframeLinewidth), t.wireframeLinecap !== void 0 && (n.wireframeLinecap = t.wireframeLinecap), t.wireframeLinejoin !== void 0 && (n.wireframeLinejoin = t.wireframeLinejoin), t.rotation !== void 0 && (n.rotation = t.rotation), t.polygonOffset !== void 0 && (n.polygonOffset = t.polygonOffset), t.polygonOffsetFactor !== void 0 && (n.polygonOffsetFactor = t.polygonOffsetFactor), t.polygonOffsetUnits !== void 0 && (n.polygonOffsetUnits = t.polygonOffsetUnits), t.dithering !== void 0 && (n.dithering = t.dithering), t.alphaToCoverage !== void 0 && (n.alphaToCoverage = t.alphaToCoverage), t.premultipliedAlpha !== void 0 && (n.premultipliedAlpha = t.premultipliedAlpha), t.toneMapped !== void 0 && (n.toneMapped = t.toneMapped), t.normalScale !== void 0 && (n.normalScale = [t.normalScale.x, t.normalScale.y]);
    const r = this.materialExternalResources[t.uuid];
    r && Object.entries(r).forEach(([a, o]) => {
      var c;
      if (a.startsWith("_")) return;
      let l = !1;
      o != null && o.userData && o.userData.embedUrlImagePreviews === void 0 && (o.userData.embedUrlImagePreviews = (c = e.options.exporterOptions) == null ? void 0 : c.embedUrlImagePreviews, l = !0), n[a] = mt.Serialize(o, this.serializedMeta), o != null && o.userData && l && delete o.userData.embedUrlImagePreviews;
    }), Object.keys(n).length > 0 && (i.extensions[Fn.WebGiMaterialExtrasExtension] = n, e.extensionsUsed[Fn.WebGiMaterialExtrasExtension] = !0);
  },
  materialExternalResources: {},
  serializedMeta: {
    images: {},
    textures: {}
  },
  beforeParse(t) {
    if (this.materialExternalResources = {}, !e.options.externalImagesInExtras) return;
    const i = [];
    (Array.isArray(t) ? t : [t]).forEach((n) => {
      n == null || n.traverse((r) => {
        var a;
        r && ((a = r.material) != null && a.isMaterial) && i.push(r.material);
      });
    }), i.forEach((n) => {
      n && (this.materialExternalResources[n.uuid] || (this.materialExternalResources[n.uuid] = {}), this.materialExternalResources[n.uuid].__materialRef = n, Object.entries(n).forEach(([r, a]) => {
        r.startsWith("_") || a && a.isTexture && a.userData.rootPath && (a.userData.rootPath.startsWith("http") || a.userData.rootPath.startsWith("data:")) && (n[r] = null, this.materialExternalResources[n.uuid][r] = a);
      }));
    });
  },
  afterParse(t) {
    const i = Object.values(this.materialExternalResources);
    if (i.length < 1) return;
    i.forEach((r) => {
      const a = r.__materialRef;
      a && (Object.entries(r).forEach(([o, l]) => {
        o.startsWith("_") || l && (a[o] = l);
      }), delete this.materialExternalResources[a.uuid]);
    });
    const n = e.json.scenes[e.json.scene || 0];
    n.extensions || (n.extensions = {}), n.extensions[Fn.WebGiMaterialExtrasExtension] = {
      resources: this.serializedMeta
    }, e.extensionsUsed[Fn.WebGiMaterialExtrasExtension] = !0;
  }
}), Fn.Textures = void 0;
let Ep = Fn;
const Pl = class Pl {
};
Pl.WebGiMaterialsAlphaMapExtension = "WEBGI_materials_alphamap", Pl.Import = (e) => new GF(e), Pl.Export = (e) => new zF(e), Pl.Textures = {
  alphaTexture: "G"
};
let lc = Pl;
class GF {
  constructor(e) {
    this.parser = e, this.name = lc.WebGiMaterialsAlphaMapExtension;
  }
  // getMaterialType(materialIndex: number) { // todo: required?
  //
  //     const parser = this.parser
  //     const materialDef = parser.json.materials[ materialIndex ]
  //
  //     if (!materialDef.extensions || !materialDef.extensions[ this.name ]) return null
  //
  //     return MeshPhysicalMaterial
  //
  // }
  async extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], a = n.extensions[this.name];
    return a.alphaTexture !== void 0 && r.push(i.assignTexture(t, "alphaMap", a.alphaTexture)), Promise.all(r);
  }
}
class zF {
  constructor(e) {
    this.writer = e, this.name = lc.WebGiMaterialsAlphaMapExtension;
  }
  writeMaterial(e, t) {
    if (!e.isMeshStandardMaterial || !e.alphaMap) return;
    const i = this.writer, n = i.extensionsUsed, r = {};
    if (e.alphaMap && i.checkEmptyMap(e.alphaMap)) {
      const a = { index: i.processTexture(e.alphaMap) };
      i.applyTextureTransform(a, e.alphaMap), r.alphaTexture = a;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
  }
}
const Ll = class Ll {
};
Ll.WebGiMaterialsBumpMapExtension = "WEBGI_materials_bumpmap", Ll.Import = (e) => new QF(e), Ll.Export = (e) => new HF(e), Ll.Textures = {
  bumpTexture: "R"
};
let cc = Ll;
class QF {
  constructor(e) {
    this.parser = e, this.name = cc.WebGiMaterialsBumpMapExtension;
  }
  // getMaterialType(materialIndex: number) { // todo: required?
  //
  //     const parser = this.parser
  //     const materialDef = parser.json.materials[ materialIndex ]
  //
  //     if (!materialDef.extensions || !materialDef.extensions[ this.name ]) return null
  //
  //     return MeshPhysicalMaterial
  //
  // }
  async extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], a = n.extensions[this.name];
    return a.bumpScale !== void 0 && (t.bumpScale = a.bumpScale), a.bumpTexture !== void 0 && r.push(i.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(r);
  }
}
class HF {
  constructor(e) {
    this.writer = e, this.name = cc.WebGiMaterialsBumpMapExtension;
  }
  writeMaterial(e, t) {
    if (!e.isMeshStandardMaterial || e.bumpScale === 0) return;
    const i = this.writer, n = i.extensionsUsed, r = {};
    if (r.bumpScale = e.bumpScale, e.bumpMap && i.checkEmptyMap(e.bumpMap)) {
      const a = { index: i.processTexture(e.bumpMap) };
      i.applyTextureTransform(a, e.bumpMap), r.bumpTexture = a;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
  }
}
const Ul = class Ul {
};
Ul.WebGiMaterialsDisplacementMapExtension = "WEBGI_materials_displacementmap", Ul.Import = (e) => new VF(e), Ul.Export = (e) => new WF(e), Ul.Textures = {
  displacementTexture: "R"
};
let hc = Ul;
class VF {
  constructor(e) {
    this.parser = e, this.name = hc.WebGiMaterialsDisplacementMapExtension;
  }
  async extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], a = n.extensions[this.name];
    return a.displacementScale !== void 0 && (t.displacementScale = a.displacementScale), a.displacementBias !== void 0 && (t.displacementBias = a.displacementBias), a.displacementTexture !== void 0 && r.push(i.assignTexture(t, "displacementMap", a.displacementTexture)), Promise.all(r);
  }
}
class WF {
  constructor(e) {
    this.writer = e, this.name = hc.WebGiMaterialsDisplacementMapExtension;
  }
  writeMaterial(e, t) {
    if (!e.isMeshStandardMaterial || e.displacementScale === 0) return;
    const i = this.writer, n = i.extensionsUsed, r = {};
    if (r.displacementScale = e.displacementScale, r.displacementBias = e.displacementBias, e.displacementMap && i.checkEmptyMap(e.displacementMap)) {
      const a = { index: i.processTexture(e.displacementMap) };
      i.applyTextureTransform(a, e.displacementMap), r.displacementTexture = a;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
  }
}
const Fl = class Fl {
};
Fl.WebGiMaterialsLightMapExtension = "WEBGI_materials_lightmap", Fl.Import = (e) => new jF(e), Fl.Export = (e) => new qF(e), Fl.Textures = {
  lightMapTexture: "RGB"
};
let uc = Fl;
class jF {
  constructor(e) {
    this.parser = e, this.name = uc.WebGiMaterialsLightMapExtension;
  }
  // getMaterialType(materialIndex: number) { // todo: required?
  //
  //     const parser = this.parser
  //     const materialDef = parser.json.materials[ materialIndex ]
  //
  //     if (!materialDef.extensions || !materialDef.extensions[ this.name ]) return null
  //
  //     return MeshPhysicalMaterial
  //
  // }
  async extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], a = n.extensions[this.name];
    return a.lightMapIntensity !== void 0 && (t.lightMapIntensity = a.lightMapIntensity), a.lightMapTexture !== void 0 && r.push(i.assignTexture(t, "lightMap", a.lightMapTexture)), Promise.all(r);
  }
}
class qF {
  constructor(e) {
    this.writer = e, this.name = uc.WebGiMaterialsLightMapExtension;
  }
  writeMaterial(e, t) {
    if (!e.isMeshStandardMaterial || e.lightMapIntensity === 0) return;
    const i = this.writer, n = i.extensionsUsed, r = {};
    if (r.lightMapIntensity = e.lightMapIntensity, e.lightMap && i.checkEmptyMap(e.lightMap)) {
      const a = { index: i.processTexture(e.lightMap) };
      i.applyTextureTransform(a, e.lightMap), r.lightMapTexture = a;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
  }
}
const js = class js {
};
js.WebGiObject3DExtrasExtension = "WEBGI_object3d_extras", js.Import = (e) => ({
  name: "__" + js.WebGiObject3DExtrasExtension,
  // __ is prefix so that the extension is added to userdata, and we can process later in afterRoot
  afterRoot: async (t) => {
    (t.scenes || (t.scene ? [t.scene] : [])).forEach((n) => {
      n.traverse((r) => {
        var l, c;
        if (!r || !r.isObject3D) return;
        const a = (c = (l = r.userData) == null ? void 0 : l.gltfExtensions) == null ? void 0 : c[js.WebGiObject3DExtrasExtension];
        if (!a) {
          r.isLight && !r.isAmbientLight && (r.castShadow = !0);
          return;
        }
        const o = a.castShadow !== void 0 || a.receiveShadow !== void 0;
        a.castShadow !== void 0 && (r.castShadow = a.castShadow), a.receiveShadow !== void 0 && (r.receiveShadow = a.receiveShadow), a.visible !== void 0 && (r.visible = a.visible), a.frustumCulled !== void 0 && (r.frustumCulled = a.frustumCulled), a.renderOrder !== void 0 && (r.renderOrder = a.renderOrder), a.layers !== void 0 && (r.layers.mask = a.layers), o && (r.userData.__keepShadowDef = !0), delete r.userData.gltfExtensions[js.WebGiObject3DExtrasExtension];
      });
    });
  }
}), js.Export = (e) => ({
  writeNode: (t, i) => {
    if (!(t != null && t.isObject3D)) return;
    i.extensions || (i.extensions = {});
    const n = {};
    t.castShadow !== void 0 && (n.castShadow = t.castShadow), t.receiveShadow !== void 0 && (n.receiveShadow = t.receiveShadow), t.visible === !1 && (n.visible = !1), t.frustumCulled === !1 && (n.frustumCulled = !1), t.renderOrder !== 0 && (n.renderOrder = t.renderOrder), t.layers.mask !== 1 && (n.layers = t.layers.mask), t.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1), Object.keys(n).length > 0 && (i.extensions[js.WebGiObject3DExtrasExtension] = n, e.extensionsUsed[js.WebGiObject3DExtrasExtension] = !0);
  }
}), js.Textures = void 0;
let bp = js;
class XF extends ti {
  constructor(e) {
    super(e), this.type = Qt;
  }
  async loadAsync(e, t) {
    const i = await this.parseAsync(e, t, !1), n = new Wr(i.data, i.width, i.height, ei, this.type);
    return n.needsUpdate = !0, n.flipY = !0, n.colorSpace = dt, n.minFilter = tt, n.magFilter = tt, n.source.data.complete = !0, n;
  }
  async parseAsync(e, t, i = !1) {
    let n = !1;
    if (!e.startsWith("data:") && !e.startsWith("blob:")) {
      this.responseType = "blob";
      const l = await super.loadAsync(e, t);
      e = URL.createObjectURL(l), n = !0;
    }
    const r = await lB(e);
    n && URL.revokeObjectURL(e);
    let a = Uint8Array;
    return this.type === Qt ? a = Uint16Array : this.type === Xt && (a = Float32Array), { data: YF(r.data, 4, a, i), width: r.width, height: r.height };
  }
  setDataType(e) {
    return this.type = e, this;
  }
}
function YF(s, e = 3, t = Uint16Array, i = !1) {
  let n;
  const r = s.byteLength >> 2, a = new t(r * e);
  for (let o = 0; o < r; o++)
    n = Math.pow(2, s[o * 4 + 3] - 136), i ? (a[o * e] = Math.min(s[o * 4] * n, 65504), a[o * e + 1] = Math.min(s[o * 4 + 1] * n, 65504), a[o * e + 2] = Math.min(s[o * 4 + 2] * n, 65504)) : (a[o * e] = Gn.toHalfFloat(Math.min(s[o * 4] * n, 65504)), a[o * e + 1] = Gn.toHalfFloat(Math.min(s[o * 4 + 1] * n, 65504)), a[o * e + 2] = Gn.toHalfFloat(Math.min(s[o * 4 + 2] * n, 65504))), e === 4 && (a[o * e + 3] = Gn.toHalfFloat(1));
  return a;
}
const Iy = class Iy {
  // region Import
  /**
   * Import viewer config from glTF(exported from {@link GLTFViewerConfigExtension.ExportViewerConfig}) and sets in scene.importedViewerConfig
   * Must be called from afterRoot in gltf loader. Used in {@link GLTFLoader2.setup}
   * Only imports, does not apply.
   * @param parser
   * @param viewer
   * @param resultScenes
   * @param scene
   */
  static async ImportViewerConfig(e, t, i, n) {
    var l;
    if (!n) {
      const c = e.json.scenes || [];
      if (c.length !== 1) {
        for (const h of c) {
          const u = c.indexOf(h);
          await this.ImportViewerConfig(e, t, u >= 0 ? [i[u]] : i, h);
        }
        return {};
      }
      n = c[0];
    }
    const r = i.length > 0 ? i[0] : void 0, a = (l = n.extensions) == null ? void 0 : l[this.ViewerConfigGLTFExtension];
    if (!a) return {};
    const o = {
      type: "ThreeViewer",
      version: "0",
      plugins: [],
      assetType: "config",
      ...a
    };
    if (o.resources) {
      await this._parseArrayBuffers(o.resources, e);
      const c = await this._parseExtraResources(o.resources, e, t);
      o.resources = await t.loadConfigResources(o.resources || {}, c);
    }
    return r && (r.importedViewerConfig = o), o;
  }
  /**
   * Find resources in parser from uuid
   * @param currentResources
   * @param parser
   * @param viewer
   * @private
   */
  static async _parseExtraResources(e, t, i) {
    const n = {
      textures: {},
      materials: {}
    };
    if (e.textures && t.json.textures)
      for (const [r, a] of [...Object.entries(e.textures)]) {
        if (a.uuid || !r) continue;
        delete e.textures[r];
        const o = t.json.textures.findIndex(
          (l) => {
            var c, h, u, d, p, f, y;
            return ((c = l.extras) == null ? void 0 : c.uuid) === r || ((d = (u = (h = t.json.samplers) == null ? void 0 : h[l.sampler]) == null ? void 0 : u.extras) == null ? void 0 : d.uuid) === r || ((y = (f = (p = t.json.images) == null ? void 0 : p[l.source]) == null ? void 0 : f.extras) == null ? void 0 : y.t_uuid) === r;
          }
        );
        o >= 0 && (n.textures[r] = await t.getDependency("texture", o));
      }
    if (e.materials && t.json.materials)
      for (const [r, a] of [...Object.entries(e.materials)]) {
        if (a.uuid || !r) continue;
        delete e.materials[r];
        const o = t.json.materials.findIndex((l) => {
          var c;
          return ((c = l.extras) == null ? void 0 : c.uuid) === r;
        });
        if (o >= 0) {
          const l = await t.getDependency("material", o);
          n.materials[r] = i.assetManager.materials.convertToIMaterial(l);
        }
      }
    return n;
  }
  static async _parseArrayBuffers(e, t) {
    const i = [];
    Object.values(e).forEach((n) => {
      Object.values(n).forEach((r) => {
        r.url && (r.url.type === "Uint16Array" && r.url.data && i.push(r.url), r.url.type === "Uint8Array" && r.url.data && i.push(r.url));
      });
    });
    for (const n of i) {
      const r = n.data.image, a = t.json.images[r], o = await t.getDependency("bufferView", a.bufferView);
      if (a.mimeType.startsWith("image/") && n.type === "Uint16Array" && n.encoding === "rgbe") {
        const l = new Blob([o]);
        let c = URL.createObjectURL(l);
        const h = n.encodingVersion || 1;
        h < 2 && (c = "data:image/png;base64," + btoa(await l.text())), n.data = (await new XF().parseAsync(c, void 0, h < 3)).data, URL.revokeObjectURL(c), delete n.encoding, delete n.encodingVersion;
      } else
        n.data = o;
    }
  }
  // endregion
  // region Export
  /**
   * Export viewer config to glTF(can be imported by {@link GLTFViewerConfigExtension.ImportViewerConfig}).
   * Used in {@link GLTFExporter2}
   * @param viewer
   * @param writer
   * @constructor
   */
  static ExportViewerConfig(e, t) {
    const i = e.toJSON(!0, void 0), n = t.json;
    this._bundleExtraResources(n, i), this._bundleArrayBuffers(i, t);
    const r = t.json.scenes[t.json.scene || 0];
    r.extensions || (r.extensions = {}), t.extensionsUsed[this.ViewerConfigGLTFExtension] = !0, r.extensions[this.ViewerConfigGLTFExtension] = i;
  }
  static _bundleArrayBuffers(e, t) {
    const i = [];
    Object.values(e.resources).forEach((n) => {
      n && Object.values(n).forEach((r) => {
        r.url && (r.url.type === "Uint16Array" && r.url.data && (r.url.data instanceof Uint16Array || (r.url.data = new Uint16Array(r.url.data)), i.push(r.url)), r.url.type === "Uint8Array" && r.url.data && (r.url.data instanceof Uint8Array || (r.url.data = new Uint8Array(r.url.data)), i.push(r.url)));
      });
    });
    for (const n of i) {
      let r = "application/octet-stream";
      if (n.mimeType && (r = n.mimeType), t.options.exporterOptions.encodeUint16Rgbe && n.type === "Uint16Array" && n.width > 0 && n.height > 0) {
        const u = GB(n.data, 4), d = new ImageData(u, n.width, n.height), p = aA.getDataURL(d, !0).split(",")[1];
        r = "image/png", n.data = Uint8Array.from(atob(p), (f) => f.charCodeAt(0)), n.encoding = "rgbe", n.encodingVersion = 3;
      }
      t.json.images || (t.json.images = []);
      const o = {
        mimeType: r
      }, l = t.json.images.push(o) - 1, c = n.data;
      o.bufferView = t.processBufferViewImageBuffer(c), n.data = { image: l };
    }
  }
  /**
   * Find the resources that are in the viewer config AND in writer.json and use the ones in writer and remove from viewer Config.
   * For now (for the lack of a better way) we can let the resources be exported twice and removed from resources. Overhead will be just for some images.
   * @param json
   * @param viewerData
   * @private
   */
  static _bundleExtraResources(e, t) {
    e.textures && e.samplers && e.images && t.resources.textures && [...Object.entries(t.resources.textures)].forEach(([i, n]) => {
      e.textures.find(
        (a) => {
          var o, l, c, h, u;
          return (
            // find same texture in gltf writer
            ((o = a.extras) == null ? void 0 : o.uuid) === i || ((c = (l = e.samplers[a.sampler]) == null ? void 0 : l.extras) == null ? void 0 : c.uuid) === i || ((u = (h = e.images[a.source]) == null ? void 0 : h.extras) == null ? void 0 : u.t_uuid) === i
          );
        }
        // todo: remove t_uuid when sampler extras supported by gltf-transform: https://github.com/donmccurdy/glTF-Transform/issues/645
      ) && (n.image && t.resources.images && t.resources.images[n.image] && delete t.resources.images[n.image], t.resources.textures[i] = {});
    }), e.materials && t.resources.materials && [...Object.entries(t.resources.materials)].forEach(([i, n]) => {
      e.materials.find((a) => {
        var o;
        return ((o = a.extras) == null ? void 0 : o.uuid) === i;
      }) && (t.resources.materials[i] = {});
    });
  }
  // endregion
};
Iy.ViewerConfigGLTFExtension = "WEBGI_viewer";
let Sp = Iy;
const KF = async (s, e) => {
  if (!s || !(s instanceof ArrayBuffer) || !s.byteLength || !e.encrypt) return s;
  if (!e.encryptKey && window && window.prompt && (e.encryptKey = window.prompt("GLTFEncryption: Enter encryption key/password") || ""), !e.encryptKey)
    return console.warn("GLTF Export: encryption key not provided, skipping encryption"), s;
  const t = await sB(new Uint8Array(s), e.encryptKey);
  return NB(t, {
    asset: {
      version: "2.0",
      generator: "ThreePipeGLBWrapper",
      encryption: {
        type: "aesgcm",
        version: 1
      }
    }
  });
}, JF = {
  key: (s, e, t) => s.key || window && window.prompt && window.prompt("GLTFEncryption: Please enter the password/key for the model: " + t) || "",
  async process(s, e) {
    var h;
    if (typeof s == "string") return s;
    const t = 100;
    if (!new TextDecoder().decode(new Uint8Array(s, 0, t)).includes("GLBWrapper")) return s;
    const n = new jb(s), r = JSON.parse(n.content || "{}");
    let a = n.body || s;
    const o = (h = r.asset) == null ? void 0 : h.encryption;
    if (!o) return a;
    const l = o.type, c = o.version;
    if (l === "aesgcm" && c === 1) {
      const u = await gi(this.key, o, r, e) || "";
      try {
        a = (await rB(new Uint8Array(a), u)).buffer;
      } catch {
        throw new ErrorEvent("decryption error");
      }
    }
    return a;
  }
}, $F = ["hdr", "exr", "webp", "avif", "ktx", "hdrpng", "svg", "cube", "ico", "bmp", "gif", "tiff"], ro = class ro extends zt {
  constructor(e) {
    super(e), this.isGLTFLoader2 = !0, this.preparsers = [], this.gltfViewerParser = (t) => (i) => {
      var u, d, p, f, y, A;
      i.importOptions = this.importOptions || void 0;
      const n = i.getDependency;
      i.getDependency = async (m, v) => {
        const g = await n.call(i, m, v);
        if (g && g.userData) {
          const _ = g.userData.gltfExtensions;
          delete g.userData.gltfExtensions, g.userData = mt.Deserialize(g.userData, {}), g.userData.gltfExtensions = _;
        }
        return g;
      };
      const r = Ss() + ".drc", a = Ss() + ".ktx2", o = (p = (d = (u = i.json) == null ? void 0 : u.extensionsRequired) == null ? void 0 : d.includes) == null ? void 0 : p.call(d, "KHR_draco_mesh_compression");
      if (o) {
        const m = t.assetManager.importer.registerFile(r);
        m && this.setDRACOLoader(m);
      }
      ((A = (y = (f = i.json) == null ? void 0 : f.extensionsUsed) == null ? void 0 : y.includes) == null ? void 0 : A.call(y, "EXT_meshopt_compression")) && (window.MeshoptDecoder ? (this.setMeshoptDecoder(window.MeshoptDecoder), i.options.meshoptDecoder = window.MeshoptDecoder) : console.error("Add GLTFMeshOptDecodePlugin(and initialize it) to viewer to enable EXT_meshopt_compression decode"));
      const c = t.assetManager.importer.registerFile(a);
      c && (this.setKTX2Loader(c), i.options.ktx2Loader = c);
      const h = $F.map((m) => Ss() + "." + m);
      return h.forEach((m) => t.assetManager.importer.registerFile(m)), { name: "GLTF2_HELPER_PLUGIN", afterRoot: async (m) => {
        o && t.assetManager.importer.unregisterFile(r), c && t.assetManager.importer.unregisterFile(a), h.forEach((v) => t.assetManager.importer.unregisterFile(v)), await Sp.ImportViewerConfig(i, t, m.scenes || [m.scene]);
      } };
    }, this.preparsers.push(JF), zt.ObjectConstructors.DirectionalLight = Bi, zt.ObjectConstructors.PointLight = yi, zt.ObjectConstructors.SpotLight = oi, zt.ObjectConstructors.MeshStandardMaterial = Ds, zt.ObjectConstructors.MeshBasicMaterial = Pa, zt.ObjectConstructors.MeshPhysicalMaterial = Ds, zt.ObjectConstructors.LineBasicMaterial = pr, zt.ObjectConstructors.PerspectiveCamera = BL, zt.ObjectConstructors.OrthographicCamera = _r;
  }
  async preparse(e, t) {
    for (const i of this.preparsers)
      e = await i.process(e, t);
    return e;
  }
  parse(e, t, i, n, r) {
    this.preparse.call(this, e, r || t).then((a) => {
      var c;
      const o = Nt.DEFAULT_IMAGE;
      Nt.DEFAULT_IMAGE || (Nt.DEFAULT_IMAGE = qh.WHITE_IMAGE_DATA);
      const l = ((c = this.importOptions) == null ? void 0 : c.useMeshLines) ?? ro.UseMeshLines;
      return zt.ObjectConstructors.LineBasicMaterial = l ? Xs : pr, a ? super.parse(a, t, (h) => {
        Nt.DEFAULT_IMAGE = o, zt.ObjectConstructors.LineBasicMaterial = l ? Xs : pr, i && i(h);
      }, n) : n && n(new ErrorEvent("no data"));
    }).catch((a) => {
      console.error(a), n && n(a ?? new ErrorEvent("unknown error"));
    });
  }
  /**
   * This is run post parse to extract the result scene from the GLTF object
   * @param res
   * @param _
   */
  transform(e, t) {
    var r;
    const i = e ? e.scene || !!e.scenes && e.scenes.length > 0 && e.scenes[0] : void 0;
    if (!i) return;
    if (e.animations.length > 0 && (i.animations = e.animations), ((r = this.importOptions) == null ? void 0 : r.useMeshLines) ?? ro.UseMeshLines) {
      const a = [];
      i.traverse((o) => {
        o.userData.gltfUUID && (wo(o, "uuid", o.userData.gltfUUID, !0, !0), delete o.userData.gltfUUID), o.isLine && a.push(o);
      });
      for (const o of a)
        ZF(o);
    }
    return i.userData || (i.userData = {}), e.userData && (i.userData.gltfExtras = e.userData), e.cameras && e.cameras.forEach((a) => !a.parent && i.add(a)), e.asset && (i.userData.gltfAsset = e.asset), i;
  }
  register(e) {
    return super.register(e);
  }
  setup(e, t) {
    this.register(Ep.Import(e.loadConfigResources));
    for (const i of t) this.register(i);
    for (const i of ro.ImportExtensions) this.register(i);
    return this.register(this.gltfViewerParser(e)), this;
  }
};
ro.ImportExtensions = [
  bp.Import,
  wp.Import,
  cc.Import,
  hc.Import,
  uc.Import,
  lc.Import
], ro.UseMeshLines = !1;
let Ng = ro;
function ZF(s) {
  const e = s.parent;
  if (!e) {
    console.warn("GLTFLoader2: Line has no parent", s);
    return;
  }
  s.geometry.index && (s.geometry = s.geometry.toNonIndexed());
  const t = s.isLineSegments ? new NL(new GL(), s.material) : new OL(new kL(), s.material);
  let i = s.geometry.attributes.position.array;
  if (s.isLineLoop) {
    const c = new Float32Array(i.length + 3);
    c.set(i), c.set(i.subarray(0, 3), i.length), i = c;
  }
  t.geometry.setPositions(i), t.computeLineDistances();
  const n = e.children.indexOf(s);
  e.add(t);
  const { geometry: r, material: a } = t, o = s.userData;
  s.userData = {}, t.copy(s, !1), t.geometry = r, t.material = a, [...s.children].map((c) => {
    t.add(c);
  }), t.userData = { ...t.userData, ...o }, a.userData.renderToGBuffer = !1, a.userData.renderToDepth = !1, s.removeFromParent();
  const l = e.children.indexOf(t);
  l >= 0 && l !== n && (e.children.splice(l, 1), e.children.splice(n, 0, t));
}
const vm = /* @__PURE__ */ new WeakMap();
class eO extends ui {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, i, n) {
    const r = new ti(this.manager);
    r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, (a) => {
      this.parse(a, t, n);
    }, i, n);
  }
  parse(e, t, i) {
    this.decodeDracoFile(e, t, null, null, dt).catch(i);
  }
  decodeDracoFile(e, t, i, n, r = Mt) {
    const a = {
      attributeIDs: i || this.defaultAttributeIDs,
      attributeTypes: n || this.defaultAttributeTypes,
      useUniqueIDs: !!i,
      vertexColorSpace: r
    };
    return this.decodeGeometry(e, a).then(t);
  }
  decodeGeometry(e, t) {
    const i = JSON.stringify(t);
    if (vm.has(e)) {
      const l = vm.get(e);
      if (l.key === i)
        return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let n;
    const r = this.workerNextTaskID++, a = e.byteLength, o = this._getWorker(r, a).then((l) => (n = l, new Promise((c, h) => {
      n._callbacks[r] = { resolve: c, reject: h }, n.postMessage({ type: "decode", id: r, taskConfig: t, buffer: e }, [e]);
    }))).then((l) => this._createGeometry(l.geometry));
    return o.catch(() => !0).then(() => {
      n && r && this._releaseTask(n, r);
    }), vm.set(e, {
      key: i,
      promise: o
    }), o;
  }
  _createGeometry(e) {
    const t = new Ze();
    e.index && t.setIndex(new Je(e.index.array, 1));
    for (let i = 0; i < e.attributes.length; i++) {
      const n = e.attributes[i], r = n.name, a = n.array, o = n.itemSize, l = new Je(a, o);
      r === "color" && (this._assignVertexColorSpace(l, n.vertexColorSpace), l.normalized = !(a instanceof Float32Array)), t.setAttribute(r, l);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== dt) return;
    const i = new se();
    for (let n = 0, r = e.count; n < r; n++)
      i.fromBufferAttribute(e, n).convertSRGBToLinear(), e.setXYZ(n, i.r, i.g, i.b);
  }
  _loadLibrary(e, t) {
    const i = new ti(this.manager);
    return i.setPath(this.decoderPath), i.setResponseType(t), i.setWithCredentials(this.withCredentials), new Promise((n, r) => {
      i.load(e, n, void 0, r);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((i) => {
      const n = i[0];
      e || (this.decoderConfig.wasmBinary = i[1]);
      const r = tO, a = [
        "/* draco decoder */",
        n,
        "",
        "/* worker */",
        r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([a]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const n = new Worker(this.workerSourceURL);
        n._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({ type: "init", decoderConfig: this.decoderConfig }), n.onmessage = function(r) {
          const a = r.data;
          switch (a.type) {
            case "decode":
              n._callbacks[a.id].resolve(a);
              break;
            case "error":
              n._callbacks[a.id].reject(a);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + a.type + '"');
          }
        }, this.workerPool.push(n);
      } else
        this.workerPool.sort(function(n, r) {
          return n._taskLoad > r._taskLoad ? -1 : 1;
        });
      const i = this.workerPool[this.workerPool.length - 1];
      return i._taskCosts[e] = t, i._taskLoad += t, i;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
const tO = `
function DRACOWorker() {

	let decoderConfig;
	let decoderPending;

	onmessage = function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':
				decoderConfig = message.decoderConfig;
				decoderPending = new Promise( function ( resolve/*, reject*/ ) {

					decoderConfig.onModuleLoaded = function ( draco ) {

						// Module is Promise-like. Wrap before resolving to avoid loop.
						resolve( { draco: draco } );

					};

					DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef

				} );
				break;

			case 'decode':
				const buffer = message.buffer;
				const taskConfig = message.taskConfig;
				decoderPending.then( ( module ) => {

					const draco = module.draco;
					const decoder = new draco.Decoder();

					try {

						const geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );

						const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );

						if ( geometry.index ) buffers.push( geometry.index.array.buffer );

						self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					} finally {

						draco.destroy( decoder );

					}

				} );
				break;

		}

	};

	function decodeGeometry( draco, decoder, array, taskConfig ) {

		const attributeIDs = taskConfig.attributeIDs;
		const attributeTypes = taskConfig.attributeTypes;

		let dracoGeometry;
		let decodingStatus;

		const geometryType = decoder.GetEncodedGeometryType( array );

		if ( geometryType === draco.TRIANGULAR_MESH ) {

			dracoGeometry = new draco.Mesh();
			decodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );

		} else if ( geometryType === draco.POINT_CLOUD ) {

			dracoGeometry = new draco.PointCloud();
			decodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );

		} else {

			throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );

		}

		if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {

			throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );

		}

		const geometry = { index: null, attributes: [] };

		// Gather all vertex attributes.
		for ( const attributeName in attributeIDs ) {

			const attributeType = self[ attributeTypes[ attributeName ] ];

			let attribute;
			let attributeID;

			// A Draco file may be created with default vertex attributes, whose attribute IDs
			// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
			// a Draco file may contain a custom set of attributes, identified by known unique
			// IDs. glTF files always do the latter, and .drc files typically do the former.
			if ( taskConfig.useUniqueIDs ) {

				attributeID = attributeIDs[ attributeName ];
				attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );

			} else {

				attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );

				if ( attributeID === - 1 ) continue;

				attribute = decoder.GetAttribute( dracoGeometry, attributeID );

			}

			const attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );

			if ( attributeName === 'color' ) {

				attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;

			}

			geometry.attributes.push( attributeResult );

		}

		// Add index.
		if ( geometryType === draco.TRIANGULAR_MESH ) {

			geometry.index = decodeIndex( draco, decoder, dracoGeometry );

		}

		draco.destroy( dracoGeometry );

		return geometry;

	}

	function decodeIndex( draco, decoder, dracoGeometry ) {

		const numFaces = dracoGeometry.num_faces();
		const numIndices = numFaces * 3;
		const byteLength = numIndices * 4;

		const ptr = draco._malloc( byteLength );
		decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );
		const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();
		draco._free( ptr );

		return { array: index, itemSize: 1 };

	}

	function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {

		const numComponents = attribute.num_components();
		const numPoints = dracoGeometry.num_points();
		const numValues = numPoints * numComponents;
		const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
		const dataType = getDracoDataType( draco, attributeType );

		const ptr = draco._malloc( byteLength );
		decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );
		const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();
		draco._free( ptr );

		return {
			name: attributeName,
			array: array,
			itemSize: numComponents
		};

	}

	function getDracoDataType( draco, attributeType ) {

		switch ( attributeType ) {

			case Float32Array: return draco.DT_FLOAT32;
			case Int8Array: return draco.DT_INT8;
			case Int16Array: return draco.DT_INT16;
			case Int32Array: return draco.DT_INT32;
			case Uint8Array: return draco.DT_UINT8;
			case Uint16Array: return draco.DT_UINT16;
			case Uint32Array: return draco.DT_UINT32;

		}

	}

}
`, ma = class ma extends eO {
  // https://github.com/google/draco
  // public static DRACO_LIBRARY_PATH = 'https://www.gstatic.com/draco/versioned/decoders/1.4.1/'
  // public static DRACO_LIBRARY_PATH = 'https://threejs.org/examples/jsm/libs/draco/'
  constructor(e) {
    super(e), this.encoderPending = null, this.encoderConfig = { type: "js" }, this.isDRACOLoader2 = !0, this.setDecoderPath(ma.DRACO_LIBRARY_PATH), this.setDecoderConfig({ type: "js" });
  }
  transform(e, t) {
    var i;
    return (i = e.attributes) != null && i.normal || e.computeVertexNormals(), e ? new Se(e, new Ds({ color: new se(1, 1, 1) })) : void 0;
  }
  preload(e = !0, t = !1) {
    return e && super.preload(), t && this.initEncoder(), this;
  }
  async initEncoder() {
    if (this.encoderPending) return this.encoderPending;
    const e = typeof WebAssembly != "object" || this.encoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_encoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_encoder.wasm", "arraybuffer"))), this.encoderPending = Promise.all(t).then((i) => {
      var a;
      const n = i[0];
      return e || (this.encoderConfig.wasmBinary = i[1]), (a = (0, eval)(n + `
DracoEncoderModule;`)) == null ? void 0 : a();
    }), this.encoderPending;
  }
  async initDecoder() {
    var i;
    await this._initDecoder();
    const e = await fetch(this.workerSourceURL).then(async (n) => n.text()).then((n) => {
      const r = n.indexOf("/* worker */");
      if (r < 1) throw new Error("unable to load decoder module");
      return n.substring(0, r - 1);
    });
    return (i = (0, eval)(e + `
DracoDecoderModule;`)) == null ? void 0 : i();
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  async _loadLibrary(e, t) {
    return ma.LibraryValueMap[e] ? ma.LibraryValueMap[e] : ma.LibraryValueMap[e] = await super._loadLibrary(e, t);
  }
  /**
   * Set the decoder js string
   * Sample for how to set LibraryValueMap
   * This is useful for bundling the draco decoder js file with your app source
   * @example
   * First put the draco_decoder.js file in your src folder, then import it in js/ts as a string
   * ```js
   * import draco_decoder from './libs/draco_decoder.1.5.6.js?raw' // vite will load this as a string
   * // console.log(draco_decoder) // this should be a string with js content
   * DRACOLoader2.SetDecoderJsString(draco_decoder)
   * ```
   * @param jsString - the contents of draco_decoder.js file
   */
  static SetDecoderJsString(e) {
    this.LibraryValueMap["draco_decoder.js"] = e;
  }
};
ma.DRACO_LIBRARY_PATH = "https://cdn.jsdelivr.net/gh/google/draco@1.5.6/javascript/", ma.LibraryValueMap = {};
let kg = ma;
class Xb extends Qw {
  constructor(e) {
    super(e), this.type = Qt;
  }
  parse(e) {
    const x = Math.pow(2.7182818, 2.2);
    function b(I, P) {
      let k = 0;
      for (let L = 0; L < 65536; ++L)
        (L == 0 || I[L >> 3] & 1 << (L & 7)) && (P[k++] = L);
      const T = k - 1;
      for (; k < 65536; ) P[k++] = 0;
      return T;
    }
    function D(I) {
      for (let P = 0; P < 16384; P++)
        I[P] = {}, I[P].len = 0, I[P].lit = 0, I[P].p = null;
    }
    const O = { l: 0, c: 0, lc: 0 };
    function Y(I, P, k, T, L) {
      for (; k < I; )
        P = P << 8 | at(T, L), k += 8;
      k -= I, O.l = P >> k & (1 << I) - 1, O.c = P, O.lc = k;
    }
    const B = new Array(59);
    function Q(I) {
      for (let k = 0; k <= 58; ++k) B[k] = 0;
      for (let k = 0; k < 65537; ++k) B[I[k]] += 1;
      let P = 0;
      for (let k = 58; k > 0; --k) {
        const T = P + B[k] >> 1;
        B[k] = P, P = T;
      }
      for (let k = 0; k < 65537; ++k) {
        const T = I[k];
        T > 0 && (I[k] = T | B[T]++ << 6);
      }
    }
    function j(I, P, k, T, L, U) {
      const N = P;
      let H = 0, $ = 0;
      for (; T <= L; T++) {
        if (N.value - P.value > k) return !1;
        Y(6, H, $, I, N);
        const ne = O.l;
        if (H = O.c, $ = O.lc, U[T] = ne, ne == 63) {
          if (N.value - P.value > k)
            throw new Error("Something wrong with hufUnpackEncTable");
          Y(8, H, $, I, N);
          let re = O.l + 6;
          if (H = O.c, $ = O.lc, T + re > L + 1)
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; re--; ) U[T++] = 0;
          T--;
        } else if (ne >= 59) {
          let re = ne - 59 + 2;
          if (T + re > L + 1)
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; re--; ) U[T++] = 0;
          T--;
        }
      }
      Q(U);
    }
    function X(I) {
      return I & 63;
    }
    function Z(I) {
      return I >> 6;
    }
    function ee(I, P, k, T) {
      for (; P <= k; P++) {
        const L = Z(I[P]), U = X(I[P]);
        if (L >> U)
          throw new Error("Invalid table entry");
        if (U > 14) {
          const N = T[L >> U - 14];
          if (N.len)
            throw new Error("Invalid table entry");
          if (N.lit++, N.p) {
            const H = N.p;
            N.p = new Array(N.lit);
            for (let $ = 0; $ < N.lit - 1; ++$)
              N.p[$] = H[$];
          } else
            N.p = new Array(1);
          N.p[N.lit - 1] = P;
        } else if (U) {
          let N = 0;
          for (let H = 1 << 14 - U; H > 0; H--) {
            const $ = T[(L << 14 - U) + N];
            if ($.len || $.p)
              throw new Error("Invalid table entry");
            $.len = U, $.lit = P, N++;
          }
        }
      }
      return !0;
    }
    const J = { c: 0, lc: 0 };
    function W(I, P, k, T) {
      I = I << 8 | at(k, T), P += 8, J.c = I, J.lc = P;
    }
    const K = { c: 0, lc: 0 };
    function ce(I, P, k, T, L, U, N, H, $) {
      if (I == P) {
        T < 8 && (W(k, T, L, U), k = J.c, T = J.lc), T -= 8;
        let ne = k >> T;
        if (ne = new Uint8Array([ne])[0], H.value + ne > $)
          return !1;
        const re = N[H.value - 1];
        for (; ne-- > 0; )
          N[H.value++] = re;
      } else if (H.value < $)
        N[H.value++] = I;
      else
        return !1;
      K.c = k, K.lc = T;
    }
    function fe(I) {
      return I & 65535;
    }
    function ve(I) {
      const P = fe(I);
      return P > 32767 ? P - 65536 : P;
    }
    const _e = { a: 0, b: 0 };
    function ze(I, P) {
      const k = ve(I), L = ve(P), U = k + (L & 1) + (L >> 1), N = U, H = U - L;
      _e.a = N, _e.b = H;
    }
    function Qe(I, P) {
      const k = fe(I), T = fe(P), L = k - (T >> 1) & 65535, U = T + L - 32768 & 65535;
      _e.a = U, _e.b = L;
    }
    function ot(I, P, k, T, L, U, N) {
      const H = N < 16384, $ = k > L ? L : k;
      let ne = 1, re, he;
      for (; ne <= $; ) ne <<= 1;
      for (ne >>= 1, re = ne, ne >>= 1; ne >= 1; ) {
        he = 0;
        const pe = he + U * (L - re), be = U * ne, Ie = U * re, Pe = T * ne, Ve = T * re;
        let $e, qt, gt, lt;
        for (; he <= pe; he += Ie) {
          let si = he;
          const et = he + T * (k - re);
          for (; si <= et; si += Ve) {
            const ci = si + Pe, Rn = si + be, vi = Rn + Pe;
            H ? (ze(I[si + P], I[Rn + P]), $e = _e.a, gt = _e.b, ze(I[ci + P], I[vi + P]), qt = _e.a, lt = _e.b, ze($e, qt), I[si + P] = _e.a, I[ci + P] = _e.b, ze(gt, lt), I[Rn + P] = _e.a, I[vi + P] = _e.b) : (Qe(I[si + P], I[Rn + P]), $e = _e.a, gt = _e.b, Qe(I[ci + P], I[vi + P]), qt = _e.a, lt = _e.b, Qe($e, qt), I[si + P] = _e.a, I[ci + P] = _e.b, Qe(gt, lt), I[Rn + P] = _e.a, I[vi + P] = _e.b);
          }
          if (k & ne) {
            const ci = si + be;
            H ? ze(I[si + P], I[ci + P]) : Qe(I[si + P], I[ci + P]), $e = _e.a, I[ci + P] = _e.b, I[si + P] = $e;
          }
        }
        if (L & ne) {
          let si = he;
          const et = he + T * (k - re);
          for (; si <= et; si += Ve) {
            const ci = si + Pe;
            H ? ze(I[si + P], I[ci + P]) : Qe(I[si + P], I[ci + P]), $e = _e.a, I[ci + P] = _e.b, I[si + P] = $e;
          }
        }
        re = ne, ne >>= 1;
      }
      return he;
    }
    function ht(I, P, k, T, L, U, N, H, $) {
      let ne = 0, re = 0;
      const he = N, pe = Math.trunc(T.value + (L + 7) / 8);
      for (; T.value < pe; )
        for (W(ne, re, k, T), ne = J.c, re = J.lc; re >= 14; ) {
          const Ie = ne >> re - 14 & 16383, Pe = P[Ie];
          if (Pe.len)
            re -= Pe.len, ce(Pe.lit, U, ne, re, k, T, H, $, he), ne = K.c, re = K.lc;
          else {
            if (!Pe.p)
              throw new Error("hufDecode issues");
            let Ve;
            for (Ve = 0; Ve < Pe.lit; Ve++) {
              const $e = X(I[Pe.p[Ve]]);
              for (; re < $e && T.value < pe; )
                W(ne, re, k, T), ne = J.c, re = J.lc;
              if (re >= $e && Z(I[Pe.p[Ve]]) == (ne >> re - $e & (1 << $e) - 1)) {
                re -= $e, ce(Pe.p[Ve], U, ne, re, k, T, H, $, he), ne = K.c, re = K.lc;
                break;
              }
            }
            if (Ve == Pe.lit)
              throw new Error("hufDecode issues");
          }
        }
      const be = 8 - L & 7;
      for (ne >>= be, re -= be; re > 0; ) {
        const Ie = P[ne << 14 - re & 16383];
        if (Ie.len)
          re -= Ie.len, ce(Ie.lit, U, ne, re, k, T, H, $, he), ne = K.c, re = K.lc;
        else
          throw new Error("hufDecode issues");
      }
      return !0;
    }
    function Xe(I, P, k, T, L, U) {
      const N = { value: 0 }, H = k.value, $ = le(P, k), ne = le(P, k);
      k.value += 4;
      const re = le(P, k);
      if (k.value += 4, $ < 0 || $ >= 65537 || ne < 0 || ne >= 65537)
        throw new Error("Something wrong with HUF_ENCSIZE");
      const he = new Array(65537), pe = new Array(16384);
      D(pe);
      const be = T - (k.value - H);
      if (j(I, k, be, $, ne, he), re > 8 * (T - (k.value - H)))
        throw new Error("Something wrong with hufUncompress");
      ee(he, $, ne, pe), ht(he, pe, I, k, re, ne, U, L, N);
    }
    function G(I, P, k) {
      for (let T = 0; T < k; ++T)
        P[T] = I[P[T]];
    }
    function Be(I) {
      for (let P = 1; P < I.length; P++) {
        const k = I[P - 1] + I[P] - 128;
        I[P] = k;
      }
    }
    function oe(I, P) {
      let k = 0, T = Math.floor((I.length + 1) / 2), L = 0;
      const U = I.length - 1;
      for (; !(L > U || (P[L++] = I[k++], L > U)); )
        P[L++] = I[T++];
    }
    function Ee(I) {
      let P = I.byteLength;
      const k = new Array();
      let T = 0;
      const L = new DataView(I);
      for (; P > 0; ) {
        const U = L.getInt8(T++);
        if (U < 0) {
          const N = -U;
          P -= N + 1;
          for (let H = 0; H < N; H++)
            k.push(L.getUint8(T++));
        } else {
          const N = U;
          P -= 2;
          const H = L.getUint8(T++);
          for (let $ = 0; $ < N + 1; $++)
            k.push(H);
        }
      }
      return k;
    }
    function de(I, P, k, T, L, U) {
      let N = new DataView(U.buffer);
      const H = k[I.idx[0]].width, $ = k[I.idx[0]].height, ne = 3, re = Math.floor(H / 8), he = Math.ceil(H / 8), pe = Math.ceil($ / 8), be = H - (he - 1) * 8, Ie = $ - (pe - 1) * 8, Pe = { value: 0 }, Ve = new Array(ne), $e = new Array(ne), qt = new Array(ne), gt = new Array(ne), lt = new Array(ne);
      for (let et = 0; et < ne; ++et)
        lt[et] = P[I.idx[et]], Ve[et] = et < 1 ? 0 : Ve[et - 1] + he * pe, $e[et] = new Float32Array(64), qt[et] = new Uint16Array(64), gt[et] = new Uint16Array(he * 64);
      for (let et = 0; et < pe; ++et) {
        let ci = 8;
        et == pe - 1 && (ci = Ie);
        let Rn = 8;
        for (let Vt = 0; Vt < he; ++Vt) {
          Vt == he - 1 && (Rn = be);
          for (let At = 0; At < ne; ++At)
            qt[At].fill(0), qt[At][0] = L[Ve[At]++], Ke(Pe, T, qt[At]), Ne(qt[At], $e[At]), Ge($e[At]);
          nt($e);
          for (let At = 0; At < ne; ++At)
            wt($e[At], gt[At], Vt * 64);
        }
        let vi = 0;
        for (let Vt = 0; Vt < ne; ++Vt) {
          const At = k[I.idx[Vt]].type;
          for (let fn = 8 * et; fn < 8 * et + ci; ++fn) {
            vi = lt[Vt][fn];
            for (let Sr = 0; Sr < re; ++Sr) {
              const rs = Sr * 64 + (fn & 7) * 8;
              N.setUint16(vi + 0 * 2 * At, gt[Vt][rs + 0], !0), N.setUint16(vi + 1 * 2 * At, gt[Vt][rs + 1], !0), N.setUint16(vi + 2 * 2 * At, gt[Vt][rs + 2], !0), N.setUint16(vi + 3 * 2 * At, gt[Vt][rs + 3], !0), N.setUint16(vi + 4 * 2 * At, gt[Vt][rs + 4], !0), N.setUint16(vi + 5 * 2 * At, gt[Vt][rs + 5], !0), N.setUint16(vi + 6 * 2 * At, gt[Vt][rs + 6], !0), N.setUint16(vi + 7 * 2 * At, gt[Vt][rs + 7], !0), vi += 8 * 2 * At;
            }
          }
          if (re != he)
            for (let fn = 8 * et; fn < 8 * et + ci; ++fn) {
              const Sr = lt[Vt][fn] + 8 * re * 2 * At, rs = re * 64 + (fn & 7) * 8;
              for (let ji = 0; ji < Rn; ++ji)
                N.setUint16(Sr + ji * 2 * At, gt[Vt][rs + ji], !0);
            }
        }
      }
      const si = new Uint16Array(H);
      N = new DataView(U.buffer);
      for (let et = 0; et < ne; ++et) {
        k[I.idx[et]].decoded = !0;
        const ci = k[I.idx[et]].type;
        if (k[et].type == 2)
          for (let Rn = 0; Rn < $; ++Rn) {
            const vi = lt[et][Rn];
            for (let Vt = 0; Vt < H; ++Vt)
              si[Vt] = N.getUint16(vi + Vt * 2 * ci, !0);
            for (let Vt = 0; Vt < H; ++Vt)
              N.setFloat32(vi + Vt * 2 * ci, me(si[Vt]), !0);
          }
      }
    }
    function Ke(I, P, k) {
      let T, L = 1;
      for (; L < 64; )
        T = P[I.value], T == 65280 ? L = 64 : T >> 8 == 255 ? L += T & 255 : (k[L] = T, L++), I.value++;
    }
    function Ne(I, P) {
      P[0] = me(I[0]), P[1] = me(I[1]), P[2] = me(I[5]), P[3] = me(I[6]), P[4] = me(I[14]), P[5] = me(I[15]), P[6] = me(I[27]), P[7] = me(I[28]), P[8] = me(I[2]), P[9] = me(I[4]), P[10] = me(I[7]), P[11] = me(I[13]), P[12] = me(I[16]), P[13] = me(I[26]), P[14] = me(I[29]), P[15] = me(I[42]), P[16] = me(I[3]), P[17] = me(I[8]), P[18] = me(I[12]), P[19] = me(I[17]), P[20] = me(I[25]), P[21] = me(I[30]), P[22] = me(I[41]), P[23] = me(I[43]), P[24] = me(I[9]), P[25] = me(I[11]), P[26] = me(I[18]), P[27] = me(I[24]), P[28] = me(I[31]), P[29] = me(I[40]), P[30] = me(I[44]), P[31] = me(I[53]), P[32] = me(I[10]), P[33] = me(I[19]), P[34] = me(I[23]), P[35] = me(I[32]), P[36] = me(I[39]), P[37] = me(I[45]), P[38] = me(I[52]), P[39] = me(I[54]), P[40] = me(I[20]), P[41] = me(I[22]), P[42] = me(I[33]), P[43] = me(I[38]), P[44] = me(I[46]), P[45] = me(I[51]), P[46] = me(I[55]), P[47] = me(I[60]), P[48] = me(I[21]), P[49] = me(I[34]), P[50] = me(I[37]), P[51] = me(I[47]), P[52] = me(I[50]), P[53] = me(I[56]), P[54] = me(I[59]), P[55] = me(I[61]), P[56] = me(I[35]), P[57] = me(I[36]), P[58] = me(I[48]), P[59] = me(I[49]), P[60] = me(I[57]), P[61] = me(I[58]), P[62] = me(I[62]), P[63] = me(I[63]);
    }
    function Ge(I) {
      const P = 0.5 * Math.cos(0.7853975), k = 0.5 * Math.cos(3.14159 / 16), T = 0.5 * Math.cos(3.14159 / 8), L = 0.5 * Math.cos(3 * 3.14159 / 16), U = 0.5 * Math.cos(5 * 3.14159 / 16), N = 0.5 * Math.cos(3 * 3.14159 / 8), H = 0.5 * Math.cos(7 * 3.14159 / 16), $ = new Array(4), ne = new Array(4), re = new Array(4), he = new Array(4);
      for (let pe = 0; pe < 8; ++pe) {
        const be = pe * 8;
        $[0] = T * I[be + 2], $[1] = N * I[be + 2], $[2] = T * I[be + 6], $[3] = N * I[be + 6], ne[0] = k * I[be + 1] + L * I[be + 3] + U * I[be + 5] + H * I[be + 7], ne[1] = L * I[be + 1] - H * I[be + 3] - k * I[be + 5] - U * I[be + 7], ne[2] = U * I[be + 1] - k * I[be + 3] + H * I[be + 5] + L * I[be + 7], ne[3] = H * I[be + 1] - U * I[be + 3] + L * I[be + 5] - k * I[be + 7], re[0] = P * (I[be + 0] + I[be + 4]), re[3] = P * (I[be + 0] - I[be + 4]), re[1] = $[0] + $[3], re[2] = $[1] - $[2], he[0] = re[0] + re[1], he[1] = re[3] + re[2], he[2] = re[3] - re[2], he[3] = re[0] - re[1], I[be + 0] = he[0] + ne[0], I[be + 1] = he[1] + ne[1], I[be + 2] = he[2] + ne[2], I[be + 3] = he[3] + ne[3], I[be + 4] = he[3] - ne[3], I[be + 5] = he[2] - ne[2], I[be + 6] = he[1] - ne[1], I[be + 7] = he[0] - ne[0];
      }
      for (let pe = 0; pe < 8; ++pe)
        $[0] = T * I[16 + pe], $[1] = N * I[16 + pe], $[2] = T * I[48 + pe], $[3] = N * I[48 + pe], ne[0] = k * I[8 + pe] + L * I[24 + pe] + U * I[40 + pe] + H * I[56 + pe], ne[1] = L * I[8 + pe] - H * I[24 + pe] - k * I[40 + pe] - U * I[56 + pe], ne[2] = U * I[8 + pe] - k * I[24 + pe] + H * I[40 + pe] + L * I[56 + pe], ne[3] = H * I[8 + pe] - U * I[24 + pe] + L * I[40 + pe] - k * I[56 + pe], re[0] = P * (I[pe] + I[32 + pe]), re[3] = P * (I[pe] - I[32 + pe]), re[1] = $[0] + $[3], re[2] = $[1] - $[2], he[0] = re[0] + re[1], he[1] = re[3] + re[2], he[2] = re[3] - re[2], he[3] = re[0] - re[1], I[0 + pe] = he[0] + ne[0], I[8 + pe] = he[1] + ne[1], I[16 + pe] = he[2] + ne[2], I[24 + pe] = he[3] + ne[3], I[32 + pe] = he[3] - ne[3], I[40 + pe] = he[2] - ne[2], I[48 + pe] = he[1] - ne[1], I[56 + pe] = he[0] - ne[0];
    }
    function nt(I) {
      for (let P = 0; P < 64; ++P) {
        const k = I[0][P], T = I[1][P], L = I[2][P];
        I[0][P] = k + 1.5747 * L, I[1][P] = k - 0.1873 * T - 0.4682 * L, I[2][P] = k + 1.8556 * T;
      }
    }
    function wt(I, P, k) {
      for (let T = 0; T < 64; ++T)
        P[k + T] = Gn.toHalfFloat(di(I[T]));
    }
    function di(I) {
      return I <= 1 ? Math.sign(I) * Math.pow(Math.abs(I), 2.2) : Math.sign(I) * Math.pow(x, Math.abs(I) - 1);
    }
    function F(I) {
      return new DataView(I.array.buffer, I.offset.value, I.size);
    }
    function R(I) {
      const P = I.viewer.buffer.slice(I.offset.value, I.offset.value + I.size), k = new Uint8Array(Ee(P)), T = new Uint8Array(k.length);
      return Be(k), oe(k, T), new DataView(T.buffer);
    }
    function te(I) {
      const P = I.array.slice(I.offset.value, I.offset.value + I.size), k = xa(P), T = new Uint8Array(k.length);
      return Be(k), oe(k, T), new DataView(T.buffer);
    }
    function we(I) {
      const P = I.viewer, k = { value: I.offset.value }, T = new Uint16Array(I.width * I.scanlineBlockSize * (I.channels * I.type)), L = new Uint8Array(8192);
      let U = 0;
      const N = new Array(I.channels);
      for (let Ie = 0; Ie < I.channels; Ie++)
        N[Ie] = {}, N[Ie].start = U, N[Ie].end = N[Ie].start, N[Ie].nx = I.width, N[Ie].ny = I.lines, N[Ie].size = I.type, U += N[Ie].nx * N[Ie].ny * N[Ie].size;
      const H = q(P, k), $ = q(P, k);
      if ($ >= 8192)
        throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
      if (H <= $)
        for (let Ie = 0; Ie < $ - H + 1; Ie++)
          L[Ie + H] = qe(P, k);
      const ne = new Uint16Array(65536), re = b(L, ne), he = le(P, k);
      Xe(I.array, P, k, he, T, U);
      for (let Ie = 0; Ie < I.channels; ++Ie) {
        const Pe = N[Ie];
        for (let Ve = 0; Ve < N[Ie].size; ++Ve)
          ot(
            T,
            Pe.start + Ve,
            Pe.nx,
            Pe.size,
            Pe.ny,
            Pe.nx * Pe.size,
            re
          );
      }
      G(ne, T, U);
      let pe = 0;
      const be = new Uint8Array(T.buffer.byteLength);
      for (let Ie = 0; Ie < I.lines; Ie++)
        for (let Pe = 0; Pe < I.channels; Pe++) {
          const Ve = N[Pe], $e = Ve.nx * Ve.size, qt = new Uint8Array(T.buffer, Ve.end * 2, $e * 2);
          be.set(qt, pe), pe += $e * 2, Ve.end += $e;
        }
      return new DataView(be.buffer);
    }
    function Ae(I) {
      const P = I.array.slice(I.offset.value, I.offset.value + I.size), k = xa(P), T = I.lines * I.channels * I.width, L = I.type == 1 ? new Uint16Array(T) : new Uint32Array(T);
      let U = 0, N = 0;
      const H = new Array(4);
      for (let $ = 0; $ < I.lines; $++)
        for (let ne = 0; ne < I.channels; ne++) {
          let re = 0;
          switch (I.type) {
            case 1:
              H[0] = U, H[1] = H[0] + I.width, U = H[1] + I.width;
              for (let he = 0; he < I.width; ++he) {
                const pe = k[H[0]++] << 8 | k[H[1]++];
                re += pe, L[N] = re, N++;
              }
              break;
            case 2:
              H[0] = U, H[1] = H[0] + I.width, H[2] = H[1] + I.width, U = H[2] + I.width;
              for (let he = 0; he < I.width; ++he) {
                const pe = k[H[0]++] << 24 | k[H[1]++] << 16 | k[H[2]++] << 8;
                re += pe, L[N] = re, N++;
              }
              break;
          }
        }
      return new DataView(L.buffer);
    }
    function Ce(I) {
      const P = I.viewer, k = { value: I.offset.value }, T = new Uint8Array(I.width * I.lines * (I.channels * I.type * 2)), L = {
        version: je(P, k),
        unknownUncompressedSize: je(P, k),
        unknownCompressedSize: je(P, k),
        acCompressedSize: je(P, k),
        dcCompressedSize: je(P, k),
        rleCompressedSize: je(P, k),
        rleUncompressedSize: je(P, k),
        rleRawSize: je(P, k),
        totalAcUncompressedCount: je(P, k),
        totalDcUncompressedCount: je(P, k),
        acCompression: je(P, k)
      };
      if (L.version < 2)
        throw new Error("EXRLoader.parse: " + na.compression + " version " + L.version + " is unsupported");
      const U = new Array();
      let N = q(P, k) - 2;
      for (; N > 0; ) {
        const Pe = We(P.buffer, k), Ve = qe(P, k), $e = Ve >> 2 & 3, qt = (Ve >> 4) - 1, gt = new Int8Array([qt])[0], lt = qe(P, k);
        U.push({
          name: Pe,
          index: gt,
          type: lt,
          compression: $e
        }), N -= Pe.length + 3;
      }
      const H = na.channels, $ = new Array(I.channels);
      for (let Pe = 0; Pe < I.channels; ++Pe) {
        const Ve = $[Pe] = {}, $e = H[Pe];
        Ve.name = $e.name, Ve.compression = 0, Ve.decoded = !1, Ve.type = $e.pixelType, Ve.pLinear = $e.pLinear, Ve.width = I.width, Ve.height = I.lines;
      }
      const ne = {
        idx: new Array(3)
      };
      for (let Pe = 0; Pe < I.channels; ++Pe) {
        const Ve = $[Pe];
        for (let $e = 0; $e < U.length; ++$e) {
          const qt = U[$e];
          Ve.name == qt.name && (Ve.compression = qt.compression, qt.index >= 0 && (ne.idx[qt.index] = Pe), Ve.offset = Pe);
        }
      }
      let re, he, pe;
      if (L.acCompressedSize > 0)
        switch (L.acCompression) {
          case 0:
            re = new Uint16Array(L.totalAcUncompressedCount), Xe(I.array, P, k, L.acCompressedSize, re, L.totalAcUncompressedCount);
            break;
          case 1:
            const Pe = I.array.slice(k.value, k.value + L.totalAcUncompressedCount), Ve = xa(Pe);
            re = new Uint16Array(Ve.buffer), k.value += L.totalAcUncompressedCount;
            break;
        }
      if (L.dcCompressedSize > 0) {
        const Pe = {
          array: I.array,
          offset: k,
          size: L.dcCompressedSize
        };
        he = new Uint16Array(te(Pe).buffer), k.value += L.dcCompressedSize;
      }
      if (L.rleRawSize > 0) {
        const Pe = I.array.slice(k.value, k.value + L.rleCompressedSize), Ve = xa(Pe);
        pe = Ee(Ve.buffer), k.value += L.rleCompressedSize;
      }
      let be = 0;
      const Ie = new Array($.length);
      for (let Pe = 0; Pe < Ie.length; ++Pe)
        Ie[Pe] = new Array();
      for (let Pe = 0; Pe < I.lines; ++Pe)
        for (let Ve = 0; Ve < $.length; ++Ve)
          Ie[Ve].push(be), be += $[Ve].width * I.type * 2;
      de(ne, Ie, $, re, he, T);
      for (let Pe = 0; Pe < $.length; ++Pe) {
        const Ve = $[Pe];
        if (!Ve.decoded)
          switch (Ve.compression) {
            case 2:
              let $e = 0, qt = 0;
              for (let gt = 0; gt < I.lines; ++gt) {
                let lt = Ie[Pe][$e];
                for (let si = 0; si < Ve.width; ++si) {
                  for (let et = 0; et < 2 * Ve.type; ++et)
                    T[lt++] = pe[qt + et * Ve.width * Ve.height];
                  qt++;
                }
                $e++;
              }
              break;
            case 1:
            // skip
            default:
              throw new Error("EXRLoader.parse: unsupported channel compression");
          }
      }
      return new DataView(T.buffer);
    }
    function We(I, P) {
      const k = new Uint8Array(I);
      let T = 0;
      for (; k[P.value + T] != 0; )
        T += 1;
      const L = new TextDecoder().decode(
        k.slice(P.value, P.value + T)
      );
      return P.value = P.value + T + 1, L;
    }
    function Me(I, P, k) {
      const T = new TextDecoder().decode(
        new Uint8Array(I).slice(P.value, P.value + k)
      );
      return P.value = P.value + k, T;
    }
    function Le(I, P) {
      const k = ye(I, P), T = le(I, P);
      return [k, T];
    }
    function z(I, P) {
      const k = le(I, P), T = le(I, P);
      return [k, T];
    }
    function ye(I, P) {
      const k = I.getInt32(P.value, !0);
      return P.value = P.value + 4, k;
    }
    function le(I, P) {
      const k = I.getUint32(P.value, !0);
      return P.value = P.value + 4, k;
    }
    function at(I, P) {
      const k = I[P.value];
      return P.value = P.value + 1, k;
    }
    function qe(I, P) {
      const k = I.getUint8(P.value);
      return P.value = P.value + 1, k;
    }
    const je = function(I, P) {
      let k;
      return "getBigInt64" in DataView.prototype ? k = Number(I.getBigInt64(P.value, !0)) : k = I.getUint32(P.value + 4, !0) + Number(I.getUint32(P.value, !0) << 32), P.value += 8, k;
    };
    function Fe(I, P) {
      const k = I.getFloat32(P.value, !0);
      return P.value += 4, k;
    }
    function He(I, P) {
      return Gn.toHalfFloat(Fe(I, P));
    }
    function me(I) {
      const P = (I & 31744) >> 10, k = I & 1023;
      return (I >> 15 ? -1 : 1) * (P ? P === 31 ? k ? NaN : 1 / 0 : Math.pow(2, P - 15) * (1 + k / 1024) : 6103515625e-14 * (k / 1024));
    }
    function q(I, P) {
      const k = I.getUint16(P.value, !0);
      return P.value += 2, k;
    }
    function ke(I, P) {
      return me(q(I, P));
    }
    function xe(I, P, k, T) {
      const L = k.value, U = [];
      for (; k.value < L + T - 1; ) {
        const N = We(P, k), H = ye(I, k), $ = qe(I, k);
        k.value += 3;
        const ne = ye(I, k), re = ye(I, k);
        U.push({
          name: N,
          pixelType: H,
          pLinear: $,
          xSampling: ne,
          ySampling: re
        });
      }
      return k.value += 1, U;
    }
    function ae(I, P) {
      const k = Fe(I, P), T = Fe(I, P), L = Fe(I, P), U = Fe(I, P), N = Fe(I, P), H = Fe(I, P), $ = Fe(I, P), ne = Fe(I, P);
      return { redX: k, redY: T, greenX: L, greenY: U, blueX: N, blueY: H, whiteX: $, whiteY: ne };
    }
    function De(I, P) {
      const k = [
        "NO_COMPRESSION",
        "RLE_COMPRESSION",
        "ZIPS_COMPRESSION",
        "ZIP_COMPRESSION",
        "PIZ_COMPRESSION",
        "PXR24_COMPRESSION",
        "B44_COMPRESSION",
        "B44A_COMPRESSION",
        "DWAA_COMPRESSION",
        "DWAB_COMPRESSION"
      ], T = qe(I, P);
      return k[T];
    }
    function st(I, P) {
      const k = le(I, P), T = le(I, P), L = le(I, P), U = le(I, P);
      return { xMin: k, yMin: T, xMax: L, yMax: U };
    }
    function Et(I, P) {
      const k = [
        "INCREASING_Y"
      ], T = qe(I, P);
      return k[T];
    }
    function Kt(I, P) {
      const k = Fe(I, P), T = Fe(I, P);
      return [k, T];
    }
    function Fi(I, P) {
      const k = Fe(I, P), T = Fe(I, P), L = Fe(I, P);
      return [k, T, L];
    }
    function It(I, P, k, T, L) {
      if (T === "string" || T === "stringvector" || T === "iccProfile")
        return Me(P, k, L);
      if (T === "chlist")
        return xe(I, P, k, L);
      if (T === "chromaticities")
        return ae(I, k);
      if (T === "compression")
        return De(I, k);
      if (T === "box2i")
        return st(I, k);
      if (T === "lineOrder")
        return Et(I, k);
      if (T === "float")
        return Fe(I, k);
      if (T === "v2f")
        return Kt(I, k);
      if (T === "v3f")
        return Fi(I, k);
      if (T === "int")
        return ye(I, k);
      if (T === "rational")
        return Le(I, k);
      if (T === "timecode")
        return z(I, k);
      if (T === "preview")
        return k.value += L, "skipped";
      k.value += L;
    }
    function pn(I, P, k) {
      const T = {};
      if (I.getUint32(0, !0) != 20000630)
        throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");
      T.version = I.getUint8(4);
      const L = I.getUint8(5);
      T.spec = {
        singleTile: !!(L & 2),
        longName: !!(L & 4),
        deepFormat: !!(L & 8),
        multiPart: !!(L & 16)
      }, k.value = 8;
      let U = !0;
      for (; U; ) {
        const N = We(P, k);
        if (N == 0)
          U = !1;
        else {
          const H = We(P, k), $ = le(I, k), ne = It(I, P, k, H, $);
          ne === void 0 ? console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${H}'.`) : T[N] = ne;
        }
      }
      if ((L & -5) != 0)
        throw console.error("THREE.EXRHeader:", T), new Error("THREE.EXRLoader: Provided file is currently unsupported.");
      return T;
    }
    function ys(I, P, k, T, L) {
      const U = {
        size: 0,
        viewer: P,
        array: k,
        offset: T,
        width: I.dataWindow.xMax - I.dataWindow.xMin + 1,
        height: I.dataWindow.yMax - I.dataWindow.yMin + 1,
        channels: I.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: I.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        colorSpace: Mt
      };
      switch (I.compression) {
        case "NO_COMPRESSION":
          U.lines = 1, U.uncompress = F;
          break;
        case "RLE_COMPRESSION":
          U.lines = 1, U.uncompress = R;
          break;
        case "ZIPS_COMPRESSION":
          U.lines = 1, U.uncompress = te;
          break;
        case "ZIP_COMPRESSION":
          U.lines = 16, U.uncompress = te;
          break;
        case "PIZ_COMPRESSION":
          U.lines = 32, U.uncompress = we;
          break;
        case "PXR24_COMPRESSION":
          U.lines = 16, U.uncompress = Ae;
          break;
        case "DWAA_COMPRESSION":
          U.lines = 32, U.uncompress = Ce;
          break;
        case "DWAB_COMPRESSION":
          U.lines = 256, U.uncompress = Ce;
          break;
        default:
          throw new Error("EXRLoader.parse: " + I.compression + " is unsupported");
      }
      if (U.scanlineBlockSize = U.lines, U.type == 1)
        switch (L) {
          case Xt:
            U.getter = ke, U.inputSize = 2;
            break;
          case Qt:
            U.getter = q, U.inputSize = 2;
            break;
        }
      else if (U.type == 2)
        switch (L) {
          case Xt:
            U.getter = Fe, U.inputSize = 4;
            break;
          case Qt:
            U.getter = He, U.inputSize = 4;
        }
      else
        throw new Error("EXRLoader.parse: unsupported pixelType " + U.type + " for " + I.compression + ".");
      U.blockCount = (I.dataWindow.yMax + 1) / U.scanlineBlockSize;
      for (let H = 0; H < U.blockCount; H++)
        je(P, T);
      U.outputChannels = U.channels == 3 ? 4 : U.channels;
      const N = U.width * U.height * U.outputChannels;
      switch (L) {
        case Xt:
          U.byteArray = new Float32Array(N), U.channels < U.outputChannels && U.byteArray.fill(1, 0, N);
          break;
        case Qt:
          U.byteArray = new Uint16Array(N), U.channels < U.outputChannels && U.byteArray.fill(15360, 0, N);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", L);
          break;
      }
      return U.bytesPerLine = U.width * U.inputSize * U.channels, U.outputChannels == 4 ? (U.format = ei, U.colorSpace = Mt) : (U.format = ao, U.colorSpace = Wt), U;
    }
    const za = new DataView(e), pf = new Uint8Array(e), ir = { value: 0 }, na = pn(za, e, ir), xt = ys(na, za, pf, ir, this.type), Vc = { value: 0 }, bu = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let I = 0; I < xt.height / xt.scanlineBlockSize; I++) {
      const P = le(za, ir);
      xt.size = le(za, ir), xt.lines = P + xt.scanlineBlockSize > xt.height ? xt.height - P : xt.scanlineBlockSize;
      const T = xt.size < xt.lines * xt.bytesPerLine ? xt.uncompress(xt) : F(xt);
      ir.value += xt.size;
      for (let L = 0; L < xt.scanlineBlockSize; L++) {
        const U = L + I * xt.scanlineBlockSize;
        if (U >= xt.height) break;
        for (let N = 0; N < xt.channels; N++) {
          const H = bu[na.channels[N].name];
          for (let $ = 0; $ < xt.width; $++) {
            Vc.value = (L * (xt.channels * xt.width) + N * xt.width + $) * xt.inputSize;
            const ne = (xt.height - 1 - U) * (xt.width * xt.outputChannels) + $ * xt.outputChannels + H;
            xt.byteArray[ne] = xt.getter(T, Vc);
          }
        }
      }
    }
    return {
      header: na,
      width: xt.width,
      height: xt.height,
      data: xt.byteArray,
      format: xt.format,
      colorSpace: xt.colorSpace,
      type: this.type
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, i, n) {
    function r(a, o) {
      a.colorSpace = o.colorSpace, a.minFilter = tt, a.magFilter = tt, a.generateMipmaps = !1, a.flipY = !1, t && t(a, o);
    }
    return super.load(e, r, i, n);
  }
}
const _m = /* @__PURE__ */ new WeakMap();
class iO extends ui {
  constructor(e) {
    super(e), this.libraryPath = "", this.libraryPending = null, this.libraryBinary = null, this.libraryConfig = {}, this.url = "", this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.workerConfig = {}, this.materials = [], this.warnings = [];
  }
  setLibraryPath(e) {
    return this.libraryPath = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, i, n) {
    const r = new ti(this.manager);
    r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), this.url = e, r.load(e, (a) => {
      if (_m.has(a))
        return _m.get(a).promise.then(t).catch(n);
      this.decodeObjects(a, e).then((o) => {
        o.userData.warnings = this.warnings, this.warnings = [], t(o);
      }).catch((o) => n(o));
    }, i, n);
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
  }
  decodeObjects(e, t) {
    let i, n;
    const r = e.byteLength, a = this._getWorker(r).then((o) => (i = o, n = this.workerNextTaskID++, new Promise((l, c) => {
      i._callbacks[n] = { resolve: l, reject: c }, i.postMessage({ type: "decode", id: n, buffer: e }, [e]);
    }))).then((o) => this._createGeometry(o.data)).catch((o) => {
      throw o;
    });
    return a.catch(() => !0).then(() => {
      i && n && this._releaseTask(i, n);
    }), _m.set(e, {
      url: t,
      promise: a
    }), a;
  }
  parse(e, t, i) {
    this.decodeObjects(e, "").then((n) => {
      n.userData.warnings = this.warnings, t(n);
    }).catch((n) => i(n));
  }
  _compareMaterials(e) {
    if (this.materials.includes(e)) return e;
    const t = {};
    t.name = e.name, t.color = {}, t.color.r = e.color.r, t.color.g = e.color.g, t.color.b = e.color.b, t.type = e.type, t.vertexColors = e.vertexColors;
    const i = JSON.stringify(t);
    for (let n = 0; n < this.materials.length; n++) {
      const r = this.materials[n], a = {};
      if (a.name = r.name, a.color = {}, a.color.r = r.color.r, a.color.g = r.color.g, a.color.b = r.color.b, a.type = r.type, a.vertexColors = r.vertexColors, JSON.stringify(a) === i)
        return r;
    }
    return this.materials.push(e), e;
  }
  _createMaterial(e, t) {
    if (e === void 0)
      return new Go({
        color: new se(1, 1, 1),
        metalness: 0.8,
        name: ui.DEFAULT_MATERIAL_NAME,
        side: zi
      });
    const i = new Sc({
      color: new se(e.diffuseColor.r / 255, e.diffuseColor.g / 255, e.diffuseColor.b / 255),
      emissive: new se(e.emissionColor.r, e.emissionColor.g, e.emissionColor.b),
      flatShading: e.disableLighting,
      ior: e.indexOfRefraction,
      name: e.name,
      reflectivity: e.reflectivity,
      opacity: 1 - e.transparency,
      side: zi,
      // todo should we change?
      specularColor: e.specularColor,
      transparent: e.transparency > 0
    });
    if (i.userData.id = e.id, e.pbrSupported) {
      const r = e.pbr;
      i.anisotropy = r.anisotropic, i.anisotropyRotation = r.anisotropicRotation, i.color = new se(r.baseColor.r, r.baseColor.g, r.baseColor.b), i.clearcoat = r.clearcoat, i.clearcoatRoughness = r.clearcoatRoughness, i.metalness = r.metallic, i.transmission = 1 - r.opacity, i.roughness = r.roughness, i.sheen = r.sheen, i.specularIntensity = r.specular, i.thickness = r.subsurface;
    }
    e.pbrSupported && e.pbr.opacity === 0 && e.transparency === 1 && (i.opacity = 0.2, i.transmission = 1);
    const n = new xo();
    for (let r = 0; r < e.textures.length; r++) {
      const a = e.textures[r];
      if (a.image !== null) {
        const o = n.load(a.image);
        switch (a.type) {
          case "Bump":
            i.bumpMap = o;
            break;
          case "Diffuse":
            i.map = o;
            break;
          case "Emap":
            i.envMap = o;
            break;
          case "Opacity":
            i.transmissionMap = o;
            break;
          case "Transparency":
            i.alphaMap = o, i.transparent = !0;
            break;
          case "PBR_Alpha":
            i.alphaMap = o, i.transparent = !0;
            break;
          case "PBR_AmbientOcclusion":
            i.aoMap = o;
            break;
          case "PBR_Anisotropic":
            i.anisotropyMap = o;
            break;
          case "PBR_BaseColor":
            i.map = o;
            break;
          case "PBR_Clearcoat":
            i.clearcoatMap = o;
            break;
          case "PBR_ClearcoatBump":
            i.clearcoatNormalMap = o;
            break;
          case "PBR_ClearcoatRoughness":
            i.clearcoatRoughnessMap = o;
            break;
          case "PBR_Displacement":
            i.displacementMap = o;
            break;
          case "PBR_Emission":
            i.emissiveMap = o;
            break;
          case "PBR_Metallic":
            i.metalnessMap = o;
            break;
          case "PBR_Roughness":
            i.roughnessMap = o;
            break;
          case "PBR_Sheen":
            i.sheenColorMap = o;
            break;
          case "PBR_Specular":
            i.specularColorMap = o;
            break;
          case "PBR_Subsurface":
            i.thicknessMap = o;
            break;
          default:
            this.warnings.push({
              message: `THREE.3DMLoader: No conversion exists for 3dm ${a.type}.`,
              type: "no conversion"
            });
            break;
        }
        o.wrapS = a.wrapU === 0 ? xn : Zt, o.wrapT = a.wrapV === 0 ? xn : Zt, a.repeat && o.repeat.set(a.repeat[0], a.repeat[1]);
      }
    }
    return t && new Xb().load(t.image, function(r) {
      r.mapping = THREE.EquirectangularReflectionMapping, i.envMap = r;
    }), i;
  }
  _createGeometry(e) {
    const t = new ut(), i = [], n = [], r = [];
    t.userData.layers = e.layers, t.userData.groups = e.groups, t.userData.settings = e.settings, t.userData.settings.renderSettings = e.renderSettings, t.userData.strings = e.strings, t.userData.objectType = "File3dm", t.userData.materials = null, t.name = this.url;
    let a = e.objects;
    const o = e.materials;
    for (let l = 0; l < a.length; l++) {
      const c = a[l], h = c.attributes;
      switch (c.objectType) {
        case "InstanceDefinition":
          n.push(c);
          break;
        case "InstanceReference":
          r.push(c);
          break;
        default:
          let u = null;
          switch (h.materialSource.name) {
            case "ObjectMaterialSource_MaterialFromLayer":
              h.layerIndex >= 0 && (u = e.layers[h.layerIndex].renderMaterialIndex);
              break;
            case "ObjectMaterialSource_MaterialFromObject":
              h.materialIndex >= 0 && (u = h.materialIndex);
              break;
          }
          let d = null;
          if (u >= 0) {
            const y = o[u];
            d = this._createMaterial(y, e.renderEnvironment);
          } else
            d = this._createMaterial();
          d = this._compareMaterials(d);
          const p = this._createObject(c, d);
          if (p === void 0)
            continue;
          const f = e.layers[h.layerIndex];
          p.visible = f ? f.visible : !0, h.isInstanceDefinitionObject ? i.push(p) : t.add(p);
          break;
      }
    }
    for (let l = 0; l < n.length; l++) {
      const c = n[l];
      a = [];
      for (let h = 0; h < c.attributes.objectIds.length; h++) {
        const u = c.attributes.objectIds[h];
        for (let d = 0; d < i.length; d++) {
          const p = i[d].userData.attributes.id;
          u === p && a.push(i[d]);
        }
      }
      for (let h = 0; h < r.length; h++) {
        const u = r[h];
        if (u.geometry.parentIdefId === c.attributes.id) {
          const d = u.geometry.xform.array, p = new Ue();
          if (p.set(...d), a.length === 1) {
            const f = a[0].clone(!0);
            if (f.name = u.attributes.name || f.name, f.applyMatrix4(p), u.attributes.materialIndex >= 0 && u.attributes.materialIndex !== a[0].userData.attributes.materialIndex) {
              const y = o[u.attributes.materialIndex], A = this._createMaterial(y);
              f.material = this._compareMaterials(A);
            }
            if (f.userData.defAttributes = f.userData.attributes, f.userData.defObjectType = f.userData.objectType, f.userData.attributes = { ...f.userData.attributes, ...u.attributes }, f.userData.objectType = u.objectType, u.attributes.layerIndex !== void 0) {
              const y = e.layers[u.attributes.layerIndex];
              f.visible = y ? y.visible : f.visible;
            }
            t.add(f);
          } else {
            console.warn("THREE.Rhino3dmLoader: InstanceReference with multiple/no objects, not all properties will be copied.");
            const f = new ut();
            f.applyMatrix4(p);
            for (let y = 0; y < a.length; y++)
              f.add(a[y].clone(!0));
            t.add(f);
          }
        }
      }
    }
    return t.userData.materials = this.materials, t.name = "", t;
  }
  _createObject(e, t) {
    const i = new Vw(), n = e.attributes;
    let r, a, o, l;
    switch (e.objectType) {
      case "Point":
      case "PointSet":
        r = i.parse(e.geometry), r.attributes.hasOwnProperty("color") ? a = new Qr({ vertexColors: !0, sizeAttenuation: !1, size: 2 }) : (o = n.drawColor, l = new se(o.r / 255, o.g / 255, o.b / 255), a = new Qr({ color: l, sizeAttenuation: !1, size: 2 })), a = this._compareMaterials(a);
        const c = new zl(r, a);
        return c.userData.attributes = n, c.userData.objectType = e.objectType, n.name && (c.name = n.name), c;
      case "Mesh":
      case "Extrusion":
      case "SubD":
      case "Brep":
        if (e.geometry === null) return;
        r = i.parse(e.geometry), t === null && (t = this._createMaterial(), t = this._compareMaterials(t)), r.attributes.hasOwnProperty("color") && (t.vertexColors = !0);
        const h = new Se(r, t);
        return h.castShadow = n.castsShadows, h.receiveShadow = n.receivesShadows, h.userData.attributes = n, h.userData.objectType = e.objectType, n.name && (h.name = n.name, r.name = n.name), h;
      case "Curve":
        r = i.parse(e.geometry), o = n.drawColor, l = new se(o.r / 255, o.g / 255, o.b / 255), a = new Ri({ color: l }), a = this._compareMaterials(a);
        const u = new an(r, a);
        return u.userData.attributes = n, u.userData.objectType = e.objectType, n.name && (u.name = n.name), u;
      case "TextDot":
        r = e.geometry;
        const d = document.createElement("canvas").getContext("2d"), p = `${r.fontHeight}px ${r.fontFace}`;
        d.font = p;
        const f = d.measureText(r.text).width + 10, y = r.fontHeight + 10, A = window.devicePixelRatio;
        d.canvas.width = f * A, d.canvas.height = y * A, d.canvas.style.width = f + "px", d.canvas.style.height = y + "px", d.setTransform(A, 0, 0, A, 0, 0), d.font = p, d.textBaseline = "middle", d.textAlign = "center", l = n.drawColor, d.fillStyle = `rgba(${l.r},${l.g},${l.b},${l.a})`, d.fillRect(0, 0, f, y), d.fillStyle = "white", d.fillText(r.text, f / 2, y / 2);
        const m = new Qp(d.canvas);
        m.minFilter = tt, m.generateMipmaps = !1, m.wrapS = Zt, m.wrapT = Zt, a = new Gp({ map: m, depthTest: !1 });
        const v = new mA(a);
        return v.position.set(r.point[0], r.point[1], r.point[2]), v.scale.set(f / 10, y / 10, 1), v.userData.attributes = n, v.userData.objectType = e.objectType, n.name && (v.name = n.name), v;
      case "Light":
        r = e.geometry;
        let g;
        switch (r.lightStyle.name) {
          case "LightStyle_WorldPoint":
            g = new nc(), g.castShadow = n.castsShadows, g.position.set(r.location[0], r.location[1], r.location[2]), g.shadow.normalBias = 0.1;
            break;
          case "LightStyle_WorldSpot":
            g = new cu(), g.castShadow = n.castsShadows, g.position.set(r.location[0], r.location[1], r.location[2]), g.target.position.set(r.direction[0], r.direction[1], r.direction[2]), g.angle = r.spotAngleRadians, g.shadow.normalBias = 0.1;
            break;
          case "LightStyle_WorldRectangular":
            g = new FA();
            const _ = Math.abs(r.width[2]), w = Math.abs(r.length[0]);
            g.position.set(r.location[0] - w / 2, r.location[1], r.location[2] - _ / 2), g.height = w, g.width = _, g.lookAt(r.direction[0], r.direction[1], r.direction[2]);
            break;
          case "LightStyle_WorldDirectional":
            g = new hu(), g.castShadow = n.castsShadows, g.position.set(r.location[0], r.location[1], r.location[2]), g.target.position.set(r.direction[0], r.direction[1], r.direction[2]), g.shadow.normalBias = 0.1;
            break;
        }
        return g && (g.intensity = r.intensity, o = r.diffuse, l = new se(o.r / 255, o.g / 255, o.b / 255), g.color = l, g.userData.attributes = n, g.userData.objectType = e.objectType), g;
    }
  }
  _initLibrary() {
    if (!this.libraryPending) {
      const e = new ti(this.manager);
      e.setPath(this.libraryPath);
      const t = new Promise((r, a) => {
        e.load("rhino3dm.js", r, void 0, a);
      }), i = new ti(this.manager);
      i.setPath(this.libraryPath), i.setResponseType("arraybuffer");
      const n = new Promise((r, a) => {
        i.load("rhino3dm.wasm", r, void 0, a);
      });
      this.libraryPending = Promise.all([t, n]).then(([r, a]) => {
        this.libraryConfig.wasmBinary = a;
        const o = nO, l = [
          "/* rhino3dm.js */",
          r,
          "/* worker */",
          o.substring(o.indexOf("{") + 1, o.lastIndexOf("}"))
        ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([l]));
      });
    }
    return this.libraryPending;
  }
  _getWorker(e) {
    return this._initLibrary().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const i = new Worker(this.workerSourceURL);
        i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({
          type: "init",
          libraryConfig: this.libraryConfig
        }), i.onmessage = (n) => {
          const r = n.data;
          switch (r.type) {
            case "warning":
              this.warnings.push(r.data), console.warn(r.data);
              break;
            case "decode":
              i._callbacks[r.id].resolve(r);
              break;
            case "error":
              i._callbacks[r.id].reject(r);
              break;
            default:
              console.error('THREE.Rhino3dmLoader: Unexpected message, "' + r.type + '"');
          }
        }, this.workerPool.push(i);
      } else
        this.workerPool.sort(function(i, n) {
          return i._taskLoad > n._taskLoad ? -1 : 1;
        });
      const t = this.workerPool[this.workerPool.length - 1];
      return t._taskLoad += e, t;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this;
  }
}
const nO = `
function Rhino3dmWorker() {

	let libraryPending;
	let libraryConfig;
	let rhino;
	let taskID;

	onmessage = function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':

				libraryConfig = message.libraryConfig;
				const wasmBinary = libraryConfig.wasmBinary;
				let RhinoModule;
				libraryPending = new Promise( function ( resolve ) {

					/* Like Basis Loader */
					RhinoModule = { wasmBinary, onRuntimeInitialized: resolve };

					rhino3dm( RhinoModule ); // eslint-disable-line no-undef

				 } ).then( () => {

					rhino = RhinoModule;

				 } );

				break;

			case 'decode':

				taskID = message.id;
				const buffer = message.buffer;
				libraryPending.then( () => {

					try {

						const data = decodeObjects( rhino, buffer );
						self.postMessage( { type: 'decode', id: message.id, data } );

					} catch ( error ) {

						self.postMessage( { type: 'error', id: message.id, error } );

					}

				} );

				break;

		}

	};

	function decodeObjects( rhino, buffer ) {

		const arr = new Uint8Array( buffer );
		const doc = rhino.File3dm.fromByteArray( arr );

		const objects = [];
		const materials = [];
		const layers = [];
		const views = [];
		const namedViews = [];
		const groups = [];
		const strings = [];

		//Handle objects

		const objs = doc.objects();
		const cnt = objs.count;

		for ( let i = 0; i < cnt; i ++ ) {

			const _object = objs.get( i );

			const object = extractObjectData( _object, doc );

			_object.delete();

			if ( object ) {

				objects.push( object );

			}

		}

		// Handle instance definitions
		// console.log( \`Instance Definitions Count: \${doc.instanceDefinitions().count()}\` );

		for ( let i = 0; i < doc.instanceDefinitions().count; i ++ ) {

			const idef = doc.instanceDefinitions().get( i );
			const idefAttributes = extractProperties( idef );
			idefAttributes.objectIds = idef.getObjectIds();

			objects.push( { geometry: null, attributes: idefAttributes, objectType: 'InstanceDefinition' } );

		}

		// Handle materials

		const textureTypes = [
			// rhino.TextureType.Bitmap,
			rhino.TextureType.Diffuse,
			rhino.TextureType.Bump,
			rhino.TextureType.Transparency,
			rhino.TextureType.Opacity,
			rhino.TextureType.Emap
		];

		const pbrTextureTypes = [
			rhino.TextureType.PBR_BaseColor,
			rhino.TextureType.PBR_Subsurface,
			rhino.TextureType.PBR_SubsurfaceScattering,
			rhino.TextureType.PBR_SubsurfaceScatteringRadius,
			rhino.TextureType.PBR_Metallic,
			rhino.TextureType.PBR_Specular,
			rhino.TextureType.PBR_SpecularTint,
			rhino.TextureType.PBR_Roughness,
			rhino.TextureType.PBR_Anisotropic,
			rhino.TextureType.PBR_Anisotropic_Rotation,
			rhino.TextureType.PBR_Sheen,
			rhino.TextureType.PBR_SheenTint,
			rhino.TextureType.PBR_Clearcoat,
			rhino.TextureType.PBR_ClearcoatBump,
			rhino.TextureType.PBR_ClearcoatRoughness,
			rhino.TextureType.PBR_OpacityIor,
			rhino.TextureType.PBR_OpacityRoughness,
			rhino.TextureType.PBR_Emission,
			rhino.TextureType.PBR_AmbientOcclusion,
			rhino.TextureType.PBR_Displacement
		];

		for ( let i = 0; i < doc.materials().count; i ++ ) {

			const _material = doc.materials().get( i );

			let material = extractProperties( _material );

			const textures = [];

			textures.push( ...extractTextures( _material, textureTypes, doc ) );

			material.pbrSupported = _material.physicallyBased().supported;

			if ( material.pbrSupported ) {

				textures.push( ...extractTextures( _material, pbrTextureTypes, doc ) );
				material.pbr = extractProperties( _material.physicallyBased() );

			}

			material.textures = textures;

			materials.push( material );

			_material.delete();

		}

		// Handle layers

		for ( let i = 0; i < doc.layers().count; i ++ ) {

			const _layer = doc.layers().get( i );
			const layer = extractProperties( _layer );

			layers.push( layer );

			_layer.delete();

		}

		// Handle views

		for ( let i = 0; i < doc.views().count; i ++ ) {

			const _view = doc.views().get( i );
			const view = extractProperties( _view );

			views.push( view );

			_view.delete();

		}

		// Handle named views

		for ( let i = 0; i < doc.namedViews().count; i ++ ) {

			const _namedView = doc.namedViews().get( i );
			const namedView = extractProperties( _namedView );

			namedViews.push( namedView );

			_namedView.delete();

		}

		// Handle groups

		for ( let i = 0; i < doc.groups().count; i ++ ) {

			const _group = doc.groups().get( i );
			const group = extractProperties( _group );

			groups.push( group );

			_group.delete();

		}

		// Handle settings

		const settings = extractProperties( doc.settings() );

		//TODO: Handle other document stuff like dimstyles, instance definitions, bitmaps etc.

		// Handle dimstyles
		// console.log( \`Dimstyle Count: \${doc.dimstyles().count()}\` );

		// Handle bitmaps
		// console.log( \`Bitmap Count: \${doc.bitmaps().count()}\` );

		// Handle strings
		// console.log( \`Document Strings Count: \${doc.strings().count()}\` );
		// Note: doc.strings().documentUserTextCount() counts any doc.strings defined in a section
		// console.log( \`Document User Text Count: \${doc.strings().documentUserTextCount()}\` );

		const strings_count = doc.strings().count;

		for ( let i = 0; i < strings_count; i ++ ) {

			strings.push( doc.strings().get( i ) );

		}

		// Handle Render Environments for Material Environment

		// get the id of the active render environment skylight, which we'll use for environment texture
		const reflectionId = doc.settings().renderSettings().renderEnvironments.reflectionId;

		const rc = doc.renderContent();

		let renderEnvironment = null;

		for( let i = 0; i < rc.count; i++ ) {

			const content = rc.get(i);

			switch( content.kind ) {

				case 'environment':

					const id = content.id;

					// there could be multiple render environments in a 3dm file
					if ( id !== reflectionId ) break;

					const renderTexture = content.findChild( 'texture' );
					const fileName = renderTexture.fileName;

					for ( let j = 0; j < doc.embeddedFiles().count; j ++ ) {

						const _fileName = doc.embeddedFiles().get( j ).fileName;

						if ( fileName === _fileName ) {

							const background = doc.getEmbeddedFileAsBase64( fileName );
							const backgroundImage = 'data:image/png;base64,' + background;
							renderEnvironment = { type: 'renderEnvironment', image: backgroundImage, name: fileName };

						}

					}

					break;

			}

		}

		// Handle Render Settings

		const renderSettings = {
			ambientLight: doc.settings().renderSettings().ambientLight,
			backgroundColorTop: doc.settings().renderSettings().backgroundColorTop,
			backgroundColorBottom: doc.settings().renderSettings().backgroundColorBottom,
			useHiddenLights: doc.settings().renderSettings().useHiddenLights,
			depthCue: doc.settings().renderSettings().depthCue,
			flatShade: doc.settings().renderSettings().flatShade,
			renderBackFaces: doc.settings().renderSettings().renderBackFaces,
			renderPoints: doc.settings().renderSettings().renderPoints,
			renderCurves: doc.settings().renderSettings().renderCurves,
			renderIsoParams: doc.settings().renderSettings().renderIsoParams,
			renderMeshEdges: doc.settings().renderSettings().renderMeshEdges,
			renderAnnotations: doc.settings().renderSettings().renderAnnotations,
			useViewportSize: doc.settings().renderSettings().useViewportSize,
			scaleBackgroundToFit: doc.settings().renderSettings().scaleBackgroundToFit,
			transparentBackground: doc.settings().renderSettings().transparentBackground,
			imageDpi: doc.settings().renderSettings().imageDpi,
			shadowMapLevel: doc.settings().renderSettings().shadowMapLevel,
			namedView: doc.settings().renderSettings().namedView,
			snapShot: doc.settings().renderSettings().snapShot,
			specificViewport: doc.settings().renderSettings().specificViewport,
			groundPlane: extractProperties( doc.settings().renderSettings().groundPlane ),
			safeFrame: extractProperties( doc.settings().renderSettings().safeFrame ),
			dithering: extractProperties( doc.settings().renderSettings().dithering ),
			skylight: extractProperties( doc.settings().renderSettings().skylight ),
			linearWorkflow: extractProperties( doc.settings().renderSettings().linearWorkflow ),
			renderChannels: extractProperties( doc.settings().renderSettings().renderChannels ),
			sun: extractProperties( doc.settings().renderSettings().sun ),
			renderEnvironments: extractProperties( doc.settings().renderSettings().renderEnvironments ),
			postEffects: extractProperties( doc.settings().renderSettings().postEffects ),

		};

		doc.delete();

		return { objects, materials, layers, views, namedViews, groups, strings, settings, renderSettings, renderEnvironment };

	}

	function extractTextures( m, tTypes, d ) {

		const textures = [];

		for ( let i = 0; i < tTypes.length; i ++ ) {

			const _texture = m.getTexture( tTypes[ i ] );
			if ( _texture ) {

				let textureType = tTypes[ i ].constructor.name;
				textureType = textureType.substring( 12, textureType.length );
				const texture = extractTextureData( _texture, textureType, d );
				textures.push( texture );
				_texture.delete();

			}

		}

		return textures;

	}

	function extractTextureData( t, tType, d ) {

		const texture = { type: tType };

		const image = d.getEmbeddedFileAsBase64( t.fileName );

		texture.wrapU = t.wrapU;
		texture.wrapV = t.wrapV;
		texture.wrapW = t.wrapW;
		const uvw = t.uvwTransform.toFloatArray( true );

		texture.repeat = [ uvw[ 0 ], uvw[ 5 ] ];

		if ( image ) {

			texture.image = 'data:image/png;base64,' + image;

		} else {

			self.postMessage( { type: 'warning', id: taskID, data: {
				message: \`THREE.3DMLoader: Image for \${tType} texture not embedded in file.\`,
				type: 'missing resource'
			}

			} );

			texture.image = null;

		}

		return texture;

	}

	function extractObjectData( object, doc ) {

		const _geometry = object.geometry();
		const _attributes = object.attributes();
		let objectType = _geometry.objectType;
		let geometry, attributes, position, data, mesh;

		// skip instance definition objects
		//if( _attributes.isInstanceDefinitionObject ) { continue; }

		// TODO: handle other geometry types
		switch ( objectType ) {

			case rhino.ObjectType.Curve:

				const pts = curveToPoints( _geometry, 100 );

				position = {};
				attributes = {};
				data = {};

				position.itemSize = 3;
				position.type = 'Float32Array';
				position.array = [];

				for ( let j = 0; j < pts.length; j ++ ) {

					position.array.push( pts[ j ][ 0 ] );
					position.array.push( pts[ j ][ 1 ] );
					position.array.push( pts[ j ][ 2 ] );

				}

				attributes.position = position;
				data.attributes = attributes;

				geometry = { data };

				break;

			case rhino.ObjectType.Point:

				const pt = _geometry.location;

				position = {};
				const color = {};
				attributes = {};
				data = {};

				position.itemSize = 3;
				position.type = 'Float32Array';
				position.array = [ pt[ 0 ], pt[ 1 ], pt[ 2 ] ];

				const _color = _attributes.drawColor( doc );

				color.itemSize = 3;
				color.type = 'Float32Array';
				color.array = [ _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 ];

				attributes.position = position;
				attributes.color = color;
				data.attributes = attributes;

				geometry = { data };

				break;

			case rhino.ObjectType.PointSet:
			case rhino.ObjectType.Mesh:

				geometry = _geometry.toThreejsJSON();

				break;

			case rhino.ObjectType.Brep:

				const faces = _geometry.faces();
				mesh = new rhino.Mesh();

				for ( let faceIndex = 0; faceIndex < faces.count; faceIndex ++ ) {

					const face = faces.get( faceIndex );
					const _mesh = face.getMesh( rhino.MeshType.Any );

					if ( _mesh ) {

						mesh.append( _mesh );
						_mesh.delete();

					}

					face.delete();

				}

				if ( mesh.faces().count > 0 ) {

					mesh.compact();
					geometry = mesh.toThreejsJSON();
					faces.delete();

				}

				mesh.delete();

				break;

			case rhino.ObjectType.Extrusion:

				mesh = _geometry.getMesh( rhino.MeshType.Any );

				if ( mesh ) {

					geometry = mesh.toThreejsJSON();
					mesh.delete();

				}

				break;

			case rhino.ObjectType.TextDot:

				geometry = extractProperties( _geometry );

				break;

			case rhino.ObjectType.Light:

				geometry = extractProperties( _geometry );

				if ( geometry.lightStyle.name === 'LightStyle_WorldLinear' ) {

					self.postMessage( { type: 'warning', id: taskID, data: {
						message: \`THREE.3DMLoader: No conversion exists for \${objectType.constructor.name} \${geometry.lightStyle.name}\`,
						type: 'no conversion',
						guid: _attributes.id
					}

					} );

				}

				break;

			case rhino.ObjectType.InstanceReference:

				geometry = extractProperties( _geometry );
				geometry.xform = extractProperties( _geometry.xform );
				geometry.xform.array = _geometry.xform.toFloatArray( true );

				break;

			case rhino.ObjectType.SubD:

				// TODO: precalculate resulting vertices and faces and warn on excessive results
				_geometry.subdivide( 3 );
				mesh = rhino.Mesh.createFromSubDControlNet( _geometry, false );
				if ( mesh ) {

					geometry = mesh.toThreejsJSON();
					mesh.delete();

				}

				break;

				/*
				case rhino.ObjectType.Annotation:
				case rhino.ObjectType.Hatch:
				case rhino.ObjectType.ClipPlane:
				*/

			default:

				self.postMessage( { type: 'warning', id: taskID, data: {
					message: \`THREE.3DMLoader: Conversion not implemented for \${objectType.constructor.name}\`,
					type: 'not implemented',
					guid: _attributes.id
				}

				} );

				break;

		}

		if ( geometry ) {

			attributes = extractProperties( _attributes );
			attributes.geometry = extractProperties( _geometry );

			if ( _attributes.groupCount > 0 ) {

				attributes.groupIds = _attributes.getGroupList();

			}

			if ( _attributes.userStringCount > 0 ) {

				attributes.userStrings = _attributes.getUserStrings();

			}

			if ( _geometry.userStringCount > 0 ) {

				attributes.geometry.userStrings = _geometry.getUserStrings();

			}

			if ( _attributes.decals().count > 0 ) {

				self.postMessage( { type: 'warning', id: taskID, data: {
					message: \`THREE.3DMLoader: No conversion exists for the decals associated with this object.\`,
					type: 'no conversion',
					guid: _attributes.id
				}

				} );

			}

			attributes.drawColor = _attributes.drawColor( doc );

			objectType = objectType.constructor.name;
			objectType = objectType.substring( 11, objectType.length );

			return { geometry, attributes, objectType };

		} else {

			self.postMessage( { type: 'warning', id: taskID, data: {
				message: \`THREE.3DMLoader: \${objectType.constructor.name} has no associated mesh geometry.\`,
				type: 'missing mesh',
				guid: _attributes.id
			}

			} );

		}

	}

	function extractProperties( object ) {

		const result = {};

		for ( const property in object ) {

			const value = object[ property ];

			if ( typeof value !== 'function' ) {

				if ( typeof value === 'object' && value !== null && value.hasOwnProperty( 'constructor' ) ) {

					result[ property ] = { name: value.constructor.name, value: value.value };

				} else if ( typeof value === 'object' && value !== null ) {

					result[ property ] = extractProperties( value );

				} else {

					result[ property ] = value;

				}

			} else {

				// these are functions that could be called to extract more data.
				//console.log( \`\${property}: \${object[ property ].constructor.name}\` );

			}

		}

		return result;

	}

	function curveToPoints( curve, pointLimit ) {

		let pointCount = pointLimit;
		let rc = [];
		const ts = [];

		if ( curve instanceof rhino.LineCurve ) {

			return [ curve.pointAtStart, curve.pointAtEnd ];

		}

		if ( curve instanceof rhino.PolylineCurve ) {

			pointCount = curve.pointCount;
			for ( let i = 0; i < pointCount; i ++ ) {

				rc.push( curve.point( i ) );

			}

			return rc;

		}

		if ( curve instanceof rhino.PolyCurve ) {

			const segmentCount = curve.segmentCount;

			for ( let i = 0; i < segmentCount; i ++ ) {

				const segment = curve.segmentCurve( i );
				const segmentArray = curveToPoints( segment, pointCount );
				rc = rc.concat( segmentArray );
				segment.delete();

			}

			return rc;

		}

		if ( curve instanceof rhino.ArcCurve ) {

			pointCount = Math.floor( curve.angleDegrees / 5 );
			pointCount = pointCount < 2 ? 2 : pointCount;
			// alternative to this hardcoded version: https://stackoverflow.com/a/18499923/2179399

		}

		if ( curve instanceof rhino.NurbsCurve && curve.degree === 1 ) {

			const pLine = curve.tryGetPolyline();

			for ( let i = 0; i < pLine.count; i ++ ) {

				rc.push( pLine.get( i ) );

			}

			pLine.delete();

			return rc;

		}

		const domain = curve.domain;
		const divisions = pointCount - 1.0;

		for ( let j = 0; j < pointCount; j ++ ) {

			const t = domain[ 0 ] + ( j / divisions ) * ( domain[ 1 ] - domain[ 0 ] );

			if ( t === domain[ 0 ] || t === domain[ 1 ] ) {

				ts.push( t );
				continue;

			}

			const tan = curve.tangentAt( t );
			const prevTan = curve.tangentAt( ts.slice( - 1 )[ 0 ] );

			// Duplicated from THREE.Vector3
			// How to pass imports to worker?

			const tS = tan[ 0 ] * tan[ 0 ] + tan[ 1 ] * tan[ 1 ] + tan[ 2 ] * tan[ 2 ];
			const ptS = prevTan[ 0 ] * prevTan[ 0 ] + prevTan[ 1 ] * prevTan[ 1 ] + prevTan[ 2 ] * prevTan[ 2 ];

			const denominator = Math.sqrt( tS * ptS );

			let angle;

			if ( denominator === 0 ) {

				angle = Math.PI / 2;

			} else {

				const theta = ( tan.x * prevTan.x + tan.y * prevTan.y + tan.z * prevTan.z ) / denominator;
				angle = Math.acos( Math.max( - 1, Math.min( 1, theta ) ) );

			}

			if ( angle < 0.1 ) continue;

			ts.push( t );

		}

		rc = ts.map( t => curve.pointAt( t ) );
		return rc;

	}

}
`, Ei = class Ei extends iO {
  constructor(e) {
    super(e), this.materials = [], this.setLibraryPath(Ei.LIBRARY_PATH);
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  _createMaterial(e) {
    return Ei.ImportMaterials ? super._createMaterial(e) : this.materials[0] || new Go({
      color: new se(1, 1, 1),
      metalness: 0.8,
      name: "default",
      side: zi
    });
  }
  async loadAsync(e, t) {
    const i = await super.loadAsync(e, t);
    i.rotateX(-Math.PI / 2), i.userData.materials && delete i.userData.materials;
    const n = i.userData.layers;
    return i.traverse((r) => {
      var h, u, d, p;
      const a = (h = r.userData.attributes) == null ? void 0 : h.castsShadows, o = (u = r.userData.attributes) == null ? void 0 : u.receivesShadows;
      r.castShadow = a, r.receiveShadow = o;
      const l = ((d = r.userData.attributes) == null ? void 0 : d.layerIndex) ?? ((p = r.userData.defAttributes) == null ? void 0 : p.layerIndex), c = n[l];
      c && (r.userData.rhinoLayer = c), r.userData.rhino3dmRoot = i.uuid, Ei.LoadUserDataStrings || (r.userData.strings = []), Ei.LoadUserDataWarnings || delete r.userData.warnings, this._hideLineMesh(r), this._useInstancedMesh(r), this._useMaterialSource(r, c);
    }), this.materials = [], i;
  }
  _useMaterialSource(e, t) {
    var n, r, a, o, l;
    if (!Ei.ImportMaterials) return;
    const i = e;
    if (((n = i.material) == null ? void 0 : n.name) === "default" || Ei.ForceLayerMaterials) {
      const c = ((r = i.userData.attributes) == null ? void 0 : r.materialSource) || ((a = i.userData.defAttributes) == null ? void 0 : a.materialSource), h = ((o = i.userData.attributes) == null ? void 0 : o.colorSource) || ((l = i.userData.defAttributes) == null ? void 0 : l.colorSource);
      if (!Ei.ForceLayerMaterials && !c && !h) return;
      Ei.ForceLayerMaterials || (c == null ? void 0 : c.value) === 0 || (c == null ? void 0 : c.value) === 1 && (h == null ? void 0 : h.value) === 0 ? t && (i.material = this._compareMaterials(this._createMaterial({
        diffuseColor: t.color,
        name: t.name,
        transparency: 0,
        textures: []
      }))) : (c == null ? void 0 : c.value) === 3 || (c == null ? void 0 : c.value) === 1 && (h == null ? void 0 : h.value) === 3 ? i.traverseAncestors((u) => {
        u != null && u.material && (i.material = u.material);
      }) : c && c.value !== 1 && console.warn("Unknown material source", c, i, i.userData.attributes);
    }
  }
  _useInstancedMesh(e) {
    if (!Ei.ReplaceWithInstancedMesh || e.children.length <= 0) return;
    const t = e.children, i = t.map((r) => r.geometry);
    i.filter((r, a) => i.indexOf(r) === a).forEach((r) => {
      var l;
      const a = t.filter((c) => c.geometry === r), o = a.length > 0 ? a.filter((c) => c.material === a[0].material) : [];
      if (o.length > 1) {
        const c = new zp(r, o[0].material, o.length);
        c.userData = { ...o[0].userData }, c.userData.instanceUserData = [], c.userData.attributes = c.userData.defAttributes || c.userData.attributes, c.userData.defAttributes && delete c.userData.defAttributes, c.name = ((l = c.userData.attributes) == null ? void 0 : l.name) || o[0].name, o.forEach((h, u) => {
          c.setMatrixAt(u, h.matrix), e.remove(h), c.userData.instanceUserData.push(h.userData);
        }), e.add(c);
      }
    });
  }
  _hideLineMesh(e) {
    if (!Ei.HideLineMesh && !Ei.HidePointMesh || e.children.length <= 0) return;
    const t = [];
    e.traverse((i) => {
      (i && Ei.HideLineMesh && (i.isLine || i.isLineSegments) || Ei.HidePointMesh && i.isPoints) && t.push(i);
    }), t.forEach((i) => {
      i.userData.visible_3dm = i.visible, i.visible = !1;
    });
  }
};
Ei.LIBRARY_PATH = `https://cdn.jsdelivr.net/npm/rhino3dm@${HA("rhino3dm", "8.0.1")}/`, Ei.ImportMaterials = !0, Ei.ForceLayerMaterials = !1, Ei.ReplaceWithInstancedMesh = !1, Ei.HideLineMesh = !1, Ei.HidePointMesh = !1, Ei.LoadUserDataStrings = !0, Ei.LoadUserDataWarnings = !0;
let lr = Ei;
const Ol = class Ol extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = Ol.USE_CANVAS_TEXTURE ? document.createElement("canvas") : void 0, a = Ol.USE_CANVAS_TEXTURE ? new Qp(r) : new Nt(), o = new Gh(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(l) {
      r ? Ol.CopyImageToCanvas(r, l) : a.image = l, a.needsUpdate = !0, t !== void 0 && t(a);
    }, i, n), a;
  }
  static CopyImageToCanvas(e, t) {
    e.width = t.naturalWidth || t.width || 512, e.height = t.naturalHeight || t.height || 512;
    const i = e.getContext("2d");
    i ? (i.clearRect(0, 0, e.width, e.height), i.drawImage(t, 0, 0, e.width, e.height)) : console.error("SVGTextureLoader: Failed to get canvas context.");
  }
};
Ol.USE_CANVAS_TEXTURE = HA("svg-load-disable-canvas") !== "true";
let Gg = Ol;
const Dy = class Dy extends Vi {
  constructor(e = !1) {
    super(), this._logger = console.log, this._loaderCache = [], this._fileDatabase = /* @__PURE__ */ new Map(), this._cachedAssets = [], this.cacheImportedAssets = !0, this.importers = [
      // new Importer(VideoTextureLoader, ['mp4', 'ogg', 'mov', 'data:video'], false),
      new $i(cb, ["json", "vjson"], ["application/json"], !1),
      new $i(ti, ["txt"], ["text/plain"], !1)
      // new Importer(RGBEPNGLoader, ['rgbe.png', 'hdr.png', 'hdrpng'], ['image/png+rgbe'], false), // todo: not working on windows?
      // new Importer(LUTCubeLoader2, ['cube'], false),
    ], this._urlModifiers = [], e || (this._logger = () => {
    }), this._onLoad = this._onLoad.bind(this), this._onProgress = this._onProgress.bind(this), this._onError = this._onError.bind(this), this._onStart = this._onStart.bind(this), this._urlModifier = this._urlModifier.bind(this), this._loadingManager = new BA(this._onLoad, this._onProgress, this._onError), this._loadingManager.onStart = this._onStart, this._loadingManager.setURLModifier(this._urlModifier);
  }
  get loadingManager() {
    return this._loadingManager;
  }
  get cachedAssets() {
    return this._cachedAssets;
  }
  addImporter(...e) {
    for (const t of e) {
      if (this.importers.includes(t)) {
        console.warn("AssetImporter: Importer already added", t);
        return;
      }
      this.importers.push(t);
    }
  }
  removeImporter(...e) {
    for (const t of e) {
      const i = this.importers.indexOf(t);
      i >= 0 && this.importers.splice(i, 1);
    }
  }
  // region import functions
  async import(e, t) {
    return e ? Array.isArray(e) ? (await Promise.all(e.map(async (i) => this.import(i, t)))).flat(1) : e instanceof File ? await this.importFile(e, t) : typeof e == "object" ? await this.importAsset(e, t) : typeof e == "string" ? await this.importPath(e, t) : (console.error("AssetImporter: Invalid asset or path", e), []) : [];
  }
  async importSingle(e, t) {
    var i;
    return (i = await this.import(e, t)) == null ? void 0 : i[0];
  }
  async importPath(e, t = {}) {
    const i = { ...t };
    delete i.pathOverride, delete i.forceImport, delete i.reimportDisposed, delete i.fileHandler, delete i.importedFile;
    const n = JSON.stringify(i), r = this._cachedAssets.find((o) => o.path === e && o._options === n);
    let a;
    return r ? a = r : a = { path: e }, a._options = n, t.importedFile && (a.file = t.importedFile), await this.importAsset(a, t);
  }
  // import and process an IAsset
  async importAsset(e, t = {}, i) {
    var a;
    if (!e) return [];
    if (!e.path && !e.file && !t.pathOverride)
      return [e];
    if (!this._cachedAssets.includes(e)) {
      if (Object.entries(e).length === 1 && e.path) {
        const l = this._cachedAssets.find((c) => c.path === e.path);
        l && Object.assign(e, l);
      }
      const o = this._cachedAssets.findIndex((l) => l.path === e.path);
      o >= 0 && this._cachedAssets.splice(o, 1), this._cachedAssets.push(e);
    }
    let n = e == null ? void 0 : e.preImported;
    !n && (e != null && e.preImportedRaw) && (n = await e.preImportedRaw);
    const r = t.pathOverride || e.path;
    if (!t.forceImport && n)
      return await this.processRaw(n, t, r);
    if (e.preImportedRaw = this._loadFile(r, typeof ((a = e.file) == null ? void 0 : a.arrayBuffer) == "function" ? e.file : void 0, t, i), n = await e.preImportedRaw, this.cacheImportedAssets || (e.preImportedRaw = void 0), n && (n = await this.processRaw(n, t, r)), n) {
      t.processRaw !== !1 && this.cacheImportedAssets && (e.preImported = n);
      const o = [], l = (c) => {
        var h;
        (h = c.userData) != null && h.rootSceneModelRoot ? o.push(...c.children) : o.push(c);
      };
      Array.isArray(n) ? n.map(l) : l(n), o.forEach((c) => (c == null ? void 0 : c.addEventListener) && c.addEventListener("dispose", () => {
        e != null && e.preImportedRaw && (e.preImportedRaw = void 0), e != null && e.preImported && (e.preImported = void 0);
      }));
    }
    return n;
  }
  async importFile(e, t = {}, i) {
    return e ? e instanceof File ? this.importAsset(this._cachedAssets.find((n) => n.file === e) ?? {
      path: e.name || e.webkitRelativePath,
      file: e
    }, t, i) : (console.error("AssetImporter: Invalid file", e), []) : [];
  }
  /**
   * Import multiple local files/blobs from a map of files, like when a local folder is loaded, or when multiple files are dropped.
   * @param files
   * @param options
   */
  async importFiles(e, t = {}) {
    const i = /* @__PURE__ */ new Map();
    let { allowedExtensions: n } = t;
    if (n && n.length < 1 && (n = void 0), e.size === 0) return i;
    this.dispatchEvent({ type: "importFiles", files: e, state: "start" });
    const r = [], a = [];
    if (e.forEach((o, l) => {
      this.registerFile(l, o);
      const c = o.ext, h = o.mime;
      (c || h) && // todo: files with no extensions are not supported right now. This also includes __MacOSX
      ((n == null ? void 0 : n.includes((c || h || "").toLowerCase())) ?? !0) && (this._isRootFile(c) ? r.push(l) : a.push(l));
    }), r.length > 0)
      for (const o of r) {
        let l = await this._loadFile(o, void 0, t);
        l && (l = await this.processRaw(l, t, o)), i.set(o, l);
      }
    else
      for (const o of a) {
        let l = await this._loadFile(o, void 0, t);
        l && (l = await this.processRaw(l, t, o)), i.set(o, l);
      }
    return this.dispatchEvent({ type: "importFiles", files: e, state: "end" }), e.forEach((o, l) => this.unregisterFile(l)), i;
  }
  // load a single file
  async _loadFile(e, t, i = {}, n) {
    this.dispatchEvent({ type: "importFile", path: e, state: "downloading", progress: 0 });
    let r;
    try {
      const a = this.registerFile(e, t, i.fileExtension, i.fileHandler);
      if (!a)
        throw new Error("AssetImporter: Unable to find loader for " + e);
      this._rootContext = {
        path: e,
        rootUrl: hr.extractUrlBase(e)
        // baseUrl: LoaderUtils.extractUrlBase(url),
      }, a.importOptions = i, r = await a.loadAsync(e + (i.queryString ? (e.includes("?") ? "&" : "?") + i.queryString : ""), (o) => {
        n && n(o);
        const l = o.lengthComputable ? o.total : void 0;
        this.dispatchEvent({
          type: "importFile",
          path: e,
          state: "downloading",
          loadedBytes: o.loaded || void 0,
          totalBytes: l && l < o.loaded ? o.loaded : o.total || void 0,
          // sometimes total is more than e.loaded
          progress: l && l > 0 && l > o.loaded ? o.loaded / l : 1
        });
      }), a.transform && (r = await a.transform(r, i)), delete a.importOptions, this._rootContext = void 0, this.dispatchEvent({ type: "importFile", path: e, state: "downloading", progress: 1 }), this.dispatchEvent({ type: "importFile", path: e, state: "adding" }), t ? this._logger("AssetImporter: loaded", e) : this._logger("AssetImporter: downloaded", e), t && this.unregisterFile(e);
    } catch (a) {
      return console.error("AssetImporter: Unable to import file", e, t), console.error(a), console.error(a == null ? void 0 : a.stack), this.dispatchEvent({ type: "importFile", path: e, state: "error", error: a }), t && this.unregisterFile(e), [];
    }
    if (this.dispatchEvent({ type: "importFile", path: e, state: "done" }), r && typeof r == "object" && !Array.isArray(r)) {
      r.__rootPath = e;
      const a = t || this._fileDatabase.get(e);
      a && (r.__rootBlob = a);
    }
    return r;
  }
  // endregion
  // region file database
  /**
   * Register a file in the database and return a loader for it. If the loader does not exist, it will be created.
   * @param path
   * @param file
   * @param extension
   * @param loader
   */
  registerFile(e, t, i, n) {
    var l;
    const r = e.startsWith("data:") || !1;
    r || (e = e.replace(/\?.*$/, ""));
    const a = i || (r ? void 0 : (t == null ? void 0 : t.ext) ?? ((l = og((t == null ? void 0 : t.name) ?? e.trim())) == null ? void 0 : l.toLowerCase())), o = ((t == null ? void 0 : t.mime) ?? r) && e.slice(0, e.indexOf(";")).split(":")[1] || void 0;
    return t && (t.name === void 0 && (t.name = e), t.ext || (t.ext = a), t.mime || (t.mime = o), this._fileDatabase.has(e) && (console.warn("AssetImporter: File already registered, replacing", e), this.unregisterFile(e)), this._fileDatabase.set(e, t)), n || this._getLoader(e, a, o) || this._createLoader(e, a, o);
  }
  /**
   * Remove a file from the database and revoke the object url if it exists.
   * @param path
   */
  unregisterFile(e) {
    e = e.replace(/\?.*$/, "");
    const t = this._fileDatabase.get(e);
    t != null && t.objectUrl && (URL.revokeObjectURL(t.objectUrl), t.objectUrl = void 0), t && this._fileDatabase.delete(e);
  }
  // endregion
  // region processRaw
  async processRaw(e, t, i) {
    var n, r;
    if (!e) return [];
    if (t.processImported !== void 0 && (console.error("AssetImporter: processImported is deprecated, use processRaw instead"), t.processRaw = t.processImported), Array.isArray(e)) {
      const a = [];
      for (const o of e)
        a.push(...await this.processRaw(o, t, i));
      return a;
    }
    if (t.processRaw === !1) return [e];
    if (e.assetImporterProcessed && !t.forceImporterReprocess) return [e];
    if (this.dispatchEvent({ type: "processRawStart", data: e, options: t, path: i }), e.isTexture && t._testDataTextureComplete && (e.isDataTexture && ((n = e.image) != null && n.data) && (e.image.complete = !0), (r = e.image) != null && r.complete && (e.needsUpdate = !0)), e.userData) {
      const a = e.userData, o = e.__rootPath;
      !a.rootPath && o && !o.startsWith("blob:") && !o.startsWith("/") && (a.rootPath = o), e.__rootBlob && (a.__sourceBlob = e.__rootBlob, a.__needsSourceBuffer && (a.__sourceBuffer = await e.__rootBlob.arrayBuffer(), delete a.__needsSourceBuffer));
    }
    return e.userData.rootSceneModelRoot && (e._childrenCopy = [...e.children]), e.assetImporterProcessed = !0, this.dispatchEvent({ type: "processRaw", data: e, options: t, path: i }), e instanceof Map && t.autoImportZipContents !== !1 ? [...(await this.importFiles(e, t)).values()].flat() : [e];
  }
  async processRawSingle(e, t, i) {
    return (await this.processRaw(e, t, i))[0];
  }
  // endregion
  // region disposal
  dispose() {
    this.clearCache();
  }
  /**
   * Clear memory asset and loader cache. Browser cache and custom cache storage is not cleared with this.
   */
  clearCache() {
    this._cachedAssets = [], this.unregisterAllFiles(), this.clearLoaderCache();
  }
  unregisterAllFiles() {
    const e = [...this._fileDatabase.keys()];
    for (const t of e)
      this.unregisterFile(t);
  }
  clearLoaderCache() {
    var e, t;
    for (const i of this._loaderCache)
      (e = i.loader) != null && e.dispose && ((t = i.loader) == null || t.dispose());
    this._loaderCache = [];
  }
  // endregion
  // region utils
  resolveURL(e) {
    return this._loadingManager.resolveURL(e);
  }
  addURLModifier(e) {
    this._urlModifiers.push(e);
  }
  removeURLModifier(e) {
    const t = this._urlModifiers.indexOf(e);
    t >= 0 && this._urlModifiers.splice(t, 1);
  }
  _urlModifier(e) {
    var a;
    e = this._urlModifiers.reduce((o, l) => l(o), e);
    let t = decodeURI(e);
    const i = (a = this._rootContext) == null ? void 0 : a.rootUrl;
    !t.includes("://") && i && !t.startsWith(i) && (t = i + t), t = t.replace("./", ""), t = t.replace(/^(\/\/)/, "/"), t = t.replace(/\?.*$/, "");
    const n = this._fileDatabase.get(t);
    return n ? n.ext ? (n.objectUrl || (n.objectUrl = URL.createObjectURL(n) + "#" + t), n.objectUrl) : (console.error("Unable to determine file extension", n), e) : e;
  }
  _isRootFile(e, t) {
    return t = t == null ? void 0 : t.toLowerCase(), e = e == null ? void 0 : e.toLowerCase(), this.importers.find((i) => i.root && (e && i.ext.includes(e.toLowerCase()) || t && i.mime.includes(t.toLowerCase()))) != null;
  }
  // get an importer that can create a loader
  _getImporter(e, t, i, n = !1) {
    return i = i == null ? void 0 : i.toLowerCase(), t = t == null ? void 0 : t.toLowerCase(), this.importers.find((r) => {
      var a;
      return n && !r.root ? !1 : !!(i && ((a = r.mime) != null && a.find((o) => i === o)) || r.ext.find((o) => {
        var l;
        return t ? o === t : ((l = e == null ? void 0 : e.toLowerCase()) == null ? void 0 : l.endsWith("." + o)) || (o == null ? void 0 : o.startsWith("data:")) && (e == null ? void 0 : e.startsWith(o));
      }));
    });
  }
  // get a loader that can load a file.
  _getLoader(e, t, i) {
    var n;
    return !t && !i && e && (t = og(e).toLowerCase()), i = i == null ? void 0 : i.toLowerCase().trim(), t = t == null ? void 0 : t.toLowerCase().trim(), (e ? this._loadingManager.getHandler(e.trim()) : void 0) || ((n = this._loaderCache.find((r) => t && r.ext.includes(t) || i && r.mime.includes(i))) == null ? void 0 : n.loader);
  }
  _createLoader(e, t, i) {
    var a;
    const n = this._getImporter(e, t, i);
    if (!n) return;
    const r = n.ctor(this);
    if (r)
      return n.ext.forEach((o) => {
        const l = new RegExp(o.startsWith("data:") ? "^" + ux(o) + "[\\/\\+\\:\\,\\;]" : "\\." + o + "$", "i");
        this._loadingManager.addHandler(l, r);
      }), (a = n.mime) == null || a.forEach((o) => {
        const l = new RegExp("^data:" + ux(o) + "[\\/\\+\\:\\,\\;]", "i");
        this._loadingManager.addHandler(l, r);
      }), this._loaderCache.push({ loader: r, ext: n.ext, mime: n.mime }), this.dispatchEvent({ type: "loaderCreate", loader: r }), r;
  }
  addEventListener(e, t) {
    if (super.addEventListener(e, t), e === "loaderCreate")
      for (const i of this._loaderCache)
        this.dispatchEvent({ type: "loaderCreate", loader: i.loader });
  }
  // endregion
  // region Loader Event Dispatchers
  _onLoad() {
    this.dispatchEvent({ type: "onLoad" });
  }
  _onProgress(e, t, i) {
    this.dispatchEvent({ type: "onProgress", url: e, loaded: t, total: i });
  }
  _onError(e) {
    this.dispatchEvent({ type: "onError", url: e });
  }
  _onStart(e, t, i) {
    this.dispatchEvent({ type: "onStart", url: e, loaded: t, total: i });
  }
  // endregion
  // region deprecated
  /**
   * @deprecated use {@link processRaw} instead
   * @param res
   * @param options
   */
  async processImported(e, t, i) {
    return console.error("processImported is deprecated. Use processRaw instead."), await this.processRaw(e, t, i);
  }
  // endregion
};
Dy.WHITE_IMAGE_DATA = new ImageData(new Uint8ClampedArray([255, 255, 255, 255]), 1, 1);
let qh = Dy;
function ux(s) {
  return RegExp.escape ? RegExp.escape(s) : s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
let Md, xm, xl, Td;
function wm(s, e = 1 / 0, t = null) {
  xm || (xm = new No(2, 2, 1, 1)), xl || (xl = new ln({
    uniforms: { blitTexture: new zA(s) },
    vertexShader: `
            varying vec2 vUv;
            void main(){
                vUv = uv;
                gl_Position = vec4(position.xy * 1.0,0.,.999999);
            }`,
    fragmentShader: `
            uniform sampler2D blitTexture; 
            varying vec2 vUv;

            void main(){ 
                gl_FragColor = vec4(vUv.xy, 0, 1);
                
                #ifdef IS_SRGB
                gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
                #else
                gl_FragColor = texture2D( blitTexture, vUv);
                #endif
            }`
  })), xl.uniforms.blitTexture.value = s, xl.defines.IS_SRGB = s.colorSpace == dt, xl.needsUpdate = !0, Td || (Td = new Se(xm, xl), Td.frustrumCulled = !1);
  const i = new ki(), n = new tc();
  n.add(Td), t || (t = Md = new kp({ antialias: !1 })), t.setSize(Math.min(s.image.width, e), Math.min(s.image.height, e)), t.clear(), t.render(n, i);
  const r = new Nt(t.domElement);
  return r.minFilter = s.minFilter, r.magFilter = s.magFilter, r.wrapS = s.wrapS, r.wrapT = s.wrapT, r.name = s.name, Md && (Md.dispose(), Md = null), r;
}
const dx = {
  POSITION: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "unsigned byte normalized",
    "short",
    "short normalized",
    "unsigned short",
    "unsigned short normalized"
  ],
  NORMAL: [
    "byte normalized",
    "short normalized"
  ],
  TANGENT: [
    "byte normalized",
    "short normalized"
  ],
  TEXCOORD: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "short",
    "short normalized",
    "unsigned short"
  ]
};
class rf {
  constructor() {
    this.pluginCallbacks = [], this.register(function(e) {
      return new dO(e);
    }), this.register(function(e) {
      return new pO(e);
    }), this.register(function(e) {
      return new gO(e);
    }), this.register(function(e) {
      return new AO(e);
    }), this.register(function(e) {
      return new yO(e);
    }), this.register(function(e) {
      return new vO(e);
    }), this.register(function(e) {
      return new fO(e);
    }), this.register(function(e) {
      return new mO(e);
    }), this.register(function(e) {
      return new _O(e);
    }), this.register(function(e) {
      return new xO(e);
    }), this.register(function(e) {
      return new wO(e);
    }), this.register(function(e) {
      return new EO(e);
    });
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Function} onError  Callback on errors
   * @param  {Object} options options
   */
  parse(e, t, i, n, r) {
    const a = r || new Kb(), o = [];
    for (let l = 0, c = this.pluginCallbacks.length; l < c; l++)
      o.push(this.pluginCallbacks[l](a));
    a.setPlugins(o), a.write(e, t, n).catch(i);
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function(n, r) {
      i.parse(e, n, r, t);
    });
  }
}
const Dt = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
}, Em = "KHR_mesh_quantization", ds = {};
ds[pi] = Dt.NEAREST;
ds[Jl] = Dt.NEAREST_MIPMAP_NEAREST;
ds[co] = Dt.NEAREST_MIPMAP_LINEAR;
ds[tt] = Dt.LINEAR;
ds[nu] = Dt.LINEAR_MIPMAP_NEAREST;
ds[Qn] = Dt.LINEAR_MIPMAP_LINEAR;
ds[Zt] = Dt.CLAMP_TO_EDGE;
ds[xn] = Dt.REPEAT;
ds[Xr] = Dt.MIRRORED_REPEAT;
const px = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
}, sO = new se(), fx = 12, rO = 1179937895, aO = 2, mx = 8, oO = 1313821514, lO = 5130562;
function Ah(s, e) {
  return s.length === e.length && s.every(function(t, i) {
    return t === e[i];
  });
}
function cO(s) {
  return new TextEncoder().encode(s).buffer;
}
function hO(s) {
  return Ah(s.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
function uO(s, e, t) {
  const i = {
    min: new Array(s.itemSize).fill(Number.POSITIVE_INFINITY),
    max: new Array(s.itemSize).fill(Number.NEGATIVE_INFINITY)
  };
  for (let n = e; n < e + t; n++)
    for (let r = 0; r < s.itemSize; r++) {
      let a;
      s.itemSize > 4 ? a = s.array[n * s.itemSize + r] : (r === 0 ? a = s.getX(n) : r === 1 ? a = s.getY(n) : r === 2 ? a = s.getZ(n) : r === 3 && (a = s.getW(n)), s.normalized === !0 && (a = ri.normalize(a, s.array))), i.min[r] = Math.min(i.min[r], a), i.max[r] = Math.max(i.max[r], a);
    }
  return i;
}
function Yb(s) {
  return Math.ceil(s / 4) * 4;
}
function Id(s, e = 0) {
  const t = Yb(s.byteLength);
  if (t !== s.byteLength) {
    const i = new Uint8Array(t);
    if (i.set(new Uint8Array(s)), e !== 0)
      for (let n = s.byteLength; n < t; n++)
        i[n] = e;
    return i.buffer;
  }
  return s;
}
function gx() {
  return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
}
function Ax(s, e) {
  if (s.toBlob !== void 0)
    return new Promise((i) => s.toBlob(i, e));
  let t;
  return e === "image/jpeg" ? t = 0.92 : e === "image/webp" && (t = 0.8), s.convertToBlob({
    type: e,
    quality: t
  });
}
class Kb {
  constructor() {
    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter"
      }
    }, this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
  }
  setPlugins(e) {
    this.plugins = e;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  async write(e, t, i = {}) {
    this.options = Object.assign({
      // default options
      binary: !1,
      trs: !1,
      onlyVisible: !0,
      maxTextureSize: 1 / 0,
      animations: [],
      includeCustomExtensions: !1,
      ignoreInvalidMorphTargetTracks: !1,
      ignoreEmptyTextures: !1
    }, i), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending);
    const n = this, r = n.buffers, a = n.json;
    i = n.options;
    const o = n.extensionsUsed, l = n.extensionsRequired, c = new Blob(r, { type: "application/octet-stream" }), h = Object.keys(o), u = Object.keys(l);
    if (h.length > 0 && (a.extensionsUsed = h), u.length > 0 && (a.extensionsRequired = u), a.buffers && a.buffers.length > 0 && (a.buffers[0].byteLength = c.size), i.binary === !0) {
      const d = new FileReader();
      d.readAsArrayBuffer(c), d.onloadend = function() {
        const p = Id(d.result), f = new DataView(new ArrayBuffer(mx));
        f.setUint32(0, p.byteLength, !0), f.setUint32(4, lO, !0);
        const y = Id(cO(JSON.stringify(a)), 32), A = new DataView(new ArrayBuffer(mx));
        A.setUint32(0, y.byteLength, !0), A.setUint32(4, oO, !0);
        const m = new ArrayBuffer(fx), v = new DataView(m);
        v.setUint32(0, rO, !0), v.setUint32(4, aO, !0);
        const g = fx + A.byteLength + y.byteLength + f.byteLength + p.byteLength;
        v.setUint32(8, g, !0);
        const _ = new Blob([
          m,
          A,
          y,
          f,
          p
        ], { type: "application/octet-stream" }), w = new FileReader();
        w.readAsArrayBuffer(_), w.onloadend = function() {
          t(w.result);
        };
      };
    } else if (a.buffers && a.buffers.length > 0) {
      const d = new FileReader();
      d.readAsDataURL(c), d.onloadend = function() {
        const p = d.result;
        a.buffers[0].uri = p, t(a);
      };
    } else
      t(a);
  }
  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(e, t) {
    if (Object.keys(e.userData).length === 0) return;
    const i = this.options, n = this.extensionsUsed;
    try {
      const r = JSON.parse(JSON.stringify(e.userData));
      if (i.includeCustomExtensions && r.gltfExtensions) {
        t.extensions === void 0 && (t.extensions = {});
        for (const a in r.gltfExtensions)
          t.extensions[a] = r.gltfExtensions[a], n[a] = !0;
        delete r.gltfExtensions;
      }
      Object.keys(r).length > 0 && (t.extras = r);
    } catch (r) {
      console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + r.message), console.warn({ ...e.userData });
    }
  }
  /**
   * Returns ids for buffer attributes.
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(e, t = !1) {
    if (this.uids.has(e) === !1) {
      const n = /* @__PURE__ */ new Map();
      n.set(!0, this.uid++), n.set(!1, this.uid++), this.uids.set(e, n);
    }
    return this.uids.get(e).get(t);
  }
  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(e) {
    if (this.cache.attributesNormalized.has(e)) return !1;
    const i = new M();
    for (let n = 0, r = e.count; n < r; n++)
      if (Math.abs(i.fromBufferAttribute(e, n).length() - 1) > 5e-4) return !1;
    return !0;
  }
  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(e) {
    const t = this.cache;
    if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e);
    const i = e.clone(), n = new M();
    for (let r = 0, a = i.count; r < a; r++)
      n.fromBufferAttribute(i, r), n.x === 0 && n.y === 0 && n.z === 0 ? n.setX(1) : n.normalize(), i.setXYZ(r, n.x, n.y, n.z);
    return t.attributesNormalized.set(e, i), i;
  }
  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(e, t) {
    let i = !1;
    const n = {};
    (t.offset.x !== 0 || t.offset.y !== 0) && (n.offset = t.offset.toArray(), i = !0), t.rotation !== 0 && (n.rotation = t.rotation, i = !0), (t.repeat.x !== 1 || t.repeat.y !== 1) && (n.scale = t.repeat.toArray(), i = !0), i && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = n, this.extensionsUsed.KHR_texture_transform = !0);
  }
  buildMetalRoughTexture(e, t) {
    if (e === t) return e;
    function i(p) {
      return p.colorSpace === dt ? function(y) {
        return y < 0.04045 ? y * 0.0773993808 : Math.pow(y * 0.9478672986 + 0.0521327014, 2.4);
      } : function(y) {
        return y;
      };
    }
    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), e instanceof ba && (e = wm(e)), t instanceof ba && (t = wm(t));
    const n = e ? e.image : null, r = t ? t.image : null, a = Math.max(n ? n.width : 0, r ? r.width : 0), o = Math.max(n ? n.height : 0, r ? r.height : 0), l = gx();
    l.width = a, l.height = o;
    const c = l.getContext("2d");
    c.fillStyle = "#00ffff", c.fillRect(0, 0, a, o);
    const h = c.getImageData(0, 0, a, o);
    if (n) {
      c.drawImage(n, 0, 0, a, o);
      const p = i(e), f = c.getImageData(0, 0, a, o).data;
      for (let y = 2; y < f.length; y += 4)
        h.data[y] = p(f[y] / 256) * 256;
    }
    if (r) {
      c.drawImage(r, 0, 0, a, o);
      const p = i(t), f = c.getImageData(0, 0, a, o).data;
      for (let y = 1; y < f.length; y += 4)
        h.data[y] = p(f[y] / 256) * 256;
    }
    c.putImageData(h, 0, 0);
    const d = (e || t).clone();
    return d.source = new Aa(l), d.colorSpace = Wt, d.channel = (e || t).channel, e && t && e.channel !== t.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), d;
  }
  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(e) {
    const t = this.json, i = this.buffers;
    return t.buffers || (t.buffers = [{ byteLength: 0 }]), i.push(e), 0;
  }
  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(e, t, i, n, r) {
    const a = this.json;
    a.bufferViews || (a.bufferViews = []);
    let o;
    switch (t) {
      case Dt.BYTE:
      case Dt.UNSIGNED_BYTE:
        o = 1;
        break;
      case Dt.SHORT:
      case Dt.UNSIGNED_SHORT:
        o = 2;
        break;
      default:
        o = 4;
    }
    const l = Yb(n * e.itemSize * o), c = new DataView(new ArrayBuffer(l));
    let h = 0;
    for (let p = i; p < i + n; p++)
      for (let f = 0; f < e.itemSize; f++) {
        let y;
        e.itemSize > 4 ? y = e.array[p * e.itemSize + f] : (f === 0 ? y = e.getX(p) : f === 1 ? y = e.getY(p) : f === 2 ? y = e.getZ(p) : f === 3 && (y = e.getW(p)), e.normalized === !0 && (y = ri.normalize(y, e.array))), t === Dt.FLOAT ? c.setFloat32(h, y, !0) : t === Dt.INT ? c.setInt32(h, y, !0) : t === Dt.UNSIGNED_INT ? c.setUint32(h, y, !0) : t === Dt.SHORT ? c.setInt16(h, y, !0) : t === Dt.UNSIGNED_SHORT ? c.setUint16(h, y, !0) : t === Dt.BYTE ? c.setInt8(h, y) : t === Dt.UNSIGNED_BYTE && c.setUint8(h, y), h += o;
      }
    const u = {
      buffer: this.processBuffer(c.buffer),
      byteOffset: this.byteOffset,
      byteLength: l
    };
    return r !== void 0 && (u.target = r), r === Dt.ARRAY_BUFFER && (u.byteStride = e.itemSize * o), this.byteOffset += l, a.bufferViews.push(u), {
      id: a.bufferViews.length - 1,
      byteLength: 0
    };
  }
  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(e) {
    const t = this, i = t.json;
    return i.bufferViews || (i.bufferViews = []), new Promise(function(n) {
      const r = new FileReader();
      r.readAsArrayBuffer(e), r.onloadend = function() {
        const a = Id(r.result), o = {
          buffer: t.processBuffer(a),
          byteOffset: t.byteOffset,
          byteLength: a.byteLength
        };
        t.byteOffset += a.byteLength, n(i.bufferViews.push(o) - 1);
      };
    });
  }
  processBufferViewImageBuffer(e) {
    const t = this, i = t.json;
    i.bufferViews || (i.bufferViews = []), e = Id(e);
    const n = {
      buffer: t.processBuffer(e),
      byteOffset: t.byteOffset,
      byteLength: e.byteLength
    };
    return t.byteOffset += e.byteLength, i.bufferViews.push(n) - 1;
  }
  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(e, t, i, n) {
    const r = this.json, a = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      9: "MAT3",
      16: "MAT4"
    };
    let o;
    if (e.array.constructor === Float32Array)
      o = Dt.FLOAT;
    else if (e.array.constructor === Int32Array)
      o = Dt.INT;
    else if (e.array.constructor === Uint32Array)
      o = Dt.UNSIGNED_INT;
    else if (e.array.constructor === Int16Array)
      o = Dt.SHORT;
    else if (e.array.constructor === Uint16Array)
      o = Dt.UNSIGNED_SHORT;
    else if (e.array.constructor === Int8Array)
      o = Dt.BYTE;
    else if (e.array.constructor === Uint8Array)
      o = Dt.UNSIGNED_BYTE;
    else
      throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e.array.constructor.name);
    if (i === void 0 && (i = 0), (n === void 0 || n === 1 / 0) && (n = e.count), n === 0) return null;
    const l = uO(e, i, n);
    let c;
    t !== void 0 && (c = e === t.index ? Dt.ELEMENT_ARRAY_BUFFER : Dt.ARRAY_BUFFER);
    const h = this.processBufferView(e, o, i, n, c), u = {
      bufferView: h.id,
      byteOffset: h.byteOffset,
      componentType: o,
      count: n,
      max: l.max,
      min: l.min,
      type: a[e.itemSize]
    };
    return e.normalized === !0 && (u.normalized = !0), r.accessors || (r.accessors = []), r.accessors.push(u) - 1;
  }
  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @param  {String} mimeType export format
   * @param  {Integer} width override image width
   * @param  {Integer} height override image height
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(e, t, i, n = "image/png", r = void 0, a = void 0) {
    if (e !== null) {
      const o = this, l = o.cache, c = o.json, h = o.options, u = o.pending;
      l.images.has(e) || l.images.set(e, {});
      const d = l.images.get(e), p = n + ":flipY/" + i.toString() + (r || a ? ";" + r + ";" + a : "");
      if (d[p] !== void 0) return d[p];
      c.images || (c.images = []);
      const f = { mimeType: n }, y = gx();
      y.width = Math.min(r || e.width, h.maxTextureSize), y.height = Math.min(a || e.height, h.maxTextureSize);
      const A = y.getContext("2d");
      if (i === !0 && (A.translate(0, y.height), A.scale(1, -1)), e.data !== void 0) {
        t !== ei && console.error("GLTFExporter: Only RGBAFormat is supported.", t), (e.width > h.maxTextureSize || e.height > h.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
        const v = new Uint8ClampedArray(e.height * e.width * 4);
        for (let g = 0; g < v.length; g += 4)
          v[g + 0] = e.data[g + 0], v[g + 1] = e.data[g + 1], v[g + 2] = e.data[g + 2], v[g + 3] = e.data[g + 3];
        A.putImageData(new ImageData(v, e.width, e.height), 0, 0);
      } else
        A.drawImage(e, 0, 0, y.width, y.height);
      h.binary === !0 ? u.push(
        Ax(y, n).then((v) => o.processBufferViewImage(v)).then((v) => {
          f.bufferView = v;
        })
      ) : y.toDataURL !== void 0 ? f.uri = y.toDataURL(n) : u.push(
        Ax(y, n).then((v) => new FileReader().readAsDataURL(v)).then((v) => {
          f.uri = v;
        })
      );
      const m = c.images.push(f) - 1;
      return d[p] = m, m;
    } else
      throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
  }
  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(e) {
    const t = this.json;
    t.samplers || (t.samplers = []);
    const i = {
      magFilter: ds[e.magFilter],
      minFilter: ds[e.minFilter],
      wrapS: ds[e.wrapS],
      wrapT: ds[e.wrapT]
    };
    return t.samplers.push(i) - 1;
  }
  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(e) {
    const i = this.options, n = this.cache, r = this.json;
    if (n.textures.has(e)) return n.textures.get(e);
    r.textures || (r.textures = []), e instanceof ba && !e.source._canSerialize && (e = wm(e, i.maxTextureSize));
    let a = e.userData.mimeType;
    a === "image/webp" && (a = "image/png"), a === "image/jpg" && (a = "image/jpeg");
    const o = ["image/jpeg", "image/png"], l = {
      sampler: this.processSampler(e),
      source: !a || o.includes(a) ? this.processImage(e.image, e.format, e.flipY, a) : null
    };
    e.name && (l.name = e.name), this._invokeAll(function(h) {
      h.writeTexture && h.writeTexture(e, l);
    }), l.source === null && console.error("GLTFExporter: Unsupported mime type: " + a + ". Cannot export texture.", e);
    const c = r.textures.push(l) - 1;
    return n.textures.set(e, c), c;
  }
  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(e) {
    const t = this.cache, i = this.json;
    if (t.materials.has(e)) return t.materials.get(e);
    if (e.isShaderMaterial)
      return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
    i.materials || (i.materials = []);
    const n = { pbrMetallicRoughness: {} };
    e.isMeshStandardMaterial !== !0 && e.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    const r = e.color.toArray().concat([e.opacity]);
    if (Ah(r, [1, 1, 1, 1]) || (n.pbrMetallicRoughness.baseColorFactor = r), e.isMeshStandardMaterial ? (n.pbrMetallicRoughness.metallicFactor = e.metalness, n.pbrMetallicRoughness.roughnessFactor = e.roughness) : (n.pbrMetallicRoughness.metallicFactor = 0.5, n.pbrMetallicRoughness.roughnessFactor = 0.5), this.checkEmptyMap(e.metalnessMap) || this.checkEmptyMap(e.roughnessMap)) {
      const o = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap), l = {
        index: this.processTexture(o),
        channel: o.channel
      };
      this.applyTextureTransform(l, o), n.pbrMetallicRoughness.metallicRoughnessTexture = l;
    }
    if (this.checkEmptyMap(e.map)) {
      const o = {
        index: this.processTexture(e.map),
        texCoord: e.map.channel
      };
      this.applyTextureTransform(o, e.map), n.pbrMetallicRoughness.baseColorTexture = o;
    }
    if (e.emissive) {
      const o = e.emissive;
      if (Math.max(o.r, o.g, o.b) > 0 && (n.emissiveFactor = e.emissive.toArray()), this.checkEmptyMap(e.emissiveMap)) {
        const c = {
          index: this.processTexture(e.emissiveMap),
          texCoord: e.emissiveMap.channel
        };
        this.applyTextureTransform(c, e.emissiveMap), n.emissiveTexture = c;
      }
    }
    if (this.checkEmptyMap(e.normalMap)) {
      const o = {
        index: this.processTexture(e.normalMap),
        texCoord: e.normalMap.channel
      };
      e.normalScale && e.normalScale.x !== 1 && (o.scale = e.normalScale.x), this.applyTextureTransform(o, e.normalMap), n.normalTexture = o;
    }
    if (this.checkEmptyMap(e.aoMap)) {
      const o = {
        index: this.processTexture(e.aoMap),
        texCoord: e.aoMap.channel
      };
      e.aoMapIntensity !== 1 && (o.strength = e.aoMapIntensity), this.applyTextureTransform(o, e.aoMap), n.occlusionTexture = o;
    }
    e.transparent ? n.alphaMode = "BLEND" : e.alphaTest > 0 && (n.alphaMode = "MASK", n.alphaCutoff = e.alphaTest), e.side === zi && (n.doubleSided = !0), e.name !== "" && (n.name = e.name), this.serializeUserData(e, n), this._invokeAll(function(o) {
      o.writeMaterial && o.writeMaterial(e, n);
    });
    const a = i.materials.push(n) - 1;
    return t.materials.set(e, a), a;
  }
  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(e) {
    const t = this.cache, i = this.json, n = [e.geometry.uuid];
    if (Array.isArray(e.material))
      for (let g = 0, _ = e.material.length; g < _; g++)
        n.push(e.material[g].uuid);
    else
      n.push(e.material.uuid);
    const r = n.join(":");
    if (t.meshes.has(r)) return t.meshes.get(r);
    const a = e.geometry;
    let o;
    e.isLineSegments ? o = Dt.LINES : e.isLineLoop ? o = Dt.LINE_LOOP : e.isLine ? o = Dt.LINE_STRIP : e.isPoints ? o = Dt.POINTS : o = e.material.wireframe ? Dt.LINES : Dt.TRIANGLES;
    const l = {}, c = {}, h = [], u = [], d = {
      uv: "TEXCOORD_0",
      uv1: "TEXCOORD_1",
      uv2: "TEXCOORD_2",
      uv3: "TEXCOORD_3",
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    }, p = a.getAttribute("normal");
    p !== void 0 && !this.isNormalizedNormalAttribute(p) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), a.setAttribute("normal", this.createNormalizedNormalAttribute(p)));
    let f = null;
    for (let g in a.attributes) {
      if (g.slice(0, 5) === "morph") continue;
      const _ = a.attributes[g];
      if (g = d[g] || g.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(g) || (g = "_" + g), t.attributes.has(this.getUID(_))) {
        c[g] = t.attributes.get(this.getUID(_));
        continue;
      }
      f = null;
      const S = _.array;
      g === "JOINTS_0" && !(S instanceof Uint16Array) && !(S instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), f = new Je(new Uint16Array(S), _.itemSize, _.normalized));
      const C = this.processAccessor(f || _, a);
      C !== null && (g.startsWith("_") || this.detectMeshQuantization(g, _), c[g] = C, t.attributes.set(this.getUID(_), C));
    }
    if (p !== void 0 && a.setAttribute("normal", p), Object.keys(c).length === 0) return null;
    if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) {
      const g = [], _ = [], w = {};
      if (e.morphTargetDictionary !== void 0)
        for (const S in e.morphTargetDictionary)
          w[e.morphTargetDictionary[S]] = S;
      for (let S = 0; S < e.morphTargetInfluences.length; ++S) {
        const C = {};
        let E = !1;
        for (const x in a.morphAttributes) {
          if (x !== "position" && x !== "normal") {
            E || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), E = !0);
            continue;
          }
          const b = a.morphAttributes[x][S], D = x.toUpperCase(), O = a.attributes[x];
          if (t.attributes.has(this.getUID(b, !0))) {
            C[D] = t.attributes.get(this.getUID(b, !0));
            continue;
          }
          const Y = b.clone();
          if (!a.morphTargetsRelative)
            for (let B = 0, Q = b.count; B < Q; B++)
              for (let j = 0; j < b.itemSize; j++)
                j === 0 && Y.setX(B, b.getX(B) - O.getX(B)), j === 1 && Y.setY(B, b.getY(B) - O.getY(B)), j === 2 && Y.setZ(B, b.getZ(B) - O.getZ(B)), j === 3 && Y.setW(B, b.getW(B) - O.getW(B));
          C[D] = this.processAccessor(Y, a), t.attributes.set(this.getUID(O, !0), C[D]);
        }
        u.push(C), g.push(e.morphTargetInfluences[S]), e.morphTargetDictionary !== void 0 && _.push(w[S]);
      }
      l.weights = g, _.length > 0 && (l.extras = {}, l.extras.targetNames = _);
    }
    const y = Array.isArray(e.material);
    if (y && a.groups.length === 0) return null;
    const A = y ? e.material : [e.material], m = y ? a.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let g = 0, _ = m.length; g < _; g++) {
      const w = {
        mode: o,
        attributes: c
      };
      if (this.serializeUserData(a, w), u.length > 0 && (w.targets = u), a.index !== null) {
        let C = this.getUID(a.index);
        (m[g].start !== void 0 || m[g].count !== void 0) && (C += ":" + m[g].start + ":" + m[g].count), t.attributes.has(C) ? w.indices = t.attributes.get(C) : (w.indices = this.processAccessor(a.index, a, m[g].start, m[g].count), t.attributes.set(C, w.indices)), w.indices === null && delete w.indices;
      }
      const S = this.processMaterial(A[m[g].materialIndex]);
      S !== null && (w.material = S), h.push(w);
    }
    l.primitives = h, i.meshes || (i.meshes = []), this._invokeAll(function(g) {
      g.writeMesh && g.writeMesh(e, l);
    });
    const v = i.meshes.push(l) - 1;
    return t.meshes.set(r, v), v;
  }
  /**
   * If a vertex attribute with a
   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
   * is used, it is checked whether it is a valid data type according to the
   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   * extension.
   * In this case the extension is automatically added to the list of used extensions.
   *
   * @param {string} attributeName
   * @param {THREE.BufferAttribute} attribute
   */
  detectMeshQuantization(e, t) {
    if (this.extensionsUsed[Em]) return;
    let i;
    switch (t.array.constructor) {
      case Int8Array:
        i = "byte";
        break;
      case Uint8Array:
        i = "unsigned byte";
        break;
      case Int16Array:
        i = "short";
        break;
      case Uint16Array:
        i = "unsigned short";
        break;
      default:
        return;
    }
    t.normalized && (i += " normalized");
    const n = e.split("_", 1)[0];
    dx[n] && dx[n].includes(i) && (this.extensionsUsed[Em] = !0, this.extensionsRequired[Em] = !0);
  }
  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(e) {
    const t = this.json;
    t.cameras || (t.cameras = []);
    const i = e.isOrthographicCamera, n = {
      type: i ? "orthographic" : "perspective"
    };
    return i ? n.orthographic = {
      xmag: e.right * 2,
      ymag: e.top * 2,
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    } : n.perspective = {
      aspectRatio: e.aspect,
      yfov: ri.degToRad(e.fov),
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    }, e.name !== "" && (n.name = e.type), t.cameras.push(n) - 1;
  }
  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(e, t) {
    const i = this.json, n = this.nodeMap;
    i.animations || (i.animations = []);
    try {
      e = rf.Utils.mergeMorphTargetTracks(e.clone(), t);
    } catch (l) {
      if (console.warn('THREE.GLTFExporter: Could not export animation clip "%s".', e.name), !this.options.ignoreInvalidMorphTargetTracks) throw l;
      return console.error(l), null;
    }
    const r = e.tracks, a = [], o = [];
    for (let l = 0; l < r.length; ++l) {
      const c = r[l], h = _t.parseTrackName(c.name);
      let u = _t.findNode(t, h.nodeName);
      const d = px[h.propertyName];
      if (h.objectName === "bones" && (u.isSkinnedMesh === !0 ? u = u.skeleton.getBoneByName(h.objectIndex) : u = void 0), !u || !d)
        return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', c.name), null;
      const p = 1;
      let f = c.values.length / c.times.length;
      d === px.morphTargetInfluences && (f /= u.morphTargetInfluences.length);
      let y;
      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (y = "CUBICSPLINE", f /= 3) : c.getInterpolation() === Zl ? y = "STEP" : y = "LINEAR", o.push({
        input: this.processAccessor(new Je(c.times, p)),
        output: this.processAccessor(new Je(c.values, f)),
        interpolation: y
      }), a.push({
        sampler: o.length - 1,
        target: {
          node: n.get(u),
          path: d
        }
      });
    }
    return i.animations.push({
      name: e.name || "clip_" + i.animations.length,
      samplers: o,
      channels: a
    }), i.animations.length - 1;
  }
  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(e) {
    const t = this.json, i = this.nodeMap, n = t.nodes[i.get(e)], r = e.skeleton;
    if (r === void 0) return null;
    const a = e.skeleton.bones[0];
    if (a === void 0) return null;
    const o = [], l = new Float32Array(r.bones.length * 16), c = new Ue();
    for (let u = 0; u < r.bones.length; ++u)
      o.push(i.get(r.bones[u])), c.copy(r.boneInverses[u]), c.multiply(e.bindMatrix).toArray(l, u * 16);
    return t.skins === void 0 && (t.skins = []), t.skins.push({
      inverseBindMatrices: this.processAccessor(new Je(l, 16)),
      joints: o,
      skeleton: i.get(a)
    }), n.skin = t.skins.length - 1;
  }
  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(e) {
    const t = this.json, i = this.options, n = this.nodeMap;
    t.nodes || (t.nodes = []);
    const r = {};
    if (i.trs) {
      const o = e.quaternion.toArray(), l = e.position.toArray(), c = e.scale.toArray();
      Ah(o, [0, 0, 0, 1]) || (r.rotation = o), Ah(l, [0, 0, 0]) || (r.translation = l), Ah(c, [1, 1, 1]) || (r.scale = c);
    } else
      e.matrixAutoUpdate && e.updateMatrix(), hO(e.matrix) === !1 && (r.matrix = e.matrix.elements);
    if (e.name !== "" && (r.name = String(e.name)), this.serializeUserData(e, r), e.isMesh || e.isLine || e.isPoints) {
      const o = this.processMesh(e);
      o !== null && (r.mesh = o);
    } else e.isCamera && (r.camera = this.processCamera(e));
    if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
      const o = [];
      for (let l = 0, c = e.children.length; l < c; l++) {
        const h = e.children[l];
        if (h.visible || i.onlyVisible === !1) {
          const u = this.processNode(h);
          u !== null && o.push(u);
        }
      }
      o.length > 0 && (r.children = o);
    }
    this._invokeAll(function(o) {
      o.writeNode && o.writeNode(e, r);
    });
    const a = t.nodes.push(r) - 1;
    return n.set(e, a), a;
  }
  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(e) {
    const t = this.json, i = this.options;
    t.scenes || (t.scenes = [], t.scene = 0);
    const n = {};
    e.name !== "" && (n.name = e.name), t.scenes.push(n);
    const r = [];
    for (let a = 0, o = e.children.length; a < o; a++) {
      const l = e.children[a];
      if (l.visible || i.onlyVisible === !1) {
        const c = this.processNode(l);
        c !== null && r.push(c);
      }
    }
    r.length > 0 && (n.nodes = r), this.serializeUserData(e, n);
  }
  /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
  processObjects(e) {
    const t = new tc();
    t.name = "AuxScene";
    for (let i = 0; i < e.length; i++)
      t.children.push(e[i]);
    this.processScene(t);
  }
  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(e) {
    const t = this.options;
    e = e instanceof Array ? e : [e], this._invokeAll(function(n) {
      n.beforeParse && n.beforeParse(e);
    });
    const i = [];
    for (let n = 0; n < e.length; n++)
      e[n] instanceof tc ? this.processScene(e[n]) : i.push(e[n]);
    i.length > 0 && this.processObjects(i);
    for (let n = 0; n < this.skins.length; ++n)
      this.processSkin(this.skins[n]);
    for (let n = 0; n < t.animations.length; ++n)
      this.processAnimation(t.animations[n], e[0]);
    this._invokeAll(function(n) {
      n.afterParse && n.afterParse(e);
    });
  }
  _invokeAll(e) {
    for (let t = 0, i = this.plugins.length; t < i; t++)
      e(this.plugins[t]);
  }
  checkEmptyMap(e) {
    return !!e && (!this.options.ignoreEmptyTextures || !!e.image);
  }
}
class dO {
  constructor(e) {
    this.writer = e, this.name = "KHR_lights_punctual";
  }
  writeNode(e, t) {
    if (!e.isLight) return;
    if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
      return;
    }
    const i = this.writer, n = i.json, r = i.extensionsUsed, a = {};
    e.name && (a.name = e.name), a.color = e.color.toArray(), a.intensity = e.intensity, e.isDirectionalLight ? a.type = "directional" : e.isPointLight ? (a.type = "point", e.distance > 0 && (a.range = e.distance)) : e.isSpotLight && (a.type = "spot", e.distance > 0 && (a.range = e.distance), a.spot = {}, a.spot.innerConeAngle = (1 - e.penumbra) * e.angle, a.spot.outerConeAngle = e.angle), e.decay !== void 0 && e.decay !== 2 && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), e.target && (e.target.parent !== e || e.target.position.x !== 0 || e.target.position.y !== 0 || e.target.position.z !== -1) && console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), r[this.name] || (n.extensions = n.extensions || {}, n.extensions[this.name] = { lights: [] }, r[this.name] = !0);
    const o = n.extensions[this.name].lights;
    o.push(a), t.extensions = t.extensions || {}, t.extensions[this.name] = { light: o.length - 1 };
  }
}
class pO {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_unlit";
  }
  writeMaterial(e, t) {
    if (!e.isMeshBasicMaterial) return;
    const n = this.writer.extensionsUsed;
    t.extensions = t.extensions || {}, t.extensions[this.name] = {}, n[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
}
class fO {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.clearcoat === 0) return;
    const i = this.writer, n = i.extensionsUsed, r = {};
    if (r.clearcoatFactor = e.clearcoat, i.checkEmptyMap(e.clearcoatMap)) {
      const a = {
        index: i.processTexture(e.clearcoatMap),
        texCoord: e.clearcoatMap.channel
      };
      i.applyTextureTransform(a, e.clearcoatMap), r.clearcoatTexture = a;
    }
    if (r.clearcoatRoughnessFactor = e.clearcoatRoughness, i.checkEmptyMap(e.clearcoatRoughnessMap)) {
      const a = {
        index: i.processTexture(e.clearcoatRoughnessMap),
        texCoord: e.clearcoatRoughnessMap.channel
      };
      i.applyTextureTransform(a, e.clearcoatRoughnessMap), r.clearcoatRoughnessTexture = a;
    }
    if (i.checkEmptyMap(e.clearcoatNormalMap)) {
      const a = {
        index: i.processTexture(e.clearcoatNormalMap),
        texCoord: e.clearcoatNormalMap.channel
      };
      i.applyTextureTransform(a, e.clearcoatNormalMap), r.clearcoatNormalTexture = a;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
  }
}
class mO {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_iridescence";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.iridescence === 0) return;
    const i = this.writer, n = i.extensionsUsed, r = {};
    if (r.iridescenceFactor = e.iridescence, i.checkEmptyMap(e.iridescenceMap)) {
      const a = {
        index: i.processTexture(e.iridescenceMap),
        texCoord: e.iridescenceMap.channel
      };
      i.applyTextureTransform(a, e.iridescenceMap), r.iridescenceTexture = a;
    }
    if (r.iridescenceIor = e.iridescenceIOR, r.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], r.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], i.checkEmptyMap(e.iridescenceThicknessMap)) {
      const a = {
        index: i.processTexture(e.iridescenceThicknessMap),
        texCoord: e.iridescenceThicknessMap.channel
      };
      i.applyTextureTransform(a, e.iridescenceThicknessMap), r.iridescenceThicknessTexture = a;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
  }
}
class gO {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_transmission";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0) return;
    const i = this.writer, n = i.extensionsUsed, r = {};
    if (r.transmissionFactor = e.transmission, i.checkEmptyMap(e.transmissionMap)) {
      const a = {
        index: i.processTexture(e.transmissionMap),
        texCoord: e.transmissionMap.channel
      };
      i.applyTextureTransform(a, e.transmissionMap), r.transmissionTexture = a;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
  }
}
class AO {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_volume";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0) return;
    const i = this.writer, n = i.extensionsUsed, r = {};
    if (r.thicknessFactor = e.thickness, i.checkEmptyMap(e.thicknessMap)) {
      const a = {
        index: i.processTexture(e.thicknessMap),
        texCoord: e.thicknessMap.channel
      };
      i.applyTextureTransform(a, e.thicknessMap), r.thicknessTexture = a;
    }
    r.attenuationDistance = e.attenuationDistance, r.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
  }
}
class yO {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_ior";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.ior === 1.5) return;
    const n = this.writer.extensionsUsed, r = {};
    r.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
  }
}
class vO {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_specular";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.specularIntensity === 1 && e.specularColor.equals(sO) && !e.specularIntensityMap && !e.specularColorTexture) return;
    const i = this.writer, n = i.extensionsUsed, r = {};
    if (i.checkEmptyMap(e.specularIntensityMap)) {
      const a = {
        index: i.processTexture(e.specularIntensityMap),
        texCoord: e.specularIntensityMap.channel
      };
      i.applyTextureTransform(a, e.specularIntensityMap), r.specularTexture = a;
    }
    if (i.checkEmptyMap(e.specularColorMap)) {
      const a = {
        index: i.processTexture(e.specularColorMap),
        texCoord: e.specularColorMap.channel
      };
      i.applyTextureTransform(a, e.specularColorMap), r.specularColorTexture = a;
    }
    r.specularFactor = e.specularIntensity, r.specularColorFactor = e.specularColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
  }
}
class _O {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_sheen";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.sheen < 1e-3) return;
    const i = this.writer, n = i.extensionsUsed, r = {};
    if (i.checkEmptyMap(e.sheenRoughnessMap)) {
      const a = {
        index: i.processTexture(e.sheenRoughnessMap),
        texCoord: e.sheenRoughnessMap.channel
      };
      i.applyTextureTransform(a, e.sheenRoughnessMap), r.sheenRoughnessTexture = a;
    }
    if (i.checkEmptyMap(e.sheenColorMap)) {
      const a = {
        index: i.processTexture(e.sheenColorMap),
        texCoord: e.sheenColorMap.channel
      };
      i.applyTextureTransform(a, e.sheenColorMap), r.sheenColorTexture = a;
    }
    r.sheenRoughnessFactor = e.sheenRoughness, r.sheenColorFactor = e.sheenColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = r, t.extras = t.extras || {}, t.extras.sheenFactor = e.sheen, n[this.name] = !0;
  }
}
class xO {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_anisotropy";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.anisotropy == 0) return;
    const i = this.writer, n = i.extensionsUsed, r = {};
    if (i.checkEmptyMap(e.anisotropyMap)) {
      const a = { index: i.processTexture(e.anisotropyMap) };
      i.applyTextureTransform(a, e.anisotropyMap), r.anisotropyTexture = a;
    }
    r.anisotropyStrength = e.anisotropy, r.anisotropyRotation = e.anisotropyRotation, t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
  }
}
class wO {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(e, t) {
    if (!e.isMeshStandardMaterial || e.emissiveIntensity === 1) return;
    const n = this.writer.extensionsUsed, r = {};
    r.emissiveStrength = e.emissiveIntensity, t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
  }
}
class EO {
  constructor(e) {
    this.writer = e, this.name = "EXT_mesh_gpu_instancing";
  }
  writeNode(e, t) {
    if (!e.isInstancedMesh) return;
    const i = this.writer, n = e, r = new Float32Array(n.count * 3), a = new Float32Array(n.count * 4), o = new Float32Array(n.count * 3), l = new Ue(), c = new M(), h = new rt(), u = new M();
    for (let p = 0; p < n.count; p++)
      n.getMatrixAt(p, l), l.decompose(c, h, u), c.toArray(r, p * 3), h.toArray(a, p * 4), u.toArray(o, p * 3);
    const d = {
      TRANSLATION: i.processAccessor(new Je(r, 3)),
      ROTATION: i.processAccessor(new Je(a, 4)),
      SCALE: i.processAccessor(new Je(o, 3))
    };
    n.instanceColor && (d._COLOR_0 = i.processAccessor(n.instanceColor)), t.extensions = t.extensions || {}, t.extensions[this.name] = { attributes: d }, i.extensionsUsed[this.name] = !0, i.extensionsRequired[this.name] = !0;
  }
}
rf.Utils = {
  GLTFWriter: Kb,
  insertKeyframe: function(s, e) {
    const i = s.getValueSize(), n = new s.TimeBufferType(s.times.length + 1), r = new s.ValueBufferType(s.values.length + i), a = s.createInterpolant(new s.ValueBufferType(i));
    let o;
    if (s.times.length === 0) {
      n[0] = e;
      for (let l = 0; l < i; l++)
        r[l] = 0;
      o = 0;
    } else if (e < s.times[0]) {
      if (Math.abs(s.times[0] - e) < 1e-3) return 0;
      n[0] = e, n.set(s.times, 1), r.set(a.evaluate(e), 0), r.set(s.values, i), o = 0;
    } else if (e > s.times[s.times.length - 1]) {
      if (Math.abs(s.times[s.times.length - 1] - e) < 1e-3)
        return s.times.length - 1;
      n[n.length - 1] = e, n.set(s.times, 0), r.set(s.values, 0), r.set(a.evaluate(e), s.values.length), o = n.length - 1;
    } else
      for (let l = 0; l < s.times.length; l++) {
        if (Math.abs(s.times[l] - e) < 1e-3) return l;
        if (s.times[l] < e && s.times[l + 1] > e) {
          n.set(s.times.slice(0, l + 1), 0), n[l + 1] = e, n.set(s.times.slice(l + 1), l + 2), r.set(s.values.slice(0, (l + 1) * i), 0), r.set(a.evaluate(e), (l + 1) * i), r.set(s.values.slice((l + 1) * i), (l + 2) * i), o = l + 1;
          break;
        }
      }
    return s.times = n, s.values = r, o;
  },
  mergeMorphTargetTracks: function(s, e) {
    const t = [], i = {}, n = s.tracks;
    for (let r = 0; r < n.length; ++r) {
      let a = n[r];
      const o = _t.parseTrackName(a.name), l = _t.findNode(e, o.nodeName);
      if (o.propertyName !== "morphTargetInfluences" || o.propertyIndex === void 0) {
        t.push(a);
        continue;
      }
      if (a.createInterpolant !== a.InterpolantFactoryMethodDiscrete && a.createInterpolant !== a.InterpolantFactoryMethodLinear) {
        if (a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), a = a.clone(), a.setInterpolation(Ao);
      }
      const c = l.morphTargetInfluences.length, h = l.morphTargetDictionary[o.propertyIndex];
      if (h === void 0)
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + o.propertyIndex);
      let u;
      if (i[l.uuid] === void 0) {
        u = a.clone();
        const p = new u.ValueBufferType(c * u.times.length);
        for (let f = 0; f < u.times.length; f++)
          p[f * c + h] = u.values[f];
        u.name = (o.nodeName || "") + ".morphTargetInfluences", u.values = p, i[l.uuid] = u, t.push(u);
        continue;
      }
      const d = a.createInterpolant(new a.ValueBufferType(1));
      u = i[l.uuid];
      for (let p = 0; p < u.times.length; p++)
        u.values[p * c + h] = d.evaluate(u.times[p]);
      for (let p = 0; p < a.times.length; p++) {
        const f = this.insertKeyframe(u, a.times[p]);
        u.values[f * c + h] = a.values[p];
      }
    }
    return s.tracks = t, s;
  }
};
class bO extends rf.Utils.GLTFWriter {
  constructor() {
    super(), this.TPAssetVersion = 1, this._defaultMaterial = new Go(), this.json.asset.subversion = this.TPAssetVersion;
  }
  serializeUserData(e, t) {
    const i = e.userData, n = {};
    i.__disposed && console.error("Serializing a disposed object", e), Object.entries(i).forEach(([a, o]) => {
      (!o || typeof o == "function" || o.isObject3D || o.isTexture || o.isMaterial || o.assetType != null || a.startsWith("_")) && (n[a] = o, delete i[a]);
    });
    const r = mt.Serialize(i);
    Object.entries(n).forEach(([a, o]) => {
      i[a] = o, delete n[a];
    }), e.userData = r, super.serializeUserData(e, t), e.userData = i;
  }
  processObjects(e) {
    var t;
    e.length === 1 && ((t = e[0]) != null && t.userData.rootSceneModelRoot) ? this.processScene(e[0]) : super.processObjects(e);
  }
  /**
   * Checks for shader material and does the same thing...
   * @param material
   */
  processMaterial(e) {
    if (this.cache.materials.has(e)) return this.cache.materials.get(e);
    let t = e;
    (!t || t.isShaderMaterial) && (t = this._defaultMaterial);
    const i = super.processMaterial(t);
    if (i === null)
      return console.error("GLTFWriter2: Unexpected error: Failed to process material", e), null;
    if (!e || t === e) return i;
    const n = JSON.stringify(this.json.materials[i]), r = JSON.parse(n);
    this.serializeUserData(e, r), this._invokeAll((o) => {
      o.writeMaterial && o.writeMaterial(e, r);
    });
    const a = this.json.materials.push(r) - 1;
    return this.cache.materials.set(e, a), a;
  }
  /**
   * Same as processImage but for image blobs
   * @param blob
   * @param texture
   */
  processImageBlob(e, t) {
    if (!e) return -1;
    const i = this.cache, n = this.options, r = this.pending, a = this.json, o = t.image;
    i.images.has(o) || i.images.set(o, {});
    const l = i.images.get(o), c = e.type + ":flipY/" + t.flipY.toString();
    if (l[c] !== void 0) return l[c];
    a.images || (a.images = []);
    const h = { mimeType: e.type };
    n.binary === !0 ? r.push(new Promise((d) => {
      this.processBufferViewImage(e).then((p) => {
        h.bufferView = p, d();
      });
    })) : r.push(Kw(e).then((d) => {
      h.uri = d;
    }));
    const u = a.images.push(h) - 1;
    return l[c] = u, u;
  }
  processSampler(e) {
    return super.processSampler(e);
  }
  processTexture(e) {
    const t = this.cache, i = this.json;
    if (t.textures.has(e)) return t.textures.get(e);
    const n = e.source.data, r = e.userData.mimeType;
    e.userData.rootPath && !this.options.exporterOptions.embedUrlImages && (e.userData.rootPath.startsWith("http") || e.userData.rootPath.startsWith("data:")) && (e.source.data && (!this.options.exporterOptions.embedUrlImagePreviews || e.isDataTexture ? e.source.data = null : e.source.data._savePreview = !0), delete e.userData.mimeType);
    const a = super.processTexture(e), o = i.textures[a];
    if (!o)
      return console.error("No texture def", a, e), a;
    const l = i.images ? i.images[o.source] : null;
    if (l && (l.extras || (l.extras = {}), e.source && (l.extras.uuid = e.source.uuid), l.extras.t_uuid = e.uuid), e.userData.rootPath && !this.options.exporterOptions.embedUrlImages && (e.userData.rootPath.startsWith("http") || e.userData.rootPath.startsWith("data:"))) {
      if (e.source.data ? delete e.source.data._savePreview : e.source.data = n, e.userData.mimeType = r, !o)
        return console.error("textureDef is null", a, e), a;
      if (o.source >= 0) {
        const c = this.json.images[o.source];
        c.uri ? console.warn("uri already set", c.uri) : (c.uri = e.userData.rootPath, c.mimeType = r, c.extras || (c.extras = {}), c.extras.flipY = e.flipY, c.extras.uri = e.userData.rootPath);
      } else
        o.source = this.processImageUri(e.image, e.userData.rootPath, e.flipY, r);
    }
    return o.source < 0 && (console.error("textureDef.source cannot be saved", o, e), delete o.source), a;
  }
  // Add extra check for null images. This is set in processTexture when we have a rootPath
  processImage(e, t, i, n = "image/png") {
    return e ? super.processImage(e, t, i, n, e._savePreview ? 32 : void 0, e._savePreview ? 32 : void 0) : -1;
  }
  /**
   * Used in GLTFWriter2.processTexture for rootPath. Note that this does not check for options.exporterOptions.embedUrlImages, it must be done separately.
   * @param image
   * @param uri
   * @param flipY
   * @param mimeType
   */
  processImageUri(e, t, i, n = "image/png") {
    const r = this.cache, a = this.json;
    r.images.has(e) || r.images.set(e, {});
    const o = r.images.get(e), l = n + ":flipY/" + i.toString();
    if (o[l] !== void 0) return o[l];
    a.images || (a.images = []);
    const c = {
      mimeType: n,
      uri: t,
      extras: { flipY: i }
    }, h = a.images.push(c) - 1;
    return o[l] = h, h;
  }
}
const Pp = class Pp extends rf {
  constructor() {
    super(), this.processors = [], this.processors.push(KF);
  }
  register(e) {
    return super.register(e);
  }
  async parseAsync(e, t) {
    if (!e) throw new Error("No object to export");
    let i = !e.__isGLTFOutput && (Array.isArray(e) || e.isObject3D) ? await new Promise((n, r) => this.parse(e, n, r, t)) : e;
    for (const n of this.processors)
      i = await n(i, t);
    if (i && i instanceof Blob) return i;
    if (i && typeof i == "object" && !i.byteLength)
      return new Blob([JSON.stringify(i, (n, r) => n.startsWith("__") ? void 0 : r, t.jsonSpaces ?? 2)], { type: "model/gltf+json" });
    if (i)
      return new Blob([i], { type: "model/gltf+binary" });
    throw new Error("GLTFExporter2.parse() failed");
  }
  parse(e, t, i, n = {}) {
    const r = {
      // default options
      binary: !1,
      trs: n.trs ?? !1,
      onlyVisible: n.onlyVisible ?? !1,
      truncateDrawRange: n.truncateDrawRange ?? !0,
      externalImagesInExtras: !n.embedUrlImages && n.externalImagesInExtras || !1,
      // this is handled in gltfMaterialExtrasWriter, also see GLTFDracoExporter
      maxTextureSize: n.maxTextureSize ?? 1 / 0,
      animations: n.animations ?? [],
      includeCustomExtensions: n.includeCustomExtensions ?? !0,
      forceIndices: n.forceIndices ?? !1,
      // todo implement
      exporterOptions: n,
      ignoreInvalidMorphTargetTracks: n.ignoreInvalidMorphTargetTracks,
      ignoreEmptyTextures: n.ignoreEmptyTextures
    };
    return n.exportExt === "glb" && (r.binary = !0), n.preserveUUIDs !== !1 && (Array.isArray(e) ? e : [e]).forEach((a) => a.traverse((o) => {
      o.uuid && (o.userData.gltfUUID = o.uuid);
    })), (Array.isArray(e) ? e : [e]).forEach((a) => a.traverse((o) => {
      if (o.animations)
        for (const l of o.animations)
          l.__gltfExport !== !1 && !r.animations.includes(l) && r.animations.push(...o.animations);
    })), super.parse(e, (a) => {
      n.preserveUUIDs !== !1 && (Array.isArray(e) ? e : [e]).forEach((o) => o.traverse((l) => {
        delete l.userData.gltfUUID;
      })), t(Object.assign(a, { __isGLTFOutput: !0 }));
    }, i, r, new bO());
  }
  setup(e, t) {
    for (const i of Pp.ExportExtensions) this.register(i);
    if (t) for (const i of t) this.register(i);
    return this.register(this.gltfViewerWriter(e)), this;
  }
  gltfViewerWriter(e) {
    return (t) => ({
      afterParse: (i) => {
        var n, r, a, o;
        i = Array.isArray(i) ? i[0] : i, !(!((n = i == null ? void 0 : i.userData) != null && n.rootSceneModelRoot) || ((a = (r = t.options) == null ? void 0 : r.exporterOptions) == null ? void 0 : a.viewerConfig) === !1 || ((o = i == null ? void 0 : i.userData) == null ? void 0 : o.__exportViewerConfig) === !1) && Sp.ExportViewerConfig(e, t);
      }
    });
  }
};
Pp.ExportExtensions = [
  Ep.Export,
  bp.Export,
  wp.Export,
  cc.Export,
  hc.Export,
  uc.Export,
  lc.Export
  // (w)=>new GLTFMeshGpuInstancingExporter(w),
];
let zg = Pp;
class SO {
  async parseAsync(e, { jsonSpaces: t = 2 }) {
    return new Blob([JSON.stringify(e, null, t)], { type: "application/json" });
  }
}
class CO {
  async parseAsync(e, t) {
    return new Blob([e], { type: "text/plain" });
  }
}
const MO = new TextEncoder(), Jb = 3;
class TO {
  parse(e, t, i) {
    if (!e || !(e.isWebGLRenderer || e.isDataTexture))
      throw Error("EXRExporter.parse: Unsupported first parameter, expected instance of WebGLRenderer or DataTexture.");
    if (e.isWebGLRenderer) {
      const n = e, r = t, a = i;
      IO(r);
      const o = RO(r, a), l = PO(n, r, o), c = yx(l, o), h = vx(c, o);
      return _x(h, o);
    } else if (e.isDataTexture) {
      const n = e, r = t;
      DO(n);
      const a = BO(n, r), o = n.image.data, l = yx(o, a), c = vx(l, a);
      return _x(c, a);
    }
  }
}
function IO(s) {
  if (!s || !s.isWebGLRenderTarget)
    throw Error("EXRExporter.parse: Unsupported second parameter, expected instance of WebGLRenderTarget.");
  if (s.isWebGLCubeRenderTarget || s.isWebGL3DRenderTarget || s.isWebGLArrayRenderTarget)
    throw Error("EXRExporter.parse: Unsupported render target type, expected instance of WebGLRenderTarget.");
  if (s.texture.type !== Xt && s.texture.type !== Qt)
    throw Error("EXRExporter.parse: Unsupported WebGLRenderTarget texture type.");
  if (s.texture.format !== ei)
    throw Error("EXRExporter.parse: Unsupported WebGLRenderTarget texture format, expected RGBAFormat.");
}
function DO(s) {
  if (s.type !== Xt && s.type !== Qt)
    throw Error("EXRExporter.parse: Unsupported DataTexture texture type.");
  if (s.format !== ei)
    throw Error("EXRExporter.parse: Unsupported DataTexture texture format, expected RGBAFormat.");
  if (!s.image.data)
    throw Error("EXRExporter.parse: Invalid DataTexture image data.");
  if (s.type === Xt && s.image.data.constructor.name !== "Float32Array")
    throw Error("EXRExporter.parse: DataTexture image data doesn't match type, expected 'Float32Array'.");
  if (s.type === Qt && s.image.data.constructor.name !== "Uint16Array")
    throw Error("EXRExporter.parse: DataTexture image data doesn't match type, expected 'Uint16Array'.");
}
function RO(s, e = {}) {
  const t = {
    0: 1,
    2: 1,
    3: 16
  }, i = s.width, n = s.height, r = s.texture.type, a = s.texture.format;
  texture.colorSpace;
  const o = e.compression !== void 0 ? e.compression : Jb, l = e.type !== void 0 ? e.type : Qt, c = l === Xt ? 2 : 1, h = t[o];
  return {
    width: i,
    height: n,
    type: r,
    format: a,
    compression: o,
    blockLines: h,
    dataType: c,
    dataSize: 2 * c,
    numBlocks: Math.ceil(n / h),
    numInputChannels: 4,
    numOutputChannels: 4,
    textureIndex: e.textureIndex || 0
  };
}
function BO(s, e = {}) {
  const t = {
    0: 1,
    2: 1,
    3: 16
  }, i = s.image.width, n = s.image.height, r = s.type, a = s.format, o = s.colorSpace, l = e.compression !== void 0 ? e.compression : Jb, c = e.type !== void 0 ? e.type : Qt, h = c === Xt ? 2 : 1, u = t[l];
  return {
    width: i,
    height: n,
    type: r,
    format: a,
    colorSpace: o,
    compression: l,
    blockLines: u,
    dataType: h,
    dataSize: 2 * h,
    numBlocks: Math.ceil(n / u),
    numInputChannels: 4,
    numOutputChannels: 4,
    flipY: s.isDataTexture && s.flipY,
    textureIndex: e.textureIndex || 0
    // todo required here?
  };
}
function PO(s, e, t) {
  let i;
  return t.type === Xt ? i = new Float32Array(t.width * t.height * t.numInputChannels) : i = new Uint16Array(t.width * t.height * t.numInputChannels), s.readRenderTargetPixels(e, 0, 0, t.width, t.height, i, void 0, t.textureIndex), i;
}
function yx(s, e) {
  const t = e.width, i = e.height, n = { r: 0, g: 0, b: 0, a: 0 }, r = { value: 0 }, a = e.numOutputChannels == 4 ? 1 : 0, o = e.type == Xt ? QO : zO, l = e.dataType == 1 ? NO : Qg, c = new Uint8Array(e.width * e.height * e.numOutputChannels * e.dataSize), h = new DataView(c.buffer);
  for (let u = 0; u < i; ++u)
    for (let d = 0; d < t; ++d) {
      const p = u * t * 4 + d * 4, f = o(s, p), y = o(s, p + 1), A = o(s, p + 2), m = o(s, p + 3), v = (e.flipY ? u : i - u - 1) * t * (3 + a) * e.dataSize;
      OO(n, f, y, A, m), r.value = v + d * e.dataSize, l(h, n.a, r), r.value = v + a * t * e.dataSize + d * e.dataSize, l(h, n.b, r), r.value = v + (1 + a) * t * e.dataSize + d * e.dataSize, l(h, n.g, r), r.value = v + (2 + a) * t * e.dataSize + d * e.dataSize, l(h, n.r, r);
    }
  return c;
}
function vx(s, e) {
  let t, i, n = 0;
  const r = { data: new Array(), totalSize: 0 }, a = e.width * e.numOutputChannels * e.blockLines * e.dataSize;
  switch (e.compression) {
    case 0:
      t = LO;
      break;
    case 2:
    case 3:
      t = UO;
      break;
  }
  e.compression !== 0 && (i = new Uint8Array(a));
  for (let o = 0; o < e.numBlocks; ++o) {
    const l = s.subarray(a * o, a * (o + 1)), c = t(l, i);
    n += c.length, r.data.push({ dataChunk: c, size: c.length });
  }
  return r.totalSize = n, r;
}
function LO(s) {
  return s;
}
function UO(s, e) {
  let t = 0, i = Math.floor((s.length + 1) / 2), n = 0;
  const r = s.length - 1;
  for (; !(n > r || (e[t++] = s[n++], n > r)); )
    e[i++] = s[n++];
  let a = e[0];
  for (let l = 1; l < e.length; l++) {
    const c = e[l] - a + 384;
    a = e[l], e[l] = c;
  }
  return Pg(e);
}
function FO(s, e, t) {
  const i = { value: 0 }, n = new DataView(s.buffer);
  Gt(n, 20000630, i), Gt(n, 2, i), Xi(n, "compression", i), Xi(n, "compression", i), Gt(n, 1, i), yh(n, t.compression, i), Xi(n, "screenWindowCenter", i), Xi(n, "v2f", i), Gt(n, 8, i), Gt(n, 0, i), Gt(n, 0, i), Xi(n, "screenWindowWidth", i), Xi(n, "float", i), Gt(n, 4, i), Qg(n, 1, i), Xi(n, "pixelAspectRatio", i), Xi(n, "float", i), Gt(n, 4, i), Qg(n, 1, i), Xi(n, "lineOrder", i), Xi(n, "lineOrder", i), Gt(n, 1, i), yh(n, 0, i), Xi(n, "dataWindow", i), Xi(n, "box2i", i), Gt(n, 16, i), Gt(n, 0, i), Gt(n, 0, i), Gt(n, t.width - 1, i), Gt(n, t.height - 1, i), Xi(n, "displayWindow", i), Xi(n, "box2i", i), Gt(n, 16, i), Gt(n, 0, i), Gt(n, 0, i), Gt(n, t.width - 1, i), Gt(n, t.height - 1, i), Xi(n, "channels", i), Xi(n, "chlist", i), Gt(n, t.numOutputChannels * 18 + 1, i), Xi(n, "A", i), Gt(n, t.dataType, i), i.value += 4, Gt(n, 1, i), Gt(n, 1, i), Xi(n, "B", i), Gt(n, t.dataType, i), i.value += 4, Gt(n, 1, i), Gt(n, 1, i), Xi(n, "G", i), Gt(n, t.dataType, i), i.value += 4, Gt(n, 1, i), Gt(n, 1, i), Xi(n, "R", i), Gt(n, t.dataType, i), i.value += 4, Gt(n, 1, i), Gt(n, 1, i), yh(n, 0, i), yh(n, 0, i);
  let r = i.value + t.numBlocks * 8;
  for (let a = 0; a < e.data.length; ++a)
    kO(n, r, i), r += e.data[a].size + 8;
}
function _x(s, e) {
  const t = e.numBlocks * 8, i = 259 + 18 * e.numOutputChannels, n = { value: i + t }, r = new Uint8Array(i + t + s.totalSize + e.numBlocks * 8), a = new DataView(r.buffer);
  FO(r, s, e);
  for (let o = 0; o < s.data.length; ++o) {
    const l = s.data[o].dataChunk, c = s.data[o].size;
    Gt(a, o * e.blockLines, n), Gt(a, c, n), r.set(l, n.value), n.value += c;
  }
  return r;
}
function OO(s, e, t, i, n) {
  s.r = e, s.g = t, s.b = i, s.a = n;
}
function yh(s, e, t) {
  s.setUint8(t.value, e), t.value += 1;
}
function Gt(s, e, t) {
  s.setUint32(t.value, e, !0), t.value += 4;
}
function NO(s, e, t) {
  s.setUint16(t.value, Gn.toHalfFloat(e), !0), t.value += 2;
}
function Qg(s, e, t) {
  s.setFloat32(t.value, e, !0), t.value += 4;
}
function kO(s, e, t) {
  s.setBigUint64(t.value, BigInt(e), !0), t.value += 8;
}
function Xi(s, e, t) {
  const i = MO.encode(e + "\0");
  for (let n = 0; n < i.length; ++n)
    yh(s, i[n], t);
}
function GO(s) {
  const e = (s & 31744) >> 10, t = s & 1023;
  return (s >> 15 ? -1 : 1) * (e ? e === 31 ? t ? NaN : 1 / 0 : Math.pow(2, e - 15) * (1 + t / 1024) : 6103515625e-14 * (t / 1024));
}
function zO(s, e) {
  return GO(s[e]);
}
function QO(s, e) {
  return s[e];
}
class $b extends TO {
  async parseAsync(e, t) {
    const i = e;
    if (i.isWebGLRenderTarget && !i.renderManager) throw new Error("No renderManager on renderTarget");
    if (!i.isWebGLRenderTarget && !e.isDataTexture) throw new Error("Invalid object type");
    i.isWebGLMultipleRenderTargets && t.textureIndex === void 0 && console.warn("No textureIndex specified for WebGLMultipleRenderTargets");
    const n = i.isWebGLRenderTarget ? this.parse(i.renderManager.webglRenderer, i, t) : this.parse(e, t);
    return new Blob([n], { type: "image/x-exr" });
  }
}
class HO extends Vi {
  constructor() {
    super(), this.exporters = [
      { ctor: () => new SO(), ext: ["json"] },
      { ctor: () => new CO(), ext: ["txt", "text"] },
      { ctor: () => new $b(), ext: ["exr"] }
      // {ctor: ()=>new EXRExporter2(), ext: ['png', 'jpeg', 'webp']}, // todo
      // {ctor: ()=>new GLTFDracoExporter(), ext: ['gltf', 'glb']},
    ], this._cachedWriters = [];
  }
  addExporter(...e) {
    for (const t of e) {
      if (this.exporters.includes(t)) {
        console.warn("Exporter already added", t);
        return;
      }
      this.exporters.push(t);
    }
  }
  removeExporter(...e) {
    for (const t of e) {
      const i = this.exporters.indexOf(t);
      i >= 0 && this.exporters.splice(i, 1);
    }
  }
  getExporter(...e) {
    return this.exporters.find((t) => t.ext.some((i) => e.includes(i)));
  }
  async exportObject(e, t = {}) {
    var r;
    if (!(e != null && e.assetType)) {
      console.error("Object has no asset type");
      return;
    }
    const i = [];
    e.assetType === "model" && e.traverse((a) => {
      a.userData.excludeFromExport && a.visible && (a.visible = !1, i.push(a));
    });
    const n = await this._exportFile(e, t);
    return e.assetType === "model" && i.forEach((a) => a.visible = !0), (r = e == null ? void 0 : e.userData) != null && r.rootSceneModelRoot && t.viewerConfig === !1 && delete e.userData.__exportViewerConfig, n;
  }
  // export to blob
  async _exportFile(e, t = {}) {
    let i;
    try {
      this.dispatchEvent({ type: "exportFile", obj: e, state: "processing", exportOptions: t });
      const n = await this.processBeforeExport(e, t), r = t.exportExt || (n == null ? void 0 : n.typeExt) || (n == null ? void 0 : n.ext);
      if (!n || !r)
        throw console.error(n, t, e), new Error(`Unable to preprocess before export ${r}`);
      if (n.blob) i = n.blob;
      else {
        const a = this._getWriter(r);
        this.dispatchEvent({ type: "exportFile", obj: e, state: "exporting", exportOptions: t }), i = await a.parseAsync(n.obj, { exportExt: n.ext ?? r, ...t }), i.ext = n.ext;
      }
      this.dispatchEvent({ type: "exportFile", obj: e, state: "done", exportOptions: t });
    } catch (n) {
      throw console.error("AssetExporter: Unable to Export file", e), this.dispatchEvent({ type: "exportFile", obj: e, state: "error", error: n, exportOptions: t }), n;
    }
    return i;
  }
  _createParser(e) {
    const t = this.exporters.find((n) => n.ext.includes(e));
    if (!t)
      throw new Error(`No exporter found for extension ${e}`);
    const i = t == null ? void 0 : t.ctor(this, t);
    if (!i) throw new Error(`Unable to create parser for extension ${e}`);
    return this._cachedWriters.push({ ext: t.ext, parser: i }), this.dispatchEvent({ type: "exporterCreate", exporter: t, parser: i }), i;
  }
  _getWriter(e) {
    var t;
    return ((t = this._cachedWriters.find((i) => i.ext.includes(e))) == null ? void 0 : t.parser) ?? this._createParser(e);
  }
  async processBeforeExport(e, t = {}) {
    var i;
    switch (e.assetType) {
      case "light":
        console.error("AssetExporter: light export not implemented");
        return;
      case "model":
        return { obj: e, ext: "glb" };
      // return {obj, ext: 'gltf'}
      case "material":
        return { obj: e.toJSON(), ext: ((i = e.constructor) == null ? void 0 : i.TypeSlug) || "json", typeExt: "json" };
      case "texture":
        return t.exportExt ? { obj: e, ext: t.exportExt } : { obj: e.toJSON(), ext: "json" };
      case "renderTarget":
        if (e.isWebGLMultipleRenderTargets) console.error("AssetExporter: WebGLMultipleRenderTargets export not supported");
        else if (e.renderManager) {
          const n = e.renderManager.exportRenderTarget(
            e,
            t.exportExt && t.exportExt !== "auto" ? t.exportExt === "exr" ? "image/x-exr" : "image/" + t.exportExt : "auto"
          );
          return {
            obj: e,
            ext: n.ext,
            blob: n
          };
        } else
          return { obj: e, ext: "exr" };
        break;
      default:
        console.error("AssetExporter: unknown asset type", e.assetType);
    }
  }
  dispose() {
  }
}
class VO extends Vi {
  constructor() {
    super(), this.templates = [
      Ds.MaterialTemplate,
      Pa.MaterialTemplate,
      pr.MaterialTemplate,
      Xs.MaterialTemplate,
      Sg.MaterialTemplate,
      bg.MaterialTemplate
    ], this._materials = [], this._disposeMaterial = (e) => {
      const t = e.target;
      if (!(!t || t.assetType !== "material")) {
        t.setDirty();
        for (const i of this._getMapsForMaterial(t))
          !i.isRenderTargetTexture && i.userData.disposeOnIdle !== !1 && !Qh(i) && typeof i.dispose == "function" && i.dispose();
      }
    }, this._materialMaps = /* @__PURE__ */ new Map(), this._materialUpdate = (e) => {
      const t = e.material || e.target;
      !t || t.assetType !== "material" || this._refreshTextureRefs(t);
    }, this._textureUpdate = function(e) {
      !this || this.assetType !== "material" || this.dispatchEvent({ texture: e.target, bubbleToParent: !0, bubbleToObject: !0, ...e, type: "textureUpdate" });
    }, this._materialExtensions = [], WO();
  }
  /**
   * @param info: uuid or template name or material type
   * @param params
   */
  findOrCreate(e, t) {
    let i = this.findMaterial(e);
    return i || (i = this.create(e, t)), i;
  }
  /**
   * Create a material from the template name or material type
   * @param nameOrType
   * @param register
   * @param params
   */
  create(e, t = {}, i = !0) {
    let n = { materialType: e, name: e };
    for (; !n.generator; ) {
      const a = this.findTemplate(n.materialType);
      if (!a) {
        console.warn("Template has no generator or materialType", n, e);
        return;
      }
      n = { ...n, ...a };
    }
    const r = this._create(n, t);
    return r && i && this.registerMaterial(r), r;
  }
  // make global function?
  _create(e, t) {
    if (!e.generator) {
      console.error("Template has no generator", e);
      return;
    }
    const i = (t == null ? void 0 : t.metadata) && (t == null ? void 0 : t.metadata.version) <= 4.5, n = Rt.enabled;
    i && (Rt.enabled = !1);
    const r = e.generator(e.params || {});
    return t && r && r.setValues(t, !0), i && (Rt.enabled = n), r;
  }
  findTemplate(e, t = !1) {
    if (e)
      return this.templates.find((i) => (i.name === e || i.materialType === e) && (!t || i.generator)) || this.templates.find((i) => {
        var n;
        return ((n = i.alias) == null ? void 0 : n.includes(e)) && (!t || i.generator);
      });
  }
  _getMapsForMaterial(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of Object.values(e))
      i && i.isTexture && t.add(i);
    for (const i of Object.values(e.userData ?? {}))
      i && i.isTexture && t.add(i);
    return t;
  }
  _refreshTextureRefs(e) {
    e.__textureUpdate || (e.__textureUpdate = this._textureUpdate.bind(e));
    const t = this._getMapsForMaterial(e), i = this._materialMaps.get(e.uuid) || /* @__PURE__ */ new Set();
    for (const n of t)
      i.has(n) || (n._appliedMaterials || (n._appliedMaterials = /* @__PURE__ */ new Set()), n._appliedMaterials.add(e), n.addEventListener("update", e.__textureUpdate));
    for (const n of i) {
      if (t.has(n) || (n.removeEventListener("update", e.__textureUpdate), !n._appliedMaterials)) continue;
      const r = n._appliedMaterials;
      r == null || r.delete(e), !(!r || n.userData.disposeOnIdle === !1) && r.size === 0 && n.dispose();
    }
    this._materialMaps.set(e.uuid, t);
  }
  registerMaterial(e) {
    var i;
    if (!e || this._materials.includes(e)) return;
    const t = this.findMaterial(e.uuid);
    if (t) {
      console.warn("Material UUID already exists", e, t);
      return;
    }
    e.addEventListener("dispose", this._disposeMaterial), e.addEventListener("materialUpdate", this._materialUpdate), (i = e.registerMaterialExtensions) == null || i.call(e, this._materialExtensions), this._materials.push(e), this._refreshTextureRefs(e);
  }
  registerMaterials(e) {
    e.forEach((t) => this.registerMaterial(t));
  }
  /**
   * This is done automatically on material dispose.
   * @param material
   */
  unregisterMaterial(e) {
    var t;
    this._materials = this._materials.filter((i) => i.uuid !== e.uuid), (t = e.unregisterMaterialExtensions) == null || t.call(e, this._materialExtensions), e.removeEventListener("dispose", this._disposeMaterial), e.removeEventListener("materialUpdate", this._materialUpdate);
  }
  clearMaterials() {
    [...this._materials].forEach((e) => this.unregisterMaterial(e));
  }
  registerMaterialTemplate(e) {
    e.templateUUID || (e.templateUUID = Ss());
    const t = this.templates.find((i) => i.templateUUID === e.templateUUID);
    if (t) {
      console.error("MaterialTemplate already exists", e, t);
      return;
    }
    this.templates.push(e);
  }
  unregisterMaterialTemplate(e) {
    const t = this.templates.findIndex((i) => i.templateUUID === e.templateUUID);
    t >= 0 && this.templates.splice(t, 1);
  }
  dispose(e = !0) {
    const t = this._materials;
    this._materials = [];
    for (const i of t) {
      if (!e && i.userData.runtimeMaterial) {
        this._materials.push(i);
        continue;
      }
      i.dispose();
    }
  }
  findMaterial(e) {
    return e ? this._materials.find((t) => t.uuid === e) : void 0;
  }
  findMaterialsByName(e, t = !1) {
    return this._materials.filter(
      (i) => typeof e != "string" || t ? i.name.match(typeof e == "string" ? "^" + e + "$" : e) !== null : i.name === e
    );
  }
  getMaterialsOfType(e) {
    return e ? this._materials.filter((t) => t.constructor.TypeSlug === e) : [];
  }
  getAllMaterials() {
    return [...this._materials];
  }
  // processModel(object: IModel, options: AnyOptions): IModel {
  //     const k = this._processModel(object, options)
  //     safeSetProperty(object, 'modelObject', k)
  //     return object
  // }
  // protected abstract _processModel(object: any, options: AnyOptions): any
  /**
   * Creates a new material if a compatible template is found or apply minimal upgrades and returns the original material.
   * Also checks from the registered materials, if one with the same uuid is found, it is returned instead with the new parameters.
   * Also caches the response.
   * Returns the same material if its already upgraded.
   * @param material - the material to upgrade/check
   * @param useSourceMaterial - if false, will not use the source material parameters in the new material. default = true
   * @param materialTemplate - any specific material template to use instead of detecting from the material type.
   * @param createFromTemplate - if false, will not create a new material from the template, but will apply minimal upgrades to the material instead. default = true
   */
  convertToIMaterial(e, { useSourceMaterial: t = !0, materialTemplate: i, createFromTemplate: n = !0 } = {}) {
    var o, l;
    if (!e) return;
    if (e.assetType) return e;
    if ((o = e.iMaterial) != null && o.assetType) return e.iMaterial;
    const r = ((l = e.userData) == null ? void 0 : l.uuid) || e.uuid;
    let a = this.findMaterial(r);
    if (!a && n !== !1) {
      const c = t === !1 || !e.isMaterial, h = i || !c && e.type && e.type || "physical";
      a = this.create(h, c ? void 0 : e);
    } else a && (console.warn("Material with the same uuid already exists, copying properties"), e.type !== a.type && console.error("Material type mismatch, delete previous material first?", e, a), a.setValues(e));
    return a ? (a.uuid = r, a.userData.uuid = r, e.iMaterial = a) : (console.warn("Failed to convert material to IMaterial, just upgrading", e, t, i), a = ge.upgradeMaterial.call(e)), a;
  }
  registerMaterialExtension(e) {
    var t;
    if (!this._materialExtensions.includes(e)) {
      this._materialExtensions.push(e);
      for (const i of this._materials) (t = i.registerMaterialExtensions) == null || t.call(i, [e]);
    }
  }
  unregisterMaterialExtension(e) {
    var i;
    const t = this._materialExtensions.indexOf(e);
    if (!(t < 0)) {
      this._materialExtensions.splice(t, 1);
      for (const n of this._materials) (i = n.unregisterMaterialExtensions) == null || i.call(n, [e]);
    }
  }
  clearExtensions() {
    [...this._materialExtensions].forEach((e) => this.unregisterMaterialExtension(e));
  }
  exportMaterial(e, t, i = !0, n = !1) {
    const r = e.toJSON(), a = JSON.stringify(r, null, i ? 0 : 2), o = (t || e.name || "physical_material") + "." + e.constructor.TypeSlug, l = new File([a], o, { type: "application/json" });
    return n && qR(l), l;
  }
  applyMaterial(e, t, i = !0) {
    let n = this.findMaterialsByName(t, i);
    (!n || n.length < 1) && (n = [this.findMaterial(t)]);
    let r = !1;
    for (const a of n) {
      if (!a || a === e || a.userData.__isVariation) continue;
      this.copyMaterialProps(a, e) && (r = !0);
    }
    return r;
  }
  /**
   * copyProps from material to c
   * @param c
   * @param material
   */
  copyMaterialProps(e, t) {
    let i = !1;
    const n = Object.getPrototypeOf(t).constructor.TYPE;
    if (Object.getPrototypeOf(e).constructor.TYPE === n) {
      const a = e.name;
      e.setValues(t), e.name = a, i = !0;
    } else {
      const a = e["__" + n] || this.create(n);
      if (a) {
        const o = e.name;
        a.setValues(t), a.name = o;
        const l = e.appliedMeshes;
        for (const c of [...l ?? []])
          c && (c.material = a, i = !0);
        e["__" + n] = a;
      }
    }
    return i;
  }
}
function WO() {
  const s = `
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
`;
  ft.bumpmap_pars_fragment = Ct(ft.bumpmap_pars_fragment, s, `
    #ifdef BUMP_MAP_SCALE_LEGACY
        ${s.replace(/normalize/g, "")}
    #else
        ${s}
    #endif
    `);
}
class jO extends Qw {
  constructor(e) {
    super(e), this.type = Qt;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(e) {
    const a = function(E, x) {
      switch (E) {
        case 1:
          throw new Error("THREE.RGBELoader: Read Error: " + (x || ""));
        case 2:
          throw new Error("THREE.RGBELoader: Write Error: " + (x || ""));
        case 3:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (x || ""));
        default:
        case 4:
          throw new Error("THREE.RGBELoader: Memory Error: " + (x || ""));
      }
    }, h = `
`, u = function(E, x, b) {
      x = x || 1024;
      let O = E.pos, Y = -1, B = 0, Q = "", j = String.fromCharCode.apply(null, new Uint16Array(E.subarray(O, O + 128)));
      for (; 0 > (Y = j.indexOf(h)) && B < x && O < E.byteLength; )
        Q += j, B += j.length, O += 128, j += String.fromCharCode.apply(null, new Uint16Array(E.subarray(O, O + 128)));
      return -1 < Y ? (E.pos += B + Y + 1, Q + j.slice(0, Y)) : !1;
    }, d = function(E) {
      const x = /^#\?(\S+)/, b = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, D = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, O = /^\s*FORMAT=(\S+)\s*$/, Y = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, B = {
        valid: 0,
        /* indicate which fields are valid */
        string: "",
        /* the actual header string */
        comments: "",
        /* comments found in header */
        programtype: "RGBE",
        /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */
        format: "",
        /* RGBE format, default 32-bit_rle_rgbe */
        gamma: 1,
        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */
        exposure: 1,
        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */
        width: 0,
        height: 0
        /* image dimensions, width/height */
      };
      let Q, j;
      for ((E.pos >= E.byteLength || !(Q = u(E))) && a(1, "no header found"), (j = Q.match(x)) || a(3, "bad initial token"), B.valid |= 1, B.programtype = j[1], B.string += Q + `
`; Q = u(E), Q !== !1; ) {
        if (B.string += Q + `
`, Q.charAt(0) === "#") {
          B.comments += Q + `
`;
          continue;
        }
        if ((j = Q.match(b)) && (B.gamma = parseFloat(j[1])), (j = Q.match(D)) && (B.exposure = parseFloat(j[1])), (j = Q.match(O)) && (B.valid |= 2, B.format = j[1]), (j = Q.match(Y)) && (B.valid |= 4, B.height = parseInt(j[1], 10), B.width = parseInt(j[2], 10)), B.valid & 2 && B.valid & 4) break;
      }
      return B.valid & 2 || a(3, "missing format specifier"), B.valid & 4 || a(3, "missing image size specifier"), B;
    }, p = function(E, x, b) {
      const D = x;
      if (
        // run length encoding is not allowed so read flat
        D < 8 || D > 32767 || // this file is not run length encoded
        E[0] !== 2 || E[1] !== 2 || E[2] & 128
      )
        return new Uint8Array(E);
      D !== (E[2] << 8 | E[3]) && a(3, "wrong scanline width");
      const O = new Uint8Array(4 * x * b);
      O.length || a(4, "unable to allocate buffer space");
      let Y = 0, B = 0;
      const Q = 4 * D, j = new Uint8Array(4), X = new Uint8Array(Q);
      let Z = b;
      for (; Z > 0 && B < E.byteLength; ) {
        B + 4 > E.byteLength && a(1), j[0] = E[B++], j[1] = E[B++], j[2] = E[B++], j[3] = E[B++], (j[0] != 2 || j[1] != 2 || (j[2] << 8 | j[3]) != D) && a(3, "bad rgbe scanline format");
        let ee = 0, J;
        for (; ee < Q && B < E.byteLength; ) {
          J = E[B++];
          const K = J > 128;
          if (K && (J -= 128), (J === 0 || ee + J > Q) && a(3, "bad scanline data"), K) {
            const ce = E[B++];
            for (let fe = 0; fe < J; fe++)
              X[ee++] = ce;
          } else
            X.set(E.subarray(B, B + J), ee), ee += J, B += J;
        }
        const W = D;
        for (let K = 0; K < W; K++) {
          let ce = 0;
          O[Y] = X[K + ce], ce += D, O[Y + 1] = X[K + ce], ce += D, O[Y + 2] = X[K + ce], ce += D, O[Y + 3] = X[K + ce], Y += 4;
        }
        Z--;
      }
      return O;
    }, f = function(E, x, b, D) {
      const O = E[x + 3], Y = Math.pow(2, O - 128) / 255;
      b[D + 0] = E[x + 0] * Y, b[D + 1] = E[x + 1] * Y, b[D + 2] = E[x + 2] * Y, b[D + 3] = 1;
    }, y = function(E, x, b, D) {
      const O = E[x + 3], Y = Math.pow(2, O - 128) / 255;
      b[D + 0] = Gn.toHalfFloat(Math.min(E[x + 0] * Y, 65504)), b[D + 1] = Gn.toHalfFloat(Math.min(E[x + 1] * Y, 65504)), b[D + 2] = Gn.toHalfFloat(Math.min(E[x + 2] * Y, 65504)), b[D + 3] = Gn.toHalfFloat(1);
    }, A = new Uint8Array(e);
    A.pos = 0;
    const m = d(A), v = m.width, g = m.height, _ = p(A.subarray(A.pos), v, g);
    let w, S, C;
    switch (this.type) {
      case Xt:
        C = _.length / 4;
        const E = new Float32Array(C * 4);
        for (let b = 0; b < C; b++)
          f(_, b * 4, E, b * 4);
        w = E, S = Xt;
        break;
      case Qt:
        C = _.length / 4;
        const x = new Uint16Array(C * 4);
        for (let b = 0; b < C; b++)
          y(_, b * 4, x, b * 4);
        w = x, S = Qt;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: v,
      height: g,
      data: w,
      header: m.string,
      gamma: m.gamma,
      exposure: m.exposure,
      type: S
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, i, n) {
    function r(a, o) {
      switch (a.type) {
        case Xt:
        case Qt:
          a.colorSpace = Mt, a.minFilter = tt, a.magFilter = tt, a.generateMipmaps = !1, a.flipY = !0;
          break;
      }
      t && t(a, o);
    }
    return super.load(e, r, i, n);
  }
}
function qO(s, e) {
  const t = (s.version ? s.version : "0.0.0").split(".").map((n) => parseInt(n));
  if (!(s.type === "ViewerApp" && t[0] === 0 && (t[1] < 7 || t[1] === 7 && t[2].toString()[0] < "6")))
    return;
  const i = /* @__PURE__ */ new Set();
  e.forEach((n) => n.traverse((r) => {
    r.material && i.add(r.material);
  })), i.forEach((n) => {
    const r = n.map;
    if (!r) return;
    const a = r.repeat, o = r.offset, l = r.center, c = r.rotation;
    ["alphaMap", "aoMap", "bumpMap", "displacementMap", "emissiveMap", "lightMap", "metalnessMap", "normalMap", "roughnessMap", "transmissionMap"].forEach((u) => {
      const d = n[u];
      d && (d.repeat.copy(a), d.offset.copy(o), d.center.copy(l), d.rotation = c, d.needsUpdate = !0);
    }), n.needsUpdate = !0;
  });
}
const Ry = class Ry extends Vi {
  constructor(e, { simpleCache: t = !1, storage: i } = {}) {
    super(), this._gltfExporter = {
      ext: ["gltf", "glb"],
      extensions: [],
      ctor: (n, r) => {
        const a = new zg();
        return a.setup(this.viewer, r.extensions), a;
      }
    }, this.processState = /* @__PURE__ */ new Map(), this.gltfExtensions = [], this._sceneUpdated = this._sceneUpdated.bind(this), this.addAsset = this.addAsset.bind(this), this.addRaw = this.addRaw.bind(this), this._loaderCreate = this._loaderCreate.bind(this), this.addImported = this.addImported.bind(this), this.importer = new qh(!!e.getPlugin("debug")), this.exporter = new HO(), this.materials = new VO(), this.viewer = e, this.viewer.scene.addEventListener("addSceneObject", this._sceneUpdated), this.viewer.scene.addEventListener("materialChanged", this._sceneUpdated), this.viewer.scene.addEventListener("beforeDeserialize", this._sceneUpdated), this._initCacheStorage(t, i ?? !0), this._setupGltfExtensions(), this._setupObjectProcess(), this._setupProcessState(), this._addImporters(), this._addExporters();
  }
  get storage() {
    return this._storage;
  }
  async addAsset(e, t) {
    if (!this.importer || !this.viewer) return [];
    const i = await this.importer.import(e, t);
    if (!i) {
      const n = typeof e == "string" ? e : e == null ? void 0 : e.path;
      return n && !n.split("?")[0].endsWith(".vjson") && console.warn("Threepipe AssetManager - Unable to import", e, i), [];
    }
    return this.loadImported(i, t);
  }
  // materials: IMaterial[] = []
  // textures: ITexture[] = []
  // todo move this function to viewer
  async loadImported(e, {
    autoSetEnvironment: t = !0,
    autoSetBackground: i = !1,
    ...n
  } = {}) {
    var o, l, c;
    const r = Array.isArray(e) ? e : [e];
    let a = Array.isArray(e) ? [] : void 0;
    if ((n == null ? void 0 : n.importConfig) !== !1) {
      const h = r.find((u) => (u == null ? void 0 : u.assetType) === "config") || ((o = r.find((u) => u && !!u.importedViewerConfig)) == null ? void 0 : o.importedViewerConfig);
      h && qO(h, r.filter((u) => u == null ? void 0 : u.isObject3D));
    }
    for (const h of r) {
      if (!h) {
        Array.isArray(a) && a.push(void 0);
        continue;
      }
      let u = h;
      switch (h.assetType) {
        case "material":
          this.materials.registerMaterial(h);
          break;
        case "texture":
          t && ((l = h.__rootPath) != null && l.endsWith(".hdr") || (c = h.__rootPath) != null && c.endsWith(".exr")) && (this.viewer.scene.environment = h), i && (this.viewer.scene.background = h);
          break;
        case "model":
        case "light":
        case "camera":
          u = await this.viewer.addSceneObject(h, n);
          break;
        case "config":
          (n == null ? void 0 : n.importConfig) !== !1 && await this.viewer.importConfig(h);
          break;
        default:
          h.type && typeof h.type == "string" && (Array.isArray(h.plugins) || h.type === "ThreeViewer" || this.viewer.getPlugin(h.type)) && await this.viewer.importConfig(h);
          break;
      }
      this.dispatchEvent({ type: "loadAsset", data: h }), Array.isArray(a) ? a.push(u) : a = u;
    }
    return a || [];
  }
  /**
   * same as {@link loadImported}
   * @param imported
   * @param options
   */
  async addProcessedAssets(e, t) {
    return this.loadImported(e, t);
  }
  async addAssetSingle(e, t) {
    var i;
    return e ? (i = await this.addAsset(e, t)) == null ? void 0 : i[0] : void 0;
  }
  // processAndAddObjects
  async addRaw(e, t = {}) {
    const i = await this.importer.processRaw(e, t);
    return this.loadImported(i, t);
  }
  async addRawSingle(e, t = {}) {
    var i;
    return (i = await this.addRaw(e, t)) == null ? void 0 : i[0];
  }
  _sceneUpdated(e) {
    var t;
    if (e.type === "addSceneObject") {
      const n = e.object;
      switch (n.assetType) {
        case "material":
          this.materials.registerMaterial(n);
          break;
      }
    } else if (e.type === "materialChanged") {
      const n = e.material, r = Array.isArray(n) ? n : n ? [n] : [];
      for (const a of r)
        this.materials.registerMaterial(a);
    } else if (e.type === "beforeDeserialize") {
      const i = e, n = i.data, r = i.meta;
      n.metadata || console.warn("Invalid data(no metadata)", n), i.material && (((t = n.metadata) == null ? void 0 : t.type) !== "Material" && console.warn("Invalid material data", n), Ap.DeserializeMaterialJSON(n, this.viewer, r, i.material).then(() => {
      }));
    } else
      console.error("Unexpected");
  }
  dispose() {
    this.importer.dispose(), this.materials.dispose(), this.processState.clear(), this.viewer.scene.removeEventListener("addSceneObject", this._sceneUpdated), this.viewer.scene.removeEventListener("materialChanged", this._sceneUpdated), this.exporter.dispose();
  }
  _addImporters() {
    const e = this.viewer;
    if (!e) return;
    const t = [
      new $i(Gg, ["svg", "data:image/svg"], ["image/svg+xml"], !1),
      // todo: use ImageBitmapLoader if supported (better performance)
      new $i(xo, ["webp", "png", "jpeg", "jpg", "ico", "data:image", "avif", "bmp", "gif", "tiff"], [
        "image/webp",
        "image/png",
        "image/jpeg",
        "image/gif",
        "image/bmp",
        "image/tiff",
        "image/x-icon",
        "image/avif"
      ], !1),
      // todo: use ImageBitmapLoader if supported (better performance)
      new $i(
        Ap,
        ["mat", ...this.materials.templates.map((i) => i.typeSlug).filter((i) => i)],
        // todo add others
        [],
        !1,
        (i) => (i && (i.viewer = this.viewer), i)
      ),
      new $i(class extends jO {
        constructor(i) {
          super(i), this.setDataType(qv(e.renderManager.renderer));
        }
      }, ["hdr"], ["image/vnd.radiance"], !1),
      new $i(class extends Xb {
        constructor(i) {
          super(i), this.setDataType(qv(e.renderManager.renderer));
        }
      }, ["exr"], ["image/x-exr"], !1),
      new $i(oF, ["fbx"], ["model/fbx"], !0),
      new $i(lF, ["zip", "glbz", "gltfz"], ["application/zip", "model/gltf+zip", "model/zip"], !0),
      // gltfz and glbz are invented zip files with gltf/glb inside along with resources
      new $i(DU, ["obj"], ["model/obj"], !0),
      new $i(hb, ["mtl"], ["model/mtl"], !1),
      new $i(Ng, ["gltf", "glb", "data:model/gltf", "data:model/glb"], ["model/gltf", "model/gltf+json", "model/gltf-binary", "model/glb"], !0, (i, n, r) => i == null ? void 0 : i.setup(this.viewer, r.extensions)),
      new $i(kg, ["drc"], ["model/mesh+draco", "model/drc"], !0)
    ];
    this.importer.addImporter(...t);
  }
  _addExporters() {
    const e = [this._gltfExporter];
    this.exporter.addExporter(...e);
  }
  _initCacheStorage(e, t) {
    var i, n;
    if (t === !0 && (window != null && window.caches)) {
      (n = (i = window.caches).open) == null || n.call(i, "threepipe-assetmanager").then((r) => {
        this._initCacheStorage(e, r), this._storage = r;
      });
      return;
    }
    (e || t) && (e && (us.enabled = !0), t && window.Cache && typeof window.Cache == "function" && t instanceof window.Cache && kB(t)), this._storage = typeof t == "boolean" ? void 0 : t;
  }
  _setupObjectProcess() {
    this.importer.addEventListener("processRaw", (e) => {
      var i;
      const t = e.data;
      !t || !t.isMaterial || !t.uuid || ((i = this.materials) != null && i.findMaterial(t.uuid) && (console.warn("imported material uuid already exists, creating new uuid"), t.uuid = Ss(), t.userData.uuid && (t.userData.uuid = t.uuid)), this.materials.registerMaterial(t));
    }), this.importer.addEventListener("processRawStart", (e) => {
      var n;
      const t = e.data, i = e.options;
      if (t.isObject3D) {
        const r = [], a = [];
        t.traverse((o) => {
          if (o.material) {
            const l = Array.isArray(o.material) ? o.material : [o.material], c = [];
            for (const h of l) {
              const u = this.materials.convertToIMaterial(h, { createFromTemplate: i.replaceMaterials !== !1 }) || h;
              u.uuid = h.uuid, u.userData.uuid = h.uuid, c.push(u);
            }
            Array.isArray(o.material) ? o.material = c : o.material = c[0];
          }
          o.isCamera && r.push(o), o.isLight && a.push(o);
        });
        for (const o of r)
          if (o.assetType !== "camera")
            if (!o.isPerspectiveCamera || !o.parent || i.replaceCameras === !1)
              Zi.upgradeCamera.call(o);
            else {
              const l = o.iCamera ?? new mu("", this.viewer.canvas);
              if (o === l) continue;
              o.parent.children.splice(o.parent.children.indexOf(o), 1, l), l.parent = o.parent, l.copy(o), o.parent = null, l.uuid = o.uuid, l.userData.uuid = o.uuid, o.iCamera = l;
            }
        for (const o of a)
          if (o.assetType !== "light")
            if (!o.parent || i.replaceLights === !1)
              en.upgradeLight.call(o);
            else {
              const l = o.iLight ?? o.isDirectionalLight ? new Bi() : o.isPointLight ? new yi() : o.isSpotLight ? new oi() : o.isAmbientLight ? new Mo() : o.isHemisphereLight ? new Kr() : o.isRectAreaLight ? new gr() : void 0;
              if (o === l || !l) continue;
              o.parent.children.splice(o.parent.children.indexOf(o), 1, l), l.parent = o.parent, l.copy(o), o.parent = null, l.uuid = o.uuid, l.userData.uuid = o.uuid, o.iLight = l;
            }
        ct.upgradeObject3D.call(t);
      } else t.isMaterial ? ge.upgradeMaterial.call(t) : t.isTexture && (tb.call(t), ((n = e == null ? void 0 : e.options) == null ? void 0 : n.generateMipmaps) !== void 0 && (t.generateMipmaps = e == null ? void 0 : e.options.generateMipmaps), !t.generateMipmaps && !t.isRenderTargetTexture && (t.minFilter = t.minFilter === Qn ? tt : t.minFilter, t.magFilter = t.magFilter === Qn ? tt : t.magFilter));
    });
  }
  /**
   * Set process state for a path
   * Progress should be a number between 0 and 100
   * Pass undefined in value to remove the state
   * @param path
   * @param value
   */
  setProcessState(e, t) {
    t === void 0 ? this.processState.delete(e) : this.processState.set(e, t), this.dispatchEvent({ type: "processStateUpdate" });
  }
  _setupProcessState() {
    this.importer.addEventListener("importFile", (e) => {
      this.setProcessState(e.path, e.state !== "done" ? {
        state: e.state,
        progress: e.progress ? e.progress * 100 : void 0
      } : void 0);
    }), this.importer.addEventListener("processRawStart", (e) => {
      this.setProcessState(e.path, {
        state: "processing",
        progress: void 0
      });
    }), this.importer.addEventListener("processRaw", (e) => {
      this.setProcessState(e.path, void 0);
    }), this.exporter.addEventListener("exportFile", (e) => {
      this.setProcessState(e.obj.name, e.state !== "done" ? {
        state: e.state,
        progress: e.progress ? e.progress * 100 : void 0
      } : void 0);
    });
  }
  _setupGltfExtensions() {
    this.importer.addEventListener("loaderCreate", this._loaderCreate), this.viewer.forPlugin("GLTFDracoExportPlugin", (e) => {
      if (e.addExtension)
        for (const t of this.gltfExtensions)
          e.addExtension(t.name, t.textures);
    });
  }
  _loaderCreate({ loader: e }) {
    if (e.isGLTFLoader2)
      for (const t of this.gltfExtensions)
        e.register(t.import);
  }
  registerGltfExtension(e) {
    var n;
    const t = this.gltfExtensions.findIndex((r) => r.name === e.name);
    t >= 0 && this.gltfExtensions.splice(t, 1), this.gltfExtensions.push(e), this._gltfExporter.extensions.push(e.export);
    const i = this.exporter.getExporter("gltf", "glb");
    i && i !== this._gltfExporter && ((n = i.extensions) == null || n.push(e.export));
  }
  unregisterGltfExtension(e) {
    var r;
    const t = this.gltfExtensions.findIndex((a) => a.name === e);
    if (t < 0) return;
    this.gltfExtensions.splice(t, 1);
    const i = this._gltfExporter.extensions.findIndex((a) => a.name === e);
    i >= 0 && this._gltfExporter.extensions.splice(i, 1);
    const n = this.exporter.getExporter("gltf", "glb");
    if (n != null && n.extensions && n !== this._gltfExporter) {
      const a = n.extensions.findIndex((o) => o.name === e);
      a >= 0 && ((r = n.extensions) == null || r.splice(a, 1));
    }
  }
  // endregion
  // region deprecated
  /**
   * @deprecated use addRaw instead
   * @param res
   * @param options
   */
  async addImported(e, t = {}) {
    return console.error("addImported is deprecated, use addRaw instead"), this.addRaw(e, t);
  }
  /**
   * @deprecated use addAsset instead
   * @param path
   * @param options
   */
  async addFromPath(e, t = {}) {
    return console.error("addFromPath is deprecated, use addAsset instead"), this.addAsset(e, t);
  }
  /**
   * @deprecated use {@link ThreeViewer.exportConfig} instead
   * @param binary - if set to false, encodes all the array buffers to base64
   */
  exportViewerConfig(e = !0) {
    return this.viewer ? (console.error("exportViewerConfig is deprecated, use viewer.toJSON instead"), this.viewer.toJSON(e, void 0)) : {};
  }
  /**
   * @deprecated use {@link ThreeViewer.exportPluginsConfig} instead
   * @param filter
   */
  exportPluginPresets(e) {
    var t;
    return console.error("exportPluginPresets is deprecated, use viewer.exportPluginsConfig instead"), (t = this.viewer) == null ? void 0 : t.exportPluginsConfig(e);
  }
  /**
   * @deprecated use {@link ThreeViewer.exportPluginConfig} instead
   * @param plugin
   */
  exportPluginPreset(e) {
    var t;
    return console.error("exportPluginPreset is deprecated, use viewer.exportPluginConfig instead"), (t = this.viewer) == null ? void 0 : t.exportPluginConfig(e);
  }
  /**
   * @deprecated use {@link ThreeViewer.importPluginConfig} instead
   * @param json
   * @param plugin
   */
  async importPluginPreset(e, t) {
    var i;
    return console.error("importPluginPreset is deprecated, use viewer.importPluginConfig instead"), (i = this.viewer) == null ? void 0 : i.importPluginConfig(e, t);
  }
  // todo continue from here by moving functions to the viewer.
  /**
   * @deprecated use {@link ThreeViewer.importConfig} instead
   * @param viewerConfig
   */
  async importViewerConfig(e) {
    var t;
    return (t = this.viewer) == null ? void 0 : t.importConfig(e);
  }
  /**
   * @deprecated use {@link ThreeViewer.fromJSON} instead
   * @param viewerConfig
   */
  applyViewerConfig(e, t) {
    var i;
    return console.error("applyViewerConfig is deprecated, use viewer.fromJSON instead"), (i = this.viewer) == null ? void 0 : i.fromJSON(e, t);
  }
  /**
   * @deprecated moved to {@link ThreeViewer.loadConfigResources}
   * @param json
   * @param extraResources - preloaded resources in the format of viewer config resources.
   */
  async importConfigResources(e, t) {
    var i;
    if (!this.importer) throw "Importer not initialized yet.";
    return e.__isLoadedResources ? e : (i = this.viewer) == null ? void 0 : i.loadConfigResources(e, t);
  }
  // endregion
};
Ry.PluginType = "AssetManager";
let Hg = Ry;
var XO = Object.defineProperty, YO = Object.getOwnPropertyDescriptor, Er = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? YO(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && XO(e, t, n), n;
};
let Mn = class extends EU {
  constructor({ canvas: s, alpha: e = !0, renderScale: t = 1, targetOptions: i }) {
    super(), this._renderSize = new ie(512, 512), this._renderScale = 1, this._passes = [], this._pipeline = [], this._passesNeedsUpdate = !0, this._frameCount = 0, this._lastTime = 0, this._totalFrameCount = 0, this.stableNoise = !1, this.frameWaitTime = 0, this._dirty = !0, this.autoBuildPipeline = !0, this.defaultRenderToScreen = !0, this.onPostFrame = () => {
      var r;
      for (const a of this._passes)
        a.enabled && a.onPostFrame && ((r = a.onPostFrame) == null || r.call(a, this));
    }, this._animationLoop = this._animationLoop.bind(this), this._renderSize = new ie(s.clientWidth, s.clientHeight), this._renderScale = t, this._renderer = this._initWebGLRenderer(s, e), this._context = this._renderer.getContext(), this._isWebGL2 = this._renderer.capabilities.isWebGL2, this._isWebGL2 || console.error("RenderManager: WebGL 1 is not officially supported anymore. Some features may not work."), this.resetShadows();
    const n = this.createTarget(i, !1);
    n.texture.name = "EffectComposer.rt1", this._composer = new xU(this._renderer, n);
  }
  // keep here in code so its at the top in the UI
  get renderScale() {
    return this._renderScale;
  }
  set renderScale(s) {
    s !== this._renderScale && (this._renderScale = s, this.setSize(void 0, void 0, !0));
  }
  _shadowMapTypeChanged() {
    this.resetShadows(), this.reset();
  }
  get renderer() {
    return this._renderer;
  }
  rebuildPipeline(s = !0) {
    this._passesNeedsUpdate = !0, s && this._updated({ change: "rebuild" });
  }
  /**
   * Regenerates the render pipeline by resolving dependencies and sorting the passes.
   * This is called automatically when the passes are changed.
   */
  _refreshPipeline() {
    if (!this.autoBuildPipeline) return this._pipeline;
    const s = this._passes;
    return this._pipeline = yU(s);
  }
  _animationLoop(s, e) {
    const t = s - this._lastTime;
    this._lastTime = s, this.frameWaitTime -= t, !(this.frameWaitTime > 0) && (this.frameWaitTime = 0, this.dispatchEvent({ type: "animationLoop", deltaTime: t, time: s, renderer: this._renderer, xrFrame: e }));
  }
  _initWebGLRenderer(s, e) {
    const t = new kp({
      canvas: s,
      antialias: !1,
      alpha: e,
      premultipliedAlpha: !1,
      // todo: see this, maybe use this with rgbm mode.
      preserveDrawingBuffer: !0,
      powerPreference: Mn.POWER_PREFERENCE
    });
    return t.setAnimationLoop(this._animationLoop), t.onContextLost = (i) => {
      this.dispatchEvent({ type: "contextLost", event: i });
    }, t.onContextRestore = () => {
      this.dispatchEvent({ type: "contextRestored" });
    }, t.setSize(this._renderSize.width, this._renderSize.height, !1), t.setPixelRatio(this._renderScale), t.toneMapping = Vr, t.toneMappingExposure = 1, t.outputColorSpace = Wt, t.shadowMap.enabled = !0, t.shadowMap.type = Zg, t.shadowMap.autoUpdate = !1, eU.call(t, this);
  }
  setSize(s, e, t = !1) {
    !t && (s ? Math.abs(s - this._renderSize.width) : 0) + (e ? Math.abs(e - this._renderSize.height) : 0) < 0.1 || (s && (this._renderSize.width = s), e && (this._renderSize.height = e), this.webglRenderer.xr.enabled && this.webglRenderer.xr.isPresenting || (this._renderer.setSize(this._renderSize.width, this._renderSize.height, !1), this._renderer.setPixelRatio(this._renderScale)), this._composer.setPixelRatio(this._renderScale, !1), this._composer.setSize(this._renderSize.width, this._renderSize.height), this.resizeTrackedTargets(), this.dispatchEvent({ type: "resize" }), this._updated({ change: "size", data: this._renderSize.toArray() }), this.reset());
  }
  render(s, e) {
    this._passesNeedsUpdate && (this._refreshPipeline(), this.refreshPasses());
    for (const t of this._passes)
      t.enabled && t.beforeRender && t.beforeRender(s, s.renderCamera, this);
    this._composer.renderToScreen = e ?? this.defaultRenderToScreen, this.dispatchEvent({ type: "preRender", scene: s, renderToScreen: this._composer.renderToScreen }), this._composer.render(), this.dispatchEvent({ type: "postRender", scene: s, renderToScreen: this._composer.renderToScreen }), this._composer.renderToScreen = !0, e && this.incRenderToScreen(), this._dirty = !1;
  }
  // todo better name
  incRenderToScreen() {
    this._frameCount += 1, this._totalFrameCount += 1;
  }
  get needsRender() {
    return this._dirty = this._dirty || this._passes.findIndex((s) => gi(s.dirty)) >= 0, this._dirty;
  }
  setDirty(s = !1) {
    this._dirty = !0, s && this.reset();
  }
  reset() {
    this._frameCount = 0, this._dirty = !0;
  }
  resetShadows() {
    this._renderer.shadowMap.needsUpdate = !0;
  }
  refreshPasses() {
    if (!this._passesNeedsUpdate) return;
    this._passesNeedsUpdate = !1;
    const s = [];
    for (const e of this._pipeline) {
      const t = this._passes.find((i) => i.passId === e);
      if (!t) {
        console.warn("Unable to find pass: ", e);
        continue;
      }
      s.push(t);
    }
    [...this._composer.passes].forEach((e) => this._composer.removePass(e)), s.forEach((e) => this._composer.addPass(e)), this._updated({ change: "passRefresh" });
  }
  dispose(s = !0) {
    super.dispose(s), this._renderer.dispose();
  }
  updateShaderProperties(s) {
    return s.uniforms.currentFrameCount && (s.uniforms.currentFrameCount.value = this.frameCount), this.stableNoise ? s.uniforms.frameCount ? s.uniforms.frameCount.value = this.frameCount : console.warn("RenderManager: no uniform: frameCount") : s.uniforms.frameCount ? s.uniforms.frameCount.value = this._totalFrameCount : console.warn("RenderManager: no uniform: frameCount"), this;
  }
  // region Passes
  registerPass(s, e = !0) {
    var t;
    if (e)
      for (const i of [...this._passes])
        s.passId === i.passId && this.unregisterPass(i);
    this._passes.push(s), (t = s.onRegister) == null || t.call(s, this), this.rebuildPipeline(!1), this._updated({ change: "registerPass", pass: s });
  }
  unregisterPass(s) {
    var t;
    const e = this._passes.indexOf(s);
    e >= 0 && ((t = s.onUnregister) == null || t.call(s, this), this._passes.splice(e, 1), this.rebuildPipeline(!1), this._updated({ change: "unregisterPass", pass: s }));
  }
  // endregion
  // region Getters and Setters
  get frameCount() {
    return this._frameCount;
  }
  get totalFrameCount() {
    return this._totalFrameCount;
  }
  resetTotalFrameCount() {
    this._totalFrameCount = 0;
  }
  set pipeline(s) {
    this._pipeline = s, this.autoBuildPipeline && console.warn("RenderManager: pipeline changed, but autoBuildPipeline is true. This will not have any effect."), this.rebuildPipeline();
  }
  get pipeline() {
    return this._pipeline;
  }
  get composer() {
    return this._composer;
  }
  get passes() {
    return this._passes;
  }
  get isWebGL2() {
    return this._isWebGL2;
  }
  get composerTarget() {
    return this._composer.renderTarget1;
  }
  get composerTarget2() {
    return this._composer.renderTarget2;
  }
  /**
   * The size set in the three.js renderer.
   * Final size is renderSize * renderScale
   */
  get renderSize() {
    return this._renderSize;
  }
  get context() {
    return this._context;
  }
  /**
   * Same as {@link renderer}
   */
  get webglRenderer() {
    return this._renderer;
  }
  get useLegacyLights() {
    return this._renderer.useLegacyLights;
  }
  set useLegacyLights(s) {
    this._renderer.useLegacyLights = s, this._updated({ change: "useLegacyLights", data: s }), this.resetShadows();
  }
  get clock() {
    return this._composer.clock;
  }
  // endregion
  // region Utils
  /**
   * blit - blits a texture to the screen or another render target.
   * @param destination - destination target, or screen if undefined or null
   * @param source - source Texture
   * @param viewport - viewport and scissor
   * @param material - override material
   * @param clear - clear before blit
   * @param respectColorSpace - does color space conversion when reading and writing to the target
   * @param blending - Note - Set to NormalBlending if transparent is set to false
   * @param transparent
   */
  blit(s, { source: e, viewport: t, material: i, clear: n = !0, respectColorSpace: r = !1, blending: a = _n, transparent: o = !0 } = {}) {
    const l = r ? this._composer.copyPass2 : this._composer.copyPass, { renderToScreen: c, material: h, uniforms: u, clear: d } = l;
    i && (l.material = i);
    const p = l.material.transparent, f = s ? s.viewport.clone() : this._renderer.getViewport(new it()), y = s ? s.scissor.clone() : this._renderer.getScissor(new it()), A = s ? s.scissorTest : this._renderer.getScissorTest(), m = this._renderer.autoClear, v = this._renderer.getRenderTarget(), g = l.material.blending;
    t && (s ? (s.viewport.copy(t), s.scissor.copy(t), s.scissorTest = !0) : (this._renderer.setViewport(t), this._renderer.setScissor(t), this._renderer.setScissorTest(!0))), this._renderer.autoClear = !1, l.material.blending = o ? a : dr, l.uniforms = l.material.uniforms, l.renderToScreen = !1, l.clear = n, l.material.transparent = o, l.material.needsUpdate = !0, this._renderer.renderWithModes({
      sceneRender: !0,
      opaqueRender: !0,
      shadowMapRender: !1,
      backgroundRender: !1,
      transparentRender: !0,
      transmissionRender: !1
    }, () => {
      l.render(this._renderer, s || null, { texture: e }, 0, !1);
    }), l.renderToScreen = c, l.clear = d, l.material = h, l.uniforms = u, l.material.blending = g, l.material.transparent = p, this._renderer.autoClear = m, t && (s ? (s.viewport.copy(f), s.scissor.copy(y), s.scissorTest = A) : (this._renderer.setViewport(f), this._renderer.setScissor(y), this._renderer.setScissorTest(A))), this._renderer.setRenderTarget(v);
  }
  clearColor({ r: s, g: e, b: t, a: i, target: n, depth: r = !0, stencil: a = !0, viewport: o }) {
    const l = this._renderer.getClearColor(new se()), c = this._renderer.getClearAlpha();
    this._renderer.setClearColor(new se(s ?? l.r, e ?? l.g, t ?? l.b), i ?? c);
    const h = this._renderer.getRenderTarget(), u = this._renderer.getActiveCubeFace(), d = this._renderer.getActiveMipmapLevel(), p = n ? n.viewport.clone() : this._renderer.getViewport(new it()), f = n ? n.scissor.clone() : this._renderer.getScissor(new it()), y = n ? n.scissorTest : this._renderer.getScissorTest();
    o && (n ? (n.viewport.copy(o), n.scissor.copy(o), n.scissorTest = !0) : (this._renderer.setViewport(o), this._renderer.setScissor(o), this._renderer.setScissorTest(!0))), this._renderer.setRenderTarget(n ?? null), this._renderer.clear(!0, r, a), n && typeof n.clear == "function" ? n.clear(this._renderer, !0, r, a) : (this._renderer.setRenderTarget(n ?? null), this._renderer.clear(!0, r, a)), o && (n ? (n.viewport.copy(p), n.scissor.copy(f), n.scissorTest = y) : (this._renderer.setViewport(p), this._renderer.setScissor(f), this._renderer.setScissorTest(y))), this._renderer.setRenderTarget(h, u, d), this._renderer.setClearColor(l, c);
  }
  /**
   * Converts a render target to a png/jpeg data url string.
   * Note: this will clamp the values to [0, 1] and converts to srgb for float and half-float render targets.
   * @param target
   * @param mimeType
   * @param quality
   * @param textureIndex - index of the texture to use in the render target (only in case of multiple render target)
   */
  renderTargetToDataUrl(s, e = "image/png", t = 90, i = 0) {
    const n = document.createElement("canvas");
    n.width = s.width, n.height = s.height;
    const r = n.getContext("2d");
    if (!r) throw new Error("Unable to get 2d context");
    const a = Array.isArray(s.texture) ? s.texture[i] : s.texture, o = r.createImageData(s.width, s.height, { colorSpace: ["display-p3", "srgb"].includes(a.colorSpace) ? a.colorSpace : void 0 });
    if (a.type === Qt || a.type === Xt) {
      const c = this.renderTargetToBuffer(s, i);
      sE({ data: c, width: s.width, height: s.height }, a.colorSpace, o);
    } else
      this._renderer.readRenderTargetPixels(s, 0, 0, s.width, s.height, o.data, void 0, i);
    r.putImageData(o, 0, 0);
    const l = (a.flipY ? n : eE(n)).toDataURL(e, t);
    return n.remove(), l;
  }
  /**
   * Rend pixels from a render target into a new Uint8Array|Uint16Array|Float32Array buffer
   * @param target - render target to read from
   * @param textureIndex - index of the texture to use in the render target (only in case of multiple render target)
   */
  renderTargetToBuffer(s, e = 0) {
    const t = Array.isArray(s.texture) ? s.texture[e] : s.texture, i = t.type === Qt ? new Uint16Array(s.width * s.height * 4) : t.type === Xt ? new Float32Array(s.width * s.height * 4) : new Uint8Array(s.width * s.height * 4);
    return this._renderer.readRenderTargetPixels(s, 0, 0, s.width, s.height, i, void 0, e), i;
  }
  /**
   * Exports a render target to a blob. The type is automatically picked from exr to png based on the render target.
   * @param target - render target to export
   * @param mimeType - mime type to use.
   * If auto (default), then it will be picked based on the render target type.
   * @param textureIndex - index of the texture to use in the render target (only in case of multiple render target)
   */
  exportRenderTarget(s, e = "auto", t = 0) {
    const i = ["image/x-exr"], n = Array.isArray(s.texture) ? s.texture[t] : s.texture;
    let r = n.type === Qt || n.type === Xt;
    e === "auto" && (e = r ? "image/x-exr" : "image/png"), i.includes(e) || (r = !1);
    let a;
    if (r)
      e !== "image/x-exr" && (console.warn("RenderManager: mimeType ", e, " is not supported for HDR. Using EXR instead"), e = "image/x-exr"), a = new $b().parse(this._renderer, s, { textureIndex: t }).buffer;
    else {
      const l = this.renderTargetToDataUrl(s, e === "auto" ? void 0 : e, 90, t);
      a = Yw(l.split(",")[1]), e = l.split(";")[0].split(":")[1];
    }
    const o = new Blob([a], { type: e });
    return o.ext = e === "image/x-exr" ? "exr" : e.split("/")[1], o;
  }
  // endregion
  // region Events Dispatch
  _updated(s) {
    this.dispatchEvent({ ...s, type: "update" });
  }
  // endregion
  _createTargetClass(s, e, t) {
    const i = this._processNewTarget, n = this.disposeTarget.bind(this);
    return new class extends s {
      constructor(a, ...o) {
        super(...o), this.renderManager = a, this.assetType = "renderTarget", this.name = "RenderTarget", this._ui_isPrimitive = !0, this.uuid = Ss();
        const l = o[o.length - 1], c = l == null ? void 0 : l.colorSpace;
        this._initTexture(c);
      }
      _initTexture(a) {
        Array.isArray(this.texture) ? this.texture.forEach((o) => {
          a !== void 0 && (o.colorSpace = a), o._target = this, o.toJSON = () => (console.warn("Multiple render target texture.toJSON not supported yet."), {});
        }) : (this.texture._target = this, this.texture.toJSON = () => ({
          // todo use readRenderTargetPixels as data url or data buffer.
          isRenderTargetTexture: !0
        }));
      }
      setSize(a, o, l) {
        return super.setSize(Math.floor(a), Math.floor(o), l), this;
      }
      clone(a = !0) {
        var c;
        if (this.isTemporary) throw "Cloning temporary render targets not supported";
        if (Array.isArray(this.texture)) throw "Cloning multiple render targets not supported";
        const o = new this.constructor(this.renderManager);
        o.copy(this), o._initTexture((c = Array.isArray(this.texture) ? this.texture[0] : this.texture) == null ? void 0 : c.colorSpace);
        const l = o.texture;
        return Array.isArray(l) ? l.forEach((h) => h.isRenderTargetTexture = !0) : l.isRenderTargetTexture = !0, i(o, this.sizeMultiplier || 1, a);
      }
      // copy(source: IRenderTarget|RenderTarget): this {
      //     super.copy(source as any)
      //     return this
      // }
      // Note - by default unregister need to be false.
      dispose(a = !1) {
        a === !0 ? n(this, !0) : super.dispose();
      }
    }(this, ...e, t);
  }
  /**
   * @deprecated use renderScale instead
   */
  get displayCanvasScaling() {
    return console.error("displayCanvasScaling is deprecated, use renderScale instead"), this.renderScale;
  }
  /**
   * @deprecated use renderScale instead
   */
  set displayCanvasScaling(s) {
    console.error("displayCanvasScaling is deprecated, use renderScale instead"), this.renderScale = s;
  }
};
Mn.POWER_PREFERENCE = "high-performance";
Er([
  Ic("Render Size")
], Mn.prototype, "_renderSize", 2);
Er([
  Ye("Render Scale", [0.1, 8], 0.05)
], Mn.prototype, "renderScale", 1);
Er([
  V(),
  er("Shadow Map Type", ["BasicShadowMap", "PCFShadowMap", "PCFSoftShadowMap", "VSMShadowMap"].map((s, e) => ({ label: s, value: e })), { tags: ["advanced"] }),
  Ht({ obj: "shadowMap", key: "type", onChange: Mn.prototype._shadowMapTypeChanged })
], Mn.prototype, "shadowMapType", 2);
Er([
  Ht({ obj: "renderer", key: "shadowMap" })
], Mn.prototype, "shadowMap", 2);
Er([
  Ki(void 0, { label: "Passes", tags: ["advanced"], order: 1e3 })
], Mn.prototype, "_passes", 2);
Er([
  ue(),
  V()
], Mn.prototype, "stableNoise", 2);
Er([
  Pi(Mn.prototype.rebuildPipeline)
], Mn.prototype, "autoBuildPipeline", 2);
Er([
  Pt("Rebuild Pipeline", { sendArgs: !1, tags: ["advanced"] })
], Mn.prototype, "rebuildPipeline", 1);
Er([
  V()
], Mn.prototype, "useLegacyLights", 1);
Mn = Er([
  $w("RenderManager"),
  Lt("Render Manager")
], Mn);
var KO = Object.defineProperty, JO = Object.getOwnPropertyDescriptor, Zb = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? JO(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && KO(e, t, n), n;
};
let Ar = class extends Mn {
  constructor({ rgbm: s = !0, msaa: e = !1, depthBuffer: t = !1, ...i }) {
    super({
      ...i,
      targetOptions: {
        samples: 0,
        // samples: msaa ? typeof msaa !== 'number' ? ViewerRenderManager.DEFAULT_MSAA_SAMPLES : msaa : 0,
        colorSpace: s ? Es : Wt,
        type: s ? Ft : Qt,
        depthBuffer: t,
        generateMipmaps: (
          /* msaa ? true : */
          !1
        ),
        // todo: hack for now, fix blurTransmissionTarget in ExtendedRenderPass
        minFilter: (
          /* msaa ? LinearMipMapLinearFilter : */
          tt
        )
        // todo: hack for now, fix blurTransmissionTarget in ExtendedRenderPass
      }
    }), this.rgbm = s, this.msaa = e && this.isWebGL2, this.depthBuffer = t, this.zPrepass = i.zPrepass || !1, this.maxHDRIntensity = i.maxHDRIntensity ?? (s ? 16 : 72);
    let n = !0;
    this._renderer.userData || (n = !1, this._renderer.userData = { __isIWebGLRenderer: !0 }), this._renderer.userData.renderTransmissionPass = !n, this.renderPass = new ab(this), this.screenPass = new La(i.screenShader || ""), this.registerPass(this.renderPass), this.registerPass(this.screenPass);
  }
  _gbufferUnpackExtensionChanged(s) {
    this.dispatchEvent({ type: "gbufferUnpackExtensionChanged", ...s });
  }
  render(s, e) {
    const t = this.screenPass.clipBackgroundForce;
    if (this.rgbm) {
      const i = !s.background && !s.backgroundColor;
      i !== t && (this.screenPass.clipBackgroundForce = i);
    }
    super.render(s, e);
  }
};
Ar.DEFAULT_MSAA_SAMPLES = 4;
Zb([
  bt(Ar.prototype._gbufferUnpackExtensionChanged)
], Ar.prototype, "gbufferUnpackExtension", 2);
Ar = Zb([
  Lt("Render Manager")
], Ar);
var $O = Object.defineProperty, ZO = Object.getOwnPropertyDescriptor, Ga = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? ZO(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && $O(e, t, n), n;
};
let Ys = class extends Tt {
  constructor(s) {
    super(), this.enabled = !0, this._allowedExtensions = void 0, this.autoImport = !0, this.autoAdd = !0, this.importOptions = {
      autoImportZipContents: !0,
      forceImporterReprocess: !1
    }, this.addOptions = {
      autoCenter: !0,
      importConfig: !0,
      autoScale: !0,
      autoScaleRadius: 2,
      centerGeometries: !1,
      // in the whole hierarchy
      centerGeometriesKeepPosition: !0,
      // this centers while keeping world position
      license: "",
      clearSceneObjects: !1,
      disposeSceneObjects: !1,
      autoSetBackground: !1,
      autoSetEnvironment: !0
    }, s && (this._domElement = s.domElement, this.allowedExtensions = s.allowedExtensions, this.autoImport = s.autoImport ?? this.autoImport, this.autoAdd = s.autoAdd ?? this.autoAdd, this.importOptions = { ...this.importOptions, ...s.importOptions }, this.addOptions = { ...this.addOptions, ...s.addOptions });
  }
  /**
   * Allowed file extensions. If undefined, all files are allowed.
   */
  get allowedExtensions() {
    return this._allowedExtensions;
  }
  set allowedExtensions(s) {
    this._allowedExtensions = s, this._inputEl && (this._inputEl.accept = s ? s.map((e) => "." + e).join(", ") : "");
  }
  promptForFile() {
    var s;
    this.isDisabled() || (this.allowedExtensions = this._allowedExtensions, (s = this._inputEl) == null || s.click());
  }
  async promptForUrl() {
    if (this.isDisabled() || !this._viewer) return;
    const s = await this._viewer.dialog.prompt("Enter URL: Enter a public URL for a 3d file with extension", "", !0);
    !s || !s.length || await this.load(s, {}, !0);
  }
  async load(s, e, t = !1) {
    if (!this._viewer) {
      console.warn("DropzonePlugin: viewer not set");
      return;
    }
    if (this.autoImport) {
      const i = this._viewer.assetManager, n = og(s);
      if (this._allowedExtensions && !this._allowedExtensions.includes(n)) {
        t && await this._viewer.dialog.alert(`DropzonePlugin: file extension ${n} not allowed`);
        return;
      }
      const a = [...await i.importer.import(s, {
        ...this.importOptions,
        ...e ?? {}
      }) ?? []].flat(2).filter((o) => !!o) ?? [];
      return this.autoAdd ? await i.loadImported(a, {
        ...this.addOptions,
        ...e ?? {}
      }) : a;
    } else
      t && await this._viewer.dialog.alert("DropzonePlugin: autoImport is disabled, file was not imported");
  }
  onAdded(s) {
    super.onAdded(s), this._inputEl = document.createElement("input"), this._inputEl.type = "file", this._domElement || (this._domElement = s.canvas), this._dropzone = new cg(this._domElement, this._inputEl, {
      drop: this._onFileDrop.bind(this)
    }), this.allowedExtensions = this._allowedExtensions;
  }
  onRemove(s) {
    var e;
    super.onRemove(s), (e = this._dropzone) == null || e.destroy(), this._dropzone = void 0, this._inputEl = void 0;
  }
  async _onFileDrop({ files: s, nativeEvent: e }) {
    var a;
    if (!s || this.isDisabled()) return;
    const t = this._viewer;
    if (!t) return;
    if (this._allowedExtensions !== void 0)
      for (const o of s.keys())
        this._allowedExtensions.includes(((a = o.split(".").pop()) == null ? void 0 : a.toLowerCase()) ?? "") || s.delete(o);
    if (s.size < 1) return;
    const i = t.assetManager;
    let n, r;
    if (this.autoImport && (n = await i.importer.importFiles(s, {
      allowedExtensions: this.allowedExtensions,
      ...this.importOptions
    }), this.autoAdd)) {
      const o = [...(n == null ? void 0 : n.values()) ?? []].flat(2).filter((l) => !!l) ?? [];
      r = await i.loadImported(o, { ...this.addOptions });
    }
    this.dispatchEvent({ type: "drop", files: s, imported: n, assets: r, nativeEvent: e });
  }
};
Ys.PluginType = "Dropzone";
Ga([
  ue(),
  V()
], Ys.prototype, "enabled", 2);
Ga([
  V()
], Ys.prototype, "autoImport", 2);
Ga([
  ue(),
  V()
], Ys.prototype, "autoAdd", 2);
Ga([
  Ki(),
  V()
], Ys.prototype, "importOptions", 2);
Ga([
  Ki(),
  V()
], Ys.prototype, "addOptions", 2);
Ga([
  Pt("Select Local files")
], Ys.prototype, "promptForFile", 1);
Ga([
  Pt("Import from URL")
], Ys.prototype, "promptForUrl", 1);
Ys = Ga([
  Lt("Dropzone")
], Ys);
const e3 = `
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return saturate(Uncharted2Helper(color)/Uncharted2Helper(vec3(1.0)));}vec3 CustomToneMapping(vec3 color){return Uncharted2ToneMapping(color);}`, t3 = `int getToneMapBit(in int number){
#ifdef WebGL2Context
return(number/2)% 2;
#else
return int(mod(floor(float(number)/2.),2.));
#endif
}vec3 TonemappingSaturation(vec3 rgb){const vec3 W=vec3(0.2125,0.7154,0.0721);vec3 intensity=vec3(dot(rgb,W));return mix(intensity,rgb,toneMappingSaturation);}vec3 TonemappingContrast(vec3 color){return(color-vec3(0.5))*toneMappingContrast+vec3(0.5);}vec4 ToneMapping(in vec4 color){vec4 outColor=color;
#if defined( TONE_MAPPING )
outColor.rgb=toneMapping(outColor.rgb);outColor.rgb=TonemappingContrast(outColor.rgb);outColor.rgb=TonemappingSaturation(outColor.rgb);
#endif
return outColor;}`, i3 = `bool doTonemap=true;
#ifdef HAS_GBUFFER
#ifdef GBUFFER_HAS_FLAGS
doTonemap=getToneMapBit(getGBufferFlags(vUv).a)>0;
#endif
#if TONEMAP_BACKGROUND < 1
if(isBackground)doTonemap=false;
#endif
#endif
if(doTonemap)diffuseColor=ToneMapping(diffuseColor);`;
var n3 = Object.defineProperty, eS = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && n3(e, t, n), n;
};
const Cp = class extends Tt {
  constructor() {
    super(), this.enabled = !0, this._beforeRender = this._beforeRender.bind(this);
  }
  /**
   * This function is called every frame before composer render, if this pass is being used in the pipeline
   * @param _
   * @param _1
   * @param _2
   */
  _beforeRender(e, t, i) {
    return this._pass ? (this._pass.enabled = !this.isDisabled(), this._pass.enabled) : !1;
  }
  onAdded(e) {
    var t;
    super.onAdded(e), this._pass = this._createPass(), (t = this._pass.onDirty) == null || t.push(e.setDirty), this._pass.beforeRender = tB(this._beforeRender, this._pass.beforeRender), e.renderManager.registerPass(this._pass);
  }
  onRemove(e) {
    this._pass && (e.renderManager.unregisterPass(this._pass), this._pass.dispose && this._pass.dispose()), this._pass = void 0, super.onRemove(e);
  }
  get pass() {
    return this._pass;
  }
  toJSON(e) {
    return super.toJSON(e);
  }
  fromJSON(e, t) {
    return super.fromJSON(e, t);
  }
  setDirty() {
    var e, t, i;
    this._pass && (this._pass.enabled = !this.isDisabled()), (e = this._viewer) == null || e.setDirty(), (i = (t = this.uiConfig) == null ? void 0 : t.uiRefresh) == null || i.call(t, !0, "postFrame", 100);
  }
};
eS([
  V(),
  ue("Enabled"),
  Oe(Cp.prototype.setDirty)
], Cp.prototype, "enabled");
eS([
  V("pass")
], Cp.prototype, "_pass");
let kc = Cp;
const xx = `#ifndef UNPACK_GBUFFER_SNIPPET
#define UNPACK_GBUFFER_SNIPPET
uniform sampler2D tNormalDepth;float unpack16(vec2 value){return value.x+value.y/255.0;}vec3 unpackNormal(vec2 enc){vec2 fenc=enc*4.0-2.0;float f=dot(fenc,fenc);float g=sqrt(1.0-f/4.0);return vec3(fenc*g,1.0-f/2.0);}float unpackDepth(vec2 uncodedDepth){float x=unpack16(uncodedDepth.xy);return x*x;}
#define getDepth(uv) unpackDepth(texture2D(tNormalDepth, uv).xy)
void getDepthNormal(const in vec2 uv,out float depth,out vec3 normal){vec4 uncodedDepth=texture2D(tNormalDepth,uv);depth=unpackDepth(uncodedDepth.xy);normal=unpackNormal(uncodedDepth.zw);}vec3 getViewNormal(const in vec2 uv){return unpackNormal(texture2D(tNormalDepth,uv).zw);}
#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1
uniform sampler2D tGBufferFlags;
#endif
ivec4 getGBufferFlags(const in vec2 uv){
#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1
return ivec4(texture2D(tGBufferFlags,uv)*255.);
#else
return ivec4(1);
#endif
}
#if defined(GBUFFER_HAS_DEPTH_TEXTURE) && GBUFFER_HAS_DEPTH_TEXTURE == 1
uniform sampler2D tGBufferDepthTexture;float getDepthTexture(vec2 coord,float cameraNear,float cameraFar){float fragCoordZ=texture2D(tGBufferDepthTexture,coord).x;float viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);return viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);}
#endif
#endif
`, s3 = `
#define DEPTH_NORMAL
#if IS_GLSL3 > 0
out vec3 vViewPosition;
#else
varying vec3 vViewPosition;
#endif
#ifdef USE_ALPHAMAP
#define USE_UV
#endif
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition=-mvPosition.xyz;}`, r3 = `
#define DEPTH_NORMAL
#if IS_GLSL3 > 0
in vec3 vViewPosition;
#else
varying vec3 vViewPosition;
#endif
#ifdef USE_ALPHAMAP
#define USE_UV
#include <packing>
#endif
#if IS_GLSL3 > 0
#ifndef gl_FragColor
layout(location=0)out vec4 gDepthNormal;layout(location=1)out vec4 gFlags;
#endif
#endif
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
uniform vec2 cameraNearFar;uniform vec4 flags;vec2 pack16(float value){float f=clamp(value,0.0,1.0)*255.0;float digitLow=fract(f);float digitHigh=floor(f)/255.0;return vec2(digitHigh,digitLow);}vec2 packNormal(vec3 n){float p=sqrt(n.z*8.0+8.0);return vec2(n.xy/p+0.5);}float linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.0,1.0);}void main(){
#glMarker mainStart
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(1.0);
#include <map_fragment>
#ifdef USE_ALPHAMAP
float alphaMapValue=
#ifdef ALPHA_I_RGBA_PACKING
1.-unpackRGBAToDepth(texture2D(alphaMap,vAlphaMapUv));
#else
texture2D(alphaMap,vAlphaMapUv).g;
#endif
#if defined(INVERSE_ALPHAMAP) && INVERSE_ALPHAMAP >= 1
diffuseColor.a*=1.0-alphaMapValue;
#else
diffuseColor.a*=alphaMapValue;
#endif
#endif
#include <alphatest_fragment>
#include <logdepthbuf_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#ifdef FORCED_LINEAR_DEPTH
float linearZ=float(FORCED_LINEAR_DEPTH);
#else
float linearZ=linstep(-cameraNearFar.x,-cameraNearFar.y,-vViewPosition.z);
#endif
vec2 packedZ=pack16(pow(max(0.,linearZ),0.5));vec2 packedNormal=packNormal(normal);
#if IS_GLSL3 > 0
#ifndef gl_FragColor
gDepthNormal=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);gFlags=flags;
#else
gl_FragColor=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);
#endif
#else
gl_FragColor=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);
#endif
}`;
var a3 = Object.defineProperty, o3 = Object.getOwnPropertyDescriptor, af = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? o3(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && a3(e, t, n), n;
};
let yr = class extends kc {
  constructor(s = Ft, e = !0, t = !0, i = !0, n = !1, r = qs) {
    super(), this.renderFlagsBuffer = i, this.renderDepthTexture = n, this.depthTextureType = r, this.passId = "gbuffer", this.textures = [], this.unpackExtension = {
      /**
       * Use this in shader to get the snippet
       * ```
       * // for gbuffer
       * #include <packing>
       * #define THREE_PACKING_INCLUDED
       * ```
       * or if you don't need packing include
       * ```
       * #include <gbuffer_unpack>
       * ```
       * @param shader
       */
      shaderExtender: (a) => {
        const l = ["gbuffer_unpack", "packing"].find((c) => a.fragmentShader.includes(`#include <${c}>`));
        a.fragmentShader = Ct(
          a.fragmentShader,
          `#include <${l}>`,
          `
` + xx + `
`,
          { append: l === "packing" }
        );
      },
      extraUniforms: {
        tNormalDepth: () => ({ value: this.normalDepthTexture }),
        tGBufferFlags: () => ({ value: this.flagsTexture }),
        tGBufferDepthTexture: () => ({ value: this.depthTexture })
      },
      extraDefines: {
        // ['GBUFFER_PACKING']: BasicDepthPacking,
        HAS_NORMAL_DEPTH_BUFFER: () => this.normalDepthTexture ? 1 : void 0,
        GBUFFER_HAS_DEPTH_TEXTURE: () => this.depthTexture ? 1 : void 0,
        GBUFFER_HAS_FLAGS: () => this.flagsTexture ? 1 : void 0,
        // ['HAS_FLAGS_BUFFER']: ()=>this.flagsTexture ? 1 : undefined,
        HAS_GBUFFER: () => this.isPrimaryGBuffer && this.normalDepthTexture ? 1 : void 0
        // LINEAR_DEPTH: 1, // to tell that the depth is linear. todo; see SSAOPlugin. also add support in DepthBufferPlugin?
      },
      priority: 100,
      isCompatible: () => !0
    }, this._isPrimaryGBufferSet = !1, this.enabled = t, this.bufferType = s, this.isPrimaryGBuffer = e;
  }
  get normalDepthTexture() {
    return this.textures[0];
  }
  get flagsTexture() {
    return this.textures[1];
  }
  get depthTexture() {
    var s;
    return (s = this.target) == null ? void 0 : s.depthTexture;
  }
  _createTargetAndMaterial(s = !0) {
    var t;
    if (!this._viewer) return;
    s && this._disposeTarget();
    const e = ((t = this._viewer) == null ? void 0 : t.renderManager.isWebGL2) && this.renderFlagsBuffer;
    if (!this.target) {
      const i = this._viewer.renderManager;
      this.target = this._viewer.renderManager.createTarget(
        {
          depthBuffer: !0,
          samples: this._viewer.renderManager.zPrepass && this.isPrimaryGBuffer && i.msaa ? (
            // requirement for zPrepass
            typeof i.msaa != "number" ? Ar.DEFAULT_MSAA_SAMPLES : i.msaa
          ) : 0,
          type: this.bufferType,
          textureCount: e ? 2 : 1,
          depthTexture: this.renderDepthTexture,
          depthTextureType: this.depthTextureType,
          // magFilter: NearestFilter,
          // minFilter: NearestFilter,
          // generateMipmaps: false,
          // encoding: LinearEncoding,
          wrapS: Zt,
          wrapT: Zt
        }
      ), Array.isArray(this.target.texture) ? (this.target.texture[0].name = "gbufferDepthNormal", this.target.texture[1].name = "gbufferFlags", this.textures = this.target.texture) : (this.target.texture.name = "gbufferDepthNormal", this.textures.push(this.target.texture));
    }
    this.material || (this.material = new tS(e, {
      blending: _n,
      transparent: !0
    })), this.isPrimaryGBuffer && (this._viewer.renderManager.gbufferTarget = this.target, this._viewer.renderManager.gbufferUnpackExtension = this.unpackExtension, this._viewer.renderManager.screenPass.material.registerMaterialExtensions([this.unpackExtension]), this._isPrimaryGBufferSet = !0);
  }
  _disposeTarget() {
    this._viewer && (this.target && (this._viewer.renderManager.disposeTarget(this.target), this.target = void 0), this.textures = [], this._isPrimaryGBufferSet && (this._viewer.renderManager.gbufferTarget = void 0, this._viewer.renderManager.gbufferUnpackExtension = void 0, this._isPrimaryGBufferSet = !1));
  }
  _createPass() {
    if (this._createTargetAndMaterial(!0), !this.target) throw new Error("GBufferPlugin: target not created");
    if (!this.material) throw new Error("GBufferPlugin: material not created");
    this.material.userData.isGBufferMaterial = !0;
    const s = new To(this.passId, () => this.target, this.material, new se(1, 1, 1), 1), e = s.preprocessMaterial;
    return s.preprocessMaterial = (t) => e(t, t.userData.renderToDepth), s.before = ["render"], s.after = [], s.required = ["render"], s;
  }
  _beforeRender(s, e, t) {
    return !super._beforeRender(s, e, t) || !this.material ? !1 : (e.updateShaderProperties(this.material), !0);
  }
  registerGBufferUpdater(s, e) {
    this.material && this.material.flagUpdaters.set(s, e);
  }
  unregisterGBufferUpdater(s) {
    this.material && this.material.flagUpdaters.delete(s);
  }
  onRemove(s) {
    var e;
    return this._disposeTarget(), (e = this.material) == null || e.dispose(), this.material = void 0, super.onRemove(s);
  }
  /**
   * @deprecated use {@link normalDepthTexture} instead
   */
  getDepthNormal() {
    return this.textures.length > 0 ? this.textures[0] : void 0;
  }
  /**
   * @deprecated use {@link flagsTexture} instead
   */
  getFlagsTexture() {
    return this.textures.length > 1 ? this.textures[1] : void 0;
  }
  /**
   * @deprecated use {@link target} instead
   */
  getTarget() {
    return this.target;
  }
  /**
   * @deprecated use {@link unpackExtension} instead
   */
  getUnpackSnippet() {
    return xx;
  }
  /**
   * @deprecated use {@link unpackExtension} instead, it adds the same uniforms and defines
   * @param material
   */
  updateShaderProperties(s) {
    var e;
    if (s.uniforms.tNormalDepth ? s.uniforms.tNormalDepth.value = this.normalDepthTexture ?? void 0 : (e = this._viewer) == null || e.console.warn("BaseRenderer: no uniform: tNormalDepth"), s.uniforms.tGBufferFlags) {
      s.uniforms.tGBufferFlags.value = this.flagsTexture ?? void 0;
      const t = s.uniforms.tGBufferFlags.value ? 1 : 0;
      t !== s.defines.GBUFFER_HAS_FLAGS && (s.defines.GBUFFER_HAS_FLAGS = t, s.needsUpdate = !0);
    }
    return this;
  }
};
yr.PluginType = "GBuffer";
af([
  ta(void 0, { readOnly: !0 })
], yr.prototype, "normalDepthTexture", 1);
af([
  ta(void 0, { readOnly: !0 })
], yr.prototype, "flagsTexture", 1);
af([
  ta(void 0, { readOnly: !0 })
], yr.prototype, "depthTexture", 1);
yr = af([
  Lt("G-Buffer Plugin")
], yr);
class tS extends gp {
  constructor(e = !0, t) {
    super({
      vertexShader: s3,
      fragmentShader: r3,
      uniforms: Ec.merge([
        Re.common,
        Re.bumpmap,
        Re.normalmap,
        Re.displacementmap,
        {
          cameraNearFar: { value: new ie(0.1, 1e3) },
          // this has to be set from outside
          flags: { value: new it(255, 255, 255, 255) }
        }
      ]),
      defines: {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        IS_GLSL3: e ? "1" : "0"
      },
      glslVersion: e ? Jm : KS,
      ...t
    }), this.flagUpdaters = /* @__PURE__ */ new Map(), this.normalMapType = Ts, this.flatShading = !1, this.reset();
  }
  onBeforeRender(e, t, i, n, r) {
    var c, h;
    super.onBeforeRender(e, t, i, n, r);
    let a = r.material;
    if (Array.isArray(a) && (a = a[0]), !a) return;
    const o = (u) => {
      const d = a[u];
      d && (this.uniforms[u].value = d, this.uniforms[u + "Transform"] ? d.isTexture && e.materials.refreshTransformUniform(d, this.uniforms[u + "Transform"]) : console.error("GBufferMaterial: " + u + "Transform is not defined in uniform"));
    };
    o("map"), a.side !== void 0 && (this.side = a.side ?? zi), o("alphaMap"), a.alphaTest !== void 0 && (this.alphaTest = a.alphaTest < 1e-4 ? 1e-4 : a.alphaTest), a.alphaHash !== void 0 && (this.alphaHash = a.alphaHash), o("bumpMap"), a.bumpScale !== void 0 && (this.uniforms.bumpScale.value = a.bumpScale), o("normalMap"), a.normalScale !== void 0 && this.uniforms.normalScale.value.copy(a.normalScale), a.normalMapType !== void 0 && (this.normalMapType = a.normalMapType), a.flatShading !== void 0 && (this.flatShading = a.flatShading), o("displacementMap"), a.displacementScale !== void 0 && (this.uniforms.displacementScale.value = a.displacementScale), a.displacementBias !== void 0 && (this.uniforms.displacementBias.value = a.displacementBias), a.wireframe !== void 0 && (this.wireframe = a.wireframe), a.wireframeLinewidth !== void 0 && (this.wireframeLinewidth = a.wireframeLinewidth), this.uniforms.flags.value.set(255, 255, 255, 255);
    const l = ((c = a.userData.gBufferData) == null ? void 0 : c.materialId) ?? a.userData.matId;
    this.uniforms.flags.value.z = l || 0, this.flagUpdaters.forEach((u) => u(this.uniforms.flags.value, { material: a, renderer: e, scene: t, camera: i, geometry: n, object: r })), this.uniforms.flags.value.x /= 255, this.uniforms.flags.value.y /= 255, this.uniforms.flags.value.z /= 255, this.uniforms.flags.value.w /= 255, this.uniformsNeedUpdate = !0, Vo({
      // ['USE_ALPHAMAP']: this.uniforms.alphaMap.value ? 1 : undefined,
      ALPHAMAP_UV: this.uniforms.alphaMap.value ? "uv" : void 0,
      // todo use getChannel, see WebGLPrograms.js
      USE_DISPLACEMENTMAP: this.uniforms.displacementMap.value ? 1 : void 0,
      DISPLACEMENTMAP_UV: this.uniforms.displacementMap.value ? "uv" : void 0,
      // todo use getChannel, see WebGLPrograms.js
      ALPHA_I_RGBA_PACKING: a.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0,
      FORCED_LINEAR_DEPTH: a.userData.forcedLinearDepth ?? void 0
      // todo add to DepthBufferPlugin as well.
    }, a), (h = a.materialExtensions) != null && h.length && this.registerMaterialExtensions(a.materialExtensions), this.needsUpdate = !0;
  }
  onAfterRender(e, t, i, n, r) {
    var o;
    super.onAfterRender(e, t, i, n, r);
    let a = r.material;
    Array.isArray(a) && (a = a[0]), a && ((o = a.materialExtensions) != null && o.length && this.unregisterMaterialExtensions(a.materialExtensions), this.reset());
  }
  reset() {
    this.uniforms.map.value = null, this.side = zi, this.uniforms.alphaMap.value = null, this.alphaTest = 1e-3, this.alphaHash = !1, this.uniforms.bumpMap.value = null, this.uniforms.bumpScale.value = 1, this.uniforms.normalMap.value = null, this.uniforms.normalScale.value.set(1, 1), this.normalMapType = Ts, this.flatShading = !1, this.uniforms.displacementMap.value = null, this.uniforms.displacementScale.value = 1, this.uniforms.displacementBias.value = 0, this.uniforms.flags.value.set(255, 255, 255, 255), this.wireframe = !1, this.wireframeLinewidth = 1;
  }
}
class EQ extends tS {
  constructor(e, t) {
    super(e, t), console.warn("DepthNormalMaterial is deprecated, use GBufferMaterial instead");
  }
}
class of extends Tt {
  constructor(e = "") {
    super(), this.priority = -100, this._shaderPatch = "", this.computeCacheKey = (t) => this.isDisabled() ? "0" : "1", this._shaderPatch = e, this.setDirty = this.setDirty.bind(this);
  }
  set uniformsNeedUpdate(e) {
    e && this.setDirty();
  }
  shaderExtender(e, t, i) {
    this.isDisabled() || (e.fragmentShader = Ct(
      e.fragmentShader,
      "#glMarker",
      `
` + this._shaderPatch + `
`,
      { prepend: !0 }
    ));
  }
  getUiConfig() {
    return this.uiConfig;
  }
  isCompatible(e) {
    return !0;
  }
  setDirty() {
    var e, t;
    (e = this.__setDirty) == null || e.call(this), (t = this._viewer) == null || t.renderManager.screenPass.setDirty();
  }
  fromJSON(e, t) {
    return e.pass && (e = { ...e }, e.extension = { ...e.pass }, delete e.extension.enabled, delete e.pass), e.extension && (e = { ...e, ...e.extension }, delete e.extension), super.fromJSON(e, t);
  }
  onAdded(e) {
    super.onAdded(e), e.forPlugin(yr, (t) => {
      t.registerGBufferUpdater(this.constructor.PluginType, this.updateGBufferFlags.bind(this));
    }, (t) => {
      t.unregisterGBufferUpdater(this.constructor.PluginType);
    }), e.renderManager.screenPass.material.registerMaterialExtensions([this]);
  }
  onRemove(e) {
    var t;
    (t = e.getPlugin(yr)) == null || t.unregisterGBufferUpdater(this.constructor.PluginType), e.renderManager.screenPass.material.unregisterMaterialExtensions([this]), super.onRemove(e);
  }
  updateGBufferFlags(e, t) {
  }
}
var l3 = Object.defineProperty, c3 = Object.getOwnPropertyDescriptor, qo = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? c3(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && l3(e, t, n), n;
};
const h3 = ew;
let es = class extends of {
  constructor() {
    super(...arguments), this.extraUniforms = {
      toneMappingContrast: { value: 1 },
      toneMappingSaturation: { value: 1 }
    }, this.extraDefines = {
      TONEMAP_BACKGROUND: "1"
    }, this.enabled = !0, this.toneMapping = eA, this.tonemapBackground = !0, this.exposure = 1, this.priority = -100, this.parsFragmentSnippet = () => this.isDisabled() ? "" : Oa`
            uniform float toneMappingContrast;
            uniform float toneMappingSaturation;
            ${t3}
        `, this._shaderPatch = i3, this._rendererState = {};
  }
  onObjectRender(s, e, t) {
    if (this.isDisabled()) return;
    const { toneMapping: i, toneMappingExposure: n } = t;
    this._rendererState.toneMapping = i, this._rendererState.toneMappingExposure = n, t.toneMapping = this.toneMapping, t.toneMappingExposure = this.exposure, e.toneMapped = !0, e.needsUpdate = !0;
  }
  onAfterRender(s, e, t) {
    t.toneMapping = this._rendererState.toneMapping, t.toneMappingExposure = this._rendererState.toneMappingExposure;
  }
  fromJSON(s, e) {
    return s.extension && s.clipBackground !== void 0 && (this._viewer ? this._viewer.renderManager.screenPass.clipBackground = s.clipBackground : console.warn("TonemapPlugin: no viewer attached, clipBackground ignored"), delete s.clipBackground), super.fromJSON(s, e);
  }
  // TODO: add gBufferData or just tonemapEnabled to the scene material UI with an extension like bloom
  updateGBufferFlags(s, e) {
    var i, n;
    const t = (((i = e.material.userData.gBufferData) == null ? void 0 : i.tonemapEnabled) ?? ((n = e.material) == null ? void 0 : n.userData.postTonemap)) === !1 ? 0 : 1;
    s.w = nE(s.w, 1, t), super.updateGBufferFlags(s, e);
  }
};
es.PluginType = "Tonemap";
ft.tonemapping_pars_fragment = ft.tonemapping_pars_fragment.replace("vec3 CustomToneMapping( vec3 color ) { return color; }", e3);
qo([
  V(),
  Oe(es.prototype.setDirty),
  ue("Enabled")
], es.prototype, "enabled", 2);
qo([
  er("Mode", [
    ["Linear", Jx],
    ["Reinhard", $x],
    ["Cineon", Zx],
    ["ACESFilmic", eA],
    ["Uncharted2", h3]
  ].map((s) => ({
    label: s[0],
    value: s[1]
  }))),
  Oe(es.prototype.setDirty),
  V()
], es.prototype, "toneMapping", 2);
qo([
  ue("Tonemap Background", (s) => ({ hidden: () => {
    var e;
    return !((e = s._viewer) != null && e.renderManager.gbufferTarget);
  } })),
  Yp("TONEMAP_BACKGROUND", void 0, !0, es.prototype.setDirty),
  V()
], es.prototype, "tonemapBackground", 2);
qo([
  Oe(es.prototype.setDirty),
  Ye("Exposure", [0, 2 * Math.PI], 0.01),
  V()
], es.prototype, "exposure", 2);
qo([
  Ye("Saturation", [0, 2], 0.01),
  Qo({ propKey: "toneMappingSaturation" }),
  V()
], es.prototype, "saturation", 2);
qo([
  Ye("Contrast", [0, 2], 0.01),
  Qo({ propKey: "toneMappingContrast" }),
  V()
], es.prototype, "contrast", 2);
es = qo([
  Lt("Tonemapping")
], es);
const u3 = "0.0.49";
var d3 = Object.defineProperty, p3 = Object.getOwnPropertyDescriptor, xu = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? p3(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && d3(e, t, n), n;
};
let $t = class extends Vi {
  // todo use in shaderReplaceString
  /**
   * Create a viewer instance for using the webgi viewer SDK.
   * @param options - {@link ThreeViewerOptions}
   */
  constructor({ debug: s = !1, ...e }) {
    var n, r, a, o, l;
    super(), this.enabled = !0, this.renderEnabled = !0, this.plugins = {}, this.maxFramePerLoop = 1, this.rendersPerFrame = 1, this.type = "ThreeViewer", this.resizeObserver = window != null && window.ResizeObserver ? new window.ResizeObserver((c) => this.resize()) : void 0, this._needsResize = !1, this._isRenderingFrame = !1, this._objectProcessor = {
      processObject: (c) => {
        c.material && (Array.isArray(c.material) ? this.assetManager.materials.registerMaterials(c.material) : this.assetManager.materials.registerMaterial(c.material));
      }
    }, this._needsReset = !0, this._lastCameraPosition = new M(), this._lastCameraQuat = new rt(), this._lastCameraTarget = new M(), this._tempVec = new M(), this._tempQuat = new rt(), this.resize = () => {
      this._needsResize = !0, this.setDirty();
    }, this.deleteImportedViewerConfigOnLoad = !0, this.deleteImportedViewerConfigOnLoadWait = 2e3, this.loadConfigResources = async (c, h) => {
      if (c.__isLoadedResources) return c;
      const u = oE(c, this);
      return await WA.ImportMeta(u, h);
    }, this._setActiveCameraView = (c) => {
      var h;
      if (c.type === "setView") {
        if (!c.camera) {
          this.console.warn("Cannot find camera", c);
          return;
        }
        this._scene.mainCamera.setViewFromCamera(c.camera);
      } else c.type === "activateMain" && ((h = c.camera) == null || h.setCanvas(this._canvas, !1), this._scene.mainCamera = c.camera || void 0);
      this._scene.mainCamera = c.camera || void 0;
    }, this._defaultConfig = {
      assetType: "config",
      type: this.type,
      version: $t.VERSION,
      metadata: {
        generator: "ThreePipe",
        version: 1
      },
      plugins: []
    }, this._lastSize = new ie(), this._onContextRestore = (c) => {
      this.enabled = !0, this._canvas.width = this._lastSize.width, this._canvas.height = this._lastSize.height, this.resize(), this._scene.setDirty({ refreshScene: !0, frameFade: !1 });
    }, this._onContextLost = (c) => {
      this._lastSize.set(this._canvas.width, this._canvas.height), this._canvas.width = 2, this._canvas.height = 2, this.resize(), this.enabled = !1;
    }, this._pluginListeners = {
      add: [],
      remove: []
    }, this.serializePluginsIgnored = [], this.debug = s, s && ($t.ViewerDebugging = !0), this._canvas = e.canvas || kR();
    let t = e.container;
    if (t && !e.canvas && t.appendChild(this._canvas), t || (t = this._canvas.parentElement ?? void 0), !t) throw new Error("No container(or canvas).");
    this._container = t, this.setDirty = this.setDirty.bind(this), this._animationLoop = this._animationLoop.bind(this), this.renderStats = new CB(this._container), s && this.renderStats.show(), window.threeViewers || (window.threeViewers = []), window.threeViewers.push(this);
    const i = ((n = e.camera) == null ? void 0 : n.type) === "orthographic" ? new eb(((r = e.camera) == null ? void 0 : r.controlsMode) ?? "orbit", this._canvas) : new mu(((a = e.camera) == null ? void 0 : a.controlsMode) ?? "orbit", this._canvas);
    i.name = "Default Camera" + (i.type === "OrthographicCamera" ? " (Ortho)" : ""), (o = e.camera) != null && o.position ? i.position.copy(e.camera.position) : i.position.set(0, 0, 5), (l = e.camera) != null && l.target ? i.target.copy(e.camera.target) : i.target.set(0, 0, 0), i.setDirty(), i.userData.autoLookAtTarget = !0, this.addEventListener("postFrame", () => {
      var h, u;
      const c = this._scene.mainCamera;
      if (c && c.canUserInteract) {
        const d = (h = this.getPlugin("ProgressivePlugin")) == null ? void 0 : h.postFrameConvergedRecordingDelta();
        if (d !== void 0 && d === 0) return;
        (u = c.controls) == null || u.update();
      }
    }), this.addEventListener("preFrame", () => {
      const c = this._scene.mainCamera;
      c.getWorldPosition(this._tempVec).sub(this._lastCameraPosition).lengthSq() + this._tempVec.subVectors(c.target, this._lastCameraTarget).lengthSq() + c.getWorldQuaternion(this._tempQuat).angleTo(this._lastCameraQuat) > 1e-6 && c.setDirty();
    }), this._scene = new Qi(i, this._objectProcessor), this._scene.setBackgroundColor("#ffffff"), this._scene.addEventListener("setView", this._setActiveCameraView), this._scene.addEventListener("activateMain", this._setActiveCameraView), this._scene.addEventListener("materialUpdate", (c) => this.setDirty(this._scene, c)), this._scene.addEventListener("materialChanged", (c) => this.setDirty(this._scene, c)), this._scene.addEventListener("objectUpdate", (c) => this.setDirty(this._scene, c)), this._scene.addEventListener("textureUpdate", (c) => this.setDirty(this._scene, c)), this._scene.addEventListener("sceneUpdate", (c) => {
      this.setDirty(this._scene, c), c.geometryChanged !== !1 && this.renderManager.resetShadows();
    }), this._scene.addEventListener("mainCameraUpdate", () => {
      this._scene.mainCamera.getWorldPosition(this._lastCameraPosition), this._lastCameraTarget.copy(this._scene.mainCamera.target), this._scene.mainCamera.getWorldQuaternion(this._lastCameraQuat);
    }), this._scene.modelRoot.scale.setScalar(e.modelRootScale ?? 1), (e.isAntialiased !== void 0 || e.useRgbm !== void 0 || e.useGBufferDepth !== void 0) && this.console.warn("isAntialiased, useRgbm and useGBufferDepth are deprecated, use msaa, rgbm and zPrepass instead."), this.renderManager = new Ar({
      canvas: this._canvas,
      msaa: e.msaa ?? e.isAntialiased ?? !1,
      rgbm: e.rgbm ?? e.useRgbm ?? !0,
      zPrepass: e.zPrepass ?? e.useGBufferDepth ?? !1,
      depthBuffer: !(e.zPrepass ?? e.useGBufferDepth ?? !1),
      screenShader: e.screenShader,
      renderScale: typeof e.renderScale == "string" ? e.renderScale === "auto" ? Math.min(e.maxRenderScale || 2, window.devicePixelRatio) : parseFloat(e.renderScale) : e.renderScale,
      maxHDRIntensity: e.maxHDRIntensity
    }), this.renderManager.addEventListener("animationLoop", this._animationLoop), this.renderManager.addEventListener("resize", () => this._scene.mainCamera.refreshAspect()), this.renderManager.addEventListener("update", (c) => {
      var h, u;
      c.change === "registerPass" && ((h = c.pass) != null && h.materialExtension) ? this.assetManager.materials.registerMaterialExtension(c.pass.materialExtension) : c.change === "unregisterPass" && ((u = c.pass) != null && u.materialExtension) && this.assetManager.materials.unregisterMaterialExtension(c.pass.materialExtension), this.setDirty(this.renderManager, c);
    }), this.assetManager = new Hg(this, e.assetManager), this.resizeObserver && this.resizeObserver.observe(this._canvas), window && window.addEventListener("resize", this.resize), this._canvas.addEventListener("webglcontextrestored", this._onContextRestore, !1), this._canvas.addEventListener("webglcontextlost", this._onContextLost, !1), e.dropzone && this.addPluginSync(new Ys(typeof e.dropzone == "object" ? e.dropzone : void 0)), e.tonemap !== !1 && this.addPluginSync(new es());
    for (const c of e.plugins ?? []) this.addPluginSync(c);
    if (this.console.log("ThreePipe Viewer instance initialized, version: ", $t.VERSION), e.load) {
      const h = [e.load.src].flat().filter((u) => u).map(async (u) => u && this.load(u));
      e.load.environment && h.push(this.setEnvironmentMap(e.load.environment)), e.load.background && h.push(this.setBackgroundMap(e.load.background)), Promise.all(h).then(e.onLoad);
    }
  }
  get materialManager() {
    return this.assetManager.materials;
  }
  /**
   * Scene with object hierarchy used for rendering
   */
  get scene() {
    return this._scene;
  }
  /**
   * Get the HTML Element containing the canvas
   * @returns {HTMLElement}
   */
  get container() {
    return this._canvas.parentElement !== this._container && this.console.error("ThreeViewer: Canvas is not in the container, this might cause issues with some plugins."), this._container;
  }
  /**
   * Get the HTML Canvas Element where the viewer is rendering
   * @returns {HTMLCanvasElement}
   */
  get canvas() {
    return this._canvas;
  }
  get console() {
    return $t.Console;
  }
  get dialog() {
    return $t.Dialog;
  }
  /**
   * Add an object/model/material/viewer-config/plugin-preset/... to the viewer scene from url or an {@link IAsset} object.
   * Same as {@link AssetManager.addAssetSingle}
   * @param obj
   * @param options
   */
  async load(s, e) {
    if (s)
      return await this.assetManager.addAssetSingle(s, e);
  }
  /**
   * Imports an object/model/material/texture/viewer-config/plugin-preset/... to the viewer scene from url or an {@link IAsset} object.
   * Same as {@link AssetImporter.importSingle}
   * @param obj
   * @param options
   */
  async import(s, e) {
    if (s)
      return await this.assetManager.importer.importSingle(s, e);
  }
  /**
   * Set the environment map of the scene from url or an {@link IAsset} object.
   * @param map
   * @param setBackground - Set the background image of the scene from the same map.
   * @param options - Options for importing the asset. See {@link ImportAssetOptions}
   */
  async setEnvironmentMap(s, { setBackground: e = !1, ...t } = {}) {
    return this._scene.environment = s && !s.isTexture ? await this.assetManager.importer.importSingle(s, t) || null : s || null, e ? this.setBackgroundMap(this._scene.environment) : this._scene.environment;
  }
  /**
   * Set the background image of the scene from url or an {@link IAsset} object.
   * @param map
   * @param setEnvironment - Set the environment map of the scene from the same map.
   * @param options - Options for importing the asset. See {@link ImportAssetOptions}
   */
  async setBackgroundMap(s, { setEnvironment: e = !1, ...t } = {}) {
    return this._scene.background = s && !s.isTexture ? await this.assetManager.importer.importSingle(s, t) || null : s || null, e ? this.setEnvironmentMap(this._scene.background) : this._scene.background;
  }
  /**
   * Exports an object/mesh/material/texture/render-target/plugin-preset/viewer to a blob.
   * If no object is given, a glb is exported with the current viewer state.
   * @param obj
   * @param options
   */
  async export(s, e) {
    var t;
    return s || (s = this._scene.modelRoot), s.type === this.type ? Yv(s.exportConfig()) : (t = s.constructor) != null && t.PluginType ? Yv(this.exportPluginConfig(s)) : await this.assetManager.exporter.exportObject(s, e);
  }
  /**
   * Export the scene to a file (default: glb with viewer config) and return a blob
   * @param options
   * @param useExporterPlugin - uses the {@link AssetExporterPlugin} if available. This is useful to use the options configured by the user in the plugin.
   */
  async exportScene(s, e = !0) {
    const t = e ? this.getPlugin("AssetExporterPlugin") : void 0;
    return t ? t.exportScene(s) : this.assetManager.exporter.exportObject(this._scene.modelRoot, s);
  }
  /**
   * Returns a blob with the screenshot of the canvas.
   * If {@link CanvasSnapshotPlugin} is added, it will be used, otherwise canvas.toBlob will be used directly.
   * @param mimeType default image/jpeg
   * @param quality between 0 and 100
   */
  async getScreenshotBlob({ mimeType: s = "image/jpeg", quality: e = 90 } = {}) {
    const t = this.getPlugin("CanvasSnapshotPlugin");
    if (t)
      return t.getFile("snapshot." + s.split("/")[1], { mimeType: s, quality: e, waitForProgressive: !0 });
    const i = async () => new Promise((n) => {
      this._canvas.toBlob((r) => {
        n(r);
      }, s, e);
    });
    return this.renderEnabled ? await this.doOnce("postFrame", async () => {
      this.renderEnabled = !1;
      const n = await i();
      return this.renderEnabled = !0, n;
    }) : i();
  }
  async getScreenshotDataUrl({ mimeType: s = "image/jpeg", quality: e = 0.9 } = {}) {
    return this.renderEnabled ? await this.doOnce("postFrame", () => this._canvas.toDataURL(s, e)) : this._canvas.toDataURL(s, e);
  }
  /**
   * Disposes the viewer and frees up all resource and events. Do not use the viewer after calling dispose.
   * NOTE - If you want to reuse the viewer, set viewer.enabled to false instead, then set it to true again when required. To dispose all the objects, materials in the scene use `viewer.scene.disposeSceneModels()`
   * This function is not fully implemented yet. There might be some leaks.
   * TODO - return promise?
   */
  dispose(s = !0) {
    var e;
    if (s)
      for (const t of [...Object.values(this.plugins)])
        this.removePlugin(t, !0);
    this._scene.dispose(s), this.renderManager.dispose(s), s && (this._canvas.removeEventListener("webglcontextrestored", this._onContextRestore, !1), this._canvas.removeEventListener("webglcontextlost", this._onContextLost, !1), (e = window.threeViewers) == null || e.splice(window.threeViewers.indexOf(this), 1), this.resizeObserver && this.resizeObserver.unobserve(this._canvas), window.removeEventListener("resize", this.resize)), this.dispatchEvent({ type: "dispose", clear: s });
  }
  /**
   * Set the viewer to dirty and trigger render of the next frame.
   * @param source - The source of the dirty event. like plugin or 3d object
   * @param event - The event that triggered the dirty event.
   */
  setDirty(s, e) {
    this._needsReset = !0, s = s ?? this, this.dispatchEvent({ ...e ?? {}, type: "update", source: s });
  }
  _animationLoop(s) {
    var e, t;
    if (!(!this.enabled || !this.renderEnabled)) {
      if (this._isRenderingFrame) {
        this.console.warn("animation loop: frame skip");
        return;
      }
      this._isRenderingFrame = !0, this.renderStats.begin();
      for (let i = 0; i < this.maxFramePerLoop; i++) {
        if (this._needsReset && (this.renderManager.reset(), this._needsReset = !1), this._needsResize) {
          const a = [this._canvas.clientWidth, this._canvas.clientHeight];
          if (s.xrFrame) {
            const o = (t = (e = this.renderManager.webglRenderer.xr.getCamera()) == null ? void 0 : e.cameras[0]) == null ? void 0 : t.viewport;
            o ? ((o.x !== 0 || o.y !== 0) && this.console.warn("x and y must be 0?"), a[0] = o.width, a[1] = o.height, this.console.log("resize for xr", a)) : this._needsResize = !1;
          }
          this._needsResize && (this.renderManager.setSize(...a), this._needsResize = !1);
        }
        this.dispatchEvent({ ...s, type: "preFrame", target: this });
        const n = Object.values(this.plugins).filter((a) => a.dirty);
        n.length > 0 && this.setDirty(n), this._needsReset && (this.renderManager.reset(), this._needsReset = !1);
        const r = this.renderManager.needsRender;
        if (r)
          for (let a = 0; a < this.rendersPerFrame; a++) {
            this.dispatchEvent({ type: "preRender", target: this });
            try {
              const o = this._scene.mainCamera;
              this._scene.renderCamera = o, o.visible && this.renderManager.render(this._scene, this.renderManager.defaultRenderToScreen);
            } catch (o) {
              if (this.console.error("ThreeViewer: Error while rendering frame. Enable debug mode to check the errors."), this.debug)
                throw this.console.error(o), o;
            }
            this.dispatchEvent({ type: "postRender", target: this });
          }
        if (this.dispatchEvent({ type: "postFrame", target: this }), this.renderManager.onPostFrame(), !r)
          break;
      }
      this.renderStats.end(), this._isRenderingFrame = !1;
    }
  }
  /**
   * Get the Plugin by a constructor type or by the string type.
   * Use string type if the plugin is not a dependency and you don't want to bundle the plugin.
   * @param type - The class of the plugin to get, or the string type of the plugin to get which is in the static PluginType property of the plugin
   * @returns {T | undefined} - The plugin of the specified type.
   */
  getPlugin(s) {
    return this.plugins[typeof s == "string" ? s : s.PluginType];
  }
  /**
   * Get the Plugin by a constructor type or add a new plugin of the specified type if it doesn't exist.
   * @param type
   * @param args - arguments for the constructor of the plugin, used when a new plugin is created.
   */
  async getOrAddPlugin(s, ...e) {
    const t = this.getPlugin(s);
    return t || this.addPlugin(s, ...e);
  }
  /**
   * Get the Plugin by a constructor type or add a new plugin to the viewer of the specified type if it doesn't exist(sync).
   * @param type
   * @param args - arguments for the constructor of the plugin, used when a new plugin is created.
   */
  getOrAddPluginSync(s, ...e) {
    const t = this.getPlugin(s);
    return t || this.addPluginSync(s, ...e);
  }
  /**
   * Add a plugin to the viewer.
   * @param plugin - The instance of the plugin to add or the class of the plugin to add.
   * @param args - Arguments for the constructor of the plugin, in case a class is passed.
   * @returns {Promise<T>} - The plugin added.
   */
  async addPlugin(s, ...e) {
    const t = this._resolvePluginOrClass(s, ...e);
    if (!t)
      throw new Error("ThreeViewer: Plugin is not defined");
    const i = t.constructor.PluginType;
    if (!t.constructor.PluginType)
      return this.console.error("ThreeViewer: PluginType is not defined for", t), t;
    for (const r of t.dependencies || [])
      await this.getOrAddPlugin(r);
    this.plugins[i] && (this.console.error(`ThreeViewer: Plugin of type ${i} already exists, removing and disposing old plugin. This might break functionality, ensure only one plugin of a type is added`, this.plugins[i], t), await this.removePlugin(this.plugins[i])), this.plugins[i] = t;
    const n = t.constructor.OldPluginType;
    return n && this.plugins[n] && this.console.error(`ThreeViewer: Plugin type mismatch ${n}`), n && (this.plugins[n] = t), await t.onAdded(this), this._onPluginAdd(t), t;
  }
  /**
   * Add a plugin to the viewer(sync).
   * @param plugin
   * @param args
   */
  addPluginSync(s, ...e) {
    const t = this._resolvePluginOrClass(s, ...e);
    if (!t)
      throw new Error("ThreeViewer: Plugin is not defined");
    const i = t.constructor.PluginType;
    if (!t.constructor.PluginType)
      return this.console.error("ThreeViewer: PluginType is not defined for", t), t;
    for (const n of t.dependencies || [])
      this.getOrAddPluginSync(n);
    this.plugins[i] && (this.console.error(`ThreeViewer: Plugin of type ${i} already exists, removing and disposing old plugin. This might break functionality, ensure only one plugin of a type is added`, this.plugins[i], t), this.removePluginSync(this.plugins[i]));
    try {
      this.plugins[i] = t;
      const n = t.constructor.OldPluginType;
      n && this.plugins[n] && this.console.error(`ThreeViewer: Plugin type mismatch ${n}`), n && (this.plugins[n] = t), t.onAdded(this);
    } catch (n) {
      this.console.error("ThreeViewer: Error adding plugin, check console for details", n), delete this.plugins[i];
    }
    return this._onPluginAdd(t), t;
  }
  /**
   * Add multiple plugins to the viewer.
   * @param plugins - List of plugin instances or classes
   */
  async addPlugins(s) {
    for (const e of s) await this.addPlugin(e);
  }
  /**
   * Add multiple plugins to the viewer(sync).
   * @param plugins - List of plugin instances or classes
   */
  addPluginsSync(s) {
    for (const e of s) this.addPluginSync(e);
  }
  /**
   * Remove a plugin instance or a plugin class. Works similar to {@link ThreeViewer.addPlugin}
   * @param p
   * @param dispose
   * @returns {Promise<void>}
   */
  async removePlugin(s, e = !0) {
    const t = s.constructor.PluginType;
    this.plugins[t] && (await s.onRemove(this), this._onPluginRemove(s, e));
  }
  /**
   * Remove a plugin instance or a plugin class(sync). Works similar to {@link ThreeViewer.addPluginSync}
   * @param p
   * @param dispose
   */
  removePluginSync(s, e = !0) {
    const t = s.constructor.PluginType;
    this.plugins[t] && (s.onRemove(this), this._onPluginRemove(s, e), delete this.plugins[t], e && s.dispose(), this.setDirty(s));
  }
  /**
   * Set size of the canvas and update the renderer.
   * If no size or width/height is passed, canvas is set to 100% of the container.
   *
   * See also {@link ThreeViewer.setRenderSize} to set the size of the render target by automatically calculating the renderScale and fitting in container.
   *
   * Note: Apps using this should ideally set `max-width: 100%` for the canvas in css.
   * @param size
   */
  setSize(s) {
    this._canvas.style.width = s != null && s.width ? s.width + "px" : "100%", this._canvas.style.height = s != null && s.height ? s.height + "px" : "100%", this._canvas.offsetHeight, this.resize();
  }
  // todo make a constructor parameter for renderSize
  // todo make getRenderSize or get renderSize
  /**
   * Set the render size of the viewer to fit in the container according to the specified mode, maintaining aspect ratio.
   * Changes the renderScale accordingly.
   * Note: the canvas needs to be centered in the container to work properly, this can be done with the following css on the container:
   * ```css
   * display: flex;
   * justify-content: center;
   * align-items: center;
   * ```
   * or in js:
   * ```js
   * viewer.container.style.display = 'flex';
   * viewer.container.style.justifyContent = 'center';
   * viewer.container.style.alignItems = 'center';
   * ```
   * Modes:
   * 'contain': The canvas is scaled to fit within the container while maintaining its aspect ratio. The canvas will be fully visible, but there may be empty space around it.
   * 'cover': The canvas is scaled to fill the entire container while maintaining its aspect ratio. Part of the canvas may be clipped to fit the container.
   * 'fill': The canvas is stretched to completely fill the container, ignoring its aspect ratio.
   * 'scale-down': The canvas is scaled down to fit within the container while maintaining its aspect ratio, but it won't be scaled up if it's smaller than the container.
   * 'none': container size is ignored, but devicePixelRatio is used
   *
   * Check the example for more details - https://threepipe.org/examples/#viewer-render-size/
   * @param size - The size to set the render to. The canvas will render to this size.
   * @param mode - 'contain', 'cover', 'fill', 'scale-down' or 'none'. Default is 'contain'.
   * @param devicePixelRatio - typically set to `window.devicePixelRatio`, or `Math.min(1.5, window.devicePixelRatio)` for performance. Use this only when size is derived from dom elements.
   * @param containerSize - (optional) The size of the container, if not passed, the bounding client rect of the container is used.
   */
  setRenderSize(s, e = "contain", t = 1, i) {
    const n = i || this.container.getBoundingClientRect(), r = n.height, a = n.width, o = s.width, l = s.height, c = o / l, h = a / r, u = t;
    let d, p;
    switch (e) {
      case "contain":
        h > c ? (d = r * c, p = r) : (d = a, p = a / c);
        break;
      case "cover":
        h > c ? (d = a, p = a / c) : (d = r * c, p = r);
        break;
      case "fill":
        d = a, p = r;
        break;
      case "scale-down":
        o < a && l < r ? (d = o, p = l) : h > c ? (d = r * c, p = r) : (d = a, p = a / c);
        break;
      case "none":
        d = o, p = l;
        break;
      default:
        throw new Error(`Invalid mode: ${e}`);
    }
    this.setSize({ width: d, height: p }), this.renderManager.renderScale = u * l / p;
  }
  /**
   * Traverse all objects in scene model root.
   * @param callback
   */
  traverseSceneObjects(s) {
    this._scene.modelRoot.traverse(s);
  }
  // ms
  /**
   * Add an object to the scene model root.
   * If an imported scene model root is passed, it will be loaded with viewer configuration, unless importConfig is false
   * @param imported
   * @param options
   */
  async addSceneObject(s, e) {
    var t;
    if ((t = s.userData) != null && t.rootSceneModelRoot) {
      const i = s;
      return this._scene.loadModelRoot(i, e), (e == null ? void 0 : e.importConfig) !== !1 && (i.importedViewerConfig ? (await this.importConfig(i.importedViewerConfig), i._deletedImportedViewerConfig && delete i._deletedImportedViewerConfig) : i._deletedImportedViewerConfig && this.console.error("ThreeViewer - Imported viewer config was deleted, cannot import it again. Set `viewer.deleteImportedViewerConfigOnLoad` to `false` to keep it in the object for reuse workflows.")), this.deleteImportedViewerConfigOnLoad && i.importedViewerConfig && setTimeout(() => {
        i.importedViewerConfig && (delete i.importedViewerConfig, i._deletedImportedViewerConfig = !0);
      }, this.deleteImportedViewerConfigOnLoadWait), this._scene.modelRoot;
    }
    return this._scene.addObject(s, e), s;
  }
  /**
   * Serialize all the plugins and their settings to save or create presets. Used in {@link toJSON}.
   * @param meta -  The meta object.
   * @param filter - List of PluginType for the to include. If empty, no plugins will be serialized. If undefined, all plugins will be serialized.
   * @returns {any[]}
   */
  serializePlugins(s, e) {
    return e && e.length === 0 ? [] : Object.entries(this.plugins).map((t) => {
      var i, n;
      if (!(e && !e.includes(t[1].constructor.PluginType)) && !this.serializePluginsIgnored.includes(t[1].constructor.PluginType))
        return t[1].serializeWithViewer !== !1 ? (n = (i = t[1]).toJSON) == null ? void 0 : n.call(i, s) : void 0;
    }).filter((t) => !!t);
  }
  /**
   * Deserialize all the plugins and their settings from a preset. Used in {@link fromJSON}.
   * @param plugins - The output of {@link serializePlugins}.
   * @param meta - The meta object.
   * @returns {this}
   */
  deserializePlugins(s, e) {
    return s.forEach((t) => {
      if (!t.type) {
        this.console.warn("Invalid plugin to import ", t);
        return;
      }
      if (this.serializePluginsIgnored.includes(t.type)) return;
      const i = this.getPlugin(t.type);
      i && i.fromJSON && i.fromJSON(t, e);
    }), this;
  }
  /**
   * Serialize a single plugin settings.
   */
  exportPluginConfig(s) {
    var i;
    if ((s && typeof s == "string" || s.PluginType) && (s = this.getPlugin(s)), !s) return {};
    const e = Sa(), t = (i = s.toJSON) == null ? void 0 : i.call(s, e);
    return t ? (t.resources = Zf(e), t) : {};
  }
  /**
   * Deserialize and import a single plugin settings.
   * Can also use {@link ThreeViewer.importConfig} to import only plugin config.
   * @param json
   * @param plugin
   */
  async importPluginConfig(s, e) {
    const t = s.type;
    if (e = e || this.getPlugin(t), !e) {
      this.console.warn(`No plugin found for type ${t} to import config`);
      return;
    }
    if (!e.fromJSON) {
      this.console.warn(`Plugin ${t} does not support importing presets`);
      return;
    }
    const i = s.resources || {};
    s.resources && delete s.resources;
    const n = await this.loadConfigResources(i);
    return await e.fromJSON(s, n), n && (s.resources = n), e;
  }
  /**
   * Serialize multiple plugin settings.
   * @param filter - List of PluginType to include. If empty, no plugins will be serialized. If undefined, all plugins will be serialized.
   */
  exportPluginsConfig(s) {
    const e = Sa(), t = this.serializePlugins(e, s);
    return Xv(e), {
      ...this._defaultConfig,
      plugins: t,
      resources: Zf(e)
    };
  }
  /**
   * Serialize all the viewer and plugin settings.
   * @param binary - Indicate that the output will be converted and saved as binary data. (default: false)
   * @param pluginFilter - List of PluginType to include. If empty, no plugins will be serialized. If undefined, all plugins will be serialized.
   */
  exportConfig(s = !1, e) {
    return this.toJSON(s, e);
  }
  /**
   * Deserialize and import all the viewer and plugin settings, exported with {@link exportConfig}.
   */
  async importConfig(s) {
    if (s.type !== this.type && s.type !== "ViewerApp" && s.type !== "ThreeViewer") {
      if (this.getPlugin(s.type))
        return this.importPluginConfig(s);
      this.console.error(`Unknown config type ${s.type} to import`);
      return;
    }
    const e = await this.loadConfigResources(s.resources || {});
    this.fromJSON(s, e);
  }
  /**
   * Serialize all the viewer and plugin settings and versions.
   * @param binary - Indicate that the output will be converted and saved as binary data. (default: true)
   * @param pluginFilter - List of PluginType to include. If empty, no plugins will be serialized. If undefined/not-passed, all plugins will be serialized.
   * @returns {any} - Serializable JSON object.
   */
  toJSON(s = !0, e) {
    const t = Sa(), i = Object.assign({
      ...this._defaultConfig,
      plugins: this.serializePlugins(t, e)
    }, mt.Serialize(this, t, !0));
    return s || Xv(t), i.resources = Zf(t), i;
  }
  /**
   * Deserialize all the viewer and plugin settings.
   * NOTE - use async {@link ThreeViewer.importConfig} to import a json/config exported with {@link ThreeViewer.exportConfig} or {@link ThreeViewer.toJSON}.
   * @param data - The serialized JSON object returned from {@link toJSON}.
   * @param meta - The meta object, see {@link SerializationMetaType}
   * @returns {this}
   */
  fromJSON(s, e) {
    var i, n, r, a, o;
    const t = { ...s };
    return t.backgroundIntensity !== void 0 && ((i = t.scene) == null ? void 0 : i.backgroundIntensity) === void 0 && (this.console.warn("old file format, backgroundIntensity moved to RootScene"), this._scene.backgroundIntensity = t.backgroundIntensity, delete t.backgroundIntensity), t.useLegacyLights !== void 0 && ((n = t.renderManager) == null ? void 0 : n.useLegacyLights) === void 0 && (this.console.warn("old file format, useLegacyLights moved to RenderManager"), this.renderManager.useLegacyLights = t.useLegacyLights, delete t.useLegacyLights), t.background !== void 0 && ((r = t.scene) == null ? void 0 : r.background) === void 0 && (this.console.warn("old file format, background moved to RootScene"), t.background === "envMapBackground" ? t.background = "environment" : typeof t.background == "number" ? t.background = new se().setHex(t.background, Mt) : typeof t.background == "string" ? t.background = new se().setStyle(t.background, Mt) : (a = t.background) != null && a.isColor && (t.background = new se(t.background)), (o = t.background) != null && o.isColor ? (this._scene.backgroundColor = t.background, this._scene.background = null) : t.background ? (this._scene.backgroundColor = new se("#ffffff"), t.scene || (t.scene = {}), t.scene.background = t.background) : (this._scene.backgroundColor = null, this._scene.background = null), delete t.background), !e && t.resources && t.resources.__isLoadedResources && (e = t.resources, delete t.resources), e != null && e.__isLoadedResources ? (Array.isArray(t.plugins) && (this.deserializePlugins(t.plugins, e), delete t.plugins), mt.Deserialize(t, this, e, !0), this) : (this.console.error("ThreeViewer: meta in fromJSON is not available or is not loaded resources, call viewer.loadConfigResources first, or directly use viewer.importConfig"), null);
  }
  async doOnce(s, e) {
    return new Promise((t) => {
      const i = async (...n) => {
        this.removeEventListener(s, i), t(await (e == null ? void 0 : e(...n)));
      };
      this.addEventListener(s, i);
    });
  }
  dispatchEvent(s) {
    super.dispatchEvent(s), super.dispatchEvent({ ...s, type: "*", eType: s.type });
  }
  /**
   * Uses the {@link FileTransferPlugin} to export a Blob/File. If the plugin is not available, it will download the blob.
   * {@link FileTransferPlugin} can be configured by other plugins to export the blob to a specific location like local file system, cloud storage, etc.
   * @param blob - The blob or file to export/download
   * @param name - name of the file, if not provided, the name of the file is used if it's a file.
   */
  async exportBlob(s, e) {
    const t = this.getPlugin("FileTransferPlugin");
    if (e = e ?? s.name ?? "file", !t) {
      jp(s, e);
      return;
    }
    await t.exportFile(s, e);
  }
  _resolvePluginOrClass(s, ...e) {
    let t;
    if (s.prototype) {
      const i = this.getPlugin(s);
      if (i)
        return this.console.error(`Plugin of type ${i.constructor.PluginType} already exists, no new plugin created`, i), i;
      try {
        t = new s(...e);
      } catch (n) {
        this.console.error("ThreeViewer: Error creating plugin", n);
        return;
      }
    } else t = s;
    return t;
  }
  _renderEnabledChanged() {
    this.dispatchEvent({ type: this.renderEnabled ? "renderEnabled" : "renderDisabled" });
  }
  // private _addSceneObject: EventListener2<'addSceneObject', ISceneEventMap, IScene> = (e)=>{
  //     if (!e || !e.object) return
  //     const config = e.object.__importedViewerConfig // this is set in gltf.ts when gltf file is imported. This is done here so that scene settings are applied whenever the imported object is added to scene.
  //     if (!config) return
  //     this.fromJSON(config, config.resources)
  // }
  async fitToView(s, e = 1.5, t, i) {
    var r;
    const n = this.getPlugin("CameraViews");
    if (!n) {
      this.console.error("ThreeViewer: CameraViewPlugin (CameraViews) is required for fitToView to work");
      return;
    }
    await (n == null ? void 0 : n.animateToFitObject(s, e, t, i, { min: (((r = this.scene.mainCamera.controls) == null ? void 0 : r.minDistance) ?? 0.5) + 0.5, max: 1e3 }));
  }
  /**
   * Create and get a three.js CanvasTexture from the viewer's canvas.
   */
  get canvasTexture() {
    if (!this._canvas) throw new Error("Canvas not found");
    return this._canvasTexture || (this._canvasTexture = new Qp(this._canvas), this._canvasTexture.flipY = !1, this._canvasTexture.needsUpdate = !0), this._canvasTexture;
  }
  // todo: create/load texture utils
  // region legacy creation functions
  // /**
  //  * Converts a three.js Camera instance to be used in the viewer.
  //  * @param camera - The three.js OrthographicCamera or PerspectiveCamera instance
  //  * @returns {CameraController} - A wrapper around the camera with some useful methods and properties.
  //  */
  // createCamera(camera: OrthographicCamera | PerspectiveCamera): CameraController {
  //     const cam: CameraController = camera.userData.iCamera ?? new CameraController(camera, {
  //         controlsMode: '',
  //         controlsEnabled: false,
  //     }, this._canvas)
  //     if (camera.userData.autoLookAtTarget === undefined) {
  //         cam.autoLookAtTarget = false
  //         camera.userData.autoLookAtTarget = false
  //     } else {
  //         cam.autoLookAtTarget = camera.userData.autoLookAtTarget
  //     }
  //     return cam
  // }
  // /**
  //  * Create a new empty object in the scene or add an existing three.js object to the scene.
  //  * @param object
  //  */
  // async createObject3D(object?: Object3D): Promise<Object3DModel | undefined> {
  //     return this.getManager()?.addImportedSingle<Object3DModel>(object || new Object3D(), {autoScale: false, pseudoCenter: false})
  // }
  // /**
  //  * Create a new physical material from a template or another material. It returns the same material if a material is passed created by the material manager.
  //  * @param material
  //  */
  // createPhysicalMaterial(material?: Material|MeshPhysicalMaterialParameters): MeshStandardMaterial2 | undefined {
  //     return this.createMaterial<MeshStandardMaterial2>('standard', material)
  // }
  // /**
  //  * Create a new material from a template or another material. It returns the same material if a material is passed created by the material manager.
  //  * @param template - template name registered in MaterialManager
  //  * @param material - three.js material object or material params to create a new material
  //  */
  // createMaterial<T extends IMaterial<any>>(template: 'standard' | 'basic' | 'diamond' | string, material?: Material|any): T | undefined {
  //     if ((material as Material)?.isMaterial) {
  //         const f = this.getManager()?.materials?.findMaterial((material as Material).uuid)
  //         if (f) return f as T
  //     }
  //     return this.getManager()?.materials?.generateFromTemplate(template, material) as T
  // }
  // endregion
  /**
   * The renderer for the viewer that's attached to the canvas. This is wrapper around WebGLRenderer and EffectComposer and manages post-processing passes and rendering logic
   * @deprecated - use {@link renderManager} instead
   */
  get renderer() {
    return this.console.error("ThreeViewer: renderer is deprecated, use renderManager instead"), this.renderManager;
  }
  /**
   * @deprecated use {@link assetManager} instead.
   * Gets the Asset manager, contains useful functions for managing, loading and inserting assets.
   */
  getManager() {
    return this.assetManager;
  }
  /**
   * Get the Plugin by the string type.
   * @deprecated - Use {@link getPlugin} instead.
   * @param type
   * @returns {T | undefined}
   */
  getPluginByType(s) {
    return this.plugins[s];
  }
  _onPluginAdd(s) {
    const e = { type: "addPlugin", target: this, plugin: s };
    this.dispatchEvent(e), this._pluginListeners.add.filter((t) => !t.p.length || t.p.includes(s.constructor.PluginType)).forEach((t) => t.l(e)), this.setDirty(s);
  }
  _onPluginRemove(s, e = !1) {
    const t = { type: "removePlugin", target: this, plugin: s };
    this.dispatchEvent(t), this._pluginListeners.remove.filter((i) => !i.p.length || i.p.includes(s.constructor.PluginType)).forEach((i) => i.l(t)), delete this.plugins[s.constructor.PluginType], e && s.dispose(), this.setDirty(s);
  }
  addPluginListener(s, e, ...t) {
    this._pluginListeners[s].push({ p: t, l: e });
  }
  removePluginListener(s, e) {
    this._pluginListeners[s] = this._pluginListeners[s].filter((t) => t.l !== e);
  }
  /**
   * Can be used to "subscribe" to plugins.
   * @param plugin
   * @param mount
   * @param unmount
   */
  forPlugin(s, e, t) {
    const i = () => {
      if (t) {
        const r = () => {
          const a = this.getPlugin(s);
          a && (this.removePluginListener("remove", r), t(a));
        };
        this.addPluginListener("remove", r, typeof s == "string" ? s : s.PluginType);
      }
    }, n = this.getPlugin(s);
    if (n)
      e(n), i();
    else {
      const r = () => {
        const a = this.getPlugin(s);
        a && (this.removePluginListener("add", r), e(a), i());
      };
      this.addPluginListener("add", r, typeof s == "string" ? s : s.PluginType);
    }
  }
};
$t.VERSION = u3;
$t.ConfigTypeSlug = "vjson";
$t.Console = {
  log: console.log.bind(console),
  warn: console.warn.bind(console),
  error: console.error.bind(console)
};
$t.Dialog = _B;
$t.ViewerDebugging = !1;
xu([
  Oe($t.prototype._renderEnabledChanged)
], $t.prototype, "renderEnabled", 2);
xu([
  Ki(void 0, { label: "Scene", expanded: !0 }),
  V("scene")
], $t.prototype, "_scene", 2);
xu([
  Ki(void 0, { label: "Rendering", expanded: !0 }),
  V("renderManager")
], $t.prototype, "renderManager", 2);
xu([
  V()
], $t.prototype, "type", 2);
$t = xu([
  Tn("Viewer")
], $t);
class iS {
  constructor(e, t, i, n) {
    iS.prototype.isMatrix2 = !0, this.elements = [
      1,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, i, n);
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      1
    ), this;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 4; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  set(e, t, i, n) {
    const r = this.elements;
    return r[0] = e, r[2] = t, r[1] = i, r[3] = n, this;
  }
}
const bQ = "158", SQ = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, CQ = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, MQ = 0, TQ = 1, IQ = 2, DQ = 3, RQ = 0, BQ = 1, PQ = 2, LQ = 3, UQ = 0, FQ = 1, OQ = 2, NQ = 2, kQ = 0, GQ = 1, zQ = 2, QQ = 3, HQ = 4, VQ = 5, WQ = 100, jQ = 101, qQ = 102, XQ = 103, YQ = 104, KQ = 200, JQ = 201, $Q = 202, ZQ = 203, e4 = 204, t4 = 205, i4 = 206, n4 = 207, s4 = 208, r4 = 209, a4 = 210, o4 = 211, l4 = 212, c4 = 213, h4 = 214, u4 = 0, d4 = 1, p4 = 2, f4 = 3, m4 = 4, g4 = 5, A4 = 6, y4 = 7, v4 = 0, _4 = 1, x4 = 2, w4 = 0, E4 = 1, b4 = 2, S4 = 3, C4 = 4, M4 = 5, T4 = "attached", I4 = "detached", D4 = 300, R4 = 301, B4 = 302, P4 = 303, L4 = 304, U4 = 306, F4 = 1e3, O4 = 1001, N4 = 1002, k4 = 1003, G4 = 1004, z4 = 1004, Q4 = 1005, H4 = 1005, V4 = 1006, W4 = 1007, j4 = 1007, q4 = 1008, X4 = 1008, Y4 = 1009, K4 = 1010, J4 = 1011, $4 = 1012, Z4 = 1013, eH = 1014, tH = 1015, iH = 1016, nH = 1017, sH = 1018, rH = 1020, aH = 1021, oH = 1023, lH = 1024, cH = 1025, hH = 1026, uH = 1027, dH = 1028, pH = 1029, fH = 1030, mH = 1031, gH = 1033, AH = 33776, yH = 33777, vH = 33778, _H = 33779, xH = 35840, wH = 35841, EH = 35842, bH = 35843, SH = 36196, CH = 37492, MH = 37496, TH = 37808, IH = 37809, DH = 37810, RH = 37811, BH = 37812, PH = 37813, LH = 37814, UH = 37815, FH = 37816, OH = 37817, NH = 37818, kH = 37819, GH = 37820, zH = 37821, QH = 36492, HH = 36494, VH = 36495, WH = 36283, jH = 36284, qH = 36285, XH = 36286, YH = 2200, KH = 2201, JH = 2202, $H = 2300, ZH = 2301, eV = 2302, tV = 2400, iV = 2401, nV = 2402, sV = 2500, rV = 2501, aV = 0, oV = 1, lV = 2, cV = 3e3, hV = 3001, uV = 3200, dV = 3201, pV = 0, fV = 1, mV = "", gV = "srgb", AV = "srgb-linear", yV = "display-p3", vV = "display-p3-linear", _V = "rgbm-16", xV = "linear", wV = "srgb", EV = "rec709", bV = "p3", SV = 0, CV = 7680, MV = 7681, TV = 7682, IV = 7683, DV = 34055, RV = 34056, BV = 5386, PV = 512, LV = 513, UV = 514, FV = 515, OV = 516, NV = 517, kV = 518, GV = 519, zV = 512, QV = 513, HV = 514, VV = 515, WV = 516, jV = 517, qV = 518, XV = 519, YV = 35044, KV = 35048, JV = 35040, $V = 35045, ZV = 35049, e5 = 35041, t5 = 35046, i5 = 35050, n5 = 35042, s5 = "100", r5 = "300 es", a5 = 1035, o5 = 2e3, l5 = 2001;
class Gc {
  constructor() {
    this.toJSON = null;
  }
  // disable serialization
  onAdded(e) {
    e.assetManager.importer.addImporter(this._importer);
  }
  onRemove(e) {
    e.assetManager.importer.removeImporter(this._importer);
  }
  dispose() {
  }
}
var f3 = Object.defineProperty, m3 = Object.getOwnPropertyDescriptor, ia = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? m3(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && f3(e, t, n), n;
};
let Hi = class extends Tt {
  constructor() {
    super(), this._transformNeedRefresh = !0, this.visible = !0, this.size = 8, this.yOffset = 0, this.renderToDepth = !0, this.tonemapGround = !0, this.limitCameraAboveGround = !1, this.autoAdjustTransform = !0, this.enableRefreshTransform = !0, this._cameraLimitsSet = !1, this._cameraLastMaxPolarAngle = Math.PI, this.useModelBounds = !1, this._refreshMaterial = this._refreshMaterial.bind(this), this._refreshTransform = this._refreshTransform.bind(this), this._refreshCameraLimits = this._refreshCameraLimits.bind(this), this.refresh = this.refresh.bind(this), this._refresh2 = this._refresh2.bind(this), this._onSceneUpdate = this._onSceneUpdate.bind(this), this._preRender = this._preRender.bind(this), this._postFrame = this._postFrame.bind(this), this._geometry = ai.upgradeGeometry.call(new No(1, 1, 1, 1)), this._geometry.attributes.uv2 = this._geometry.attributes.uv.clone(), this._geometry.attributes.uv2.needsUpdate = !0, this._mesh = this._createMesh(), this.refresh();
  }
  get enabled() {
    return this.visible;
  }
  set enabled(s) {
    this.visible = s;
  }
  onAdded(s) {
    super.onAdded(s), s.scene.addObject(this._mesh, { addToRoot: !0 }), s.scene.addEventListener("sceneUpdate", this._onSceneUpdate), s.scene.addEventListener("addSceneObject", this._onSceneUpdate), s.addEventListener("preRender", this._preRender), s.addEventListener("postFrame", this._postFrame), this.refresh();
  }
  onRemove(s) {
    var e;
    return (e = this._mesh) == null || e.dispose(!0), this._removeMaterial(), s.scene.removeEventListener("sceneUpdate", this._onSceneUpdate), s.scene.removeEventListener("addSceneObject", this._onSceneUpdate), s.removeEventListener("postFrame", this._postFrame), s.removeEventListener("preRender", this._preRender), super.onRemove(s);
  }
  _postFrame() {
    this._transformNeedRefresh && this._refreshTransform(), this._viewer;
  }
  _preRender() {
    this._viewer;
  }
  dispose() {
    var s, e, t;
    this._removeMaterial(), this._geometry.dispose(), (s = this._material) == null || s.dispose(), (t = (e = this._mesh) == null ? void 0 : e.dispose) == null || t.call(e), super.dispose();
  }
  _removeMaterial() {
    this._material && (this._material.userData.renderToDepth = this._material.userData.__renderToDepth, this._material.userData.__renderToDepth = void 0, this._material = void 0);
  }
  _onSceneUpdate(s) {
    (s == null ? void 0 : s.geometryChanged) !== !1 && (s == null ? void 0 : s.updateGround) !== !1 && this.refreshTransform();
  }
  refreshTransform() {
    this.enableRefreshTransform && (this._transformNeedRefresh = !0);
  }
  refresh() {
    this._viewer && (this._refreshMaterial(), this.refreshTransform(), this._refreshCameraLimits());
  }
  // because of inheritance breaks onChange
  _refresh2() {
    this.refresh();
  }
  _refreshCameraLimits() {
    var e;
    const s = (e = this._viewer) == null ? void 0 : e.scene.mainCamera.controls;
    if (s) {
      if (s.maxPolarAngle === void 0) {
        console.warn("refreshCameraLimits only available with orbit controls.");
        return;
      }
      this.limitCameraAboveGround ? (this._cameraLimitsSet || (this._cameraLastMaxPolarAngle = s.maxPolarAngle), s.maxPolarAngle = Math.PI / 2, this._cameraLimitsSet = !0) : this._cameraLimitsSet && (s.maxPolarAngle = this._cameraLastMaxPolarAngle, this._cameraLimitsSet = !1);
    }
  }
  _refreshTransform() {
    var e;
    if (!this._mesh || !this._viewer) return !1;
    let s = !1;
    if (this.visible !== this._mesh.visible && (this._mesh.visible = this.visible, s = !0), this.isDisabled())
      return s && ((e = this._viewer) == null || e.scene.setDirty()), !1;
    if (this.autoAdjustTransform) {
      this._mesh.userData.bboxVisible = !1;
      const t = this.useModelBounds ? this._viewer.scene.getModelBounds(!0, !0, !0) : this._viewer.scene.getBounds(!0, !0, !0);
      this._mesh.userData.bboxVisible = !0;
      const i = t.getCenter(
        new M()
      ).sub(new M(
        0,
        t.getSize(new M()).y / 2 + this.yOffset,
        0
      ));
      s = s || i.clone().sub(this._mesh.position).length() > 1e-4, s && this._mesh.position.copy(i);
    }
    return s = s || Math.abs(this._mesh.scale.x - this.size) > 1e-4, s && (this._mesh.scale.setScalar(this.size), this._mesh.setRotationFromEuler(new xi(-Math.PI / 2, 0, this._mesh.rotation.z)), this._mesh.matrixWorldNeedsUpdate = !0, this._mesh.setDirty({ refreshScene: !1, source: Hi.PluginType })), this._transformNeedRefresh = !1, !0;
  }
  _createMesh(s) {
    return s ? s.geometry = this._geometry : s = new FL(this._geometry, this._createMaterial()), s && (s.userData.physicsMass = 0, s.userData.userSelectable = !1, s.userData.isGroundMesh = !0, s.castShadow = !0, s.receiveShadow = !0, s.name = "Ground Plane"), s;
  }
  setGeometry(s) {
    s ? this._geometry && this._geometry.dispose() : s = this._geometry, s && (ai.upgradeGeometry.call(s), this._geometry.attributes.uv2 || (this._geometry.attributes.uv2 = this._geometry.attributes.uv.clone(), this._geometry.attributes.uv2.needsUpdate = !0), this._mesh && (this._mesh.geometry = this._geometry));
  }
  _createMaterial(s) {
    return s || (s = new Ds({
      name: "BaseGroundMaterial",
      color: 16777215,
      roughness: 0.8,
      metalness: 0.5
    })), s.userData.runtimeMaterial = !0, s;
  }
  _refreshMaterial() {
    this._viewer && (this.isDisabled() || (this._material || (this._material = this._createMaterial(), this._viewer.scene.setDirty()), this._material && (this._material.userData.__renderToDepth === void 0 && (this._material.userData.__renderToDepth = this._material.userData.renderToDepth), this._material.userData.renderToDepth !== this.renderToDepth && (this._material.userData.renderToDepth = this.renderToDepth), this._material.userData.gBufferData || (this._material.userData.gBufferData = {}), this._material.userData.gBufferData.__tonemapEnabled === void 0 && (this._material.userData.gBufferData.__tonemapEnabled = this._material.userData.gBufferData.tonemapEnabled), this._material.userData.gBufferData.tonemapEnabled !== this.tonemapGround && (this._material.userData.gBufferData.tonemapEnabled = this.tonemapGround)), this._viewer.setDirty(this)));
  }
  get material() {
    return this._material;
  }
  get mesh() {
    return this._mesh;
  }
  fromJSON(s, e) {
    return s.options && console.error("todo: support old webgi v0 file"), super.fromJSON(s, e) ? (this.refresh(), this) : null;
  }
};
Hi.PluginType = "BaseGroundPlugin";
Hi.OldPluginType = "Ground";
ia([
  ue("Visible"),
  Oe(Hi.prototype.refreshTransform),
  V()
], Hi.prototype, "visible", 2);
ia([
  ii("Size"),
  Pi(Hi.prototype._onSceneUpdate),
  V()
], Hi.prototype, "size", 2);
ia([
  ii("Height (yOffset)"),
  Pi(Hi.prototype._onSceneUpdate),
  V()
], Hi.prototype, "yOffset", 2);
ia([
  ue("Render to Depth"),
  Oe(Hi.prototype._refresh2),
  V()
], Hi.prototype, "renderToDepth", 2);
ia([
  ue("Tonemap Ground"),
  Oe(Hi.prototype._refresh2),
  V()
], Hi.prototype, "tonemapGround", 2);
ia([
  ue("Limit Camera Above Ground"),
  Oe(Hi.prototype._refreshCameraLimits),
  V()
], Hi.prototype, "limitCameraAboveGround", 2);
ia([
  ue("Auto Adjust Transform"),
  Oe(Hi.prototype.refreshTransform),
  V()
], Hi.prototype, "autoAdjustTransform", 2);
ia([
  V("material"),
  Ki(),
  Ht({ obj: "mesh", key: "material" })
], Hi.prototype, "_material", 2);
Hi = ia([
  Lt("Ground")
], Hi);
class Ay extends Tt {
  constructor() {
    super(...arguments), this.enabled = !0, this.toJSON = void 0, this._cameraChanged = (e) => {
      var t, i, n, r;
      (i = (t = e.lastCamera) == null ? void 0 : t.removeControlsCtor) == null || i.call(t, this.controlsKey), (r = (n = e.camera) == null ? void 0 : n.setControlsCtor) == null || r.call(n, this.controlsKey, this._controlsCtor);
    };
  }
  onAdded(e) {
    super.onAdded(e), this._cameraChanged({ camera: e.scene.mainCamera, lastCamera: void 0 }), e.scene.addEventListener("mainCameraChange", this._cameraChanged);
  }
  onRemove(e) {
    this._cameraChanged({ lastCamera: e.scene.mainCamera, camera: void 0 }), e.scene.removeEventListener("mainCameraChange", this._cameraChanged), super.onRemove(e);
  }
}
var g3 = Object.defineProperty, A3 = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && g3(e, t, n), n;
};
const Vg = class extends Tt {
  constructor(e, t) {
    super(), this.container = t, this.enabled = !0, this._mainDiv = po({
      id: "assetManager" + e,
      addToBody: !1,
      innerHTML: ""
    }), this._contentDiv = po({
      id: "assetManager" + e + "Content",
      addToBody: !1,
      innerHTML: ""
    }), this.enabled || (this._mainDiv.style.display = "none"), this._mainDiv.appendChild(this._contentDiv), this._onProcessStateUpdate = this._onProcessStateUpdate.bind(this);
  }
  _onEnabledChange() {
    this.enabled || (this._mainDiv.style.display = "none");
  }
  onAdded(e) {
    super.onAdded(e), (this.container ?? e.container).appendChild(this._mainDiv), this._updateMainDiv(e.assetManager.processState), e.assetManager.addEventListener("processStateUpdate", this._onProcessStateUpdate);
  }
  _onProcessStateUpdate() {
    this._viewer && this._updateMainDiv(this._viewer.assetManager.processState);
  }
  onRemove(e) {
    return this._mainDiv.remove(), e.assetManager.removeEventListener("processStateUpdate", this._onProcessStateUpdate), super.onRemove(e);
  }
};
A3([
  ue("Enabled"),
  Oe(Vg.prototype._onEnabledChange),
  V()
], Vg.prototype, "enabled");
let y3 = Vg;
class nS extends gu {
  constructor(e, t = 120) {
    super({
      vertexShader: rc.vertexShader,
      fragmentShader: Oa`
                uniform vec4 weight;
                uniform vec4 weight2;
                varying vec2 vUv;
                void main() {
                    vec4 texel = clamp(weight * tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ) + weight2 * tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), vec4(0), vec4(MAX_INTENSITY));
                    gl_FragColor = texel;
                    #include <colorspace_fragment>
                }
            `,
      uniforms: {
        tDiffuse: { value: null },
        tDiffuse2: { value: e },
        weight: { value: new it(1, 1, 1, 1) },
        weight2: { value: new it(1, 1, 1, 1) }
      },
      defines: {
        MAX_INTENSITY: t
      }
    }, "tDiffuse", "tDiffuse2"), this.clear = !1, this.needsSwap = !0;
  }
}
var v3 = Object.defineProperty, _3 = Object.getOwnPropertyDescriptor, wu = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? _3(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && v3(e, t, n), n;
};
let Bs = class extends Tt {
  constructor(s = 1) {
    super(), this.enabled = !0, this.rendersPerFrame = 1, this.jitterRenderCamera = !0, this.jitterLightCameras = !0, this._hasSetOffsetRC = !1, this._hasSetOffsetLC = !1, this.trackedJitterCameras = /* @__PURE__ */ new Set(), this.dependencies = [vr], this._addSceneObject = (e) => {
      var t;
      (t = e.object) == null || t.traverse((i) => {
        i && i.shadow && i.shadow.camera && i.shadow.mapSize && this.trackedJitterCameras.add([i.shadow.camera, i.shadow.mapSize]);
      });
    }, this._preRender = () => {
      const e = this._viewer;
      if (!e || !this.enabled || e.renderManager.frameCount <= 1) return;
      this.rendersPerFrame = e.rendersPerFrame;
      const t = e.scene.renderCamera;
      this.jitterRenderCamera && this._jitter(t, {
        width: e.renderManager.renderSize.x * e.renderManager.renderScale,
        height: e.renderManager.renderSize.y * e.renderManager.renderScale
      }, e.renderManager.frameCount), this.jitterLightCameras && this.trackedJitterCameras.forEach((i) => this._jitter(...i, e.renderManager.frameCount)), this._hasSetOffsetRC = this.jitterRenderCamera, this._hasSetOffsetLC = this.jitterLightCameras, e.renderManager.resetShadows();
    }, this._postRender = () => {
      const e = this._viewer;
      e && (this._hasSetOffsetRC && (this._clearJitter(e.scene.renderCamera), this._hasSetOffsetRC = !1), this._hasSetOffsetLC && (this.trackedJitterCameras.forEach(([t]) => this._clearJitter(t)), this._hasSetOffsetLC = !1));
    }, this.jitterOffsets = [
      { x: 0, y: 0 },
      { x: -0.5, y: 0 },
      { x: -0.375, y: -0.25 },
      { x: -0.1875, y: -0.125 },
      { x: -0.125, y: -0.375 },
      { x: 0.0625, y: -0.0625 },
      { x: 0.125, y: -0.3125 },
      { x: 0.375, y: -0.4375 },
      { x: 0.3125, y: -0.1875 },
      { x: 0.25, y: 0.0625 },
      { x: 0.4375, y: 0.25 },
      { x: 0.1875, y: 0.3125 },
      { x: 0, y: 0.4375 },
      { x: -0.0625, y: 0.1875 },
      { x: -0.25, y: 0.375 },
      { x: -0.4375, y: 0.5 },
      { x: -0.3125, y: 0.125 }
    ], this.rendersPerFrame = s;
  }
  onAdded(s) {
    super.onAdded(s), s.addEventListener("preRender", this._preRender), s.addEventListener("postRender", this._postRender), s.scene.addEventListener("addSceneObject", this._addSceneObject);
  }
  onRemove(s) {
    return s.removeEventListener("preRender", this._preRender), s.removeEventListener("postRender", this._postRender), s.scene.removeEventListener("addSceneObject", this._addSceneObject), super.onRemove(s);
  }
  setDirty() {
    var s, e;
    this._viewer && (this._viewer.rendersPerFrame = this.rendersPerFrame, this._viewer.setDirty(), (e = (s = this.uiConfig) == null ? void 0 : s.uiRefresh) == null || e.call(s, !0, "postFrame"));
  }
  _jitter(s, e, t) {
    var n;
    if (s.userData.disableJitter) return;
    if (s.userData.__jittered) {
      (n = this._viewer) == null || n.console.warn("SSAAPlugin: Camera already jittered");
      return;
    }
    const i = { ...this.jitterOffsets[t % this.jitterOffsets.length] };
    s.setViewOffset(e.width, e.height, i.x, i.y, e.width, e.height), s.userData.__jittered = !0;
  }
  _clearJitter(s) {
    s.userData.__jittered && (s.clearViewOffset(), delete s.userData.__jittered);
  }
};
Bs.PluginType = "SSAAPlugin";
wu([
  V(),
  ue("Enabled"),
  Oe(Bs.prototype.setDirty)
], Bs.prototype, "enabled", 2);
wu([
  V(),
  Ye("Renders/Frame", [1, 32], 1),
  Oe(Bs.prototype.setDirty)
], Bs.prototype, "rendersPerFrame", 2);
wu([
  V(),
  ue("Render Camera"),
  Oe(Bs.prototype.setDirty)
], Bs.prototype, "jitterRenderCamera", 2);
wu([
  V(),
  ue("Light Cameras"),
  Oe(Bs.prototype.setDirty)
], Bs.prototype, "jitterLightCameras", 2);
Bs = wu([
  Lt("SSAA Plugin")
], Bs);
var x3 = Object.defineProperty, w3 = Object.getOwnPropertyDescriptor, yy = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? w3(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && x3(e, t, n), n;
};
let vr = class extends kc {
  // cannot be changed after creation (for now)
  constructor(s = 32, e = Ft, t = !0) {
    super(), this.passId = "progressive", this._targets = /* @__PURE__ */ new Map(), this.maxFrameCount = s, this.enabled = t, this.bufferType = e;
  }
  // @uiImage('Last Texture', {readOnly: true}) texture?: Texture
  get texture() {
    var s;
    return (s = this.target) == null ? void 0 : s.texture;
  }
  get target() {
    return this._viewer ? this._targets.get(this._viewer.scene.renderCamera.uuid) : void 0;
  }
  getTarget(s) {
    return this._viewer ? this._targets.get((s || this._viewer.scene.renderCamera).uuid) : void 0;
  }
  get textures() {
    return this._viewer ? Array.from(this._targets.values()).map((s) => s.texture) : [];
  }
  get mainTexture() {
    var s;
    return this._viewer ? (s = this.getTarget(this._viewer.scene.mainCamera)) == null ? void 0 : s.texture : void 0;
  }
  _createTarget(s, e = !1) {
    if (!this._viewer) return;
    if (s = s ?? this._viewer.scene.renderCamera, e && this._disposeTarget(s), this._targets.has(s.uuid)) return this._targets.get(s.uuid);
    const t = this._viewer.renderManager.composerTarget.clone(!0);
    return t.texture.name = "progressiveLastBuffer_" + s.uuid, this._targets.set(s.uuid, t), t;
  }
  _disposeTarget(s) {
    if (this._viewer)
      if (!s)
        this._targets.forEach((e) => this._viewer.renderManager.disposeTarget(e)), this._targets.clear();
      else {
        const e = this._targets.get(s.uuid);
        e && (this._viewer.renderManager.disposeTarget(e), this._targets.delete(s.uuid));
      }
  }
  _createPass() {
    var e;
    const s = new E3(this.passId, () => this.target ?? this._createTarget(), (e = this._viewer) == null ? void 0 : e.renderManager.maxHDRIntensity);
    return s.dirty = () => {
      var t;
      return (((t = this._viewer) == null ? void 0 : t.renderManager.frameCount) || 0) < this.maxFrameCount;
    }, s;
  }
  onAdded(s) {
    super.onAdded(s);
  }
  onRemove(s) {
    return this._disposeTarget(), super.onRemove(s);
  }
  /**
   *
   * @param postRender - if called after rendering frame.
   */
  isConverged(s = !1) {
    var e;
    return (((e = this._viewer) == null ? void 0 : e.renderManager.frameCount) || 0) >= this.maxFrameCount - 1 + (s ? 1 : 0);
  }
  updateShaderProperties(s) {
    var e;
    return s.uniforms.tLastFrame && (s.uniforms.tLastFrame.value = ((e = this.target) == null ? void 0 : e.texture) ?? void 0), this;
  }
  /**
   * Get recording delta post render, For use with animations to sync with converge mode in canvas recorder. See PopmotionPlugin for usage.
   * @returns {number} - delta time in milliseconds, or 0 when converging, or -1 in case of not recording in converge mode
   */
  postFrameConvergedRecordingDelta(s = "CanvasRecorder") {
    return -1;
  }
  get convergedPromise() {
    return new Promise((s) => {
      var e, t;
      if (this.isConverged())
        (e = this._viewer) == null || e.doOnce("postFrame", () => s());
      else {
        const i = () => {
          var n, r;
          this.isConverged(!0) && ((n = this._viewer) == null || n.removeEventListener("postRender", i), (r = this._viewer) == null || r.doOnce("postFrame", () => s()));
        };
        (t = this._viewer) == null || t.addEventListener("postRender", i);
      }
    });
  }
  fromJSON(s, e) {
    var t;
    if (s.jitter !== void 0) {
      const i = (t = this._viewer) == null ? void 0 : t.getPlugin(Bs);
      i ? (s = { ...s }, i.enabled = s.jitter, delete s.jitter) : console.warn("Loading old webgi v0 file, add SSAAPlugin to get anti-aliasing");
    }
    return super.fromJSON(s, e);
  }
};
vr.PluginType = "ProgressivePlugin";
vr.OldPluginType = "Progressive";
yy([
  V(),
  pt("Frame count")
], vr.prototype, "maxFrameCount", 2);
yy([
  ta("Last Texture", { readOnly: !0 })
], vr.prototype, "mainTexture", 1);
vr = yy([
  Lt("Progressive Plugin")
], vr);
class E3 extends nS {
  constructor(e, t, i = 120) {
    super(void 0, i), this.passId = e, this.target = t, this.before = ["screen"], this.after = ["render"], this.required = ["render"], this.dirty = () => !1;
  }
  render(e, t, i, n, r) {
    if (!this.enabled) return;
    const a = gi(this.target);
    if (!a) {
      console.warn("ProgressiveBlendPass: target not defined");
      return;
    }
    if (e.renderManager.frameCount < 1) {
      this.needsSwap = !1, i != null && i.texture && e.renderManager.blit(a, {
        source: i.texture,
        respectColorSpace: !1
      });
      return;
    }
    this.needsSwap = !0, super.render(e, t, i, n, r), e.renderManager.blit(a, {
      source: t.texture,
      respectColorSpace: !1
    });
  }
  beforeRender(e, t, i) {
    var r;
    if (!this.enabled) return;
    if (!this.target) {
      console.error("ProgressiveBlendPass: render target undefined");
      return;
    }
    let n = 1 / (Math.max(i.frameCount, 0) + 1);
    this.uniforms.weight.value.set(n, n, n, n), n = 1 - n, this.uniforms.weight2.value.set(n, n, n, n), this.uniforms.tDiffuse2.value = (r = gi(this.target)) == null ? void 0 : r.texture, this.material.uniformsNeedUpdate = !0;
  }
}
const b3 = `#if defined(HAS_DEPTH_BUFFER)
#if DEPTH_PACKING == 3200
#define unpackDepth(rgba_depth) (1.0 - rgba_depth.r)
#elif DEPTH_PACKING == 3201
#define unpackDepth(rgba_depth) unpackRGBAToDepth(rgba_depth)
#endif
uniform sampler2D tDepthBuffer;
#define getDepth(uv) unpackDepth(texture2D(tDepthBuffer, uv))
#endif
`;
var S3 = Object.defineProperty, C3 = Object.getOwnPropertyDescriptor, vy = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? C3(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && S3(e, t, n), n;
};
let dc = class extends kc {
  constructor(s = Ft, e = !1, t = !0, i = kl) {
    super(), this.passId = "depth", this.material = new M3({
      depthPacking: kl,
      blending: _n,
      transparent: !0
    }), this.unpackExtension = {
      shaderExtender: (n) => {
        const a = ["depth_buffer_unpack", "gbuffer_unpack", "packing"].find((o) => n.fragmentShader.includes(`#include <${o}>`));
        n.fragmentShader = Ct(
          n.fragmentShader,
          `#include <${a}>`,
          `
` + b3 + `
`,
          { append: a === "packing" }
        );
      },
      extraUniforms: {
        tDepthBuffer: () => {
          var n;
          return { value: (n = this.target) == null ? void 0 : n.texture };
        }
      },
      extraDefines: {
        DEPTH_PACKING: kl,
        HAS_DEPTH_BUFFER: () => {
          var n;
          return (n = this.target) != null && n.texture ? 1 : void 0;
        },
        HAS_GBUFFER: () => {
          var n;
          return this.isPrimaryGBuffer && ((n = this.target) != null && n.texture) ? 1 : void 0;
        }
      },
      priority: 100,
      isCompatible: () => !0
    }, this._isPrimaryGBufferSet = !1, this.enabled = t, this.depthPacking = i, this.bufferType = s, this.isPrimaryGBuffer = e;
  }
  // cannot be changed after creation (for now)
  _depthPackingChanged() {
    var s, e;
    this.material.depthPacking = this.depthPacking, this.material.needsUpdate = !0, this.unpackExtension && this.unpackExtension.extraDefines && (this.unpackExtension.extraDefines.DEPTH_PACKING = this.depthPacking, (e = (s = this.unpackExtension).setDirty) == null || e.call(s)), this.setDirty();
  }
  _createTarget(s = !0) {
    if (!this._viewer) return;
    s && this._disposeTarget();
    const e = this._viewer.renderManager;
    this.target || (this.target = this._viewer.renderManager.createTarget(
      {
        depthBuffer: !0,
        samples: this._viewer.renderManager.zPrepass && this.isPrimaryGBuffer && e.msaa ? (
          // requirement for zPrepass
          typeof e.msaa != "number" ? Ar.DEFAULT_MSAA_SAMPLES : e.msaa
        ) : 0,
        type: this.bufferType
        // magFilter: NearestFilter,
        // minFilter: NearestFilter,
        // generateMipmaps: false,
        // encoding: LinearEncoding,
      }
    )), this.texture = this.target.texture, this.texture.name = "depthBuffer", this.isPrimaryGBuffer && (this._viewer.renderManager.gbufferTarget = this.target, this._viewer.renderManager.gbufferUnpackExtension = this.unpackExtension, this._viewer.renderManager.screenPass.material.registerMaterialExtensions([this.unpackExtension]), this._isPrimaryGBufferSet = !0);
  }
  _disposeTarget() {
    this._viewer && (this.target && (this._viewer.renderManager.disposeTarget(this.target), this.target = void 0), this.texture = void 0, this._isPrimaryGBufferSet && (this._viewer.renderManager.gbufferTarget = void 0, this._viewer.renderManager.gbufferUnpackExtension = void 0, this._isPrimaryGBufferSet = !1));
  }
  _createPass() {
    if (this._createTarget(!0), !this.target) throw new Error("DepthBufferPlugin: target not created");
    this.material.userData.isGBufferMaterial = !0;
    const s = new To(this.passId, () => this.target, this.material, new se(0, 0, 0), 1), e = s.preprocessMaterial;
    return s.preprocessMaterial = (t) => e(t, t.userData.renderToDepth), s.before = ["render"], s.after = [], s.required = ["render"], s;
  }
  onRemove(s) {
    return this._disposeTarget(), super.onRemove(s);
  }
};
dc.PluginType = "DepthBufferPlugin";
vy([
  ta("Depth Buffer", { readOnly: !0 })
], dc.prototype, "texture", 2);
vy([
  Oe(dc.prototype._depthPackingChanged),
  er("Depth Packing", hE.DepthPackingStrategies.uiConfig)
], dc.prototype, "depthPacking", 2);
dc = vy([
  Lt("Depth Buffer Plugin")
], dc);
class M3 extends Np {
  constructor(e) {
    super(e), this.reset();
  }
  onBeforeRender(e, t, i, n, r) {
    super.onBeforeRender(e, t, i, n, r);
    let a = r.material;
    Array.isArray(a) && (a = a[0]), a && (a.map !== void 0 && (this.map = a.map), a.side !== void 0 && (this.side = a.side ?? $n), a.alphaMap !== void 0 && (this.alphaMap = a.alphaMap), a.alphaTest !== void 0 && (this.alphaTest = a.alphaTest < 1e-4 ? 1e-4 : a.alphaTest), a.alphaHash !== void 0 && (this.alphaHash = a.alphaHash), a.displacementMap !== void 0 && (this.displacementMap = a.displacementMap), a.displacementScale !== void 0 && (this.displacementScale = a.displacementScale), a.displacementBias !== void 0 && (this.displacementBias = a.displacementBias), a.wireframe !== void 0 && (this.wireframe = a.wireframe), a.wireframeLinewidth !== void 0 && (this.wireframeLinewidth = a.wireframeLinewidth), this.needsUpdate = !0);
  }
  onAfterRender(e, t, i, n, r) {
    super.onAfterRender(e, t, i, n, r), this.reset();
  }
  reset() {
    this.map = null, this.side = zi, this.alphaMap = null, this.alphaTest = 1e-3, this.alphaHash = !1, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1;
  }
}
var T3 = Object.defineProperty, I3 = Object.getOwnPropertyDescriptor, sS = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? I3(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && T3(e, t, n), n;
};
let Mp = class extends kc {
  constructor(s = Qt, e = !0) {
    super(), this.passId = "normal", this.material = new D3({
      blending: _n
    }), this.enabled = e, this.bufferType = s;
  }
  // cannot be changed after creation (for now)
  _createTarget(s = !0) {
    this._viewer && (s && this._disposeTarget(), this.target || (this.target = this._viewer.renderManager.createTarget(
      {
        depthBuffer: !0,
        // samples: rm.msaa ? typeof rm.msaa !== 'number' ? ViewerRenderManager.DEFAULT_MSAA_SAMPLES : rm.msaa : 0,
        samples: 0,
        type: this.bufferType,
        magFilter: pi,
        minFilter: pi,
        generateMipmaps: !1,
        colorSpace: Mt
      }
    )), this.texture = this.target.texture, this.texture.name = "normalBuffer");
  }
  _disposeTarget() {
    this._viewer && (this.target && (this._viewer.renderManager.disposeTarget(this.target), this.target = void 0), this.texture = void 0);
  }
  _createPass() {
    if (this._createTarget(!0), !this.target) throw new Error("NormalBufferPlugin: target not created");
    this.material.userData.isGBufferMaterial = !0;
    const s = new To(this.passId, () => this.target, this.material, new se(0, 0, 0), 1), e = s.preprocessMaterial;
    return s.preprocessMaterial = (t) => e(t, !0), s.before = ["render"], s.after = [], s.required = ["render"], s;
  }
  onRemove(s) {
    return this._disposeTarget(), super.onRemove(s);
  }
};
Mp.PluginType = "NormalBufferPlugin";
sS([
  ta("Normal Buffer", { readOnly: !0 })
], Mp.prototype, "texture", 2);
Mp = sS([
  Lt("Normal Buffer Plugin")
], Mp);
class D3 extends Uw {
  constructor(e) {
    super(e), this.reset();
  }
  onBeforeRender(e, t, i, n, r) {
    if (super.onBeforeRender(e, t, i, n, r), !r.material) return;
    const a = r.material;
    a.bumpMap !== void 0 && (this.bumpMap = a.bumpMap), a.bumpScale !== void 0 && (this.bumpScale = a.bumpScale), a.alphaTest !== void 0 && (this.alphaTest = a.alphaTest < 1e-4 ? 1e-4 : a.alphaTest), a.alphaHash !== void 0 && (this.alphaHash = a.alphaHash), a.normalMap !== void 0 && (this.normalMap = a.normalMap), a.normalMapType !== void 0 && (this.normalMapType = a.normalMapType), a.normalScale !== void 0 && this.normalScale.copy(a.normalScale), a.displacementMap !== void 0 && (this.displacementMap = a.displacementMap), a.displacementScale !== void 0 && (this.displacementScale = a.displacementScale), a.displacementBias !== void 0 && (this.displacementBias = a.displacementBias), a.flatShading !== void 0 && (this.flatShading = a.flatShading), a.side !== void 0 && (this.side = a.side), a.wireframe !== void 0 && (this.wireframe = a.wireframe), a.wireframeLinewidth !== void 0 && (this.wireframeLinewidth = a.wireframeLinewidth);
  }
  onAfterRender(e, t, i, n, r) {
    super.onAfterRender(e, t, i, n, r), this.reset();
  }
  reset() {
    this.bumpMap = null, this.bumpScale = 1, this.alphaTest = 0, this.normalMap = null, this.normalMapType = Ts, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.flatShading = !1, this.side = zi, this.wireframe = !1, this.wireframeLinewidth = 1;
  }
}
var R3 = Object.defineProperty, B3 = Object.getOwnPropertyDescriptor, lf = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? B3(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && R3(e, t, n), n;
};
let Do = class extends kc {
  constructor(s = !0) {
    super(), this.passId = "frameFade", this.dependencies = [vr], this.isEditor = !1, this.fadeOnActiveCameraChange = !0, this.fadeOnMaterialUpdate = !0, this.fadeOnSceneUpdate = !0, this._pointerEnabled = !0, this.saveFrameTimeThreshold = 500, this._fadeCam = async (e) => e.frameFade !== !1 && !this.isEditor && this.fadeOnActiveCameraChange && this.startTransition(e.fadeDuration || 1e3), this._fadeMat = async (e) => e.frameFade !== !1 && !this.isEditor && this.fadeOnMaterialUpdate && this.startTransition(e.fadeDuration || 200), this._fadeScene = async (e) => e.frameFade !== !1 && !this.isEditor && this.fadeOnSceneUpdate && this.startTransition(e.fadeDuration || 500), this._fadeObjectUpdate = async (e) => e.frameFade && !this.isEditor && this.startTransition(e.fadeDuration || 500), this._onPointerMove = (e) => {
      var a;
      const t = (a = this._viewer) == null ? void 0 : a.canvas;
      if (!t) {
        this._pointerEnabled = !1;
        return;
      }
      if (!e.buttons || e.target !== t) {
        this._pointerEnabled = !0;
        return;
      }
      const i = t.getBoundingClientRect(), n = (e.clientX - i.left) / i.width, r = (e.clientY - i.top) / i.height;
      this._pointerEnabled = n < 0 || n > 1 || r < 0 || r > 1;
    }, this.enabled = s, this.startTransition = this.startTransition.bind(this), this.stopTransition = this.stopTransition.bind(this), this._fadeCam = this._fadeCam.bind(this), this._fadeMat = this._fadeMat.bind(this), this.isDisabled = /* @__PURE__ */ ((e) => () => !this._pointerEnabled || e())(this.isDisabled);
  }
  // ms
  /**
   * Start a frame fade transition.
   * Note that the current frame data will only be used if the last running transition is ended or near the end. To do it anyway, call {@link stopTransition} first
   * @param duration
   */
  async startTransition(s) {
    !this._viewer || !this._pass || this.isDisabled() || (this._target || (this._target = this._viewer.renderManager.getTempTarget({
      sizeMultiplier: 1,
      minFilter: tt,
      magFilter: tt,
      colorSpace: this._viewer.renderManager.composerTarget.texture.colorSpace
    })), this._pass.fadeTimeState < this.saveFrameTimeThreshold && (this._pass.toSaveFrame = !0), this._pass.fadeTimeState = Math.max(s, this._pass.fadeTimeState), this._pass.fadeTime = this._pass.fadeTimeState, this.setDirty(), await bs(s));
  }
  /**
   * Stop a frame fade transition if running. Note that it will be stopped next frame.
   */
  stopTransition() {
    this._pass && (this._pass.fadeTimeState = 0);
  }
  onAdded(s) {
    super.onAdded(s), s.scene.addEventListener("mainCameraUpdate", this.stopTransition), s.scene.addEventListener("mainCameraChange", this._fadeCam), s.scene.addEventListener("materialUpdate", this._fadeMat), s.scene.addEventListener("sceneUpdate", this._fadeScene), s.scene.addEventListener("objectUpdate", this._fadeObjectUpdate), window.addEventListener("pointermove", this._onPointerMove);
  }
  onRemove(s) {
    s.scene.removeEventListener("mainCameraUpdate", this.stopTransition), s.scene.removeEventListener("mainCameraChange", this._fadeCam), s.scene.removeEventListener("materialUpdate", this._fadeMat), s.scene.removeEventListener("sceneUpdate", this._fadeScene), s.scene.removeEventListener("objectUpdate", this._fadeObjectUpdate), window.removeEventListener("pointermove", this._onPointerMove), super.onRemove(s);
  }
  setDirty() {
    var s;
    super.setDirty(), !this.isDisabled() && ((s = this._viewer) == null || s.setDirty());
  }
  get dirty() {
    return !this.isDisabled() && !!this._pass && this._pass.fadeTimeState > 0;
  }
  set dirty(s) {
    console.error("FrameFadePlugin.dirty is readonly");
  }
  _createPass() {
    var s;
    return new P3(this.passId, this, (s = this._viewer) == null ? void 0 : s.renderManager.maxHDRIntensity);
  }
  get canFrameFade() {
    return this._target && this._pointerEnabled && this.dirty && this._pass && this._pass.fadeTimeState > 1e-3 && this._viewer && this._viewer.scene.renderCamera === this._viewer.scene.mainCamera;
  }
  get lastFrame() {
    var s, e;
    return (e = (s = this._viewer) == null ? void 0 : s.getPlugin(vr)) == null ? void 0 : e.texture;
  }
  get target() {
    return this._target;
  }
  _beforeRender() {
    return !super._beforeRender() || !this._pass ? !1 : (this.isDisabled() && this.stopTransition(), this._pass.fadeTimeState < 1e-3 && (this._pass.toSaveFrame = !1, this._target && this._viewer && (this._viewer.renderManager.releaseTempTarget(this._target), this._target = void 0)), !0);
  }
};
Do.PluginType = "FrameFadePlugin";
lf([
  V(),
  ue()
], Do.prototype, "fadeOnActiveCameraChange", 2);
lf([
  V(),
  ue()
], Do.prototype, "fadeOnMaterialUpdate", 2);
lf([
  V(),
  ue()
], Do.prototype, "fadeOnSceneUpdate", 2);
Do = lf([
  Lt("FrameFade Plugin")
], Do);
class P3 extends nS {
  constructor(e, t, i = 120) {
    super(void 0, i), this.passId = e, this.plugin = t, this.before = ["progressive", "taa"], this.after = ["render"], this.required = ["render", "progressive"], this.dirty = () => !1, this.fadeTime = 0, this.fadeTimeState = 0, this.toSaveFrame = !1, this._lastTime = 0;
  }
  render(e, t, i, n, r) {
    this.needsSwap = !1;
    const a = this.plugin.target;
    if (!this.plugin.canFrameFade || !a) return;
    const o = this.plugin.lastFrame;
    this.toSaveFrame && o && (e.renderManager.blit(a, { source: o, respectColorSpace: !1 }), this._lastTime = 0, this.toSaveFrame = !1), this.uniforms.tDiffuse2.value = a.texture;
    const l = this.fadeTimeState / this.fadeTime;
    this.uniforms.weight2.value.setScalar(l), this.uniforms.weight2.value.w = 1, this.uniforms.weight.value.setScalar(1 - l), this.uniforms.weight.value.w = 1, super.render(e, t, i, n, r), this.needsSwap = !0;
    const c = zn();
    this._lastTime < 10 && (this._lastTime = c - 10);
    const h = c - this._lastTime;
    this._lastTime = c, this.fadeTimeState -= h;
  }
}
const L3 = `#include <randomHelpers>
#include <common>
#include <packing>
#define THREE_PACKING_INCLUDED
#include <cameraHelpers>
varying vec2 vUv;uniform sampler2D tLastThis;
#ifndef D_frameCount
#define D_frameCount
uniform float frameCount;
#endif
uniform vec4 saoData;uniform vec3 saoBiasEpsilon;uniform vec2 screenSize;const float INV_NUM_SAMPLES=1.0/float(NUM_SAMPLES);int getSelectionBit(in int number){
#ifdef WebGL2Context
return(number/8)% 2;
#else
return int(mod(floor(float(number)/8.),2.));
#endif
}vec3 packFloatToRGB(const in float x){const vec3 code=vec3(1.0,255.0,65025.0);vec3 pack=vec3(code*x);pack.gb=fract(pack.gb);pack.rg-=pack.gb*(1.0/256.0);return pack;}vec3 getPositionFromOffset(const in vec2 uvOffset){
#if defined(HAS_DEPTH_BUFFER) || defined(HAS_NORMAL_DEPTH_BUFFER)
float d=getDepth(uvOffset);
#else
float d=0.5;
#endif
#if LINEAR_DEPTH == 0
float centerViewZ=viewZFromNDCZ(d);return screenToView3(uvOffset,centerViewZ);
#else
d=mix(-cameraNearFar.x,-cameraNearFar.y,d);return screenToView3(uvOffset,d);
#endif
}float getOcclusion(const in vec2 uv,const in int id,const in float randomAngle,const in float occlusionSphereRadius,const in vec3 centerPosition,const in vec3 centerNormal){float screenSpaceRadius=(float(id)+mod(randomAngle,1.)+0.5)*INV_NUM_SAMPLES;float angle=screenSpaceRadius*(float(NUM_SPIRAL_TURNS)*6.28318)+randomAngle;screenSpaceRadius=(screenSpaceRadius*occlusionSphereRadius);vec2 uvOffset=uv+floor(screenSpaceRadius*vec2(cos(angle),sin(angle)))/screenSize;
#if CHECK_GBUFFER_FLAG == 1
if(getSelectionBit(getGBufferFlags(uvOffset.xy).a)<1)return 0.0;
#endif
vec3 samplePosition=getPositionFromOffset(uvOffset);vec3 direction=samplePosition-centerPosition;float d2=dot(direction,direction);float ao=max((dot(centerNormal,direction)+centerPosition.z*saoBiasEpsilon.x)/(saoBiasEpsilon.z*d2+saoBiasEpsilon.y),0.0);return ao;}void main(){float centerDepth=0.5;vec3 centerNormal=vec3(0,1,0);
#ifdef HAS_NORMAL_DEPTH_BUFFER
getDepthNormal(vUv,centerDepth,centerNormal);
#else
#ifdef HAS_DEPTH_BUFFER
centerDepth=getDepth(vUv);
#endif
#endif
#if LINEAR_DEPTH == 0
float centerViewZ=viewZFromNDCZ(centerDepth);
#else
float centerViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,centerDepth);
#endif
vec3 centerPosition=screenToView3(vUv,centerViewZ);float occlusionSphereScreenRadius=200.*saoData.z/(-centerPosition.z);float randomAngle=6.2*random3(vec3(vUv,frameCount*0.1));float sum=0.0;sum+=getOcclusion(vUv,0,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#if NUM_SAMPLES > 1
sum+=getOcclusion(vUv,1,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 2
sum+=getOcclusion(vUv,2,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 3
sum+=getOcclusion(vUv,3,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 4
sum+=getOcclusion(vUv,4,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 5
sum+=getOcclusion(vUv,5,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 6
sum+=getOcclusion(vUv,6,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 7
sum+=getOcclusion(vUv,7,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 8
sum+=getOcclusion(vUv,8,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 9
sum+=getOcclusion(vUv,9,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 10
sum+=getOcclusion(vUv,10,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
float aoValue=sum*saoData.y*INV_NUM_SAMPLES;aoValue=1.-clamp(aoValue,0.,1.);
#if SSAO_PACKING == 1
gl_FragColor.gba=packFloatToRGB(centerDepth);gl_FragColor.r=aoValue;
#elif SSAO_PACKING == 2
gl_FragColor.rgb=vec3(aoValue);gl_FragColor.a=1.;
#elif SSAO_PACKING == 3
gl_FragColor.rgba=packDepthToRGBA(aoValue);
#elif SSAO_PACKING == 4
gl_FragColor.rgb=packFloatToRGB(aoValue);gl_FragColor.a=1.;
#endif
}`, U3 = `
#ifndef USE_TRANSMISSION
#if defined(SSAO_ENABLED) && SSAO_ENABLED > 0
float ambientOcclusion=tSSAOMapTexelToLinear(texture2D(tSSAOMap,viewToScreen(vViewPosition.xyz).xy)).r;reflectedLight.indirectDiffuse*=ambientOcclusion;
#if defined( USE_ENVMAP )
float dotNV=saturate(dot(geometryNormal,geometryViewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);
#endif
#else
#include <aomap_fragment>
#endif
#endif
`;
var F3 = Object.defineProperty, O3 = Object.getOwnPropertyDescriptor, br = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? O3(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && F3(e, t, n), n;
};
let Ua = class extends kc {
  // cannot be changed after creation (for now)
  constructor(s = Ft, e = 1, t = !0) {
    super(), this.passId = "ssao", this.dependencies = [yr], this._gbufferUnpackExtension = void 0, this._gbufferUnpackExtensionChanged = () => {
      if (!this._pass || !this._viewer) throw new Error("SSAOPlugin: pass/viewer not created yet");
      const i = this._viewer.renderManager.gbufferUnpackExtension;
      this._gbufferUnpackExtension !== i && (this._gbufferUnpackExtension && this._pass.material.unregisterMaterialExtensions([this._gbufferUnpackExtension]), this._gbufferUnpackExtension = i, this._gbufferUnpackExtension ? this._pass.material.registerMaterialExtensions([this._gbufferUnpackExtension]) : this._viewer.console.warn("SSAOPlugin: GBuffer unpack extension removed"));
    }, this.enabled = t, this.bufferType = s, this.sizeMultiplier = e;
  }
  _createTarget(s = !0) {
    this._viewer && (s && this._disposeTarget(), this.target || (this.target = this._viewer.renderManager.createTarget(
      {
        depthBuffer: !1,
        type: this.bufferType,
        sizeMultiplier: this.sizeMultiplier
        // magFilter: NearestFilter,
        // minFilter: NearestFilter,
        // generateMipmaps: false,
        // encoding: LinearEncoding,
      }
    )), this.texture = this.target.texture, this.texture.name = "ssaoBuffer");
  }
  _disposeTarget() {
    this._viewer && (this.target && (this._viewer.renderManager.disposeTarget(this.target), this.target = void 0), this.texture = void 0);
  }
  _createPass() {
    if (!this._viewer) throw new Error("SSAOPlugin: viewer not set");
    if (!this._viewer.renderManager.gbufferTarget || !this._viewer.renderManager.gbufferUnpackExtension)
      throw new Error("SSAOPlugin: GBuffer target not created. GBufferPlugin or DepthBufferPlugin is required.");
    return this._createTarget(!0), new ts(this.passId, () => this.target);
  }
  onAdded(s) {
    super.onAdded(s), s.forPlugin(yr, (e) => {
      e.registerGBufferUpdater(this.constructor.PluginType, this.updateGBufferFlags.bind(this));
    }, (e) => {
      e.unregisterGBufferUpdater(this.constructor.PluginType);
    }), this._gbufferUnpackExtensionChanged(), s.renderManager.addEventListener("gbufferUnpackExtensionChanged", this._gbufferUnpackExtensionChanged);
  }
  onRemove(s) {
    return this._disposeTarget(), super.onRemove(s);
  }
  fromJSON(s, e) {
    var t;
    return (t = s.passes) != null && t.ssao && (s = { ...s }, s.pass = s.passes.ssao, delete s.passes, s.pass.enabled !== void 0 && (s.enabled = s.pass.enabled)), super.fromJSON(s, e);
  }
  updateGBufferFlags(s, e) {
    if (!e.material || !e.material.userData) return;
    const t = e.material.userData.ssaoCastDisabled || e.material.userData.pluginsDisabled, i = t ? 0 : 1;
    s.w = nE(s.w, 3, i), t && this._pass && (this._pass.checkGBufferFlag = !0);
  }
  /**
   * @deprecated use {@link target} instead
   */
  get aoTarget() {
    return console.warn("SSAOPlugin: aoTarget is deprecated, use target instead"), this.target;
  }
};
Ua.PluginType = "SSAOPlugin";
Ua.OldPluginType = "SSAO";
br([
  ta("SSAO Buffer", { readOnly: !0 })
], Ua.prototype, "texture", 2);
br([
  Ki()
], Ua.prototype, "_pass", 2);
Ua = br([
  Lt("SSAO Plugin")
], Ua);
let ts = class extends gu {
  // todo after bilateralPass is implemented
  // @bindToValue({obj: 'bilateralPass', key: 'enabled', onChange: 'setDirty'})
  // smoothEnabled = true
  // todo after bilateralPass is implemented
  // @bindToValue({obj: 'bilateralPass', key: 'enabled', onChange: 'setDirty'})
  // smoothEdgeSharpness = true
  constructor(s, e) {
    super({
      defines: {
        LINEAR_DEPTH: 1,
        // todo set from unpack extension
        NUM_SAMPLES: 11,
        NUM_SPIRAL_TURNS: 3,
        SSAO_PACKING: 1,
        // 1 is (r: ssao, gba: depth), 2 is (rgb: ssao, a: 1), 3 is (rgba: packed_ssao), 4 is (rgb: packed_ssao, a: 1)
        PERSPECTIVE_CAMERA: 1,
        // set in PerspectiveCamera2
        CHECK_GBUFFER_FLAG: 0
      },
      uniforms: {
        tLastThis: { value: null },
        screenSize: { value: new ie(0, 0) },
        // set in ExtendedRenderMaterial
        saoData: { value: new it() },
        frameCount: { value: 0 },
        // set in RenderManager
        cameraNearFar: { value: new ie(0.1, 1e3) },
        // set in PerspectiveCamera2
        projection: { value: new Ue() },
        // set in PerspectiveCamera2
        saoBiasEpsilon: { value: new M(1, 1, 1) }
      },
      vertexShader: lp.defaultVertex,
      fragmentShader: L3
    }, "tDiffuse"), this.passId = s, this.target = e, this.before = ["render"], this.after = ["gbuffer", "depth"], this.required = ["render"], this.intensity = 0.25, this.occlusionWorldRadius = 1, this.bias = 1e-3, this.falloff = 1.3, this.numSamples = 8, this.checkGBufferFlag = !1, this.materialExtension = {
      extraUniforms: {
        tSSAOMap: () => {
          var t;
          return { value: ((t = gi(this.target)) == null ? void 0 : t.texture) ?? null };
        }
      },
      shaderExtender: (t, i, n) => {
        t.defines.SSAO_ENABLED && (t.fragmentShader = Ct(t.fragmentShader, "#include <aomap_fragment>", U3));
      },
      onObjectRender: (t, i, n) => {
        var a, o;
        const r = this.enabled && // opaque &&
        n.userData.screenSpaceRendering !== !1 && !((a = i.userData) != null && a.pluginsDisabled) && !((o = i.userData) != null && o.ssaoDisabled) ? 1 : 0;
        i.defines.SSAO_ENABLED !== r && (i.defines.SSAO_ENABLED = r, i.needsUpdate = !0);
      },
      parsFragmentSnippet: () => {
        var t;
        return Oa`
             uniform sampler2D tSSAOMap;
             ${lE("tSSAOMap", (t = gi(this.target)) == null ? void 0 : t.texture.colorSpace)}
             #include <simpleCameraHelpers>
        `;
      },
      computeCacheKey: () => {
        var t, i;
        return (this.enabled ? "1" : "0") + ((i = (t = gi(this.target)) == null ? void 0 : t.texture) == null ? void 0 : i.colorSpace);
      },
      uuid: Ua.PluginType,
      ...fL(this._getUiConfig.bind(this), Ua.PluginType),
      isCompatible: (t) => t.isPhysicalMaterial
    }, this.needsSwap = !1, this.clear = !0;
  }
  render(s, e, t, i, n) {
    if (!this.enabled) return;
    const r = gi(this.target);
    if (!r) {
      console.warn("SSAOPluginPass: target not defined");
      return;
    }
    this._updateParameters(), s.renderManager.blit(e, {
      source: r.texture
    }), this.uniforms.tLastThis.value = e.texture, super.render(s, r, t, i, n);
  }
  _updateParameters() {
    const s = this.material.uniforms.saoData.value;
    s.y = this.intensity, s.z = this.occlusionWorldRadius;
    const e = this.material.uniforms.saoBiasEpsilon.value;
    e.x = this.bias, e.y = 1e-3, e.z = this.falloff;
  }
  beforeRender(s, e, t) {
    this.enabled && this.updateShaderProperties([e, t]);
  }
  /**
   * Returns a uiConfig to toggle SSAO on a material.
   * This uiConfig is added to each material by extension
   * @param material
   * @private
   */
  _getUiConfig(s) {
    return {
      type: "folder",
      label: "SSAO",
      children: [
        {
          type: "checkbox",
          label: "Enabled",
          get value() {
            return !(s.userData.ssaoDisabled ?? !1);
          },
          set value(e) {
            e !== !(s.userData.ssaoDisabled ?? !1) && (s.userData.ssaoDisabled = !e, s.setDirty());
          },
          onChange: this.setDirty
        },
        {
          type: "checkbox",
          label: "Cast SSAO",
          get value() {
            return !(s.userData.ssaoCastDisabled ?? !1);
          },
          set value(e) {
            e !== !(s.userData.ssaoCastDisabled ?? !1) && (s.userData.ssaoCastDisabled = !e, s.setDirty());
          },
          onChange: this.setDirty
        }
      ]
    };
  }
};
br([
  V(),
  Ye("Intensity", [0, 4], 0.01),
  Pi(ts.prototype.setDirty)
], ts.prototype, "intensity", 2);
br([
  V(),
  Ye("Occlusion World Radius", [0.1, 8], 0.01),
  Pi(ts.prototype.setDirty)
], ts.prototype, "occlusionWorldRadius", 2);
br([
  V(),
  Ye("Bias", [1e-5, 0.01], 1e-5),
  Pi(ts.prototype.setDirty)
], ts.prototype, "bias", 2);
br([
  V(),
  Ye("Falloff", [0.01, 3], 0.01),
  Pi(ts.prototype.setDirty)
], ts.prototype, "falloff", 2);
br([
  V(),
  Ye("Num Samples", [1, 11], 1),
  jA("NUM_SAMPLES", void 0, void 0, ts.prototype.setDirty)
], ts.prototype, "numSamples", 2);
br([
  Yp("CHECK_GBUFFER_FLAG")
], ts.prototype, "checkGBufferFlag", 2);
ts = br([
  Lt("SSAO Pass")
], ts);
const N3 = '#RenderTargetPreviewPluginContainer{position:absolute;left:0;bottom:0;width:100%;z-index:1000;display:flex;flex-wrap:wrap;flex-direction:row;gap:5px;padding:5px;pointer-events:none;height:auto}.RenderTargetPreviewPluginTarget{position:relative;width:200px;height:200px}.RenderTargetPreviewPluginCollapsed{height:25px}.RenderTargetPreviewPluginTargetHeader{position:absolute;top:0;left:0;right:0;background:#00000080;color:#fff;padding:2px;font-size:16px;height:20px;font-family:monospace;text-align:center;pointer-events:auto;cursor:pointer}.RenderTargetPreviewPluginTargetHeader:after{content:"-";position:absolute;right:2px;width:20px;height:20px;line-height:16px}.RenderTargetPreviewPluginCollapsed .RenderTargetPreviewPluginTargetHeader:after{content:"+";line-height:20px}';
var k3 = Object.defineProperty, G3 = Object.getOwnPropertyDescriptor, rS = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? G3(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && k3(e, t, n), n;
};
let Xh = class extends Tt {
  constructor(s = !0) {
    super(), this.enabled = !0, this.toJSON = null, this.mainDiv = po({ id: "RenderTargetPreviewPluginContainer", addToBody: !1 }), this.targetBlocks = [], this._postRender = () => {
      if (this._viewer)
        for (const e of this.targetBlocks) {
          if (!e.visible) continue;
          const t = gi(e.target);
          if (!t)
            continue;
          const i = e.div.getBoundingClientRect();
          let n = t.texture;
          const r = this._viewer.canvas.getBoundingClientRect();
          i.x = i.x - r.x, i.y = r.height + r.y - i.y - i.height, Array.isArray(n) && (this._viewer.console.warn("Multi target preview not supported yet, rendering just the first one"), n = n[0]);
          const a = this._viewer.renderManager.webglRenderer.outputColorSpace;
          e.originalColorSpace || (this._viewer.renderManager.webglRenderer.outputColorSpace = dt), this._viewer.renderManager.blit(null, {
            source: n,
            clear: !e.transparent,
            // transparent: targetBlock.transparent, // todo
            respectColorSpace: !e.originalColorSpace,
            viewport: new it(i.x, i.y, i.width, i.height),
            material: e.material
          }), this._viewer.renderManager.webglRenderer.outputColorSpace = a;
        }
    }, this.enabled = s;
  }
  onAdded(s) {
    super.onAdded(s), s.addEventListener("postRender", this._postRender), this.stylesheet = zh(N3, s.container), this.refreshUi();
  }
  onRemove(s) {
    var e;
    s.removeEventListener("postRender", this._postRender), (e = this.stylesheet) == null || e.remove(), this.stylesheet = void 0, this.refreshUi(), super.onRemove(s);
  }
  /**
   *
   * @param target - render target or a function that returns a render target
   * @param name - name of the target
   * @param transparent - if true, the target will be rendered with transparency
   * @param originalColorSpace - if true, the target will be rendered in its original color space
   * @param visible - initial visibility
   * @param material - snippet for {@link ExtendedCopyPass} or a custom {@link ExtendedShaderMaterial} or three.js ShaderMaterial. Example to read just the red channel `(s)=>s + ' = vec4(' + s + '.r);'`
   */
  addTarget(s, e, t = !1, i = !1, n = !0, r) {
    if (!s) return this;
    const a = document.createElement("div"), o = { target: s, name: e, transparent: t, div: a, originalColorSpace: i, visible: n };
    r && (o.material = r != null && r.isMaterial ? r : new ob(r).material), a.classList.add("RenderTargetPreviewPluginTarget"), o.visible || a.classList.add("RenderTargetPreviewPluginCollapsed");
    const l = document.createElement("div");
    return l.classList.add("RenderTargetPreviewPluginTargetHeader"), l.innerText = e, l.onclick = () => {
      var c;
      o.visible = !o.visible, o.visible ? a.classList.remove("RenderTargetPreviewPluginCollapsed") : a.classList.add("RenderTargetPreviewPluginCollapsed"), (c = this._viewer) == null || c.setDirty();
    }, l.oncontextmenu = (c) => {
      c.preventDefault(), c.stopPropagation(), cp.Create({
        Download: () => this.downloadTarget(s),
        Remove: () => this.removeTarget(s)
      }, c.clientX, c.clientY);
    }, a.appendChild(l), this.mainDiv.appendChild(a), this.targetBlocks.push(o), this.refreshUi(), this;
  }
  removeTarget(s) {
    const e = this.targetBlocks.findIndex((t) => t.target === s);
    if (e >= 0) {
      const t = this.targetBlocks[e];
      this.targetBlocks.splice(e, 1), t.div.remove();
    }
    return this.refreshUi(), this;
  }
  downloadTarget(s) {
    var o;
    if (!this._viewer) return this;
    const e = gi(s);
    if (!e) return this;
    const t = e.texture;
    if (Array.isArray(t))
      return this._viewer.dialog.alert("Multi target not supported yet"), this._viewer.console.warn("todo: support multi target export"), this;
    if (!((o = this._viewer) == null ? void 0 : o.canvas)) return this;
    const n = this._viewer.renderManager.exportRenderTarget(e), r = URL.createObjectURL(n), a = document.createElement("a");
    return document.body.appendChild(a), a.style.display = "none", a.href = r, a.download = "renderTarget." + (n.ext || "png"), a.click(), document.body.removeChild(a), URL.revokeObjectURL(r), this;
  }
  refreshUi() {
    var s, e;
    if (this.mainDiv) {
      if (!this._viewer) {
        this.mainDiv.parentElement && this.mainDiv.remove(), this.mainDiv.style.display = "none", this.mainDiv.style.zIndex = "1000";
        return;
      }
      this.mainDiv.parentElement || (s = this._viewer.container) == null || s.appendChild(this.mainDiv), this.mainDiv.style.display = this.isDisabled() ? "none" : "flex", this.mainDiv.style.zIndex = parseInt(this._viewer.canvas.style.zIndex || "0") + 1 + "", (e = this._viewer) == null || e.setDirty();
    }
  }
  setDirty() {
    this.refreshUi();
  }
  dispose() {
    for (const s of this.targetBlocks)
      this.removeTarget(s.target);
    super.dispose();
  }
};
Xh.PluginType = "RenderTargetPreviewPlugin";
rS([
  ue("Enabled"),
  Oe(Xh.prototype.refreshUi)
], Xh.prototype, "enabled", 2);
Xh = rS([
  Lt("Render Target Preview Plugin")
], Xh);
const z3 = '#GeometryUVPreviewPluginContainer{position:absolute;left:0;bottom:0;width:100%;z-index:1000;display:flex;flex-wrap:wrap;flex-direction:row;gap:5px;padding:5px;pointer-events:none;height:auto}.GeometryUVPreviewPluginTarget{position:relative;width:200px;height:200px}.GeometryUVPreviewPluginCollapsed{height:25px}.GeometryUVPreviewPluginTargetHeader{position:absolute;top:0;left:0;right:0;background:#00000080;color:#fff;padding:2px;font-size:16px;height:20px;font-family:monospace;text-align:center;pointer-events:auto;cursor:pointer}.GeometryUVPreviewPluginTargetHeader:after{content:"-";position:absolute;right:2px;width:20px;height:20px;line-height:16px}.GeometryUVPreviewPluginCollapsed .GeometryUVPreviewPluginTargetHeader:after{content:"+";line-height:20px}';
function Q3(s, e = 1024) {
  const t = "abc", i = new ie(), n = new ie(), r = [
    new ie(),
    new ie(),
    new ie()
  ], a = [], o = document.createElement("canvas"), l = e, c = e;
  o.width = l, o.height = c;
  const h = o.getContext("2d");
  h.lineWidth = 1, h.strokeStyle = "rgb( 63, 63, 63 )", h.textAlign = "center", h.fillStyle = "rgb( 255, 255, 255 )", h.fillRect(0, 0, l, c);
  const u = s.index, d = s.attributes.uv;
  if (u)
    for (let f = 0, y = u.count; f < y; f += 3)
      a[0] = u.getX(f), a[1] = u.getX(f + 1), a[2] = u.getX(f + 2), r[0].fromBufferAttribute(d, a[0]), r[1].fromBufferAttribute(d, a[1]), r[2].fromBufferAttribute(d, a[2]), p(a, r, f / 3);
  else
    for (let f = 0, y = d.count; f < y; f += 3)
      a[0] = f, a[1] = f + 1, a[2] = f + 2, r[0].fromBufferAttribute(d, a[0]), r[1].fromBufferAttribute(d, a[1]), r[2].fromBufferAttribute(d, a[2]), p(a, r, f / 3);
  return o;
  function p(f, y, A) {
    h.beginPath(), i.set(0, 0);
    for (let m = 0, v = y.length; m < v; m++) {
      const g = y[m];
      i.x += g.x, i.y += g.y, m === 0 ? h.moveTo(g.x * (l - 2) + 0.5, (1 - g.y) * (c - 2) + 0.5) : h.lineTo(g.x * (l - 2) + 0.5, (1 - g.y) * (c - 2) + 0.5);
    }
    h.closePath(), h.stroke(), i.divideScalar(y.length), h.font = "18px Arial", h.fillStyle = "rgb( 63, 63, 63 )", h.fillText(A, i.x * l, (1 - i.y) * c), i.x > 0.95 && h.fillText(A, i.x % 1 * l, (1 - i.y) * c), h.font = "12px Arial", h.fillStyle = "rgb( 191, 191, 191 )";
    for (let m = 0, v = y.length; m < v; m++) {
      const g = y[m];
      n.addVectors(i, g).divideScalar(2);
      const _ = f[m];
      h.fillText(t[m] + _, n.x * l, (1 - n.y) * c), n.x > 0.95 && h.fillText(t[m] + _, n.x % 1 * l, (1 - n.y) * c);
    }
  }
}
var H3 = Object.defineProperty, V3 = Object.getOwnPropertyDescriptor, aS = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? V3(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && H3(e, t, n), n;
};
let Yh = class extends Tt {
  constructor(s = !0) {
    super(), this.enabled = !0, this.toJSON = null, this.mainDiv = po({ id: "GeometryUVPreviewPluginContainer", addToBody: !1 }), this.targetBlocks = [], this._postRender = () => {
      var e;
      if (this._viewer)
        for (const t of this.targetBlocks) {
          if (!t.visible) continue;
          const i = gi(t.target);
          (e = i == null ? void 0 : i.attributes) != null && e.uv && (t.uvCanvas || (t.uvCanvas = Q3(i, 1024), t.uvCanvas.style.width = "100%", t.uvCanvas.style.height = "100%"), t.uvCanvas && t.uvCanvas.parentElement !== t.div && t.div.appendChild(t.uvCanvas));
        }
    }, this.enabled = s;
  }
  onAdded(s) {
    super.onAdded(s), s.addEventListener("postRender", this._postRender), this.stylesheet = zh(z3, s.container), this.refreshUi();
  }
  onRemove(s) {
    var e;
    s.removeEventListener("postRender", this._postRender), (e = this.stylesheet) == null || e.remove(), this.stylesheet = void 0, this.refreshUi(), super.onRemove(s);
  }
  addGeometry(s, e, t = !0) {
    if (!s) return this;
    const i = document.createElement("div"), n = { target: s, name: e, div: i, visible: t };
    i.classList.add("GeometryUVPreviewPluginTarget"), n.visible || i.classList.add("GeometryUVPreviewPluginCollapsed");
    const r = document.createElement("div");
    return r.classList.add("GeometryUVPreviewPluginTargetHeader"), r.innerText = e, r.onclick = () => {
      var a;
      n.visible = !n.visible, n.visible ? i.classList.remove("GeometryUVPreviewPluginCollapsed") : i.classList.add("GeometryUVPreviewPluginCollapsed"), (a = this._viewer) == null || a.setDirty();
    }, r.oncontextmenu = (a) => {
      a.preventDefault(), a.stopPropagation(), cp.Create({
        Download: () => this.downloadGeometryUV(n),
        Remove: () => this.removeGeometry(s)
      }, a.clientX, a.clientY);
    }, i.appendChild(r), this.mainDiv.appendChild(i), this.targetBlocks.push(n), this.refreshUi(), this;
  }
  removeGeometry(s) {
    const e = this.targetBlocks.findIndex((t) => t.target === s);
    if (e >= 0) {
      const t = this.targetBlocks[e];
      this.targetBlocks.splice(e, 1), t.div.remove();
    }
    return this.refreshUi(), this;
  }
  downloadGeometryUV(s) {
    if (!this._viewer) return this;
    if (!s.uvCanvas) return this;
    const t = s.uvCanvas.toDataURL("image/png"), i = document.createElement("a");
    return document.body.appendChild(i), i.style.display = "none", i.href = t, i.download = "renderTarget.png", i.click(), document.body.removeChild(i), URL.revokeObjectURL(t), this;
  }
  refreshUi() {
    var s, e;
    if (this.mainDiv) {
      if (!this._viewer) {
        this.mainDiv.parentElement && this.mainDiv.remove(), this.mainDiv.style.display = "none", this.mainDiv.style.zIndex = "1000";
        return;
      }
      this.mainDiv.parentElement || (s = this._viewer.container) == null || s.appendChild(this.mainDiv), this.mainDiv.style.display = this.isDisabled() ? "none" : "flex", this.mainDiv.style.zIndex = parseInt(this._viewer.canvas.style.zIndex || "0") + 1 + "", (e = this._viewer) == null || e.setDirty();
    }
  }
  setDirty() {
    this.refreshUi();
  }
  dispose() {
    for (const s of this.targetBlocks)
      this.removeGeometry(s.target);
    super.dispose();
  }
};
Yh.PluginType = "GeometryUVPreviewPlugin";
aS([
  ue("Enabled"),
  Oe(Yh.prototype.refreshUi)
], Yh.prototype, "enabled", 2);
Yh = aS([
  Lt("Render Target Preview Plugin")
], Yh);
var W3 = Object.defineProperty, j3 = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && W3(e, t, n), n;
};
const By = class By extends Tt {
  constructor() {
    super(), this.enabled = !0, this.serializeWithViewer = !1, this.uiConfig = {};
  }
  onAdded(e) {
    super.onAdded(e), this.uiConfig = e.uiConfig, this.uiConfig.expanded = !0;
  }
  // todo: fix deserialization throwing error
  // toJSON(): any {
  //     return this._viewer?.toJSON() ?? {}
  // }
  // fromJSON(data: ISerializedViewerConfig, meta?: SerializationMetaType): this | null {
  //     this._viewer?.fromJSON(data, meta)
  //     return this
  // }
};
By.PluginType = "ViewerUiConfigPlugin";
let Wg = By;
j3([
  V("viewer")
], Wg.prototype, "_viewer");
var q3 = Object.defineProperty, X3 = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && q3(e, t, n), n;
};
const Py = class Py extends Tt {
  constructor() {
    super(), this.enabled = !0, this.serializeWithViewer = !1, this.uiConfig = {};
  }
  onAdded(e) {
    super.onAdded(e), this.uiConfig = e.scene.uiConfig, this._scene = e.scene;
  }
};
Py.PluginType = "SceneUiConfigPlugin";
let jg = Py;
X3([
  V("scene")
], jg.prototype, "_scene");
var Y3 = Object.defineProperty, K3 = Object.getOwnPropertyDescriptor, cf = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? K3(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && Y3(e, t, n), n;
};
let pc = class extends Tt {
  constructor() {
    super(), this.toJSON = void 0, this.enabled = !0, this._lastSize = ["100%", "100%"], this._lastFsElement = null, this._fsChangeHandler = (s) => {
      var e;
      if (this.isFullScreen())
        this.dispatchEvent({ type: "enter" });
      else {
        const t = this._lastFsElement || ((e = this._viewer) == null ? void 0 : e.canvas);
        t && (t.style.width = this._lastSize[0], t.style.height = this._lastSize[1]), document.removeEventListener("webkitfullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("mozfullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("fullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("MSFullscreenChange", this._fsChangeHandler, !1), this.dispatchEvent({ type: "exit" });
      }
    }, this.enter = this.enter.bind(this), this.exit = this.exit.bind(this);
  }
  async enter(s) {
    var t;
    if (this.isFullScreen()) return;
    const e = s || ((t = this._viewer) == null ? void 0 : t.canvas);
    if (e) {
      if (this._lastFsElement = e, document.addEventListener && (document.addEventListener("webkitfullscreenchange", this._fsChangeHandler, !1), document.addEventListener("mozfullscreenchange", this._fsChangeHandler, !1), document.addEventListener("fullscreenchange", this._fsChangeHandler, !1), document.addEventListener("MSFullscreenChange", this._fsChangeHandler, !1)), this._lastSize = [e.style.width, e.style.height], e.style.width = "100%", e.style.height = "100%", e.requestFullscreen)
        return e.requestFullscreen();
      if (e.mozRequestFullScreen)
        return e.mozRequestFullScreen();
      if (e.webkitRequestFullscreen)
        return e.webkitRequestFullscreen();
      if (e.msRequestFullscreen)
        return e.msRequestFullscreen();
    }
  }
  async exit() {
    if (document.exitFullscreen)
      return document.exitFullscreen();
    if (document.mozCancelFullScreen)
      return document.mozCancelFullScreen();
    if (document.webkitExitFullscreen)
      return document.webkitExitFullscreen();
    if (document.msExitFullscreen)
      return document.msExitFullscreen();
  }
  async toggle(s) {
    return this.isFullScreen() ? this.exit() : this.enter(s);
  }
  isFullScreen() {
    return document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement !== void 0;
  }
};
pc.PluginType = "FullScreenPlugin";
cf([
  Pt("Enter FullScreen", { sendArgs: !1 })
], pc.prototype, "enter", 1);
cf([
  Pt("Exit FullScreen", { sendArgs: !1 })
], pc.prototype, "exit", 1);
cf([
  Pt("Toggle FullScreen", { sendArgs: !1 })
], pc.prototype, "toggle", 1);
pc = cf([
  Lt("Full Screen")
], pc);
const J3 = '#assetManagerLoadingScreen{z-index:50;position:absolute;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";bottom:0;right:0;min-width:100%;min-height:100%;color:#333;font-size:1rem;gap:1rem;display:flex;align-content:center;justify-content:center;align-items:center;flex-direction:column;opacity:1;transition:opacity .5s ease-in-out,min-width .5s,min-height .5s,bottom .5s,right .5s;overflow:hidden;background:transparent;-webkit-backdrop-filter:blur(16px);backdrop-filter:blur(16px);background-blend-mode:luminosity;--b-opacity: .8;--b-background: #fff}#assetManagerLoadingScreen:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;z-index:-1;opacity:var(--b-opacity);background:var(--b-background)}#assetManagerLoadingScreenContent{padding-top:.5rem}.loadingScreenProcessState{font-weight:700}#assetManagerLoadingScreen.minimizedLoadingScreen{top:unset;left:unset;bottom:2rem;right:2rem;min-width:0;min-height:0;max-width:80vw;max-height:80vh;width:max-content;height:max-content;padding:1.5rem;border-radius:.5rem}.loadingScreenFilesElement{min-height:4rem;padding:1rem}.loadingScreenLogoElement{margin-bottom:.5rem;max-width:80%}.loadingScreenLogoElement img{min-height:3rem;max-height:5rem;max-width:100%;object-fit:contain}.loadingScreenLogoImage{width:max-content;height:max-content}.minimizedLoadingScreen .loadingScreenLoadingElement{display:none}.minimizedLoadingScreen .loadingScreenFilesElement{min-height:0}.minimizedLoadingScreen .loadingScreenLogoElement{min-height:0;display:none}.minimizedLoadingScreen #assetManagerLoadingScreenContent{display:none}', $3 = ".loader{width:48px;height:48px;border:5px solid #333;border-bottom-color:transparent;border-radius:50%;display:inline-block;box-sizing:border-box;animation:rotation 1s linear infinite}@keyframes rotation{0%{transform:rotate(0)}to{transform:rotate(360deg)}}";
var Z3 = Object.defineProperty, eN = Object.getOwnPropertyDescriptor, Li = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? eN(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && Z3(e, t, n), n;
};
let kt = class extends y3 {
  constructor(s) {
    super("LoadingScreen", s), this.styles = J3, this.spinners = [{
      styles: $3,
      html: '<span class="loader"></span>'
    }], this.loader = 0, this.loadingTextHeader = "Loading Files", this.errorTextHeader = "Error Loading Files", this.showFileNames = !0, this.showProcessStates = !0, this.showProgress = !0, this.hideOnOnlyErrors = !0, this.hideOnFilesLoad = !0, this.hideOnSceneObjectLoad = !1, this.minimizeOnSceneObjectLoad = !0, this.showOnFilesLoading = !0, this.showOnSceneEmpty = !0, this.hideDelay = 500, this.backgroundOpacity = 0.5, this.backgroundBlur = 24, this.background = "#ffffff", this.textColor = "#222222", this.logoImage = kt.LS_DEFAULT_LOGO, this._isPreviewing = !1, this._previewState = /* @__PURE__ */ new Map([["file.glb", { state: "downloading", progress: 50 }], ["environment.hdr", { state: "adding" }]]), this.loadingElement = po({ classList: ["loadingScreenLoadingElement"], addToBody: !1 }), this.filesElement = po({ classList: ["loadingScreenFilesElement"], addToBody: !1 }), this.logoElement = po({ classList: ["loadingScreenLogoElement"], addToBody: !1 }), this._isHidden = !1, this._temp = document.createElement("template"), this.isEditor = !1, this._sceneUpdate = (e) => {
      if (!this._viewer || !e.hierarchyChanged) return;
      const t = this._viewer.scene.modelRoot.children;
      if (t.length === 0 && this.showOnSceneEmpty && !this.isEditor && this.show(), t.length > 0) {
        const i = this._viewer.assetManager.processState, n = [...i.values()].filter((r) => r.state === "error");
        this._updateVisibility(i, n.length) || (this.hideOnSceneObjectLoad ? this.hideWithDelay() : this.minimizeOnSceneObjectLoad && this._viewer.scene.environment && bs(this.hideDelay + 300).then(() => this.minimize()));
      } else this.minimizeOnSceneObjectLoad && this.maximize();
    }, this._mainDiv.prepend(this.loadingElement), this._mainDiv.prepend(this.logoElement), this._mainDiv.appendChild(this.filesElement);
  }
  refresh() {
    this._viewer && this._updateMainDiv(this._isPreviewing ? this._previewState : this._viewer.assetManager.processState, !1);
  }
  togglePreview() {
    this.maximize(), this._isPreviewing = !this._isPreviewing, this.refresh(), this._isPreviewing ? this.show() : this.hideWithDelay();
  }
  get visible() {
    return !this._isHidden;
  }
  async hide() {
    this._isHidden = !0, this._mainDiv.style.opacity = "0", await bs(502), this._isHidden && (this._mainDiv.style.display = "none", this._showMainDiv());
  }
  async hideWithDelay() {
    if (this._isHidden = !0, await bs(this.hideDelay), !!this._isHidden)
      return this.hide();
  }
  show() {
    this._isHidden && (this._isHidden = !1, this._showMainDiv(), this._mainDiv.style.display = "flex");
  }
  _showMainDiv() {
    this._mainDiv.style.opacity = "1";
  }
  minimize() {
    this._mainDiv.classList.add("minimizedLoadingScreen"), this.showFileNames || (this.loadingElement.style.display = "block");
  }
  maximize() {
    this._mainDiv.classList.remove("minimizedLoadingScreen"), this.loadingElement.style.display = "";
  }
  _setHTML(s, e) {
    this._temp.innerHTML = e, this._temp.innerHTML.trim() !== s.innerHTML.trim() && (s.innerHTML = e);
  }
  _updateMainDiv(s, e = !0) {
    if (!this._viewer || !this._contentDiv) return;
    if (!this.enabled) {
      this._mainDiv.style.display = "none";
      return;
    }
    if (this.showFileNames) {
      let i = "";
      s.forEach((n, r) => {
        i += (this.showProcessStates ? `<span class="loadingScreenProcessState">${n.state}</span>: ` : "") + (r || "").split("/").pop() + (this.showProgress && n.progress ? " - " + (n.progress.toFixed(0) + "%") : "") + "<br>";
      }), this._setHTML(this.filesElement, i);
    } else
      this._setHTML(this.filesElement, "");
    const t = [...s.values()].filter((i) => i.state === "error");
    t.length > 0 && t.length === s.size && !this.hideOnOnlyErrors ? this._setHTML(this._contentDiv, this.errorTextHeader) : this._setHTML(this._contentDiv, this.loadingTextHeader), this._setHTML(this.loadingElement, this.spinners[this.loader].html), this._mainDiv.style.setProperty("--b-opacity", this.backgroundOpacity.toString()), this._mainDiv.style.setProperty("--b-background", this.background), this._mainDiv.style.backdropFilter = `blur(${this.backgroundBlur}px)`, this._mainDiv.style.color = this.textColor, this._setHTML(this.logoElement, this.logoImage ? `<img class="loadingScreenLogoImage" src="${this.logoImage}"/>` : ""), e && this._updateVisibility(s, t.length);
  }
  _updateVisibility(s, e) {
    return this._viewer ? this.hideOnFilesLoad && (s.size === 0 || e === s.size && this.hideOnOnlyErrors) && !this._isHidden ? (this.hideDelay ? this.hideWithDelay() : this.hide(), !0) : s.size > 0 && this.showOnFilesLoading && this._isHidden ? (this._viewer.scene.modelRoot.children.length > 0 && this.minimizeOnSceneObjectLoad && this._viewer.scene.environment ? this.minimize() : this.maximize(), this.show(), !0) : !1 : !1;
  }
  onAdded(s) {
    this.stylesheet = zh(this.styles, s.container), this.stylesheetLoader = this.spinners.map((e) => zh(e.styles, s.container)), s.scene.addEventListener("sceneUpdate", this._sceneUpdate), super.onAdded(s);
  }
  onRemove(s) {
    var e, t;
    return s.scene.removeEventListener("sceneUpdate", this._sceneUpdate), (e = this.stylesheet) == null || e.remove(), this.stylesheet = void 0, (t = this.stylesheetLoader) == null || t.forEach((i) => i.remove()), this.stylesheetLoader = void 0, super.onRemove(s);
  }
};
kt.PluginType = "LoadingScreenPlugin";
kt.LS_DEFAULT_LOGO = "https://threepipe.org/logo.svg";
Li([
  er("Loader", ["Spinner 1"].map((s, e) => ({ value: e, label: s }))),
  V()
], kt.prototype, "loader", 2);
Li([
  pt("Loading text header"),
  Oe(kt.prototype.refresh),
  V()
], kt.prototype, "loadingTextHeader", 2);
Li([
  pt("Error text header"),
  V()
], kt.prototype, "errorTextHeader", 2);
Li([
  ue("Show file names"),
  Oe(kt.prototype.refresh),
  V()
], kt.prototype, "showFileNames", 2);
Li([
  ue("Show process states"),
  Oe(kt.prototype.refresh),
  V()
], kt.prototype, "showProcessStates", 2);
Li([
  ue("Show progress"),
  Oe(kt.prototype.refresh),
  V()
], kt.prototype, "showProgress", 2);
Li([
  ue("Hide on only errors"),
  V()
], kt.prototype, "hideOnOnlyErrors", 2);
Li([
  ue("Hide on files load"),
  V()
], kt.prototype, "hideOnFilesLoad", 2);
Li([
  ue("Hide on scene object load"),
  V()
], kt.prototype, "hideOnSceneObjectLoad", 2);
Li([
  ue("Minimize on scene object load"),
  V()
], kt.prototype, "minimizeOnSceneObjectLoad", 2);
Li([
  ue("Show when files start loading"),
  V()
], kt.prototype, "showOnFilesLoading", 2);
Li([
  ue("Show when scene empty"),
  V()
], kt.prototype, "showOnSceneEmpty", 2);
Li([
  pt("Hide delay (ms)"),
  V()
], kt.prototype, "hideDelay", 2);
Li([
  Ye("Background Opacity", [0, 1]),
  Oe(kt.prototype.refresh),
  V()
], kt.prototype, "backgroundOpacity", 2);
Li([
  Ye("Background Blur", [0, 100]),
  Oe(kt.prototype.refresh),
  V()
], kt.prototype, "backgroundBlur", 2);
Li([
  pt("Background Color"),
  Oe(kt.prototype.refresh),
  V()
], kt.prototype, "background", 2);
Li([
  pt("Text Color"),
  Oe(kt.prototype.refresh),
  V()
], kt.prototype, "textColor", 2);
Li([
  pt("Logo Image"),
  Oe(kt.prototype.refresh),
  V()
], kt.prototype, "logoImage", 2);
Li([
  Pt("Toggle preview")
], kt.prototype, "togglePreview", 1);
Li([
  Pt("Minimize")
], kt.prototype, "minimize", 1);
Li([
  Pt("Maximize")
], kt.prototype, "maximize", 1);
kt = Li([
  Lt("Loading Screen")
], kt);
var tN = Object.defineProperty, iN = Object.getOwnPropertyDescriptor, dn = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? iN(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && tN(e, t, n), n;
};
let wi = class extends Tt {
  constructor(s = !0) {
    super(), this.animationRunning = !1, this.animationDuration = 2e3, this.animationDistance = 80, this.animationPauseDuration = 6e3, this.rotationDistance = 0.3, this.yOffset = 0, this.autoStart = !0, this.autoStartDelay = 3e4, this.autoStop = !0, this.autoStartOnObjectLoad = !0, this.autoStartOnObjectLoadDelay = 3e3, this.currentTime = 0, this.lastActionTime = 1 / 0, this.pointerIcon = `<svg xmlns="http://www.w3.org/2000/svg" style="transform: translate(-50%, -25%);" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">
    <defs>
        <path id="A" d="M.001.232h24.997V36H.001z"></path>
    </defs>
    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">
        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z"></path>
        <g transform="translate(11 3)">
            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4"></path>
            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000"></path>
            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff"></path>
            <g transform="translate(0 .769)">
                <mask id="B" fill="#fff">
                    <use xlink:href="#A"></use>
                </mask>
                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)"></path>
            </g>
        </g>
    </g>
</svg>`, this._mainCameraUpdate = (e) => {
      this.isDisabled() || (e.change === "deserialize" && this.animationRunning ? (this.stopAnimation({ reset: !1 }), this.startAnimation()) : this.lastActionTime = zn());
    }, this._addSceneObject = () => {
      this.autoStartOnObjectLoad && (this.lastActionTime = zn() - this.autoStartDelay + this.autoStartOnObjectLoadDelay);
    }, this.onlyOnOrbitControls = !0, this._orbitWarning = !1, this.startAnimation = () => {
      var e;
      if (!(!this._viewer || !this.cursorEl || this.isDisabled())) {
        if (((e = this._viewer.scene.mainCamera.controls) == null ? void 0 : e.type) !== "OrbitControls" && this.onlyOnOrbitControls) {
          this._orbitWarning || console.warn("InteractionPromptPlugin requires OrbitControls, to run anyway, set onlyOnOrbitControls to false"), this._orbitWarning = !0;
          return;
        }
        this._viewer.scene.modelRoot.children.length !== 0 && (this.currentSphericalPosition = new sc().setFromVector3(new M().subVectors(
          this._viewer.scene.mainCamera.position,
          this._viewer.scene.mainCamera.target
        )), this.cursorEl.style.opacity = "1", this.currentTime = 0, this.animationRunning = !0, this._viewer.scene.mainCamera.setInteractions(!1, wi.PluginType));
      }
    }, this.stopAnimation = async ({ reset: e = !0 } = {}) => {
      if (!(!this._viewer || !this.cursorEl))
        return this.animationRunning = !1, this.cursorEl.style.opacity = "0", this.currentSphericalPosition && e && (this._viewer.scene.mainCamera.position.setFromSpherical(this.currentSphericalPosition).add(this._viewer.scene.mainCamera.target), this._viewer.scene.mainCamera.setDirty(), this.currentSphericalPosition = void 0), this._viewer.scene.mainCamera.setInteractions(!0, wi.PluginType), this._viewer.doOnce("postFrame");
    }, this._pointerDown = () => {
      this.isDisabled() || (this.autoStop && this.stopAnimation({ reset: !1 }), this.lastActionTime = zn());
    }, this._x = 0, this._preFrame = async (e) => {
      if (!this._viewer || !this.cursorEl || (this.isDisabled() && this.animationRunning && this.stopAnimation(), this.isDisabled()) || (!this.animationRunning && this.autoStart && this.lastActionTime + this.autoStartDelay < zn() && this.startAnimation(), !this.animationRunning)) return;
      if (this.currentTime <= this.animationDuration) {
        this.cursorEl.style.opacity = "1";
        const r = this.currentTime / this.animationDuration;
        this._x = Math.sin(Math.PI * 2 * r), (r < 0.25 || r > 0.75) && (this._x *= this._x * Math.sign(this._x));
      } else
        this.cursorEl.style.opacity = "0", this._x = 0;
      if (this.currentTime <= this.animationDuration + 50) {
        const r = this.currentSphericalPosition.clone();
        r.theta += this._x * this.rotationDistance, this._viewer.scene.mainCamera.position.setFromSpherical(r).add(this._viewer.scene.mainCamera.target), this._viewer.scene.mainCamera.setDirty();
      }
      const t = this._viewer.container.getBoundingClientRect(), i = t.width / 2 + -this._x * Math.min(this.animationDistance, t.width / 4), n = t.height / 2 + this.yOffset * t.height / 2;
      this.cursorEl.style.transform = `translate(${Math.floor(i)}px, ${Math.floor(n)}px)`, this.currentTime += e.deltaTime, this.currentTime > this.animationDuration + this.animationPauseDuration && (this.currentTime = 0);
    }, this.enabled = s;
  }
  onAdded(s) {
    super.onAdded(s);
    {
      Jn(s.plugins, "InteractionPointerPlugin") && delete s.plugins.InteractionPointerPlugin;
      const e = this;
      Object.defineProperty(s.plugins, "InteractionPointerPlugin", {
        get() {
          return console.warn("InteractionPromptPlugin: PluginType renamed from InteractionPointerPlugin to InteractionPromptPlugin. Please update your code/vjson."), e;
        },
        configurable: !0
        // required to be able to delete
      });
    }
    this.lastActionTime = 1 / 0, s.addEventListener("preFrame", this._preFrame), s.container.addEventListener("pointerdown", this._pointerDown, !0), s.container.addEventListener("wheel", this._pointerDown, !0), s.scene.addEventListener("addSceneObject", this._addSceneObject), s.scene.addEventListener("mainCameraUpdate", this._mainCameraUpdate), this._initializeCursor();
  }
  onRemove(s) {
    return this.stopAnimation(), s.removeEventListener("preFrame", this._preFrame), s.container.removeEventListener("pointerdown", this._pointerDown, !0), s.container.removeEventListener("wheel", this._pointerDown, !0), s.scene.removeEventListener("addSceneObject", this._addSceneObject), s.scene.removeEventListener("mainCameraUpdate", this._mainCameraUpdate), this.cursorEl && this.cursorEl.remove(), super.onRemove(s);
  }
  _pointerIconChanged() {
    this.cursorEl && (this.cursorEl.innerHTML = this.pointerIcon);
  }
  _initializeCursor() {
    this.cursorEl = document.createElement("div"), this.cursorEl.style.position = "absolute", this.cursorEl.style.top = "0", this.cursorEl.style.left = "0", this.cursorEl.style.width = "10px", this.cursorEl.style.height = "10px", this.cursorEl.style.opacity = "0", this._pointerIconChanged(), this._viewer.container.appendChild(this.cursorEl);
  }
};
wi.PluginType = "InteractionPromptPlugin";
dn([
  V(),
  ue()
], wi.prototype, "enabled", 2);
dn([
  V(),
  pt()
], wi.prototype, "animationDuration", 2);
dn([
  V(),
  pt()
], wi.prototype, "animationDistance", 2);
dn([
  V(),
  pt()
], wi.prototype, "animationPauseDuration", 2);
dn([
  V(),
  pt()
], wi.prototype, "rotationDistance", 2);
dn([
  V(),
  pt()
], wi.prototype, "yOffset", 2);
dn([
  V(),
  ue()
], wi.prototype, "autoStart", 2);
dn([
  V(),
  pt()
], wi.prototype, "autoStartDelay", 2);
dn([
  V(),
  ue()
], wi.prototype, "autoStop", 2);
dn([
  V(),
  ue()
], wi.prototype, "autoStartOnObjectLoad", 2);
dn([
  V(),
  ue()
], wi.prototype, "autoStartOnObjectLoadDelay", 2);
dn([
  Ic()
], wi.prototype, "currentTime", 2);
dn([
  Ic()
], wi.prototype, "lastActionTime", 2);
dn([
  Oe(wi.prototype._pointerIconChanged)
], wi.prototype, "pointerIcon", 2);
dn([
  V()
], wi.prototype, "onlyOnOrbitControls", 2);
dn([
  Pt()
], wi.prototype, "startAnimation", 2);
dn([
  Pt()
], wi.prototype, "stopAnimation", 2);
wi = dn([
  Lt("Interaction Prompt")
], wi);
const Ly = class Ly extends Tt {
  // disable serialization
  constructor(e = !0) {
    super(), this.enabled = !0, this.toJSON = void 0, this.fromJSON = void 0, this._lastFrameTime = 0, this._updaters = [], this.dependencies = [], this._fadeDisabled = !1, this.disableFrameFade = !0, this._postFrame = () => {
      var r, a;
      if (!this._viewer) return;
      if (this.isDisabled() || Object.keys(this.animations).length < 1) {
        this._lastFrameTime = 0, this._fadeDisabled && ((r = this._viewer.getPlugin("FrameFade")) == null || r.enable(this), this._fadeDisabled = !1);
        return;
      }
      const t = zn() / 1e3;
      this._lastFrameTime < 1 && (this._lastFrameTime = t - 1 / 60);
      let i = t - this._lastFrameTime;
      this._lastFrameTime = t;
      const n = (a = this._viewer.getPlugin("Progressive")) == null ? void 0 : a.postFrameConvergedRecordingDelta();
      if (n && n > 0 && (i = n), n !== 0 && (i *= 1e3, !(i <= 1e-3) && (this._updaters.forEach((o) => {
        let l = i;
        o.time + l < 0 && (l = -o.time), o.time += l, Math.abs(l) > 1e-3 && o.u(l);
      }), !this._fadeDisabled && this.disableFrameFade))) {
        const o = this._viewer.getPlugin("FrameFade");
        o && (o.disable(this), this._fadeDisabled = !0);
      }
    }, this.defaultDriver = (t) => ({
      start: () => this._updaters.push({ u: t, time: 0 }),
      stop: () => this._updaters.splice(this._updaters.findIndex((i) => i.u === t), 1)
    }), this.animations = {}, this.enabled = e, this._postFrame = this._postFrame.bind(this);
  }
  onAdded(e) {
    super.onAdded(e), e.addEventListener("postFrame", this._postFrame);
  }
  onRemove(e) {
    e.removeEventListener("postFrame", this._postFrame), super.onRemove(e);
  }
  animateTarget(e, t, i) {
    return this.animate({ ...i, target: e, key: t });
  }
  animate(e) {
    let t;
    const i = { ...e };
    if (i.target !== void 0) {
      if (i.key === void 0) throw new Error("key must be defined");
      i.key in i.target || (console.warn("key not present in target, creating", i.key, i.target), i.target[i.key] = i.from || 0);
      const a = HE(i.target, i.key), o = i.target[i.key];
      i.lastOnUpdate = i.onUpdate, i.onUpdate = (l) => {
        a(l), i.lastOnUpdate && i.lastOnUpdate(l);
      }, t = { target: i.target, key: i.key }, i.from === void 0 && (i.from = o), delete i.target, delete i.key;
    }
    const n = Ss(), r = {
      id: n,
      options: i,
      stop: () => {
        var a, o, l;
        (a = this.animations[n]) != null && a._stop ? (l = (o = this.animations[n]) == null ? void 0 : o._stop) == null || l.call(o) : console.warn("Animation not started");
      },
      promise: void 0,
      targetRef: t
    };
    return this.animations[n] = r, r.promise = new Promise((a, o) => {
      const l = () => {
        try {
          i.onEnd && i.onEnd();
        } catch (d) {
          return o(d), !1;
        }
        return !0;
      };
      if (i.from === void 0) {
        console.warn("from is undefined", i), a();
        return;
      }
      const c = typeof i.from == "boolean";
      c && (i.from = i.from ? 1 : 0, i.to = i.to ? 1 : 0);
      const h = {
        driver: this.defaultDriver,
        ...i,
        onUpdate: c ? void 0 : i.onUpdate,
        onComplete: async () => {
          var d;
          try {
            c && ((d = i.onUpdate) == null || d.call(i, i.to)), i.onComplete && await i.onComplete();
          } catch (p) {
            if (!l()) return;
            o(p);
            return;
          }
          l() && a();
        },
        onStop: async () => {
          try {
            i.onStop && await i.onStop();
          } catch (d) {
            if (!l()) return;
            o(d);
            return;
          }
          a();
        }
      }, u = QE(h);
      this.animations[n]._stop = u.stop, this.animations[n].options = h;
    }).then(() => (delete this.animations[n], n)), this.animations[n];
  }
  async animateAsync(e, t) {
    const i = this.animate(e);
    return t && t.push(i), i.promise;
  }
  async animateTargetAsync(e, t, i, n) {
    const r = this.animate({ ...i, target: e, key: t });
    return n && n.push(r), r.promise;
  }
  animateCamera(e, t, i = !0, n) {
    const r = i ? x2(e, t) : w2(e, t);
    return this.animate({
      ease: ey.linear,
      ...r,
      ...n,
      duration: (n.duration ?? 1e3) * (t.duration ?? 1)
    });
  }
  async animateCameraAsync(e, t, i = !0, n, r) {
    const a = this.animateCamera(e, t, i, n);
    return r && r.push(a), a.promise;
  }
};
Ly.PluginType = "PopmotionPlugin";
let fc = Ly;
var nN = Object.defineProperty, sN = Object.getOwnPropertyDescriptor, As = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? sN(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && nN(e, t, n), n;
}, Ma;
const Hn = (Ma = class extends Tt {
  // get dirty() { // todo: issue with recorder convergeMode?
  //     return this._animating
  // }
  constructor(e = {}) {
    super(), this.enabled = !0, this._cameraViews = [], this.viewLooping = !1, this.viewPauseTime = 200, this.animEase = "easeInOutSine", this.animDuration = 1e3, this.interpolateMode = "spherical", this.rotationOffset = 0.25, this._animating = !1, this.dependencies = [fc], this._viewSetView = ({ view: t, camera: i }) => {
      var n;
      if (!t) {
        (n = this._viewer) == null || n.console.warn("Invalid view", t);
        return;
      }
      this.setView(t, i);
    }, this._viewUpdateView = ({ view: t, camera: i }) => {
      var r;
      if (!t) {
        (r = this._viewer) == null || r.console.warn("Invalid view", t);
        return;
      }
      const n = t.name;
      this.getView(i, t.isWorldSpace ?? !0, t), t.name = n;
    }, this._viewDeleteView = ({ view: t }) => {
      var i;
      if (!t) {
        (i = this._viewer) == null || i.console.warn("Invalid view", t);
        return;
      }
      this.deleteView(t);
    }, this._viewAnimateView = async ({ view: t, camera: i, duration: n, easing: r, throwOnStop: a }) => {
      var o;
      if (!t) {
        (o = this._viewer) == null || o.console.warn("Invalid view", t);
        return;
      }
      return this.animateToView(t, n || this.animDuration, r || this.animEase, i, a);
    }, this.focusNext = (t = !0) => {
      if (this._animating || this._cameraViews.length < 2) return;
      let i = this._cameraViews.findIndex((n) => n === this._currentView);
      i < 0 && (i = -1), i = i + 1, t ? i = i % this._cameraViews.length : i = Math.min(i, this._cameraViews.length - 1), this.animateToView(i);
    }, this.focusPrevious = (t = !0) => {
      if (this._animating || this._cameraViews.length < 2 || !this._currentView) return;
      let i = this._cameraViews.findIndex((n) => n === this._currentView);
      i < 0 && (i = 0), i = i - 1, t ? i = (i + this._cameraViews.length) % this._cameraViews.length : i = Math.max(i, 0), this.animateToView(i);
    }, this._popAnimations = [], this.uiConfig = {
      type: "folder",
      label: "Camera Views",
      // expanded: true,
      children: [
        () => [...this._cameraViews.map((t) => t.uiConfig)],
        ...mr(this) || []
      ]
    }, this._viewQueue = [], this._animationLooping = !1, this._infiniteLooping = !0, this.addCurrentView = this.addCurrentView.bind(this), this.resetToFirstView = this.resetToFirstView.bind(this), this.animateAllViews = this.animateAllViews.bind(this), this.animDuration = e.duration ?? this.animDuration, this.animEase = e.ease ?? this.animEase, this.interpolateMode = e.interpolateMode ?? this.interpolateMode;
  }
  get cameraViews() {
    return this._cameraViews;
  }
  get camViews() {
    return this._cameraViews;
  }
  get animating() {
    return this._animating;
  }
  // private _updaters: {u: ((timestamp: number) => void), time: number}[] = []
  // private _lastFrameTime = 0 // for post frame
  onAdded(e) {
    super.onAdded(e), e.addEventListener("preFrame", (t) => {
    });
  }
  onRemove(e) {
    return super.onRemove(e);
  }
  async resetToFirstView(e = 100) {
    this.isDisabled() || (this._currentView = void 0, await this.animateToView(0, e), await bs(2));
  }
  async addCurrentView() {
    var i;
    if (this.isDisabled()) return;
    const e = (i = this._viewer) == null ? void 0 : i.scene.mainCamera;
    if (!e) return;
    const t = this.getView(e);
    return this.addView(t), t.name = "View " + this._cameraViews.length, t;
  }
  addView(e) {
    var t, i;
    this._cameraViews.includes(e) || this._cameraViews.push(e), e.addEventListener("setView", this._viewSetView), e.addEventListener("updateView", this._viewUpdateView), e.addEventListener("deleteView", this._viewDeleteView), e.addEventListener("animateView", this._viewAnimateView), (i = (t = this.uiConfig).uiRefresh) == null || i.call(t), this.dispatchEvent({ type: "viewAdd", view: e });
  }
  deleteView(e) {
    var i, n;
    const t = this._cameraViews.indexOf(e);
    t >= 0 && this._cameraViews.splice(t, 1), e.removeEventListener("setView", this._viewSetView), e.removeEventListener("updateView", this._viewUpdateView), e.removeEventListener("deleteView", this._viewDeleteView), e.removeEventListener("animateView", this._viewAnimateView), (n = (i = this.uiConfig).uiRefresh) == null || n.call(i), this.dispatchEvent({ type: "viewDelete", view: e });
  }
  getView(e, t = !0, i) {
    var n;
    return e = e || ((n = this._viewer) == null ? void 0 : n.scene.mainCamera), e ? e.getView(t, i) : i ?? new hn();
  }
  setView(e, t) {
    var i;
    t = t || ((i = this._viewer) == null ? void 0 : i.scene.mainCamera), t && t.setView(e);
  }
  async animateToView(e, t, i, n, r = !1) {
    var h, u, d, p, f, y, A;
    if (n = n || ((h = this._viewer) == null ? void 0 : h.scene.mainCamera), !n) return;
    if (this._animating) {
      this._popAnimations.forEach((v) => (v == null ? void 0 : v.stop) && v.stop()), this._popAnimations = [];
      let m = 0;
      for (; this._animating && (await bs(100), !(m++ > 20)); )
        ;
      if (this._animating) {
        console.warn("Unable to stop all animations, maybe because of viewLooping?");
        return;
      }
    }
    const a = typeof e == "number" ? this._cameraViews[e] : typeof e == "string" ? this._cameraViews.find((m) => m.name === e) : e;
    if (!a) {
      (u = this._viewer) == null || u.console.warn("Invalid view", e);
      return;
    }
    const o = (d = this._viewer) == null ? void 0 : d.getPlugin(wi);
    o && o.animationRunning && await o.stopAnimation({ reset: !0 }), this._currentView = a, this._animating = !0, (p = this._viewer) == null || p.scene.mainCamera.setInteractions(!1, Ma.PluginType), this.dispatchEvent({ type: "startViewChange", view: a });
    const l = (f = this._viewer) == null ? void 0 : f.getPlugin(fc);
    if (!l) throw new Error("PopmotionPlugin not found");
    t === void 0 && (t = this.animDuration);
    const c = typeof i == "function" ? i : ey[i || this.animEase];
    this._popAnimations = [], await l.animateCameraAsync(n, a, this.interpolateMode === "spherical", { ease: c, duration: t }, this._popAnimations).catch((m) => {
      if (r) throw m;
    }), (y = this._viewer) == null || y.scene.mainCamera.setInteractions(!0, Ma.PluginType), this._animating = !1, (A = this._viewer) == null || A.setDirty(), this.dispatchEvent({ type: "viewChange", view: a }), await bs(10);
  }
  async animateAllViews() {
    if (!this.isDisabled() && !(this.viewLooping || this._cameraViews.length < 2)) {
      for (; this._viewQueue.length > 0; ) this._viewQueue.pop();
      this._viewQueue.push(...this._cameraViews), this._viewQueue.push(this._viewQueue.shift()), this._infiniteLooping = !1, await this._animationLoop(), this._infiniteLooping = !0;
    }
  }
  async stopAllAnimations() {
    for (this.viewLooping = !1, this._popAnimations.forEach((e) => {
      var t;
      return (t = e == null ? void 0 : e.stop) == null ? void 0 : t.call(e);
    }), this._popAnimations = []; this._animating || this._animationLooping; )
      await bs(100);
  }
  fromJSON(e, t) {
    var i, n;
    return this._cameraViews.forEach((r) => this.deleteView(r)), super.fromJSON(e, t) ? (this._cameraViews.forEach((r) => this.addView(r)), (n = (i = this.uiConfig).uiRefresh) == null || n.call(i), this) : null;
  }
  async animateToObject(e, t = 4, i, n, r = { min: 0.5, max: 5 }) {
    if (!this._viewer) return;
    const a = new Nn().expandByObject(e || this._viewer.scene.modelRoot, !1, !0), o = a.getCenter(new M()), c = a.getSize(new M()).length() / 2;
    await this.animateToTarget(Math.min(r.max, Math.max(r.min, c * t)), o, i, n);
  }
  async animateToFitObject(e, t = 1.5, i = 1e3, n, r = { min: 0.5, max: 50 }) {
    if (!this._viewer) return;
    const a = new Nn().expandByObject(e || this._viewer.scene.modelRoot, !1, !0), o = nb(this._viewer.scene.mainCamera, a), l = a.getCenter(new M());
    await this.animateToTarget(Math.min(r.max, Math.max(r.min, o * t)), l, i, n);
  }
  /**
   *
   * @param distanceFromTarget - in world units
   * @param center - target (center) of the view in world coordinates
   * @param duration - in milliseconds
   * @param ease
   */
  async animateToTarget(e, t, i, n) {
    const r = this.getView();
    r.target.copy(t);
    const a = new M().subVectors(r.target, r.position).normalize();
    r.position.copy(a.multiplyScalar(-e).add(r.target)), await this.animateToView(r, i, n);
  }
  get animationLooping() {
    return this._animationLooping;
  }
  async _animationLoop() {
    if (!this._animationLooping) {
      for (this._animationLooping = !0; (this.viewLooping || !this._infiniteLooping) && !(this.isDisabled() || this._cameraViews.length < 1); ) {
        if (this._viewQueue.length === 0)
          if (this._infiniteLooping) this._viewQueue.push(...this._cameraViews);
          else break;
        await this.animateToView(this._viewQueue.shift()), await bs(2 + this.viewPauseTime);
      }
      this._animationLooping = !1;
    }
  }
  // region deprecated
  /**
   * @deprecated - renamed to {@link getView} or {@link ICamera.getView}
   * @param camera
   * @param worldSpace
   */
  getCurrentCameraView(e, t = !0) {
    return this.getView(e, t);
  }
  /**
   * @deprecated - renamed to {@link setView} or {@link ICamera.setView}
   * @param view
   */
  setCurrentCameraView(e) {
    return this.setView(e);
  }
  /**
   * @deprecated - use {@link animateToView} instead
   * @param view
   */
  async focusView(e) {
    return this.animateToView(e);
  }
  // endregion
  // region to be ported to other plugins
  // /**
  //  * For slight rotation of camera when seekOnScroll is enabled
  //  */
  // private _pointerMove(ev: PointerEvent) {
  //     if (this.isDisabled()) return
  //     if (!this._animating && this.seekOnScroll) {
  //         const cam = this._viewer?.scene.mainCamera
  //         if (!cam) return
  //         const s = new Spherical()
  //         const p = cam.position
  //         const t = cam.target
  //         const q = new Quaternion().setFromUnitVectors(cam.cameraObject.up, new Vector3(0, 1, 0))
  //         const qi = q.clone().invert()
  //         const offset = p.clone().sub(t)
  //         offset.applyQuaternion(q)
  //         s.setFromVector3(offset)
  //         s.theta += this.rotationOffset * ev.movementX / this._viewer!.canvas!.clientWidth
  //         s.phi += this.rotationOffset * ev.movementY / this._viewer!.canvas!.clientHeight
  //         s.makeSafe()
  //         offset.setFromSpherical(s)
  //         offset.applyQuaternion(qi)
  //         p.copy(t).add(offset)
  //         cam.setDirty()
  //     }
  // }
  // // @uiToggle() @serialize()
  // animateOnScroll = false // buggy
  //
  // @uiToggle() @serialize()
  // seekOnScroll = false
  // private _scrollAnimationState = 0
  // scrollAnimationDamping = 0.1
  // private _wheel(ev: any | WheelEvent) {
  //     if (this.isDisabled()) return
  //     if (this.seekOnScroll && !this._animating) {
  //         // if (ev.deltaY > 0) this.focusNext(false)
  //         // else this.focusPrevious(false)
  //     } else if (Math.abs(ev.deltaY) > 0.001) {
  //         this._scrollAnimationState = -1. * Math.sign(ev.deltaY)
  //     }
  // }
  // private _driver: Driver = (update)=>{
  //     return {
  //         start: ()=>this._updaters.push({u:update, time:0}),
  //         stop: ()=> this._updaters.splice(this._updaters.findIndex(u=>u.u === update), 1),
  //     }
  // }
  // private _fadeDisabled = false
  // todo: same code used in PopmotionPlugin, merge somehow
  // private _postFrame() {
  //     if (!this._viewer) return
  //     if (this.isDisabled() || !this._animating) {
  //         this._lastFrameTime = 0
  //         if (this._fadeDisabled) {
  //             this._viewer.getPluginByType<FrameFadePlugin>('FrameFade')?.enable(CameraViewPlugin.PluginType)
  //             this._fadeDisabled = false
  //         }
  //         // console.log('not anim')
  //         return
  //     }
  //     const time = now() / 1000.0
  //     if (this._lastFrameTime < 1) this._lastFrameTime = time - 1.0 / 60.0
  //     let delta = time - this._lastFrameTime
  //     this._lastFrameTime = time
  //     delta = delta * (this.animateOnScroll ? this._scrollAnimationState : 1)
  //
  //     const d = this._viewer.getPluginByType<ProgressivePlugin>('Progressive')?.postFrameConvergedRecordingDelta()
  //     if (d && d > 0) delta = d
  //     if (d === 0) return // not converged yet.
  //     // if d < 0: not recording, do nothing
  //
  //     delta *= 1000
  //
  //     // delta = 16.666
  //
  //     // console.log(delta)
  //     // console.log(dt)
  //     //
  //
  //     if (delta <= 0) return
  //
  //     this._updaters.forEach(u=>{
  //         let dt = delta
  //         if (u.time + dt < 0) dt = -u.time
  //         u.time += dt
  //         if (Math.abs(dt) > 0.001)
  //             u.u(dt)
  //     })
  //     if (this._scrollAnimationState < 0.001) this._scrollAnimationState = 0
  //     else this._scrollAnimationState *= 1.0 - this.scrollAnimationDamping
  //
  //     if (!this._fadeDisabled) {
  //         const ff = this._viewer.getPluginByType<FrameFadePlugin>('FrameFade')
  //         if (ff) {
  //             ff.disable(CameraViewPlugin.PluginType)
  //             this._fadeDisabled = true
  //         }
  //     }
  // }
  // @uiButton('Record All Views')
  // public async recordAllViews(onStart?: ()=>void, downloadOnEnd = true) {
  //     if (this.isDisabled()) return
  //     const recorder = this._viewer?.getPluginByType<CanvasRecorderPlugin>('CanvasRecorder')
  //     if (!recorder || !recorder.enabled) return
  //     if (this._cameraViews.length < 1) return
  //     if (recorder.isRecording()) {
  //         console.error('CanvasRecorderPlugin is already recording')
  //         return
  //     }
  //     let looping = false
  //     if (this.viewLooping) {
  //         looping = true
  //         this.viewLooping = false
  //     }
  // await this.resetToFirstView()
  //     return new Promise<Blob|undefined>((resolve, reject) => {
  //         const listener2 = ()=>{
  //             recorder.removeEventListener('start', listenerStart)
  //             recorder.removeEventListener('stop', listener2)
  //             recorder.removeEventListener('error', listenerError)
  //         }
  //         const listenerStart = async() => {
  //             listener2()
  //             onStart?.()
  //             await this.animateAllViews()
  //             const blob = await recorder.stopRecording()
  //             if (looping) this.viewLooping = true
  //             if (downloadOnEnd) {
  //                 const name = await this._viewer?.prompt('Canvas Recorder: Save file as', 'recording.mp4')
  //                 if (name !== null && blob) await this._downloadBlob(blob, name || 'recording.mp4')
  //             }
  //             resolve(blob)
  //         }
  //         const listenerError = async() => {
  //             listener2()
  //             reject()
  //         }
  //         recorder.addEventListener('start', listenerStart)
  //         recorder.addEventListener('stop', listener2)
  //         recorder.addEventListener('error', listenerError)
  //         if (!recorder.startRecording()) {
  //             console.error('cannot start recording')
  //             return
  //         }
  //     })
  // }
  // private async _downloadBlob(blob: Blob, name: string) {
  //     const tr = this._viewer?.getPluginByType<FileTransferPlugin>('FileTransferPlugin')
  //     if (!tr) {
  //         this._viewer?.console.error('FileTransferPlugin required to export/download file')
  //         return
  //     }
  //     await tr.exportFile(blob, name)
  // }
  // endregion
}, Ma.PluginType = "CameraViews", Ma);
As([
  V("cameraViews")
], Hn.prototype, "_cameraViews", 2);
As([
  Oe(Hn.prototype._animationLoop),
  V(),
  ue("Loop All Views")
], Hn.prototype, "viewLooping", 2);
As([
  V(),
  pt("View Pause Time")
], Hn.prototype, "viewPauseTime", 2);
As([
  V(),
  er("Ease", Object.keys(ey).map((s) => ({ label: s })))
], Hn.prototype, "animEase", 2);
As([
  V(),
  Ye("Duration", [10, 1e4], 10)
], Hn.prototype, "animDuration", 2);
As([
  V(),
  er("Interpolation", [
    "spherical",
    "linear"
    /* , 'spline (dev)'*/
  ].map((s) => ({ label: s, value: s.split(" ")[0] })))
], Hn.prototype, "interpolateMode", 2);
As([
  V()
], Hn.prototype, "rotationOffset", 2);
As([
  Pt("Reset To First View", { sendArgs: !1 })
], Hn.prototype, "resetToFirstView", 1);
As([
  Pt("Add Current View")
], Hn.prototype, "addCurrentView", 1);
As([
  Pt("Focus Next", { sendArgs: !1 })
], Hn.prototype, "focusNext", 2);
As([
  Pt("Focus Previous", { sendArgs: !1 })
], Hn.prototype, "focusPrevious", 2);
As([
  Pt("Animate All Views")
], Hn.prototype, "animateAllViews", 1);
As([
  Pt("Stop All Animations")
], Hn.prototype, "stopAllAnimations", 1);
let rN = Hn;
var aN = Object.defineProperty, _y = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && aN(e, t, n), n;
}, Ta;
const mc = (Ta = class extends Tt {
  constructor(e = AL, t = !0, i = !1) {
    super(), this.enabled = !0, this.dependencies = [rN], this.autoFocusHover = !1, this.widgetEnabled = !0, this._mainCameraChange = () => {
      !this._picker || !this._viewer || (this._picker.camera = this._viewer.scene.mainCamera);
    }, this._sceneUpdated = !1, this._onSceneUpdate = (n) => {
      n.hierarchyChanged && (this._sceneUpdated = !0);
    }, this._viewerListeners = {
      preFrame: () => {
        !this._viewer || !this._picker || this._sceneUpdated && (this._checkSelectedInScene(), this._sceneUpdated = !1);
      }
    }, this._onObjectSelectEvent = (n) => {
      n.source !== Ta.PluginType && (n.object === void 0 && n.value === void 0 ? console.error("e.object or e.value must be set for picking, can be null to unselect") : this.setSelectedObject(n.object || n.value, this.autoFocus || n.focusCamera, !0));
    }, this._selectedObjectChanged = (n) => {
      var l, c;
      if (!this._viewer) return;
      this.dispatchEvent(n);
      const r = ((l = this._picker) == null ? void 0 : l.selectedObject) || void 0, a = this._viewer.getPlugin(Do);
      if (a && (r ? a.disable(this) : a.enable(this)), this._viewer.scene.autoNearFarEnabled = !r, this._pickUi) {
        const h = this.uiConfig;
        if (h.children = [...this._uiConfigChildren], r) {
          h.children.push(
            {
              type: "button",
              label: "Focus",
              value: () => {
                r.assetType && r.parentRoot ? r.dispatchEvent({ type: "select", ui: !0, object: r, bubbleToParent: !0, focusCamera: !0 }) : this.setSelectedObject(r, !0);
              }
            },
            {
              type: "button",
              label: "Select Parent",
              hidden: () => !r.parent,
              value: () => {
                const d = r.parent;
                d && (d.assetType && d.parentRoot ? d.dispatchEvent({ type: "select", ui: !0, bubbleToParent: !0, object: d }) : this.setSelectedObject(d, !1));
              }
            }
          );
          let u = r.uiConfig;
          if (u) h.children.push(u);
          else {
            const d = r.materials ?? [r.material];
            for (const p of d)
              u = p == null ? void 0 : p.uiConfig, u && h.children.push(u);
          }
        }
        (c = h.uiRefresh) == null || c.call(h);
      }
      const o = this._widget;
      o && this.widgetEnabled && (r ? o.attach(r) : o.detach()), this._viewer.setDirty(), this.autoFocus && this.focusObject(r);
    }, this._hoverObjectChanged = (n) => {
      var o, l;
      this.dispatchEvent(n);
      const r = ((o = this._picker) == null ? void 0 : o.hoverObject) || void 0, a = this._hoverWidget;
      a && this.widgetEnabled && (r ? a.attach(r) : a.detach()), (l = this._viewer) == null || l.setDirty(), this.autoFocusHover && this.focusObject(r);
    }, this._onObjectHit = (n) => {
      if (this._viewer) {
        if (this.isDisabled()) {
          n.intersects.selectedObject = null;
          return;
        }
        this.dispatchEvent(n);
      }
    }, this._uiConfigChildren = [
      {
        label: "Enabled",
        type: "checkbox",
        property: [this, "enabled"]
      },
      {
        label: "Hover Enabled",
        type: "checkbox",
        property: [this, "hoverEnabled"],
        onChange: () => {
          var n, r;
          return (r = (n = this.uiConfig).uiRefresh) == null ? void 0 : r.call(n, !0);
        }
        // for autoFocusHover
      },
      {
        label: "Auto Focus",
        type: "checkbox",
        property: [this, "autoFocus"],
        onChange: () => {
          const n = this.getSelectedObject();
          this.autoFocus && n && this.setSelectedObject(n, !0);
        }
      },
      {
        label: "Auto Focus on Hover",
        type: "checkbox",
        hidden: () => !this.hoverEnabled,
        property: [this, "autoFocusHover"]
      },
      {
        label: "Widget Enabled",
        type: "checkbox",
        property: [this, "widgetEnabled"]
      }
    ], this.uiConfig = {
      type: "panel",
      label: "Picker",
      expanded: !0,
      children: [
        ...this._uiConfigChildren
      ]
    }, e && (this._widget = new e(), this._hoverWidget = new e(), this._hoverWidget.lineMaterial && (this._hoverWidget.lineMaterial.linewidth /= 2, this._hoverWidget.lineMaterial.color.set("#aa2222"))), this._pickUi = t, this.autoFocus = i, this.dispatchEvent = this.dispatchEvent.bind(this);
  }
  get picker() {
    return this._picker;
  }
  get hoverEnabled() {
    var e;
    return ((e = this._picker) == null ? void 0 : e.hoverEnabled) ?? !1;
  }
  set hoverEnabled(e) {
    var t, i;
    this._picker && (this._picker.hoverEnabled = e, this.uiConfig && ((i = (t = this.uiConfig).uiRefresh) == null || i.call(t)));
  }
  _widgetEnabledChange() {
    var e, t, i, n, r;
    this.widgetEnabled && ((e = this._picker) != null && e.selectedObject) ? (t = this._widget) == null || t.attach(this._picker.selectedObject) : (i = this._widget) == null || i.detach(), (r = (n = this.uiConfig) == null ? void 0 : n.uiRefresh) == null || r.call(n, !0);
  }
  setDirty() {
    this._viewer && (this.isDisabled() && this.setSelectedObject(void 0), this._viewer.setDirty());
  }
  getSelectedObject() {
    var e;
    if (!this.isDisabled())
      return ((e = this._picker) == null ? void 0 : e.selectedObject) || void 0;
  }
  setSelectedObject(e, t = !1, i = !0) {
    const n = this.isDisabled();
    if (n && !e || !this._picker) return;
    const r = this.autoFocus;
    this.autoFocus = !1, this._picker.setSelected(e || null, i), this.autoFocus = r, !n && e && (r || t) && this.focusObject(e);
  }
  onAdded(e) {
    super.onAdded(e), this.setDirty(), this._picker = new pg(e.scene.modelRoot, e.canvas, e.scene.mainCamera, (t) => {
      if (!t.material) return !1;
      let n = t, r = !1;
      for (; n; ) {
        if (!n.visible || ((n.assetType === "model" || n.assetType === "light") && (r = !0), n.assetType === "widget") || n.userData.userSelectable === !1 || n.userData.bboxVisible === !1) return !1;
        n = n.parent;
      }
      return r;
    }), this._widget && e.scene.addObject(this._widget, { addToRoot: !0 }), this._hoverWidget && e.scene.addObject(this._hoverWidget, { addToRoot: !0 }), this._picker.addEventListener("selectedObjectChanged", this._selectedObjectChanged), this._picker.addEventListener("hoverObjectChanged", this._hoverObjectChanged), this._picker.addEventListener("hitObject", this._onObjectHit), e.scene.addEventListener("select", this._onObjectSelectEvent), e.scene.addEventListener("sceneUpdate", this._onSceneUpdate), e.scene.addEventListener("mainCameraChange", this._mainCameraChange), e.forPlugin("UndoManagerPlugin", (t) => {
      this._picker && (this._picker.undoManager = t.undoManager);
    }, () => {
      this._picker && (this._picker.undoManager = void 0);
    });
  }
  onRemove(e) {
    var t, i;
    e.scene.removeEventListener("select", this._onObjectSelectEvent), e.scene.removeEventListener("sceneUpdate", this._onSceneUpdate), e.scene.removeEventListener("mainCameraChange", this._mainCameraChange), (t = this._widget) == null || t.removeFromParent(), (i = this._hoverWidget) == null || i.removeFromParent(), this._picker && (this._picker.removeEventListener("selectedObjectChanged", this._selectedObjectChanged), this._picker.removeEventListener("hoverObjectChanged", this._hoverObjectChanged), this._picker.removeEventListener("hitObject", this._onObjectHit), this._picker.dispose(), this._picker.undoManager = void 0, this._picker = void 0), super.onRemove(e);
  }
  dispose() {
    var e, t;
    super.dispose(), (e = this._widget) == null || e.dispose(), (t = this._hoverWidget) == null || t.dispose();
  }
  _checkSelectedInScene() {
    if (this.isDisabled()) return;
    const e = this.getSelectedObject();
    let t = !1;
    e == null || e.traverseAncestors((i) => {
      var n;
      i === ((n = this._viewer) == null ? void 0 : n.scene) && (t = !0);
    }), t || this.setSelectedObject(void 0, !1, !1);
  }
  async focusObject(e) {
    var t;
    (t = this._viewer) == null || t.fitToView(e, 1.25, 1e3, "easeOut");
  }
  get widget() {
    return this._widget;
  }
}, Ta.PluginType = "Picking", Ta.OldPluginType = "PickingPlugin", Ta);
_y([
  V(),
  Oe(mc.prototype.setDirty)
], mc.prototype, "enabled");
_y([
  V()
], mc.prototype, "autoFocus");
_y([
  Oe(mc.prototype._widgetEnabledChange)
], mc.prototype, "widgetEnabled");
let Dh = mc;
var oN = Object.defineProperty, lN = Object.getOwnPropertyDescriptor, hf = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? lN(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && oN(e, t, n), n;
};
let Fa = class extends Tt {
  constructor(s = !0) {
    super(), this.enabled = !0, this._pickingWidgetDisabled = !1, this.toJSON = void 0, this.dependencies = [Dh], this._isInteracting = !1, this._viewerListeners = {
      postFrame: () => {
        !this.transformControls || this._viewer;
      }
    }, this._transformState = {
      obj: null,
      position: new M(),
      rotation: new xi(),
      scale: new M()
    }, this._mainCameraChange = () => {
      !this.transformControls || !this._viewer || (this.transformControls.camera = this._viewer.scene.mainCamera);
    }, Eo.ObjectConstructors.MeshBasicMaterial = Pa, Eo.ObjectConstructors.LineBasicMaterial = pr, this.enabled = s;
  }
  setDirty() {
    if (!this._viewer) return;
    const s = this._viewer.getPlugin(Dh), e = !this.isDisabled();
    e && s.widgetEnabled ? (s.widgetEnabled = !1, this._pickingWidgetDisabled = !0) : !e && this._pickingWidgetDisabled && (s.widgetEnabled = !0, this._pickingWidgetDisabled = !1), this.transformControls && (e && s.getSelectedObject() ? this.transformControls.attach(s.getSelectedObject()) : this.transformControls.detach()), this._viewer.setDirty();
  }
  onAdded(s) {
    super.onAdded(s), this.setDirty(), this.transformControls = new Yr(s.scene.mainCamera, s.canvas), this._mainCameraChange = this._mainCameraChange.bind(this), s.scene.addEventListener("mainCameraChange", this._mainCameraChange), this.transformControls.addEventListener("dragging-changed", (t) => {
      if (!(this != null && this._viewer)) return;
      const i = this._viewer.scene.mainCamera.controls;
      typeof (i == null ? void 0 : i.stopDamping) == "function" && (i != null && i.enabled) && i.stopDamping(), this._viewer.scene.mainCamera.setInteractions(!t.value, Fa.PluginType);
    }), this.transformControls.addEventListener("axis-changed", (t) => {
      if (!(this != null && this._viewer)) return;
      this._isInteracting = !!t.value;
      const i = this._viewer.scene.mainCamera.controls;
      typeof (i == null ? void 0 : i.stopDamping) == "function" && (i != null && i.enabled) && i.stopDamping(), this._viewer.setDirty();
    }), s.scene.addObject(this.transformControls, { addToRoot: !0 }), s.getPlugin(Dh).addEventListener("selectedObjectChanged", (t) => {
      if (this.transformControls) {
        if (this.isDisabled()) {
          this.transformControls.object && this.transformControls.detach();
          return;
        }
        t.object ? this.transformControls.attach(t.object) : this.transformControls.detach();
      }
    }), s.forPlugin("UndoManagerPlugin", (t) => {
      this.undoManager = t.undoManager;
    }, () => this.undoManager = void 0), this.transformControls.addEventListener("mouseDown", () => {
      if (!this.transformControls) return;
      const t = this.transformControls.object;
      t && (this._transformState.obj = t, this._transformState.position = t.position.clone(), this._transformState.rotation = t.rotation.clone(), this._transformState.scale = t.scale.clone());
    }), this.transformControls.addEventListener("mouseUp", () => {
      if (!this.transformControls) return;
      const t = this.transformControls.object;
      if (!t || this._transformState.obj !== t || !this.undoManager) return;
      const i = {
        translate: "position",
        rotate: "rotation",
        scale: "scale"
      }[this.transformControls.getMode()];
      if (!i || this._transformState[i].equals(t[i])) return;
      const n = {
        last: this._transformState[i].clone(),
        current: t[i].clone(),
        set: (r) => {
          var a, o;
          t[i].copy(r), t.updateMatrixWorld(!0), (a = this.transformControls) == null || a.dispatchEvent({ type: "change" }), (o = this.transformControls) == null || o.dispatchEvent({ type: "objectChange" });
        },
        undo: () => n.set(n.last),
        redo: () => n.set(n.current)
      };
      this.undoManager.record(n);
    });
  }
  onRemove(s) {
    s.scene.removeEventListener("mainCameraChange", this._mainCameraChange), this.transformControls && (this.transformControls.detach(), s.scene.remove(this.transformControls), this.transformControls.dispose()), this.transformControls = void 0, super.onRemove(s);
  }
  centerAllMeshes() {
    var s;
    return (s = this._viewer) == null ? void 0 : s.scene.centerAllGeometries(!0);
  }
};
Fa.PluginType = "TransformControlsPlugin";
hf([
  ue(),
  Oe(Fa.prototype.setDirty)
], Fa.prototype, "enabled", 2);
hf([
  Ki(void 0, { expanded: !0 })
], Fa.prototype, "transformControls", 2);
hf([
  Pt("Center All Meshes")
], Fa.prototype, "centerAllMeshes", 1);
Fa = hf([
  Tn("Transform Controls")
], Fa);
var cN = Object.defineProperty, hN = Object.getOwnPropertyDescriptor, oS = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? hN(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && cN(e, t, n), n;
};
let gc = class extends Tt {
  constructor(s = "top-left", e = 128) {
    super(), this.placement = s, this.size = e, this.enabled = !0, this._needsRender = !1, this._viewerListeners = {
      postRender: (t) => {
        !this._viewer || !this.widget || this.isDisabled() || (this._needsRender = !0);
      },
      postFrame: (t) => {
        !this._viewer || !this.widget || this.isDisabled() || !this._needsRender || (this.widget.update(), this.widget.render(), this.widget.animating && this._viewer.scene.mainCamera.setDirty(), this._needsRender = !1);
      }
    };
  }
  setDirty() {
    !this._viewer || !this.widget || (this.widget.domContainer.style.display = this.isDisabled() ? "none" : "block");
  }
  onAdded(s) {
    super.onAdded(s), this.widget = new fE(s.scene.mainCamera, s.canvas, this.placement, this.size), this.widget.target = s.scene.mainCamera.target, this.widget.addEventListener("animating-changed", (e) => {
      const t = e.detail.value;
      s.scene.mainCamera.setInteractions(!t, gc.PluginType);
    }), this.widget.addEventListener("update", () => this._needsRender = !0), s.scene.addEventListener("mainCameraChange", this._mainCameraChange), s.scene.addEventListener("mainCameraUpdate", this._mainCameraUpdate);
  }
  onRemove(s) {
    var e;
    (e = this.widget) == null || e.dispose(), this.widget = void 0, s.scene.removeEventListener("mainCameraChange", this._mainCameraChange), s.scene.removeEventListener("mainCameraUpdate", this._mainCameraUpdate), super.onRemove(s);
  }
  _mainCameraChange() {
    !this._viewer || !this.widget || (this.widget.camera = this._viewer.scene.mainCamera);
  }
  _mainCameraUpdate() {
    !this._viewer || !this.widget || (this.widget.target = this._viewer.scene.mainCamera.target);
  }
  setOrientation(s) {
    this.widget && this.widget.setOrientation(s);
  }
};
gc.PluginType = "EditorViewWidgetPlugin";
oS([
  ue(),
  Oe(gc.prototype.setDirty)
], gc.prototype, "enabled", 2);
gc = oS([
  Lt("Editor View Widget")
], gc);
const Uy = class Uy extends Ay {
  constructor() {
    super(...arguments), this.controlsKey = "deviceOrientation", this._controlsCtor = (e, t) => new bo(e);
  }
};
Uy.PluginType = "DeviceOrientationControlsPlugin";
let wx = Uy;
const Fy = class Fy extends Ay {
  constructor() {
    super(...arguments), this.controlsKey = "pointerLock", this._controlsCtor = (e, t) => new Ba(e, t != null && t.ownerDocument ? t : (t || document).documentElement);
  }
};
Fy.PluginType = "PointerLockControlsPlugin";
let Ex = Fy;
const Oy = class Oy extends Ay {
  constructor() {
    super(...arguments), this.controlsKey = "threeFirstPerson", this._controlsCtor = (e, t) => new cn(e, t || document.documentElement);
  }
};
Oy.PluginType = "ThreeFirstPersonControlsPlugin";
let bx = Oy;
var uN = Object.defineProperty, lS = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && uN(e, t, n), n;
}, Wl;
const Kh = (Wl = class extends Tt {
  constructor(e = !0, t = 1e3) {
    super(), this.enabled = !0, this.limit = 1e3, this.toJSON = void 0, this.enabled = e, this.limit = t;
  }
  _refresh() {
    var e;
    this.undoManager && (this.undoManager.enabled = this.enabled, this.undoManager.limit = this.limit, this.undoManager.options.debug = ((e = this._viewer) == null ? void 0 : e.debug) || this.undoManager.options.debug);
  }
  onAdded(e) {
    super.onAdded(e), this.undoManager = new NR({ bindHotKeys: !0, limit: this.limit, debug: e.debug || HA("debugUndo") !== null, hotKeyRoot: document });
  }
  onRemove(e) {
    var t;
    (t = this.undoManager) == null || t.dispose(), this.undoManager = void 0, super.onRemove(e);
  }
}, Wl.PluginType = "UndoManagerPlugin", Wl);
lS([
  Oe(Kh.prototype._refresh)
], Kh.prototype, "enabled");
lS([
  Oe(Kh.prototype._refresh)
], Kh.prototype, "limit");
let h5 = Kh;
var dN = Object.defineProperty, pN = Object.getOwnPropertyDescriptor, Xo = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? pN(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && dN(e, t, n), n;
};
let Vn = class extends Gc {
  constructor() {
    super(...arguments), this._importer = new $i(lr, ["3dm"], ["model/vnd.3dm", "model/3dm"], !0), this.importMaterials = !0, this.forceLayerMaterials = !1, this.replaceWithInstancedMesh = !1, this.hideLineMesh = !1, this.hidePointMesh = !0, this.loadUserDataStrings = !0;
  }
  _refresh() {
    lr.ImportMaterials = this.importMaterials, lr.ForceLayerMaterials = this.forceLayerMaterials, lr.ReplaceWithInstancedMesh = this.replaceWithInstancedMesh, lr.HideLineMesh = this.hideLineMesh, lr.HidePointMesh = this.hidePointMesh, lr.LoadUserDataStrings = this.loadUserDataStrings, lr.LoadUserDataWarnings = !1;
  }
  onAdded(s) {
    if (!window.WebAssembly) throw new Error("Rhino3dmLoadPlugin requires WebAssembly support");
    super.onAdded(s), this._refresh();
  }
};
Vn.PluginType = "Rhino3dmLoadPlugin";
Xo([
  Oe(Vn.prototype._refresh),
  ue()
], Vn.prototype, "importMaterials", 2);
Xo([
  Oe(Vn.prototype._refresh),
  ue()
], Vn.prototype, "forceLayerMaterials", 2);
Xo([
  Oe(Vn.prototype._refresh),
  ue()
], Vn.prototype, "replaceWithInstancedMesh", 2);
Xo([
  Oe(Vn.prototype._refresh),
  ue()
], Vn.prototype, "hideLineMesh", 2);
Xo([
  Oe(Vn.prototype._refresh),
  ue()
], Vn.prototype, "hidePointMesh", 2);
Xo([
  Oe(Vn.prototype._refresh),
  ue()
], Vn.prototype, "loadUserDataStrings", 2);
Vn = Xo([
  Lt("Rhino 3dm Loader")
], Vn);
class fN {
  parse(e) {
    const t = {}, i = e.split(`
`), n = i.length;
    let r = 0, a = null, o = t;
    const l = [t];
    function c() {
      const h = i[r];
      if (h.includes("=")) {
        const u = h.split("="), d = u[0].trim(), p = u[1].trim();
        if (p.endsWith("{")) {
          const f = {};
          l.push(f), o[d] = f, o = f;
        } else
          o[d] = p;
      } else if (h.endsWith("{")) {
        const u = o[a] || {};
        l.push(u), o[a] = u, o = u;
      } else if (h.endsWith("}")) {
        if (l.pop(), l.length === 0) return;
        o = l[l.length - 1];
      } else if (h.endsWith("(")) {
        const u = {};
        l.push(u), a = h.split("(")[0].trim() || a, o[a] = u, o = u;
      } else h.endsWith(")") ? (l.pop(), o = l[l.length - 1]) : a = h.trim();
      r++, r < n && c();
    }
    return c(), t;
  }
}
class mN extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, a = new ti(r.manager);
    a.setPath(r.path), a.setResponseType("arraybuffer"), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(o));
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e) {
    const t = new fN();
    function i(E) {
      const x = {};
      new ti().setResponseType("arraybuffer");
      for (const D in E) {
        if (D.endsWith("png")) {
          const O = new Blob([E[D]], { type: { type: "image/png" } });
          x[D] = URL.createObjectURL(O);
        }
        if (D.endsWith("usd") || D.endsWith("usda")) {
          if (n(E[D])) {
            console.warn("THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.");
            continue;
          }
          const O = _p(E[D]);
          x[D] = t.parse(O);
        }
      }
      return x;
    }
    function n(E) {
      const x = E.slice(0, 7), b = new Uint8Array([80, 88, 82, 45, 85, 83, 68, 67]);
      return x.every((D, O) => D === b[O]);
    }
    function r(E) {
      if (E.length < 1) return;
      const x = Object.keys(E)[0];
      let b = !1;
      if (x.endsWith("usda")) return E[x];
      if (x.endsWith("usdc"))
        b = !0;
      else if (x.endsWith("usd"))
        if (n(E[x]))
          b = !0;
        else
          return E[x];
      b && console.warn("THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.");
    }
    const a = kb(new Uint8Array(e)), o = i(a), l = r(a);
    if (l === void 0)
      return console.warn("THREE.USDZLoader: No usda file found."), new Kn();
    const c = _p(l), h = t.parse(c);
    function u(E) {
      if (E) {
        if ("prepend references" in E) {
          const b = E["prepend references"].split("@"), D = b[1].replace(/^.\//, ""), O = b[2].replace(/^<\//, "").replace(/>$/, "");
          return d(o[D], O);
        }
        return d(E);
      }
    }
    function d(E, x) {
      if (E) {
        if (x !== void 0) {
          const b = `def Mesh "${x}"`;
          if (b in E)
            return E[b];
        }
        for (const b in E) {
          const D = E[b];
          if (b.startsWith("def Mesh"))
            return "point3f[] points" in E && (D["point3f[] points"] = E["point3f[] points"]), "texCoord2f[] primvars:st" in E && (D["texCoord2f[] primvars:st"] = E["texCoord2f[] primvars:st"]), "int[] primvars:st:indices" in E && (D["int[] primvars:st:indices"] = E["int[] primvars:st:indices"]), D;
          if (typeof D == "object") {
            const O = d(D);
            if (O) return O;
          }
        }
      }
    }
    function p(E) {
      if (!E) return;
      let x = new Ze();
      if ("int[] faceVertexIndices" in E) {
        const b = JSON.parse(E["int[] faceVertexIndices"]);
        x.setIndex(b);
      }
      if ("point3f[] points" in E) {
        const b = JSON.parse(E["point3f[] points"].replace(/[()]*/g, "")), D = new Je(new Float32Array(b), 3);
        x.setAttribute("position", D);
      }
      if ("normal3f[] normals" in E) {
        const b = JSON.parse(E["normal3f[] normals"].replace(/[()]*/g, "")), D = new Je(new Float32Array(b), 3);
        x.setAttribute("normal", D);
      } else
        x.computeVertexNormals();
      if ("float2[] primvars:st" in E && (E["texCoord2f[] primvars:st"] = E["float2[] primvars:st"]), "texCoord2f[] primvars:st" in E) {
        const b = JSON.parse(E["texCoord2f[] primvars:st"].replace(/[()]*/g, "")), D = new Je(new Float32Array(b), 2);
        if ("int[] primvars:st:indices" in E) {
          x = x.toNonIndexed();
          const O = JSON.parse(E["int[] primvars:st:indices"]);
          x.setAttribute("uv", f(D, O));
        } else
          x.setAttribute("uv", D);
      }
      return x;
    }
    function f(E, x) {
      const b = E.array, D = E.itemSize, O = new b.constructor(x.length * D);
      let Y = 0, B = 0;
      for (let Q = 0, j = x.length; Q < j; Q++) {
        Y = x[Q] * D;
        for (let X = 0; X < D; X++)
          O[B++] = b[Y++];
      }
      return new Je(O, D);
    }
    function y(E) {
      if (E) {
        if ("rel material:binding" in E) {
          const D = E["rel material:binding"].replace(/^<\//, "").replace(/>$/, "").split("/");
          return A(h, ` "${D[1]}"`);
        }
        return A(E);
      }
    }
    function A(E, x = "") {
      for (const b in E) {
        const D = E[b];
        if (b.startsWith("def Material" + x))
          return D;
        if (typeof D == "object") {
          const O = A(D, x);
          if (O) return O;
        }
      }
    }
    function m(E, x) {
      x["float inputs:rotation"] && (E.rotation = parseFloat(x["float inputs:rotation"])), x["float2 inputs:scale"] && (E.repeat = new ie().fromArray(JSON.parse("[" + x["float2 inputs:scale"].replace(/[()]*/g, "") + "]"))), x["float2 inputs:translation"] && (E.offset = new ie().fromArray(JSON.parse("[" + x["float2 inputs:translation"].replace(/[()]*/g, "") + "]")));
    }
    function v(E) {
      const x = new Sc();
      if (E !== void 0) {
        if ('def Shader "PreviewSurface"' in E) {
          const b = E['def Shader "PreviewSurface"'];
          if ("color3f inputs:diffuseColor.connect" in b) {
            const D = b["color3f inputs:diffuseColor.connect"], O = g(h, /(\w+).output/.exec(D)[1]);
            x.map = _(O), x.map.colorSpace = dt, 'def Shader "Transform2d_diffuse"' in E && m(x.map, E['def Shader "Transform2d_diffuse"']);
          } else if ("color3f inputs:diffuseColor" in b) {
            const D = b["color3f inputs:diffuseColor"].replace(/[()]*/g, "");
            x.color.fromArray(JSON.parse("[" + D + "]"));
          }
          if ("color3f inputs:emissiveColor.connect" in b) {
            const D = b["color3f inputs:emissiveColor.connect"], O = g(h, /(\w+).output/.exec(D)[1]);
            x.emissiveMap = _(O), x.emissiveMap.colorSpace = dt, x.emissive.set(16777215), 'def Shader "Transform2d_emissive"' in E && m(x.emissiveMap, E['def Shader "Transform2d_emissive"']);
          } else if ("color3f inputs:emissiveColor" in b) {
            const D = b["color3f inputs:emissiveColor"].replace(/[()]*/g, "");
            x.emissive.fromArray(JSON.parse("[" + D + "]"));
          }
          if ("normal3f inputs:normal.connect" in b) {
            const D = b["normal3f inputs:normal.connect"], O = g(h, /(\w+).output/.exec(D)[1]);
            x.normalMap = _(O), x.normalMap.colorSpace = Wt, 'def Shader "Transform2d_normal"' in E && m(x.normalMap, E['def Shader "Transform2d_normal"']);
          }
          if ("float inputs:roughness.connect" in b) {
            const D = b["float inputs:roughness.connect"], O = g(h, /(\w+).output/.exec(D)[1]);
            x.roughness = 1, x.roughnessMap = _(O), x.roughnessMap.colorSpace = Wt, 'def Shader "Transform2d_roughness"' in E && m(x.roughnessMap, E['def Shader "Transform2d_roughness"']);
          } else "float inputs:roughness" in b && (x.roughness = parseFloat(b["float inputs:roughness"]));
          if ("float inputs:metallic.connect" in b) {
            const D = b["float inputs:metallic.connect"], O = g(h, /(\w+).output/.exec(D)[1]);
            x.metalness = 1, x.metalnessMap = _(O), x.metalnessMap.colorSpace = Wt, 'def Shader "Transform2d_metallic"' in E && m(x.metalnessMap, E['def Shader "Transform2d_metallic"']);
          } else "float inputs:metallic" in b && (x.metalness = parseFloat(b["float inputs:metallic"]));
          if ("float inputs:clearcoat.connect" in b) {
            const D = b["float inputs:clearcoat.connect"], O = g(h, /(\w+).output/.exec(D)[1]);
            x.clearcoat = 1, x.clearcoatMap = _(O), x.clearcoatMap.colorSpace = Wt, 'def Shader "Transform2d_clearcoat"' in E && m(x.clearcoatMap, E['def Shader "Transform2d_clearcoat"']);
          } else "float inputs:clearcoat" in b && (x.clearcoat = parseFloat(b["float inputs:clearcoat"]));
          if ("float inputs:clearcoatRoughness.connect" in b) {
            const D = b["float inputs:clearcoatRoughness.connect"], O = g(h, /(\w+).output/.exec(D)[1]);
            x.clearcoatRoughness = 1, x.clearcoatRoughnessMap = _(O), x.clearcoatRoughnessMap.colorSpace = Wt, 'def Shader "Transform2d_clearcoatRoughness"' in E && m(x.clearcoatRoughnessMap, E['def Shader "Transform2d_clearcoatRoughness"']);
          } else "float inputs:clearcoatRoughness" in b && (x.clearcoatRoughness = parseFloat(b["float inputs:clearcoatRoughness"]));
          if ("float inputs:ior" in b && (x.ior = parseFloat(b["float inputs:ior"])), "float inputs:occlusion.connect" in b) {
            const D = b["float inputs:occlusion.connect"], O = g(h, /(\w+).output/.exec(D)[1]);
            x.aoMap = _(O), x.aoMap.colorSpace = Wt, 'def Shader "Transform2d_occlusion"' in E && m(x.aoMap, E['def Shader "Transform2d_occlusion"']);
          }
        }
        if ('def Shader "diffuseColor_texture"' in E) {
          const b = E['def Shader "diffuseColor_texture"'];
          x.map = _(b), x.map.colorSpace = dt;
        }
        if ('def Shader "normal_texture"' in E) {
          const b = E['def Shader "normal_texture"'];
          x.normalMap = _(b), x.normalMap.colorSpace = Wt;
        }
      }
      return x;
    }
    function g(E, x) {
      for (const b in E) {
        const D = E[b];
        if (b.startsWith(`def Shader "${x}"`))
          return D;
        if (typeof D == "object") {
          const O = g(D, x);
          if (O) return O;
        }
      }
    }
    function _(E) {
      if ("asset inputs:file" in E) {
        const x = E["asset inputs:file"].replace(/@*/g, ""), D = new xo().load(o[x]), O = {
          '"clamp"': Zt,
          '"mirror"': Xr,
          '"repeat"': xn
        };
        return "token inputs:wrapS" in E && (D.wrapS = O[E["token inputs:wrapS"]]), "token inputs:wrapT" in E && (D.wrapT = O[E["token inputs:wrapT"]]), D;
      }
      return null;
    }
    function w(E) {
      const x = p(u(E)), b = v(y(E)), D = x ? new Se(x, b) : new ut();
      if ("matrix4d xformOp:transform" in E) {
        const O = JSON.parse("[" + E["matrix4d xformOp:transform"].replace(/[()]*/g, "") + "]");
        D.matrix.fromArray(O), D.matrix.decompose(D.position, D.quaternion, D.scale);
      }
      return D;
    }
    function S(E, x) {
      for (const b in E)
        if (b.startsWith("def Scope"))
          S(E[b], x);
        else if (b.startsWith("def Xform")) {
          const D = w(E[b]);
          /def Xform "(\w+)"/.test(b) && (D.name = /def Xform "(\w+)"/.exec(b)[1]), x.add(D), S(E[b], D);
        }
    }
    const C = new Kn();
    return S(h, C), C;
  }
}
const Ny = class Ny extends Gc {
  constructor() {
    super(...arguments), this._importer = new $i(class extends mN {
      constructor() {
        super(...arguments), this.currentUrl = "";
      }
      async loadAsync(e, t) {
        this.currentUrl = e;
        const i = await super.loadAsync(e, t);
        if (this.currentUrl = "", !i.children.length) throw new Error("No mesh found in USDZ file, note that usdc files are not supported.");
        return i;
      }
      parse(e) {
        if (this.currentUrl.endsWith(".usda") && typeof e != "string") {
          const t = this.currentUrl.split("/").pop();
          if (t) {
            const i = {};
            i[t] = new Uint8Array(e), e = Nb(i).buffer;
          }
        }
        return super.parse(e);
      }
    }, ["usdz", "usda"], ["model/vnd.usd+zip", "model/vnd.usdz+zip", "model/vnd.usda"], !1);
  }
};
Ny.PluginType = "USDZLoadPlugin";
let Sx = Ny;
const Wn = new se();
class gN extends ui {
  constructor(e) {
    super(e), this.propertyNameMapping = {}, this.customPropertyMapping = {};
  }
  load(e, t, i, n) {
    const r = this, a = new ti(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(o));
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
    }, i, n);
  }
  setPropertyNameMapping(e) {
    this.propertyNameMapping = e;
  }
  setCustomPropertyNameMapping(e) {
    this.customPropertyMapping = e;
  }
  parse(e) {
    function t(A, m = 0) {
      const v = /^ply([\s\S]*)end_header(\r\n|\r|\n)/;
      let g = "";
      const _ = v.exec(A);
      _ !== null && (g = _[1]);
      const w = {
        comments: [],
        elements: [],
        headerLength: m,
        objInfo: ""
      }, S = g.split(/\r\n|\r|\n/);
      let C;
      function E(x, b) {
        const D = { type: x[0] };
        return D.type === "list" ? (D.name = x[3], D.countType = x[1], D.itemType = x[2]) : D.name = x[1], D.name in b && (D.name = b[D.name]), D;
      }
      for (let x = 0; x < S.length; x++) {
        let b = S[x];
        if (b = b.trim(), b === "") continue;
        const D = b.split(/\s+/), O = D.shift();
        switch (b = D.join(" "), O) {
          case "format":
            w.format = D[0], w.version = D[1];
            break;
          case "comment":
            w.comments.push(b);
            break;
          case "element":
            C !== void 0 && w.elements.push(C), C = {}, C.name = D[0], C.count = parseInt(D[1]), C.properties = [];
            break;
          case "property":
            C.properties.push(E(D, y.propertyNameMapping));
            break;
          case "obj_info":
            w.objInfo = b;
            break;
          default:
            console.log("unhandled", O, D);
        }
      }
      return C !== void 0 && w.elements.push(C), w;
    }
    function i(A, m) {
      switch (m) {
        case "char":
        case "uchar":
        case "short":
        case "ushort":
        case "int":
        case "uint":
        case "int8":
        case "uint8":
        case "int16":
        case "uint16":
        case "int32":
        case "uint32":
          return parseInt(A);
        case "float":
        case "double":
        case "float32":
        case "float64":
          return parseFloat(A);
      }
    }
    function n(A, m) {
      const v = {};
      for (let g = 0; g < A.length; g++) {
        if (m.empty()) return null;
        if (A[g].type === "list") {
          const _ = [], w = i(m.next(), A[g].countType);
          for (let S = 0; S < w; S++) {
            if (m.empty()) return null;
            _.push(i(m.next(), A[g].itemType));
          }
          v[A[g].name] = _;
        } else
          v[A[g].name] = i(m.next(), A[g].type);
      }
      return v;
    }
    function r() {
      const A = {
        indices: [],
        vertices: [],
        normals: [],
        uvs: [],
        faceVertexUvs: [],
        colors: [],
        faceVertexColors: []
      };
      for (const m of Object.keys(y.customPropertyMapping))
        A[m] = [];
      return A;
    }
    function a(A) {
      const m = A.map((g) => g.name);
      function v(g) {
        for (let _ = 0, w = g.length; _ < w; _++) {
          const S = g[_];
          if (m.includes(S)) return S;
        }
        return null;
      }
      return {
        attrX: v(["x", "px", "posx"]) || "x",
        attrY: v(["y", "py", "posy"]) || "y",
        attrZ: v(["z", "pz", "posz"]) || "z",
        attrNX: v(["nx", "normalx"]),
        attrNY: v(["ny", "normaly"]),
        attrNZ: v(["nz", "normalz"]),
        attrS: v(["s", "u", "texture_u", "tx"]),
        attrT: v(["t", "v", "texture_v", "ty"]),
        attrR: v(["red", "diffuse_red", "r", "diffuse_r"]),
        attrG: v(["green", "diffuse_green", "g", "diffuse_g"]),
        attrB: v(["blue", "diffuse_blue", "b", "diffuse_b"])
      };
    }
    function o(A, m) {
      const v = r(), g = /end_header\s+(\S[\s\S]*\S|\S)\s*$/;
      let _, w;
      (w = g.exec(A)) !== null ? _ = w[1].split(/\s+/) : _ = [];
      const S = new AN(_);
      e: for (let C = 0; C < m.elements.length; C++) {
        const E = m.elements[C], x = a(E.properties);
        for (let b = 0; b < E.count; b++) {
          const D = n(E.properties, S);
          if (!D) break e;
          c(v, E.name, D, x);
        }
      }
      return l(v);
    }
    function l(A) {
      let m = new Ze();
      A.indices.length > 0 && m.setIndex(A.indices), m.setAttribute("position", new Te(A.vertices, 3)), A.normals.length > 0 && m.setAttribute("normal", new Te(A.normals, 3)), A.uvs.length > 0 && m.setAttribute("uv", new Te(A.uvs, 2)), A.colors.length > 0 && m.setAttribute("color", new Te(A.colors, 3)), (A.faceVertexUvs.length > 0 || A.faceVertexColors.length > 0) && (m = m.toNonIndexed(), A.faceVertexUvs.length > 0 && m.setAttribute("uv", new Te(A.faceVertexUvs, 2)), A.faceVertexColors.length > 0 && m.setAttribute("color", new Te(A.faceVertexColors, 3)));
      for (const v of Object.keys(y.customPropertyMapping))
        A[v].length > 0 && m.setAttribute(
          v,
          new Te(
            A[v],
            y.customPropertyMapping[v].length
          )
        );
      return m.computeBoundingSphere(), m;
    }
    function c(A, m, v, g) {
      if (m === "vertex") {
        A.vertices.push(v[g.attrX], v[g.attrY], v[g.attrZ]), g.attrNX !== null && g.attrNY !== null && g.attrNZ !== null && A.normals.push(v[g.attrNX], v[g.attrNY], v[g.attrNZ]), g.attrS !== null && g.attrT !== null && A.uvs.push(v[g.attrS], v[g.attrT]), g.attrR !== null && g.attrG !== null && g.attrB !== null && (Wn.setRGB(
          v[g.attrR] / 255,
          v[g.attrG] / 255,
          v[g.attrB] / 255
        ).convertSRGBToLinear(), A.colors.push(Wn.r, Wn.g, Wn.b));
        for (const _ of Object.keys(y.customPropertyMapping))
          for (const w of y.customPropertyMapping[_])
            A[_].push(v[w]);
      } else if (m === "face") {
        const _ = v.vertex_indices || v.vertex_index, w = v.texcoord;
        _.length === 3 ? (A.indices.push(_[0], _[1], _[2]), w && w.length === 6 && (A.faceVertexUvs.push(w[0], w[1]), A.faceVertexUvs.push(w[2], w[3]), A.faceVertexUvs.push(w[4], w[5]))) : _.length === 4 && (A.indices.push(_[0], _[1], _[3]), A.indices.push(_[1], _[2], _[3])), g.attrR !== null && g.attrG !== null && g.attrB !== null && (Wn.setRGB(
          v[g.attrR] / 255,
          v[g.attrG] / 255,
          v[g.attrB] / 255
        ).convertSRGBToLinear(), A.faceVertexColors.push(Wn.r, Wn.g, Wn.b), A.faceVertexColors.push(Wn.r, Wn.g, Wn.b), A.faceVertexColors.push(Wn.r, Wn.g, Wn.b));
      }
    }
    function h(A, m) {
      const v = {};
      let g = 0;
      for (let _ = 0; _ < m.length; _++) {
        const w = m[_], S = w.valueReader;
        if (w.type === "list") {
          const C = [], E = w.countReader.read(A + g);
          g += w.countReader.size;
          for (let x = 0; x < E; x++)
            C.push(S.read(A + g)), g += S.size;
          v[w.name] = C;
        } else
          v[w.name] = S.read(A + g), g += S.size;
      }
      return [v, g];
    }
    function u(A, m, v) {
      function g(_, w, S) {
        switch (w) {
          // corespondences for non-specific length types here match rply:
          case "int8":
          case "char":
            return { read: (C) => _.getInt8(C), size: 1 };
          case "uint8":
          case "uchar":
            return { read: (C) => _.getUint8(C), size: 1 };
          case "int16":
          case "short":
            return { read: (C) => _.getInt16(C, S), size: 2 };
          case "uint16":
          case "ushort":
            return { read: (C) => _.getUint16(C, S), size: 2 };
          case "int32":
          case "int":
            return { read: (C) => _.getInt32(C, S), size: 4 };
          case "uint32":
          case "uint":
            return { read: (C) => _.getUint32(C, S), size: 4 };
          case "float32":
          case "float":
            return { read: (C) => _.getFloat32(C, S), size: 4 };
          case "float64":
          case "double":
            return { read: (C) => _.getFloat64(C, S), size: 8 };
        }
      }
      for (let _ = 0, w = A.length; _ < w; _++) {
        const S = A[_];
        S.type === "list" ? (S.countReader = g(m, S.countType, v), S.valueReader = g(m, S.itemType, v)) : S.valueReader = g(m, S.type, v);
      }
    }
    function d(A, m) {
      const v = r(), g = m.format === "binary_little_endian", _ = new DataView(A, m.headerLength);
      let w, S = 0;
      for (let C = 0; C < m.elements.length; C++) {
        const E = m.elements[C], x = E.properties, b = a(x);
        u(x, _, g);
        for (let D = 0; D < E.count; D++) {
          w = h(S, x), S += w[1];
          const O = w[0];
          c(v, E.name, O, b);
        }
      }
      return l(v);
    }
    function p(A) {
      let m = 0, v = !0, g = "";
      const _ = [], w = new TextDecoder().decode(A.subarray(0, 5)), S = /^ply\r\n/.test(w);
      do {
        const C = String.fromCharCode(A[m++]);
        C !== `
` && C !== "\r" ? g += C : (g === "end_header" && (v = !1), g !== "" && (_.push(g), g = ""));
      } while (v && m < A.length);
      return S === !0 && m++, { headerText: _.join("\r") + "\r", headerLength: m };
    }
    let f;
    const y = this;
    if (e instanceof ArrayBuffer) {
      const A = new Uint8Array(e), { headerText: m, headerLength: v } = p(A), g = t(m, v);
      if (g.format === "ascii") {
        const _ = new TextDecoder().decode(A);
        f = o(_, g);
      } else
        f = d(e, g);
    } else
      f = o(e, t(e));
    return f;
  }
}
class AN {
  constructor(e) {
    this.arr = e, this.i = 0;
  }
  empty() {
    return this.i >= this.arr.length;
  }
  next() {
    return this.arr[this.i++];
  }
}
const ky = class ky extends Gc {
  constructor() {
    super(...arguments), this._importer = new $i(class extends gN {
      transform(e, t) {
        var i;
        return (i = e.attributes) != null && i.normal || e.computeVertexNormals(), e ? new Se(e, new Ds({
          color: new se(1, 1, 1),
          vertexColors: e.hasAttribute("color")
        })) : void 0;
      }
    }, ["ply"], ["text/plain+ply"], !1);
  }
};
ky.PluginType = "PLYLoadPlugin";
let Cx = ky;
class yN extends ui {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, a = new ti(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(o));
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e) {
    function t(c) {
      const h = new DataView(c), u = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8, d = h.getUint32(80, !0);
      if (80 + 32 / 8 + d * u === h.byteLength)
        return !0;
      const f = [115, 111, 108, 105, 100];
      for (let y = 0; y < 5; y++)
        if (i(f, h, y)) return !1;
      return !0;
    }
    function i(c, h, u) {
      for (let d = 0, p = c.length; d < p; d++)
        if (c[d] !== h.getUint8(u + d)) return !1;
      return !0;
    }
    function n(c) {
      const h = new DataView(c), u = h.getUint32(80, !0);
      let d, p, f, y = !1, A, m, v, g, _;
      for (let D = 0; D < 70; D++)
        h.getUint32(D, !1) == 1129270351 && h.getUint8(D + 4) == 82 && h.getUint8(D + 5) == 61 && (y = !0, A = new Float32Array(u * 3 * 3), m = h.getUint8(D + 6) / 255, v = h.getUint8(D + 7) / 255, g = h.getUint8(D + 8) / 255, _ = h.getUint8(D + 9) / 255);
      const w = 84, S = 12 * 4 + 2, C = new Ze(), E = new Float32Array(u * 3 * 3), x = new Float32Array(u * 3 * 3), b = new se();
      for (let D = 0; D < u; D++) {
        const O = w + D * S, Y = h.getFloat32(O, !0), B = h.getFloat32(O + 4, !0), Q = h.getFloat32(O + 8, !0);
        if (y) {
          const j = h.getUint16(O + 48, !0);
          (j & 32768) === 0 ? (d = (j & 31) / 31, p = (j >> 5 & 31) / 31, f = (j >> 10 & 31) / 31) : (d = m, p = v, f = g);
        }
        for (let j = 1; j <= 3; j++) {
          const X = O + j * 12, Z = D * 3 * 3 + (j - 1) * 3;
          E[Z] = h.getFloat32(X, !0), E[Z + 1] = h.getFloat32(X + 4, !0), E[Z + 2] = h.getFloat32(X + 8, !0), x[Z] = Y, x[Z + 1] = B, x[Z + 2] = Q, y && (b.set(d, p, f).convertSRGBToLinear(), A[Z] = b.r, A[Z + 1] = b.g, A[Z + 2] = b.b);
        }
      }
      return C.setAttribute("position", new Je(E, 3)), C.setAttribute("normal", new Je(x, 3)), y && (C.setAttribute("color", new Je(A, 3)), C.hasColors = !0, C.alpha = _), C;
    }
    function r(c) {
      const h = new Ze(), u = /solid([\s\S]*?)endsolid/g, d = /facet([\s\S]*?)endfacet/g, p = /solid\s(.+)/;
      let f = 0;
      const y = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source, A = new RegExp("vertex" + y + y + y, "g"), m = new RegExp("normal" + y + y + y, "g"), v = [], g = [], _ = [], w = new M();
      let S, C = 0, E = 0, x = 0;
      for (; (S = u.exec(c)) !== null; ) {
        E = x;
        const b = S[0], D = (S = p.exec(b)) !== null ? S[1] : "";
        for (_.push(D); (S = d.exec(b)) !== null; ) {
          let B = 0, Q = 0;
          const j = S[0];
          for (; (S = m.exec(j)) !== null; )
            w.x = parseFloat(S[1]), w.y = parseFloat(S[2]), w.z = parseFloat(S[3]), Q++;
          for (; (S = A.exec(j)) !== null; )
            v.push(parseFloat(S[1]), parseFloat(S[2]), parseFloat(S[3])), g.push(w.x, w.y, w.z), B++, x++;
          Q !== 1 && console.error("THREE.STLLoader: Something isn't right with the normal of face number " + f), B !== 3 && console.error("THREE.STLLoader: Something isn't right with the vertices of face number " + f), f++;
        }
        const O = E, Y = x - E;
        h.userData.groupNames = _, h.addGroup(O, Y, C), C++;
      }
      return h.setAttribute("position", new Te(v, 3)), h.setAttribute("normal", new Te(g, 3)), h;
    }
    function a(c) {
      return typeof c != "string" ? new TextDecoder().decode(c) : c;
    }
    function o(c) {
      if (typeof c == "string") {
        const h = new Uint8Array(c.length);
        for (let u = 0; u < c.length; u++)
          h[u] = c.charCodeAt(u) & 255;
        return h.buffer || h;
      } else
        return c;
    }
    const l = o(e);
    return t(l) ? n(l) : r(a(e));
  }
}
const Gy = class Gy extends Gc {
  constructor() {
    super(...arguments), this._importer = new $i(class extends yN {
      transform(e, t) {
        var i;
        return (i = e.attributes) != null && i.normal || e.computeVertexNormals(), e ? new Se(e, new Ds({
          color: new se(1, 1, 1),
          vertexColors: e.hasAttribute("color")
        })) : void 0;
      }
    }, ["stl"], ["model/stl", "model/x.stl-binary", "model/x.stl-ascii"], !1);
  }
};
Gy.PluginType = "STLLoadPlugin";
let Mx = Gy;
class vN extends hR {
  constructor(e) {
    super(e);
  }
  parse(e, t) {
    const i = new wN(e, 1);
    return {
      mipmaps: i.mipmaps(t),
      width: i.pixelWidth,
      height: i.pixelHeight,
      format: i.glInternalFormat,
      isCubemap: i.numberOfFaces === 6,
      mipmapCount: i.numberOfMipmapLevels
    };
  }
}
const _N = 12 + 13 * 4, xN = 0;
class wN {
  /**
   * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file
   * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or
   * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented
   * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented
   */
  constructor(e, t) {
    this.arrayBuffer = e;
    const i = new Uint8Array(this.arrayBuffer, 0, 12);
    if (i[0] !== 171 || i[1] !== 75 || i[2] !== 84 || i[3] !== 88 || i[4] !== 32 || i[5] !== 49 || i[6] !== 49 || i[7] !== 187 || i[8] !== 13 || i[9] !== 10 || i[10] !== 26 || i[11] !== 10) {
      console.error("texture missing KTX identifier");
      return;
    }
    const n = Uint32Array.BYTES_PER_ELEMENT, r = new DataView(this.arrayBuffer, 12, 13 * n), o = r.getUint32(0, !0) === 67305985;
    if (this.glType = r.getUint32(1 * n, o), this.glTypeSize = r.getUint32(2 * n, o), this.glFormat = r.getUint32(3 * n, o), this.glInternalFormat = r.getUint32(4 * n, o), this.glBaseInternalFormat = r.getUint32(5 * n, o), this.pixelWidth = r.getUint32(6 * n, o), this.pixelHeight = r.getUint32(7 * n, o), this.pixelDepth = r.getUint32(8 * n, o), this.numberOfArrayElements = r.getUint32(9 * n, o), this.numberOfFaces = r.getUint32(10 * n, o), this.numberOfMipmapLevels = r.getUint32(11 * n, o), this.bytesOfKeyValueData = r.getUint32(12 * n, o), this.glType !== 0) {
      console.warn("only compressed formats currently supported");
      return;
    } else
      this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);
    if (this.pixelHeight === 0 || this.pixelDepth !== 0) {
      console.warn("only 2D textures currently supported");
      return;
    }
    if (this.numberOfArrayElements !== 0) {
      console.warn("texture arrays not currently supported");
      return;
    }
    if (this.numberOfFaces !== t) {
      console.warn("number of faces expected" + t + ", but found " + this.numberOfFaces);
      return;
    }
    this.loadType = xN;
  }
  mipmaps(e) {
    const t = [];
    let i = _N + this.bytesOfKeyValueData, n = this.pixelWidth, r = this.pixelHeight;
    const a = e ? this.numberOfMipmapLevels : 1;
    for (let o = 0; o < a; o++) {
      const l = new Int32Array(this.arrayBuffer, i, 1)[0];
      i += 4;
      for (let c = 0; c < this.numberOfFaces; c++) {
        const h = new Uint8Array(this.arrayBuffer, i, l);
        t.push({ data: h, width: n, height: r }), i += l, i += 3 - (l + 3) % 4;
      }
      n = Math.max(1, n * 0.5), r = Math.max(1, r * 0.5);
    }
    return t;
  }
}
const zy = class zy extends Gc {
  constructor() {
    super(...arguments), this._importer = new $i(vN, ["ktx"], ["image/ktx"], !1);
  }
};
zy.PluginType = "KTXLoadPlugin";
let Tx = zy;
class EN {
  constructor(e = 4) {
    this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
  }
  _initWorker(e) {
    if (!this.workers[e]) {
      const t = this.workerCreator();
      t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t;
    }
  }
  _getIdleWorker() {
    for (let e = 0; e < this.pool; e++)
      if (!(this.workerStatus & 1 << e)) return e;
    return -1;
  }
  _onMessage(e, t) {
    const i = this.workersResolve[e];
    if (i && i(t), this.queue.length) {
      const { resolve: n, msg: r, transfer: a } = this.queue.shift();
      this.workersResolve[e] = n, this.workers[e].postMessage(r, a);
    } else
      this.workerStatus ^= 1 << e;
  }
  setWorkerCreator(e) {
    this.workerCreator = e;
  }
  setWorkerLimit(e) {
    this.pool = e;
  }
  postMessage(e, t) {
    return new Promise((i) => {
      const n = this._getIdleWorker();
      n !== -1 ? (this._initWorker(n), this.workerStatus |= 1 << n, this.workersResolve[n] = i, this.workers[n].postMessage(e, t)) : this.queue.push({ resolve: i, msg: e, transfer: t });
    });
  }
  dispose() {
    this.workers.forEach((e) => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
  }
}
const bN = 0, Ix = 2, SN = 1, Dx = 2, CN = 0, MN = 1, TN = 10, IN = 0, cS = 9, hS = 15, uS = 16, dS = 22, pS = 37, fS = 43, mS = 76, gS = 83, AS = 97, yS = 100, vS = 103, _S = 109, xS = 165, wS = 166;
class DN {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
}
class lh {
  constructor(e, t, i, n) {
    this._dataView = new DataView(e.buffer, e.byteOffset + t, i), this._littleEndian = n, this._offset = 0;
  }
  _nextUint8() {
    const e = this._dataView.getUint8(this._offset);
    return this._offset += 1, e;
  }
  _nextUint16() {
    const e = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, e;
  }
  _nextUint32() {
    const e = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _nextUint64() {
    const e = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, e;
  }
  _nextInt32() {
    const e = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _skip(e) {
    return this._offset += e, this;
  }
  _scan(e, t = 0) {
    const i = this._offset;
    let n = 0;
    for (; this._dataView.getUint8(this._offset) !== t && n < e; ) n++, this._offset++;
    return n < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + i, n);
  }
}
const Ln = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function Rx(s) {
  return typeof TextDecoder < "u" ? new TextDecoder().decode(s) : Buffer.from(s).toString("utf8");
}
function RN(s) {
  const e = new Uint8Array(s.buffer, s.byteOffset, Ln.length);
  if (e[0] !== Ln[0] || e[1] !== Ln[1] || e[2] !== Ln[2] || e[3] !== Ln[3] || e[4] !== Ln[4] || e[5] !== Ln[5] || e[6] !== Ln[6] || e[7] !== Ln[7] || e[8] !== Ln[8] || e[9] !== Ln[9] || e[10] !== Ln[10] || e[11] !== Ln[11]) throw new Error("Missing KTX 2.0 identifier.");
  const t = new DN(), i = 17 * Uint32Array.BYTES_PER_ELEMENT, n = new lh(s, Ln.length, i, !0);
  t.vkFormat = n._nextUint32(), t.typeSize = n._nextUint32(), t.pixelWidth = n._nextUint32(), t.pixelHeight = n._nextUint32(), t.pixelDepth = n._nextUint32(), t.layerCount = n._nextUint32(), t.faceCount = n._nextUint32();
  const r = n._nextUint32();
  t.supercompressionScheme = n._nextUint32();
  const a = n._nextUint32(), o = n._nextUint32(), l = n._nextUint32(), c = n._nextUint32(), h = n._nextUint64(), u = n._nextUint64(), d = new lh(s, Ln.length + i, 3 * r * 8, !0);
  for (let X = 0; X < r; X++) t.levels.push({ levelData: new Uint8Array(s.buffer, s.byteOffset + d._nextUint64(), d._nextUint64()), uncompressedByteLength: d._nextUint64() });
  const p = new lh(s, a, o, !0), f = { vendorId: p._skip(4)._nextUint16(), descriptorType: p._nextUint16(), versionNumber: p._nextUint16(), descriptorBlockSize: p._nextUint16(), colorModel: p._nextUint8(), colorPrimaries: p._nextUint8(), transferFunction: p._nextUint8(), flags: p._nextUint8(), texelBlockDimension: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()], bytesPlane: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()], samples: [] }, y = (f.descriptorBlockSize / 4 - 6) / 4;
  for (let X = 0; X < y; X++) {
    const Z = { bitOffset: p._nextUint16(), bitLength: p._nextUint8(), channelType: p._nextUint8(), samplePosition: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 };
    64 & Z.channelType ? (Z.sampleLower = p._nextInt32(), Z.sampleUpper = p._nextInt32()) : (Z.sampleLower = p._nextUint32(), Z.sampleUpper = p._nextUint32()), f.samples[X] = Z;
  }
  t.dataFormatDescriptor.length = 0, t.dataFormatDescriptor.push(f);
  const A = new lh(s, l, c, !0);
  for (; A._offset < c; ) {
    const X = A._nextUint32(), Z = A._scan(X), ee = Rx(Z), J = A._scan(X - Z.byteLength);
    t.keyValue[ee] = ee.match(/^ktx/i) ? Rx(J) : J, A._offset % 4 && A._skip(4 - A._offset % 4);
  }
  if (u <= 0) return t;
  const m = new lh(s, h, u, !0), v = m._nextUint16(), g = m._nextUint16(), _ = m._nextUint32(), w = m._nextUint32(), S = m._nextUint32(), C = m._nextUint32(), E = [];
  for (let X = 0; X < r; X++) E.push({ imageFlags: m._nextUint32(), rgbSliceByteOffset: m._nextUint32(), rgbSliceByteLength: m._nextUint32(), alphaSliceByteOffset: m._nextUint32(), alphaSliceByteLength: m._nextUint32() });
  const x = h + m._offset, b = x + _, D = b + w, O = D + S, Y = new Uint8Array(s.buffer, s.byteOffset + x, _), B = new Uint8Array(s.buffer, s.byteOffset + b, w), Q = new Uint8Array(s.buffer, s.byteOffset + D, S), j = new Uint8Array(s.buffer, s.byteOffset + O, C);
  return t.globalData = { endpointCount: v, selectorCount: g, imageDescs: E, endpointsData: Y, selectorsData: B, tablesData: Q, extendedData: j }, t;
}
let bm, Ur, qg;
const Sm = { env: { emscripten_notify_memory_growth: function(s) {
  qg = new Uint8Array(Ur.exports.memory.buffer);
} } };
class BN {
  init() {
    return bm || (bm = typeof fetch < "u" ? fetch("data:application/wasm;base64," + Bx).then((e) => e.arrayBuffer()).then((e) => WebAssembly.instantiate(e, Sm)).then(this._init) : WebAssembly.instantiate(Buffer.from(Bx, "base64"), Sm).then(this._init), bm);
  }
  _init(e) {
    Ur = e.instance, Sm.env.emscripten_notify_memory_growth(0);
  }
  decode(e, t = 0) {
    if (!Ur) throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const i = e.byteLength, n = Ur.exports.malloc(i);
    qg.set(e, n), t = t || Number(Ur.exports.ZSTD_findDecompressedSize(n, i));
    const r = Ur.exports.malloc(t), a = Ur.exports.ZSTD_decompress(r, t, n, i), o = qg.slice(r, r + a);
    return Ur.exports.free(n), Ur.exports.free(r), o;
  }
}
const Bx = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", Cm = /* @__PURE__ */ new WeakMap();
let Mm = 0, Tm;
class ur extends ui {
  constructor(e) {
    super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new EN(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn(
      'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
    );
  }
  setTranscoderPath(e) {
    return this.transcoderPath = e, this;
  }
  setWorkerLimit(e) {
    return this.workerPool.setWorkerLimit(e), this;
  }
  detectSupport(e) {
    return e.isWebGPURenderer === !0 ? this.workerConfig = {
      astcSupported: e.hasFeature("texture-compression-astc"),
      etc1Supported: !1,
      etc2Supported: e.hasFeature("texture-compression-etc2"),
      dxtSupported: e.hasFeature("texture-compression-bc"),
      bptcSupported: !1,
      pvrtcSupported: !1
    } : (this.workerConfig = {
      astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
      etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    }, e.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1)), this;
  }
  init() {
    if (!this.transcoderPending) {
      const e = new ti(this.manager);
      e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
      const t = e.loadAsync("basis_transcoder.js"), i = new ti(this.manager);
      i.setPath(this.transcoderPath), i.setResponseType("arraybuffer"), i.setWithCredentials(this.withCredentials);
      const n = i.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([t, n]).then(([r, a]) => {
        const o = ur.BasisWorker, l = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(ur.EngineFormat),
          "let _TranscoderFormat = " + JSON.stringify(ur.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(ur.BasisFormat),
          "/* basis_transcoder.js */",
          r,
          "/* worker */",
          o.substring(o.indexOf("{") + 1, o.lastIndexOf("}"))
        ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([l])), this.transcoderBinary = a, this.workerPool.setWorkerCreator(() => {
          const c = new Worker(this.workerSourceURL), h = this.transcoderBinary.slice(0);
          return c.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: h }, [h]), c;
        });
      }), Mm > 0 && console.warn(
        "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
      ), Mm++;
    }
    return this.transcoderPending;
  }
  load(e, t, i, n) {
    if (this.workerConfig === null)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    const r = new ti(this.manager);
    r.setResponseType("arraybuffer"), r.setCrossOrigin(this.crossOrigin), r.setWithCredentials(this.withCredentials), r.load(e, (a) => {
      if (Cm.has(a))
        return Cm.get(a).promise.then(t).catch(n);
      this.createTexture(a).then((o) => t ? t(o) : null).catch(n);
    }, i, n);
  }
  _createTextureFrom(e, t) {
    const { faces: i, width: n, height: r, format: a, type: o, error: l, dfdFlags: c } = e;
    if (o === "error") return Promise.reject(l);
    let h;
    if (t.faceCount === 6)
      h = new AD(i, a, Ft);
    else {
      const u = i[0].mipmaps;
      h = t.layerCount > 1 ? new gD(u, n, r, t.layerCount, a, Ft) : new ba(u, n, r, a, Ft);
    }
    return h.minFilter = i[0].mipmaps.length === 1 ? tt : Qn, h.magFilter = tt, h.generateMipmaps = !1, h.needsUpdate = !0, h.colorSpace = ES(t), h.premultiplyAlpha = !!(c & SN), h;
  }
  /**
   * @param {ArrayBuffer} buffer
   * @param {object?} config
   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
   */
  async createTexture(e, t = {}) {
    const i = RN(new Uint8Array(e));
    if (i.vkFormat !== IN)
      return LN(i);
    const n = t, r = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: e, taskConfig: n }, [e])).then((a) => this._createTextureFrom(a.data, i));
    return Cm.set(e, { promise: r }), r;
  }
  dispose() {
    return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), Mm--, this;
  }
}
ur.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
ur.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
ur.EngineFormat = {
  RGBAFormat: ei,
  RGBA_ASTC_4x4_Format: Wm,
  RGBA_BPTC_Format: Bd,
  RGBA_ETC2_EAC_Format: Vm,
  RGBA_PVRTC_4BPPV1_Format: Qm,
  RGBA_S3TC_DXT5_Format: Rd,
  RGB_ETC1_Format: aw,
  RGB_ETC2_Format: Hm,
  RGB_PVRTC_4BPPV1_Format: zm,
  RGB_S3TC_DXT1_Format: Dd
};
ur.BasisWorker = `function () {

	let config;
	let transcoderPending;
	let BasisModule;

	const EngineFormat = _EngineFormat; // eslint-disable-line no-undef
	const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef
	const BasisFormat = _BasisFormat; // eslint-disable-line no-undef

	self.addEventListener( 'message', function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':
				config = message.config;
				init( message.transcoderBinary );
				break;

			case 'transcode':
				transcoderPending.then( () => {

					try {

						const { faces, buffers, width, height, hasAlpha, format, dfdFlags } = transcode( message.buffer );

						self.postMessage( { type: 'transcode', id: message.id, faces, width, height, hasAlpha, format, dfdFlags }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					}

				} );
				break;

		}

	} );

	function init( wasmBinary ) {

		transcoderPending = new Promise( ( resolve ) => {

			BasisModule = { wasmBinary, onRuntimeInitialized: resolve };
			BASIS( BasisModule ); // eslint-disable-line no-undef

		} ).then( () => {

			BasisModule.initializeBasis();

			if ( BasisModule.KTX2File === undefined ) {

				console.warn( 'THREE.KTX2Loader: Please update Basis Universal transcoder.' );

			}

		} );

	}

	function transcode( buffer ) {

		const ktx2File = new BasisModule.KTX2File( new Uint8Array( buffer ) );

		function cleanup() {

			ktx2File.close();
			ktx2File.delete();

		}

		if ( ! ktx2File.isValid() ) {

			cleanup();
			throw new Error( 'THREE.KTX2Loader:	Invalid or unsupported .ktx2 file' );

		}

		const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
		const width = ktx2File.getWidth();
		const height = ktx2File.getHeight();
		const layerCount = ktx2File.getLayers() || 1;
		const levelCount = ktx2File.getLevels();
		const faceCount = ktx2File.getFaces();
		const hasAlpha = ktx2File.getHasAlpha();
		const dfdFlags = ktx2File.getDFDFlags();

		const { transcoderFormat, engineFormat } = getTranscoderFormat( basisFormat, width, height, hasAlpha );

		if ( ! width || ! height || ! levelCount ) {

			cleanup();
			throw new Error( 'THREE.KTX2Loader:	Invalid texture' );

		}

		if ( ! ktx2File.startTranscoding() ) {

			cleanup();
			throw new Error( 'THREE.KTX2Loader: .startTranscoding failed' );

		}

		const faces = [];
		const buffers = [];

		for ( let face = 0; face < faceCount; face ++ ) {

			const mipmaps = [];

			for ( let mip = 0; mip < levelCount; mip ++ ) {

				const layerMips = [];

				let mipWidth, mipHeight;

				for ( let layer = 0; layer < layerCount; layer ++ ) {

					const levelInfo = ktx2File.getImageLevelInfo( mip, layer, face );

					if ( face === 0 && mip === 0 && layer === 0 && ( levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0 ) ) {

						console.warn( 'THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.' );

					}

					if ( levelCount > 1 ) {

						mipWidth = levelInfo.origWidth;
						mipHeight = levelInfo.origHeight;

					} else {

						// Handles non-multiple-of-four dimensions in textures without mipmaps. Textures with
						// mipmaps must use multiple-of-four dimensions, for some texture formats and APIs.
						// See mrdoob/three.js#25908.
						mipWidth = levelInfo.width;
						mipHeight = levelInfo.height;

					}

					const dst = new Uint8Array( ktx2File.getImageTranscodedSizeInBytes( mip, layer, 0, transcoderFormat ) );
					const status = ktx2File.transcodeImage( dst, mip, layer, face, transcoderFormat, 0, - 1, - 1 );

					if ( ! status ) {

						cleanup();
						throw new Error( 'THREE.KTX2Loader: .transcodeImage failed.' );

					}

					layerMips.push( dst );

				}

				const mipData = concat( layerMips );

				mipmaps.push( { data: mipData, width: mipWidth, height: mipHeight } );
				buffers.push( mipData.buffer );

			}

			faces.push( { mipmaps, width, height, format: engineFormat } );

		}

		cleanup();

		return { faces, buffers, width, height, hasAlpha, format: engineFormat, dfdFlags };

	}

	//

	// Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),
	// device capabilities, and texture dimensions. The list below ranks the formats separately
	// for ETC1S and UASTC.
	//
	// In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at
	// significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently
	// chooses RGBA32 only as a last resort and does not expose that option to the caller.
	const FORMAT_OPTIONS = [
		{
			if: 'astcSupported',
			basisFormat: [ BasisFormat.UASTC_4x4 ],
			transcoderFormat: [ TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4 ],
			engineFormat: [ EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format ],
			priorityETC1S: Infinity,
			priorityUASTC: 1,
			needsPowerOfTwo: false,
		},
		{
			if: 'bptcSupported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
			transcoderFormat: [ TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5 ],
			engineFormat: [ EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format ],
			priorityETC1S: 3,
			priorityUASTC: 2,
			needsPowerOfTwo: false,
		},
		{
			if: 'dxtSupported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
			transcoderFormat: [ TranscoderFormat.BC1, TranscoderFormat.BC3 ],
			engineFormat: [ EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format ],
			priorityETC1S: 4,
			priorityUASTC: 5,
			needsPowerOfTwo: false,
		},
		{
			if: 'etc2Supported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
			transcoderFormat: [ TranscoderFormat.ETC1, TranscoderFormat.ETC2 ],
			engineFormat: [ EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format ],
			priorityETC1S: 1,
			priorityUASTC: 3,
			needsPowerOfTwo: false,
		},
		{
			if: 'etc1Supported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
			transcoderFormat: [ TranscoderFormat.ETC1 ],
			engineFormat: [ EngineFormat.RGB_ETC1_Format ],
			priorityETC1S: 2,
			priorityUASTC: 4,
			needsPowerOfTwo: false,
		},
		{
			if: 'pvrtcSupported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
			transcoderFormat: [ TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA ],
			engineFormat: [ EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format ],
			priorityETC1S: 5,
			priorityUASTC: 6,
			needsPowerOfTwo: true,
		},
	];

	const ETC1S_OPTIONS = FORMAT_OPTIONS.sort( function ( a, b ) {

		return a.priorityETC1S - b.priorityETC1S;

	} );
	const UASTC_OPTIONS = FORMAT_OPTIONS.sort( function ( a, b ) {

		return a.priorityUASTC - b.priorityUASTC;

	} );

	function getTranscoderFormat( basisFormat, width, height, hasAlpha ) {

		let transcoderFormat;
		let engineFormat;

		const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;

		for ( let i = 0; i < options.length; i ++ ) {

			const opt = options[ i ];

			if ( ! config[ opt.if ] ) continue;
			if ( ! opt.basisFormat.includes( basisFormat ) ) continue;
			if ( hasAlpha && opt.transcoderFormat.length < 2 ) continue;
			if ( opt.needsPowerOfTwo && ! ( isPowerOfTwo( width ) && isPowerOfTwo( height ) ) ) continue;

			transcoderFormat = opt.transcoderFormat[ hasAlpha ? 1 : 0 ];
			engineFormat = opt.engineFormat[ hasAlpha ? 1 : 0 ];

			return { transcoderFormat, engineFormat };

		}

		console.warn( 'THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.' );

		transcoderFormat = TranscoderFormat.RGBA32;
		engineFormat = EngineFormat.RGBAFormat;

		return { transcoderFormat, engineFormat };

	}

	function isPowerOfTwo( value ) {

		if ( value <= 2 ) return true;

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	}

	/** Concatenates N byte arrays. */
	function concat( arrays ) {

		if ( arrays.length === 1 ) return arrays[ 0 ];

		let totalByteLength = 0;

		for ( let i = 0; i < arrays.length; i ++ ) {

			const array = arrays[ i ];
			totalByteLength += array.byteLength;

		}

		const result = new Uint8Array( totalByteLength );

		let byteOffset = 0;

		for ( let i = 0; i < arrays.length; i ++ ) {

			const array = arrays[ i ];
			result.set( array, byteOffset );

			byteOffset += array.byteLength;

		}

		return result;

	}

}`;
const PN = /* @__PURE__ */ new Set([ei, bl, ao]), Im = {
  [_S]: ei,
  [AS]: ei,
  [pS]: ei,
  [fS]: ei,
  [vS]: bl,
  [gS]: bl,
  [uS]: bl,
  [dS]: bl,
  [yS]: ao,
  [mS]: ao,
  [hS]: ao,
  [cS]: ao,
  [wS]: Jd,
  [xS]: Jd
}, Dm = {
  [_S]: Xt,
  [AS]: Qt,
  [pS]: Ft,
  [fS]: Ft,
  [vS]: Xt,
  [gS]: Qt,
  [uS]: Ft,
  [dS]: Ft,
  [yS]: Xt,
  [mS]: Qt,
  [hS]: Ft,
  [cS]: Ft,
  [wS]: Ft,
  [xS]: Ft
};
async function LN(s) {
  const { vkFormat: e } = s;
  if (Im[e] === void 0)
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  let t;
  s.supercompressionScheme === Ix && (Tm || (Tm = new Promise(async (r) => {
    const a = new BN();
    await a.init(), r(a);
  })), t = await Tm);
  const i = [];
  for (let r = 0; r < s.levels.length; r++) {
    const a = Math.max(1, s.pixelWidth >> r), o = Math.max(1, s.pixelHeight >> r), l = s.pixelDepth ? Math.max(1, s.pixelDepth >> r) : 0, c = s.levels[r];
    let h;
    if (s.supercompressionScheme === bN)
      h = c.levelData;
    else if (s.supercompressionScheme === Ix)
      h = t.decode(c.levelData, c.uncompressedByteLength);
    else
      throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
    let u;
    Dm[e] === Xt ? u = new Float32Array(
      h.buffer,
      h.byteOffset,
      h.byteLength / Float32Array.BYTES_PER_ELEMENT
    ) : Dm[e] === Qt ? u = new Uint16Array(
      h.buffer,
      h.byteOffset,
      h.byteLength / Uint16Array.BYTES_PER_ELEMENT
    ) : u = h, i.push({
      data: u,
      width: a,
      height: o,
      depth: l
    });
  }
  let n;
  if (PN.has(Im[e]))
    n = s.pixelDepth === 0 ? new Wr(i[0].data, s.pixelWidth, s.pixelHeight) : new lA(i[0].data, s.pixelWidth, s.pixelHeight, s.pixelDepth);
  else {
    if (s.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
    n = new ba(i, s.pixelWidth, s.pixelHeight);
  }
  return n.mipmaps = i, n.type = Dm[e], n.format = Im[e], n.colorSpace = ES(s), n.needsUpdate = !0, Promise.resolve(n);
}
function ES(s) {
  const e = s.dataFormatDescriptor[0];
  return e.colorPrimaries === MN ? e.transferFunction === Dx ? dt : Mt : e.colorPrimaries === TN ? e.transferFunction === Dx ? su : ru : (e.colorPrimaries === CN || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`), Wt);
}
const Nl = class Nl extends Gc {
  constructor() {
    super(...arguments), this._importer = new $i(UN, ["ktx2"], ["image/ktx2"], !1);
  }
  onAdded(e) {
    var t, i;
    this._importer.onCtor = (n) => n.setTranscoderPath(Nl.TRANSCODER_LIBRARY_PATH).detectSupport(e.renderManager.renderer), super.onAdded(e), (i = (t = e.assetManager.exporter.getExporter("gltf", "glb")) == null ? void 0 : t.extensions) == null || i.push(Lx);
  }
  onRemove(e) {
    var n, r;
    super.onRemove(e);
    const t = e.assetManager.exporter.getExporter("gltf", "glb"), i = (n = t == null ? void 0 : t.extensions) == null ? void 0 : n.indexOf(Lx);
    i !== void 0 && i !== -1 && ((r = t == null ? void 0 : t.extensions) == null || r.splice(i, 1));
  }
};
Nl.PluginType = "KTX2LoadPlugin", Nl.TRANSCODER_LIBRARY_PATH = "https://cdn.jsdelivr.net/gh/BinomialLLC/basis_universal@1.16.4/webgl/transcoder/build/", Nl.SAVE_SOURCE_BLOBS = !1;
let Tp = Nl;
class UN extends ur {
  _initTexture(e) {
    tb.call(e), e.userData.mimeType = "image/ktx2", e.toJSON = (i) => BB(e, i, e.name, "image/ktx2");
    const t = e.clone;
    return e.clone = () => {
      const i = t.call(e);
      return i.source !== e.source && (i.source._sourceImgBuffer = e.source._sourceImgBuffer), this._initTexture(i);
    }, e;
  }
  async createTexture(e, t) {
    const i = Tp.SAVE_SOURCE_BLOBS ? new Uint8Array(e.slice(0)) : void 0, n = await super.createTexture(e, t);
    return Tp.SAVE_SOURCE_BLOBS && i && (n.source._sourceImgBuffer = i, n.source._canSerialize = !0), this._initTexture(n), n;
  }
}
const Px = "KHR_texture_basisu", Lx = (s) => ({
  writeTexture: (e, t) => {
    if (e.userData.mimeType !== "image/ktx2") return;
    if (t.source !== void 0 && t.source !== null) {
      console.warn("ktx2 export: source already set");
      return;
    }
    const i = e.source._sourceImgBuffer || e.__sourceBuffer;
    if (!i) {
      console.warn("ktx2 export: no source buffer for ktx2");
      return;
    }
    t.extensions = t.extensions || {};
    const n = {}, r = new Blob([i], { type: "image/ktx2" });
    n.source = s.processImageBlob(r, e), t.extensions[Px] = n, s.extensionsUsed[Px] = !0;
  }
}), Ph = class Ph extends Xw {
  constructor(e = !0, t = document.head) {
    super(), this.rootNode = t, this.enabled = !0, this.toJSON = void 0, this._initializing = void 0, e && this.initialize();
  }
  get initialized() {
    return !!window.MeshoptDecoder;
  }
  async initialize() {
    if (this.initialized) return;
    if (this._initializing) return await this._initializing;
    const e = document.createElement("script");
    e.type = "module";
    const t = Math.random().toString(36).substring(7);
    e.innerHTML = `
import { MeshoptDecoder } from '${Ph.DECODER_URL}';
window.MeshoptDecoder = MeshoptDecoder; // setting it before ready as GLTFLoader supports it.
MeshoptDecoder.ready.then(() => {
window.dispatchEvent(new CustomEvent('${t}'))
});
`, this._initializing = new Promise((i) => {
      window.addEventListener(t, () => i(), { once: !0 }), this.rootNode.appendChild(e), this._script = e;
    }), await this._initializing, this.dispatchEvent({ type: "initialized" });
  }
  dispose() {
    this._script && (this._script.remove(), delete window.MeshoptDecoder), this._script = void 0;
  }
  onAdded() {
  }
  onRemove() {
  }
};
Ph.PluginType = "GLTFMeshOptDecodePlugin", Ph.DECODER_URL = "https://unpkg.com/meshoptimizer@0.20.0/meshopt_decoder.module.js";
let Ux = Ph;
var FN = Object.defineProperty, ON = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && FN(e, t, n), n;
};
const Qy = class Qy extends Tt {
  constructor() {
    super(), this.enabled = !0, this.exportOptions = {
      name: "scene",
      viewerConfig: !0,
      encodeUint16Rgbe: !1,
      convertMeshToIndexed: !1,
      embedUrlImagePreviews: !1,
      embedUrlImages: !1,
      encrypt: !1,
      encryptKey: "",
      ignoreInvalidMorphTargetTracks: !0,
      ignoreEmptyTextures: !0
    }, this.uiConfig = {
      type: "folder",
      label: "Asset Export",
      expanded: !0,
      children: [
        {
          type: "input",
          property: [this.exportOptions, "name"]
        },
        {
          type: "folder",
          label: "GLB Export",
          expanded: !0,
          children: [
            {
              type: "checkbox",
              label: "Viewer Config (All Settings)",
              property: [this.exportOptions, "viewerConfig"],
              onChange: () => {
                var e, t;
                return (t = (e = this.uiConfig).uiRefresh) == null ? void 0 : t.call(e, !0);
              }
            },
            {
              type: "checkbox",
              label: "Embed Image Previews",
              property: [this.exportOptions, "embedUrlImagePreviews"]
            },
            {
              type: "checkbox",
              label: "Encrypt",
              property: [this.exportOptions, "encrypt"],
              onChange: () => {
                var e, t;
                return (t = (e = this.uiConfig).uiRefresh) == null ? void 0 : t.call(e, !0);
              }
            },
            {
              type: "input",
              label: "Encrypt Password",
              hidden: () => !this.exportOptions.encrypt,
              property: [this.exportOptions, "encryptKey"]
            },
            {
              type: "checkbox",
              label: "Compress hdr env maps",
              hidden: () => !this.exportOptions.viewerConfig,
              property: [this.exportOptions, "encodeUint16Rgbe"]
            },
            // { // todo
            //     type: 'checkbox',
            //     label: 'Convert to indexed',
            //     property: [this.exportOptions, 'convertMeshToIndexed'],
            // },
            {
              type: "checkbox",
              label: "Ignore invalid animations",
              property: [this.exportOptions, "ignoreInvalidMorphTargetTracks"]
            },
            {
              type: "checkbox",
              label: "Ignore invalid textures",
              property: [this.exportOptions, "ignoreInvalidTextures"]
            },
            {
              type: "button",
              label: "Export GLB",
              property: [this, "downloadSceneGlb"]
            }
          ]
        },
        {
          type: "button",
          label: "Export Config",
          value: async () => {
            var t, i;
            const e = new Blob([JSON.stringify((t = this._viewer) == null ? void 0 : t.exportConfig(!1), null, 2)], { type: "application/json" });
            e && await ((i = this._viewer) == null ? void 0 : i.exportBlob(e, this.exportOptions.name + "." + $t.ConfigTypeSlug));
          }
        },
        {
          type: "button",
          label: "Export Selected",
          hidden: () => {
            var e;
            return !((e = this._viewer) != null && e.getPlugin("PickingPlugin"));
          },
          value: async () => this.exportSelected(this.exportOptions, !0)
        }
      ]
    }, this.exportScene = this.exportScene.bind(this);
  }
  onAdded(e) {
    super.onAdded(e);
  }
  onRemove(e) {
    return super.onRemove(e);
  }
  async exportScene(e) {
    var t, i, n;
    return (n = (t = this._viewer) == null ? void 0 : t.assetManager.exporter) == null ? void 0 : n.exportObject((i = this._viewer) == null ? void 0 : i.scene.modelRoot, e || { ...this.exportOptions });
  }
  async downloadSceneGlb() {
    var t;
    const e = await this.exportScene(this.exportOptions);
    e && await ((t = this._viewer) == null ? void 0 : t.exportBlob(e, this.exportOptions.name + "." + e.ext));
  }
  async exportSelected(e, t = !0) {
    var r, a, o;
    const i = (a = (r = this._viewer) == null ? void 0 : r.getPlugin("PickingPlugin")) == null ? void 0 : a.getSelectedObject();
    if (!i) {
      alert("Nothing selected");
      return;
    }
    const n = await this._viewer.assetManager.exporter.exportObject(i, e ?? this.exportOptions);
    return n && t && await ((o = this._viewer) == null ? void 0 : o.exportBlob(n, "object." + n.ext)), n;
  }
};
Qy.PluginType = "AssetExporterPlugin";
let Xg = Qy;
ON([
  V()
], Xg.prototype, "exportOptions");
var NN = Object.defineProperty, kN = Object.getOwnPropertyDescriptor, zc = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? kN(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && NN(e, t, n), n;
};
let Ks = class extends Tt {
  constructor() {
    super(), this.enabled = !0, this.filename = "snapshot", this._downloading = !1, this.defaultOptions = {
      waitForProgressive: !0,
      displayPixelRatio: window.devicePixelRatio,
      scale: 1,
      timeout: 0,
      quality: 0.9,
      tileRows: 1,
      tileColumns: 1,
      progressiveFrames: 64,
      rect: {
        x: 0,
        y: 0,
        width: 1,
        height: 1,
        normalized: !0,
        assumeClientRect: !1
      }
    }, this.downloadSnapshot = this.downloadSnapshot.bind(this);
  }
  /**
   * Returns a File object with screenshot of the viewer canvas
   * @param filename default is {@link CanvasSnapshotPlugin.filename}
   * @param options waitForProgressive: wait for progressive rendering to finish, default: true
   */
  async getFile(s, e = { waitForProgressive: !0 }) {
    return await this._getFile(s || this.filename, { ...e, getDataUrl: !1 });
  }
  /**
   * Returns a data url of the screenshot of the viewer canvas
   * @param options waitForProgressive: wait for progressive rendering to finish, default: true
   */
  async getDataUrl(s = {}) {
    return await this._getFile("", { ...s, getDataUrl: !0 }) ?? "";
  }
  async _getFile(s, e = {}) {
    var c, h;
    await ((c = this._viewer) == null ? void 0 : c.doOnce("postFrame"));
    const t = this._viewer, i = (h = this._viewer) == null ? void 0 : h.canvas;
    if (!t || !i) return;
    t.scene.mainCamera.setInteractions(!1, Ks.PluginType);
    const n = t.renderManager.renderScale;
    e.displayPixelRatio !== void 0 && e.displayPixelRatio !== n && (t.renderManager.renderScale = e.displayPixelRatio), e.timeout && await bs(e.timeout);
    const r = t.getPlugin(vr);
    let a = e.waitForProgressive ?? !!r;
    a && !r && (t.console.warn("CanvasSnapshotPlugin: ProgressivePlugin required to wait for progressive rendering"), a = !1), e.progressiveFrames && !a && t.console.warn("CanvasSnapshotPlugin: waitForProgressive must be true to use progressiveFrames");
    const o = r == null ? void 0 : r.maxFrameCount;
    if (a && r)
      for (r.maxFrameCount = Math.max(e.progressiveFrames ?? 64, r.maxFrameCount), t.setDirty(), await t.doOnce("postFrame"); !r.isConverged(!0); )
        await t.doOnce("postFrame");
    else
      t.setDirty(), await t.doOnce("postFrame");
    delete e.displayPixelRatio;
    let l;
    if (e.tileRows && e.tileRows > 1 || e.tileColumns && e.tileColumns > 1) {
      const u = await dp.GetTiledFiles(i, s, Math.max(1, e.tileRows || 1), Math.max(1, e.tileColumns || 1), e);
      if (Array.isArray(u))
        if (u.length === 1) l = u[0];
        else if (u.length === 0) l = void 0;
        else if (e.getDataUrl)
          l = u;
        else {
          const d = {};
          for (const f of u)
            d[f.name] = new Uint8Array(await f.arrayBuffer());
          const p = Nb(d);
          l = new File([p], s + ".zip", { type: "application/zip", lastModified: Date.now() });
        }
      else
        l = u;
    } else
      l = await dp.GetFile(i, s, e);
    return e.displayPixelRatio = t.renderManager.renderScale, r && o !== void 0 && (r.maxFrameCount = o), t.scene.mainCamera.setInteractions(!0, Ks.PluginType, !1), t.renderManager.renderScale = n, l;
  }
  // @uiButton('Download .png', {sendArgs: false})
  async downloadSnapshot(s, e = { waitForProgressive: !0 }) {
    if (!this._viewer) return;
    for (; this._downloading; )
      console.warn("CanvasSnipperPlugin: Another rendering already in progress, waiting..."), await bs(100);
    this._downloading = !0;
    const t = await this.getFile(s, { ...this.defaultOptions, ...e }).catch((i) => {
      var n;
      return (n = this._viewer) == null || n.console.error("CanvasSnapshotPlugin: Error exporting file", i), null;
    });
    t && await this._viewer.exportBlob(t, t.name), this._downloading = !1;
  }
  async _downloadPng() {
    return this.downloadSnapshot(void 0, { mimeType: "image/png" });
  }
  async _downloadJpeg() {
    return this.downloadSnapshot(void 0, { mimeType: "image/jpeg" });
  }
  async _downloadWebp() {
    return this.downloadSnapshot(void 0, { mimeType: "image/webp" });
  }
};
Ks.PluginType = "CanvasSnapshotPlugin";
zc([
  pt("Filename"),
  V()
], Ks.prototype, "filename", 2);
zc([
  Ki(),
  V()
], Ks.prototype, "defaultOptions", 2);
zc([
  Pt("Download .png")
], Ks.prototype, "_downloadPng", 1);
zc([
  Pt("Download .jpeg")
], Ks.prototype, "_downloadJpeg", 1);
zc([
  Pt("Download .webp")
], Ks.prototype, "_downloadWebp", 1);
Ks = zc([
  Lt("Image Export (Canvas Snapshot)")
], Ks);
const Hy = class Hy extends Ks {
  constructor() {
    super(), console.warn("CanvasSnipperPlugin is deprecated, use CanvasSnapshotPlugin");
  }
};
Hy.PluginType = "CanvasSnipper";
let Fx = Hy;
const Vy = class Vy extends Tt {
  constructor() {
    super(), this.enabled = !0, this.toJSON = void 0, this.defaultActions = {
      exportFile: async (e, t, i) => {
        jp(e, t);
      }
    }, this.actions = { ...this.defaultActions }, this._updateProcessState = this._updateProcessState.bind(this);
  }
  async exportFile(e, t) {
    t = t || e.name || "file_export", this.dispatchEvent({ type: "transferFile", path: t, state: "exporting", progress: 0 }), await this.actions.exportFile(e, t, ({ state: i, progress: n }) => {
      this.dispatchEvent({ type: "transferFile", path: t, state: i ?? "exporting", progress: n });
    }), this.dispatchEvent({ type: "transferFile", path: t, state: "done" });
  }
  onAdded(e) {
    super.onAdded(e), this.addEventListener("transferFile", this._updateProcessState);
  }
  onRemove(e) {
    this.removeEventListener("transferFile", this._updateProcessState), super.onRemove(e);
  }
  _updateProcessState(e) {
    this._viewer && this._viewer.assetManager.setProcessState(e.path, e.state !== "done" ? {
      state: e.state,
      progress: e.progress ? e.progress * 100 : void 0
    } : void 0);
  }
};
Vy.PluginType = "FileTransferPlugin";
let Ox = Vy;
const GN = "vec4 Vignette(in vec4 color){vec2 uv=vUv*(1.0-vUv);float vig=uv.x*uv.y*16.0;vig=pow(vig,power);return vec4(mix(color.rgb,vec3(bgcolor),1.-vig),color.a);}";
var zN = Object.defineProperty, QN = Object.getOwnPropertyDescriptor, uf = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? QN(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && zN(e, t, n), n;
};
let Ro = class extends of {
  constructor(s = !0) {
    super(), this.extraUniforms = {
      power: { value: 1 },
      bgcolor: { value: new se() }
    }, this.power = 0.5, this.color = new se(0), this.priority = -50, this.parsFragmentSnippet = () => this.isDisabled() ? "" : Oa`
            uniform float power;
            uniform vec3 bgcolor;
            ${GN}
        `, this._shaderPatch = "diffuseColor = Vignette(diffuseColor);", this.enabled = s;
  }
  /**
   * @deprecated
   */
  get bgcolor() {
    return console.warn("VignettePlugin.bgcolor is deprecated, use VignettePlugin.color instead"), this.color;
  }
  /**
   * @deprecated
   */
  set bgcolor(s) {
    console.warn("VignettePlugin.bgcolor is deprecated, use VignettePlugin.color instead"), this.color = s;
  }
};
Ro.PluginType = "Vignette";
uf([
  Oe(Ro.prototype.setDirty),
  ue("Enable"),
  V()
], Ro.prototype, "enabled", 2);
uf([
  Ye("Power", [0.1, 4], 0.01),
  Qo({ propKey: "power" }),
  V()
], Ro.prototype, "power", 2);
uf([
  wr("Color", (s) => ({ onChange: () => s == null ? void 0 : s.setDirty() })),
  Qo({ propKey: "bgcolor" }),
  V("bgcolor")
], Ro.prototype, "color", 2);
Ro = uf([
  Lt("Vignette")
], Ro);
const HN = "vec4 ChromaticAberration(in vec4 color){vec2 distFromCenter=vUv-0.5;vec2 aberrated=aberrationIntensity*pow(abs(distFromCenter),vec2(2.0));vec4 outColor=vec4(tDiffuseTexelToLinear(texture2D(tDiffuse,vUv+aberrated)).r,color.g,tDiffuseTexelToLinear(texture2D(tDiffuse,vUv-aberrated)).b,color.a);return outColor;}";
var VN = Object.defineProperty, WN = Object.getOwnPropertyDescriptor, xy = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? WN(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && VN(e, t, n), n;
};
let Ac = class extends of {
  constructor(s = !0) {
    super(), this.extraUniforms = {
      aberrationIntensity: { value: 1 }
    }, this.intensity = 0.5, this.priority = -50, this.parsFragmentSnippet = () => this.isDisabled() ? "" : Oa`
            uniform float aberrationIntensity;
            ${HN}
        `, this._shaderPatch = "diffuseColor = ChromaticAberration(diffuseColor);", this.enabled = s;
  }
  get aberrationIntensity() {
    return console.warn("ChromaticAberrationPlugin.aberrationIntensity is deprecated, use ChromaticAberrationPlugin.intensity instead"), this.intensity;
  }
  set aberrationIntensity(s) {
    console.warn("ChromaticAberrationPlugin.aberrationIntensity is deprecated, use ChromaticAberrationPlugin.intensity instead"), this.intensity = s;
  }
};
Ac.PluginType = "ChromaticAberration";
xy([
  Oe(Ac.prototype.setDirty),
  ue("Enable"),
  V()
], Ac.prototype, "enabled", 2);
xy([
  Ye("Intensity", [0, 0.3], 1e-3),
  Qo({ propKey: "aberrationIntensity" }),
  V("aberrationIntensity")
], Ac.prototype, "intensity", 2);
Ac = xy([
  Lt("ChromaticAberration")
], Ac);
const jN = "vec4 FilmicGrain(in vec4 color){float x=(vUv.x+4.0)*(vUv.y+4.0)*(10.0);vec4 grain=vec4(mod((mod(x,13.0)+1.0)*(mod(x,123.0)+1.0),0.01)-0.005)*grainIntensity;return vec4(grainMultiply ?(color.rgb*vec3(1.-grain)):(color.rgb+vec3(grain)),color.a);}";
var qN = Object.defineProperty, XN = Object.getOwnPropertyDescriptor, df = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? XN(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && qN(e, t, n), n;
};
let Bo = class extends of {
  constructor(s = !0) {
    super(), this.extraUniforms = {
      grainIntensity: { value: 1 },
      grainMultiply: { value: !1 }
    }, this.intensity = 10, this.multiply = !1, this.priority = -50, this.parsFragmentSnippet = () => this.isDisabled() ? "" : Oa`
            uniform float grainIntensity;
            uniform bool grainMultiply;
            ${jN}
        `, this._shaderPatch = "diffuseColor = FilmicGrain(diffuseColor);", this.enabled = s;
  }
  get grainIntensity() {
    return console.warn("FilmicGrainPlugin.grainIntensity is deprecated, use FilmicGrainPlugin.intensity instead"), this.intensity;
  }
  set grainIntensity(s) {
    console.warn("FilmicGrainPlugin.grainIntensity is deprecated, use FilmicGrainPlugin.intensity instead"), this.intensity = s;
  }
};
Bo.PluginType = "FilmicGrain";
df([
  Oe(Bo.prototype.setDirty),
  ue("Enable"),
  V()
], Bo.prototype, "enabled", 2);
df([
  Ye("Intensity", [0, 20], 0.01),
  Qo({ propKey: "grainIntensity" }),
  V("grainIntensity")
], Bo.prototype, "intensity", 2);
df([
  ue("Multiply"),
  Qo({ propKey: "grainMultiply" }),
  V("grainMultiply")
], Bo.prototype, "multiply", 2);
Bo = df([
  Lt("FilmicGrain")
], Bo);
var YN = Object.defineProperty, KN = Object.getOwnPropertyDescriptor, Ui = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? KN(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && YN(e, t, n), n;
};
let li = class extends Tt {
  constructor() {
    super(), this.enabled = !0, this.animations = [], this.autoIncrementTime = !0, this.loopAnimations = !0, this.loopRepetitions = 1 / 0, this.timeScale = 1, this.animationSpeed = 1, this.animateOnScroll = !1, this.scrollAnimationDamping = 0.1, this.animateOnPageScroll = !1, this.pageScrollAnimationDamping = 0.1, this.animateOnDrag = !1, this.dragAxis = "y", this.dragAnimationDamping = 0.3, this.autoplayOnLoad = !1, this.syncMaxDuration = !1, this._animationState = "none", this._lastAnimationTime = 0, this._animationTime = 0, this._animationDuration = 0, this._scrollAnimationState = 0, this._pageScrollAnimationState = 0, this._dragAnimationState = 0, this._pointerDragHelper = new OR(), this._lastFrameTime = 0, this._fadeDisabled = !1, this._lastAnimId = "", this._objectAdded = (s) => {
      var n;
      const e = s.object;
      if (!this._viewer) return;
      let t = !1;
      const i = (n = s.options) == null ? void 0 : n.addToRoot;
      e.traverse((r) => {
        if (!this._viewer) return;
        const a = r.animations;
        if (a.length < 1) return;
        const o = Math.max(...a.map((h) => h.duration));
        (e.userData.gltfAnim_SyncMaxDuration ?? this.syncMaxDuration) && (a.forEach((h) => h.duration = o), e.userData.gltfAnim_SyncMaxDuration = !0);
        const l = new PR(i ? this._viewer.scene : this._viewer.scene.modelRoot), c = a.map((h) => l.clipAction(h).setLoop(this.loopAnimations ? qm : jm, this.loopRepetitions));
        c.forEach((h) => h.clampWhenFinished = !0), this.animations.push({
          mixer: l,
          clips: a,
          actions: c,
          duration: o
        }), t = !0;
      }), t && (this._onPropertyChange(!this.autoplayOnLoad), this.autoplayOnLoad && this.playAnimation());
    }, this.pageScrollHeight = () => Math.max(
      document.body.scrollHeight,
      document.body.offsetHeight,
      document.documentElement.clientHeight,
      document.documentElement.scrollHeight,
      document.documentElement.offsetHeight
    ) - window.innerHeight, this.playClips = this.playClips.bind(this), this.playClip = this.playClip.bind(this), this.playAnimation = this.playAnimation.bind(this), this.playPauseAnimation = this.playPauseAnimation.bind(this), this.pauseAnimation = this.pauseAnimation.bind(this), this.stopAnimation = this.stopAnimation.bind(this), this.resetAnimation = this.resetAnimation.bind(this), this._onPropertyChange = this._onPropertyChange.bind(this), this._postFrame = this._postFrame.bind(this), this._wheel = this._wheel.bind(this), this._scroll = this._scroll.bind(this), this._pointerDragHelper.addEventListener("drag", this._drag.bind(this));
  }
  get animationState() {
    return this._animationState;
  }
  get animationTime() {
    return this._animationTime;
  }
  get animationDuration() {
    return this._animationDuration;
  }
  playPauseAnimation() {
    this._animationState === "playing" ? this.pauseAnimation() : this.playAnimation();
  }
  setTime(s) {
    this._animationTime = Math.max(0, Math.min(s, this._animationDuration));
  }
  onAdded(s) {
    super.onAdded(s), s.scene.addEventListener("addSceneObject", this._objectAdded), s.addEventListener("postFrame", this._postFrame), window.addEventListener("wheel", this._wheel), window.addEventListener("scroll", this._scroll), this._pointerDragHelper.element = s.canvas;
  }
  onRemove(s) {
    for (; this.animations.length; ) this.animations.pop();
    return s.scene.removeEventListener("addSceneObject", this._objectAdded), s.removeEventListener("postFrame", this._postFrame), window.removeEventListener("wheel", this._wheel), window.removeEventListener("scroll", this._scroll), this._pointerDragHelper.element = void 0, super.onRemove(s);
  }
  onStateChange() {
    var s, e;
    (e = (s = this.uiConfig) == null ? void 0 : s.uiRefresh) == null || e.call(s, !0, "postFrame");
  }
  /**
   * This will play a single clip by name
   * It might reset all other animations, this is a bug; https://codepen.io/repalash/pen/mdjgpvx
   * @param name
   * @param resetOnEnd
   */
  async playClip(s, e = !1) {
    return this.playClips([s], e);
  }
  async playClips(s, e = !1) {
    const t = [];
    return this.animations.forEach(({ actions: i }) => {
      i.forEach((n) => {
        s.includes(n.getClip().name) && t.push(n);
      });
    }), this.playAnimation(e, t);
  }
  /**
   * Starts all the animations and returns a promise that resolves when all animations are done.
   * @param resetOnEnd - if true, will reset the animation to the start position when it ends.
   * @param animations - play specific animations, otherwise play all animations. Note: the promise returned (if this is set) from this will resolve before time if the animations was ever paused, or converged mode is on in recorder.
   */
  async playAnimation(s = !1, e) {
    var a;
    if (this.isDisabled()) return;
    let t = !1;
    this._animationState === "playing" && (this.stopAnimation(!1), t = !0);
    let i = 0;
    const n = !e;
    e || (e = [], this.animations.forEach(({ actions: o }) => {
      e.push(...o);
    })), t ? this.resetAnimation() : this.animationState !== "paused" && (e.forEach((o) => {
      o.reset();
    }), this._animationTime = 0);
    const r = Ss();
    this._lastAnimId = r;
    for (const o of e)
      o.setLoop(this.loopAnimations ? qm : jm, this.loopRepetitions), o.play(), i = Math.max(i, o.getClip().duration / Math.abs(o.timeScale));
    if (this._animationState = "playing", (a = this._viewer) == null || a.setDirty(), n) {
      if (!isFinite(this._animationDuration))
        return;
      await new Promise((o) => {
        const l = () => {
          this.removeEventListener("checkpointEnd", l), o();
        };
        this.addEventListener("checkpointEnd", l);
      });
    } else {
      const o = this.loopAnimations ? this.loopRepetitions : 1;
      if (i *= o, !isFinite(i))
        return;
      await new Promise((l) => {
        const c = (h) => {
          h.time >= i && (this.removeEventListener("animationStep", c), l());
        };
        this.addEventListener("animationStep", c);
      });
    }
    r === this._lastAnimId && this.stopAnimation(s);
  }
  pauseAnimation() {
    var s;
    if (this._animationState !== "playing") {
      console.warn("pauseAnimation called when animation was not playing.");
      return;
    }
    this._animationState = "paused", (s = this._viewer) == null || s.setDirty();
  }
  resumeAnimation() {
    var s;
    if (this._animationState !== "paused") {
      console.warn("resumeAnimation called when animation was not paused.");
      return;
    }
    this._animationState = "playing", (s = this._viewer) == null || s.setDirty();
  }
  stopAnimation(s = !1) {
    var e, t;
    this._animationState = "stopped", s ? this.resetAnimation() : (e = this._viewer) == null || e.setDirty(), this._lastAnimId = "", this._viewer && this._fadeDisabled && ((t = this._viewer.getPlugin("FrameFade")) == null || t.enable(this), this._fadeDisabled = !1);
  }
  resetAnimation() {
    var s;
    if (this._animationState !== "stopped" && this._animationState !== "none") {
      this.stopAnimation(!0);
      return;
    }
    this.animations.forEach(({ mixer: e }) => {
      e.stopAllAction(), e.setTime(0);
    }), this._animationTime = 0, (s = this._viewer) == null || s.setDirty();
  }
  _postFrame() {
    var r, a;
    if (!this._viewer) return;
    const s = this.animateOnScroll, e = this.animateOnPageScroll, t = this.animateOnDrag;
    if (this.isDisabled() || this.animations.length < 1 || this._animationState !== "playing" && !s && !t && !e) {
      this._lastFrameTime = 0, this._fadeDisabled && ((r = this._viewer.getPlugin("FrameFade")) == null || r.enable(this), this._fadeDisabled = !1);
      return;
    }
    if (this._animationTime < 1e-4 && this.dispatchEvent({ type: "checkpointBegin" }), this.autoIncrementTime) {
      const o = zn() / 1e3;
      this._lastFrameTime < 1 && (this._lastFrameTime = o - 1 / 30);
      let l = o - this._lastFrameTime;
      if (l *= this.animationSpeed, this._lastFrameTime = o, e ? l *= this._pageScrollAnimationState : s && t ? l *= pB(this._scrollAnimationState, this._dragAnimationState) : s ? l *= this._scrollAnimationState : t && (l *= this._dragAnimationState), Math.abs(l) < 1e-4) return;
      const c = (a = this._viewer.getPlugin("Progressive")) == null ? void 0 : a.postFrameConvergedRecordingDelta();
      if (c && c > 0 && (l = c), c === 0) return;
      const h = Math.abs(this.timeScale);
      this._animationTime += l * (h > 0 ? h : 1);
    }
    const i = this._animationTime - this._lastAnimationTime;
    this._lastAnimationTime = this._animationTime;
    const n = this.timeScale < 0 ? (isFinite(this._animationDuration) ? this._animationDuration : 0) - this._animationTime : this._animationTime;
    if (this.animations.map((o) => {
      o.mixer.setTime(n);
    }), !(Math.abs(i) < 1e-5)) {
      if (this._pageScrollAnimationState = this.pageScrollTime - this._animationTime, Math.abs(this._pageScrollAnimationState) < 1e-3 ? this._pageScrollAnimationState = 0 : this._pageScrollAnimationState *= 1 - this.pageScrollAnimationDamping, Math.abs(this._scrollAnimationState) < 1e-3 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping, Math.abs(this._dragAnimationState) < 1e-3 ? this._dragAnimationState = 0 : this._dragAnimationState *= 1 - this.dragAnimationDamping, this.dispatchEvent({ type: "animationStep", delta: i, time: n }), this._viewer.renderManager.resetShadows(), this._viewer.setDirty(), !this._fadeDisabled) {
        const o = this._viewer.getPlugin("FrameFade");
        o && (o.disable(li.PluginType), this._fadeDisabled = !0);
      }
      this._animationTime >= this._animationDuration && this.dispatchEvent({ type: "checkpointEnd" });
    }
  }
  _onPropertyChange(s = !0) {
    this._animationDuration = Math.max(...this.animations.map(({ duration: e }) => e)) * (this.loopAnimations ? this.loopRepetitions : 1), this._animationState === "playing" && s && this.playAnimation();
  }
  get pageScrollTime() {
    const s = this.pageScrollHeight();
    return window.scrollY / s * (this.animationDuration - 0.05);
  }
  _scroll() {
    this.isDisabled() || (this._pageScrollAnimationState = this.pageScrollTime - this.animationTime);
  }
  _wheel({ deltaY: s }) {
    this.isDisabled() || Math.abs(s) > 1e-3 && (this._scrollAnimationState = -1 * Math.sign(s));
  }
  _drag(s) {
    this.isDisabled() || !this._viewer || (this._dragAnimationState = this.dragAxis === "x" ? s.delta.x * this._viewer.canvas.width / 4 : s.delta.y * this._viewer.canvas.height / 4);
  }
};
li.PluginType = "GLTFAnimation";
Ui([
  V()
], li.prototype, "autoIncrementTime", 2);
Ui([
  Pi(li.prototype._onPropertyChange),
  ue("Loop"),
  V()
], li.prototype, "loopAnimations", 2);
Ui([
  Pi(li.prototype._onPropertyChange),
  V()
], li.prototype, "loopRepetitions", 2);
Ui([
  Ye("Timescale", [-2, 2], 0.01),
  V()
], li.prototype, "timeScale", 2);
Ui([
  Ye("Speed", [0.1, 4], 0.1),
  V()
], li.prototype, "animationSpeed", 2);
Ui([
  ue(),
  V()
], li.prototype, "animateOnScroll", 2);
Ui([
  Ye("Scroll Damping", [0, 1]),
  V()
], li.prototype, "scrollAnimationDamping", 2);
Ui([
  ue(),
  V()
], li.prototype, "animateOnPageScroll", 2);
Ui([
  Ye("Page Scroll Damping", [0, 1]),
  V()
], li.prototype, "pageScrollAnimationDamping", 2);
Ui([
  ue(),
  V()
], li.prototype, "animateOnDrag", 2);
Ui([
  er("Drag Axis", [{ label: "x" }, { label: "y" }]),
  V()
], li.prototype, "dragAxis", 2);
Ui([
  Ye("Drag Damping", [0, 1]),
  V()
], li.prototype, "dragAnimationDamping", 2);
Ui([
  ue(),
  V()
], li.prototype, "autoplayOnLoad", 2);
Ui([
  ue("syncMaxDuration(dev)"),
  V()
], li.prototype, "syncMaxDuration", 2);
Ui([
  Ic()
], li.prototype, "animationState", 1);
Ui([
  Ic()
], li.prototype, "animationTime", 1);
Ui([
  Ic()
], li.prototype, "animationDuration", 1);
Ui([
  Pt("Play/Pause", (s) => ({
    label: () => s.animationState === "playing" ? "Pause" : "Play"
  }))
], li.prototype, "playPauseAnimation", 1);
Ui([
  Oe(li.prototype.onStateChange)
], li.prototype, "_animationState", 2);
Ui([
  Pt("Stop", { sendArgs: !1 })
], li.prototype, "stopAnimation", 1);
Ui([
  Pt("Reset", { sendArgs: !1 })
], li.prototype, "resetAnimation", 1);
li = Ui([
  Lt("GLTF Animations")
], li);
const cs = class cs extends Tt {
  constructor() {
    super(), this.toJSON = void 0, this.enabled = !0, this.dependencies = [fc], this._addSceneObject = (e) => {
      const t = e.object;
      t != null && t.traverse && t.traverse((i) => {
        var r, a, o;
        i.userData[cs.PluginType] || (i.userData[cs.PluginType] = {
          transforms: []
        }), (r = i.userData[cs.PluginType].transforms) == null || r.forEach((l, c) => {
          l.name === void 0 && (l.name = "Transform " + c);
        });
        const n = {
          type: "folder",
          label: "Transform Animation",
          children: [
            {
              type: "button",
              label: "Add Current Transform",
              value: () => {
                var l;
                this.addTransform(i), (l = n == null ? void 0 : n.uiRefresh) == null || l.call(n);
              }
            },
            () => {
              var l;
              return (l = i.userData[cs.PluginType]) == null ? void 0 : l.transforms.map((c, h) => ({
                type: "folder",
                label: c.name || `Transform ${h}`,
                children: [
                  {
                    type: "input",
                    label: "Name",
                    property: [c, "name"]
                  },
                  {
                    type: "vec3",
                    label: "Position",
                    property: [c, "position"]
                  },
                  {
                    type: "vec3",
                    label: "Quaternion",
                    property: [c, "quaternion"]
                  },
                  {
                    type: "vec3",
                    label: "Scale",
                    property: [c, "scale"]
                  },
                  {
                    type: "button",
                    label: "Set",
                    value: () => {
                      this.setTransform(i, c);
                    }
                  },
                  {
                    type: "button",
                    label: "Animate",
                    value: () => {
                      this.animateTransform(i, c);
                    }
                  }
                ]
              }));
            }
          ]
        };
        (o = (a = i.uiConfig) == null ? void 0 : a.children) == null || o.push(n);
      });
    };
  }
  onAdded(e) {
    super.onAdded(e), e.scene.addEventListener("addSceneObject", this._addSceneObject);
  }
  onRemove(e) {
    return e.scene.removeEventListener("addSceneObject", this._addSceneObject), super.onRemove(e);
  }
  addTransform(e, t) {
    e.userData[cs.PluginType] || (e.userData[cs.PluginType] = {
      transforms: []
    });
    const i = {
      name: t || "Transform " + (e.userData[cs.PluginType].transforms.length + 1),
      position: e.position.clone(),
      quaternion: e.quaternion.clone(),
      scale: e.scale.clone()
    };
    return e.userData[cs.PluginType].transforms.push(i), i;
  }
  setTransform(e, t) {
    var n, r, a;
    const i = this.getSavedTransform(t, e);
    i && (e.position.copy(i.position), e.quaternion.copy(i.quaternion), e.scale.copy(i.scale), (n = e.setDirty) == null || n.call(e), (a = (r = e.uiConfig) == null ? void 0 : r.uiRefresh) == null || a.call(r));
  }
  getSavedTransform(e, t) {
    var i, n;
    return typeof e == "number" ? (i = t.userData[cs.PluginType]) == null ? void 0 : i.transforms[e] : typeof e == "string" ? (n = t.userData[cs.PluginType]) == null ? void 0 : n.transforms.find((r) => r.name === e) : e;
  }
  animateTransform(e, t, i = 2e3) {
    var y, A;
    const n = (y = this._viewer) == null ? void 0 : y.getPlugin(fc);
    n || (A = this._viewer) == null || A.console.error("PopmotionPlugin required for animation");
    const r = this.getSavedTransform(t, e);
    if (!r) return;
    const a = new M(), o = new rt(), l = new M(), c = e.position.clone(), h = e.quaternion.clone(), u = e.scale.clone(), d = r.position, p = r.quaternion, f = r.scale;
    return n == null ? void 0 : n.animate({
      from: 0,
      to: 1,
      duration: i,
      onUpdate: (m) => {
        var v, g;
        a.lerpVectors(c, d, m), o.slerpQuaternions(h, p, m), l.lerpVectors(u, f, m), e.position.copy(a), e.quaternion.copy(o), e.scale.copy(l), (v = this._viewer) == null || v.setDirty(), (g = this._viewer) == null || g.renderManager.resetShadows();
      },
      onStop: () => {
        var m, v, g;
        e.position.copy(r.position), e.quaternion.copy(r.quaternion), e.scale.copy(r.scale), (m = e.setDirty) == null || m.call(e), (g = (v = e.uiConfig) == null ? void 0 : v.uiRefresh) == null || g.call(v);
      }
    });
  }
};
cs.PluginType = "TransformAnimationPlugin";
let Nx = cs;
var JN = Object.defineProperty, $N = Object.getOwnPropertyDescriptor, bS = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? $N(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && JN(e, t, n), n;
};
let Po = class extends Tt {
  constructor() {
    super(), this.enabled = !0, this._uniforms = {
      ccTintColor: { value: new se() },
      ccThickness: { value: 0 },
      ccIor: { value: 0 }
    }, this.materialExtension = {
      parsFragmentSnippet: (s, e) => {
        var t;
        return this.isDisabled() || !((t = e == null ? void 0 : e.userData._clearcoatTint) != null && t.enableTint) || !(e.clearcoat > 0) ? "" : Oa`
uniform vec3 ccTintColor;
uniform float ccThickness;
uniform float ccIor;
vec3 clearcoatTint(const in float dotNV, const in float dotNL, const in float clearcoat) {
    vec3 tint = ( ccThickness > 0. ? 1. - ccTintColor : ccTintColor); // Set thickness < 0 for glow.
    tint = exp(tint * -(ccThickness * ((dotNL + dotNV) / max(dotNL * dotNV, 1e-3)))); // beer's law
    return mix(vec3(1.0), tint, clearcoat);
}
        `;
      },
      shaderExtender: (s, e) => {
        var t;
        this.isDisabled() || !((t = e == null ? void 0 : e.userData._clearcoatTint) != null && t.enableTint) || !(e.clearcoat > 0) || (s.fragmentShader = Ct(
          s.fragmentShader,
          "float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );",
          "float dotNVcc = saturate( dot( geometryClearcoatNormal, -refract(geometryViewDir, geometryClearcoatNormal, 1./ccIor) ) );"
        ), s.fragmentShader = Ct(
          s.fragmentShader,
          "outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;",
          `outgoingLight *= clearcoatTint(dotNVcc, dotNVcc, material.clearcoat);
`,
          { prepend: !0 }
        ), s.defines.USE_UV = "");
      },
      onObjectRender: (s, e) => {
        const t = e.userData._clearcoatTint;
        t != null && t.enableTint && (this._uniforms.ccTintColor.value.set(t.tintColor), this._uniforms.ccThickness.value = t.thickness, this._uniforms.ccIor.value = t.ior, Vo({
          // ...this._defines,
          CLEARCOAT_TINT_ENABLED: +!this.isDisabled()
        }, e));
      },
      extraUniforms: {
        // ...this._uniforms, // done in constructor
      },
      computeCacheKey: (s) => {
        var e;
        return (this.isDisabled() ? "0" : "1") + ((e = s.userData._clearcoatTint) != null && e.enableTint ? "1" : "0") + (s.clearcoat > 0 ? "1" : "0");
      },
      isCompatible: (s) => s.isPhysicalMaterial,
      getUiConfig: (s) => {
        const e = this._viewer;
        s.userData._clearcoatTint === void 0 && (s.userData._clearcoatTint = {});
        const t = s.userData._clearcoatTint, i = {
          type: "folder",
          label: "Clearcoat Tint",
          onChange: (n) => {
            n.config && this.setDirty();
          },
          children: [
            {
              type: "checkbox",
              label: "Enabled",
              get value() {
                return t.enableTint || !1;
              },
              set value(n) {
                var r;
                n !== t.enableTint && (n ? Po.AddClearcoatTint(s) || e.dialog.alert("Cannot add clearcoat tint.") : (t.enableTint = !1, s.setDirty && s.setDirty()), (r = i.uiRefresh) == null || r.call(i, !0, "postFrame"));
              }
            },
            {
              type: "color",
              label: "Tint color",
              hidden: () => !t.enableTint,
              property: [t, "tintColor"]
            },
            {
              type: "input",
              label: "Thickness",
              hidden: () => !t.enableTint,
              property: [t, "thickness"]
            },
            {
              type: "slider",
              bounds: [0.8, 2.5],
              label: "IOR",
              hidden: () => !t.enableTint,
              property: [t, "ior"]
            }
          ]
        };
        return i;
      }
    }, this.setDirty = () => {
      var s, e, t;
      (e = (s = this.materialExtension).setDirty) == null || e.call(s), (t = this._viewer) == null || t.setDirty();
    }, Object.assign(this.materialExtension.extraUniforms, this._uniforms);
  }
  static AddClearcoatTint(s, e) {
    const t = s == null ? void 0 : s.userData;
    if (!t) return null;
    t._clearcoatTint || (t._clearcoatTint = {});
    const i = t._clearcoatTint;
    return i.enableTint = !0, i.tintColor === void 0 && (i.tintColor = "#ffffff"), i.thickness === void 0 && (i.thickness = 0.1), i.ior === void 0 && (i.ior = 1.5), e && Object.assign(i, e), s.setDirty && s.setDirty(), i;
  }
  onAdded(s) {
    super.onAdded(s), s.assetManager.materials.registerMaterialExtension(this.materialExtension), s.assetManager.registerGltfExtension(Jh);
  }
  onRemove(s) {
    var e;
    return (e = s.assetManager.materials) == null || e.unregisterMaterialExtension(this.materialExtension), s.assetManager.unregisterGltfExtension(Jh.name), super.onRemove(s);
  }
};
Po.PluginType = "ClearcoatTintPlugin";
Po.CLEARCOAT_TINT_GLTF_EXTENSION = "WEBGI_materials_clearcoat_tint";
bS([
  ue("Enabled", (s) => ({ onChange: s.setDirty })),
  V()
], Po.prototype, "enabled", 2);
Po = bS([
  Lt("Clearcoat Tint (MatExt)")
], Po);
class ZN {
  constructor(e) {
    this.parser = e, this.name = Jh.name;
  }
  async extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return;
    const r = n.extensions[this.name];
    t.userData || (t.userData = {}), Po.AddClearcoatTint(t), mt.Deserialize(r, t.userData._clearcoatTint);
  }
}
const ek = (s) => ({
  writeMaterial: (e, t) => {
    var n;
    if (!e.isMeshStandardMaterial || !((n = e.userData._clearcoatTint) != null && n.enableTint)) return;
    t.extensions = t.extensions || {};
    const i = mt.Serialize(e.userData._clearcoatTint);
    t.extensions[Jh.name] = i, s.extensionsUsed[Jh.name] = !0;
  }
}), Jh = {
  name: "WEBGI_materials_clearcoat_tint",
  import: (s) => new ZN(s),
  export: ek,
  textures: void 0
}, tk = `#include <randomHelpers>
#include <voronoiNoise>
uniform vec2 noiseBumpParams;uniform float noiseBumpScale;uniform float noiseBumpFlakeScale;uniform float noiseFlakeClamp;uniform float noiseFlakeRadius;uniform bool useColorFlakes;uniform vec4 flakeParams;uniform vec3 flakeFallOffParams;vec3 perturbNormalArb_nb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){
#ifdef BUMP_MAP_SCALE_LEGACY
vec3 vSigmaX=(dFdx(surf_pos.xyz));vec3 vSigmaY=(dFdy(surf_pos.xyz));
#else
vec3 vSigmaX=normalize(dFdx(surf_pos.xyz));vec3 vSigmaY=normalize(dFdy(surf_pos.xyz));
#endif
vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}`, ik = `vec3 outColor,outColor1,outColor2,outColor3,outColor4,outColor5;float distFac=length(vViewPosition.xyz);/*float e=floor(log2(0.3*distFac+3.0)/0.3785116);float level_z=0.1*pow(1.3,e)-0.2;*/float level=1.;vec2 uvMod=noiseBumpFlakeScale*noiseBumpParams.xy*vUv*level;float voronoiDist=clamp(voronoi_f1_2d(uvMod,1.,noiseFlakeClamp,noiseFlakeRadius,outColor),0.0,1.0);vec3 oldNormal=normal;normal=perturbNormalArb_nb(-vViewPosition,normal,(2.*outColor.xy-1.)*noiseBumpScale,faceDirection);float oldRoughnessFactor=roughnessFactor;float oldMetalnessFactor=metalnessFactor;roughnessFactor=mix(roughnessFactor,flakeParams.x,1.-voronoiDist);metalnessFactor=mix(metalnessFactor,flakeParams.y,1.-voronoiDist);
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
vec3 sparkleRadiance=getIBLRadiance(normalize(vViewPosition),normal,roughnessFactor);float sparkleIntensity=length(sparkleRadiance);float sparkleIntensityMultiplier=sparkleIntensity>1.3 ? flakeParams.z : 1.;vec3 oldDiffuseColor=diffuseColor.rgb;vec2 cellPosition_=floor(uvMod);vec3 colorRGB=useColorFlakes ? hash3(cellPosition_): vec3(1.);float fallOff_=mix(1.,1./(1.+flakeFallOffParams.y*distFac+flakeFallOffParams.z*distFac*distFac),flakeFallOffParams.x);diffuseColor.rgb*=mix(vec3(1.),sparkleIntensityMultiplier*colorRGB*fallOff_,vec3(1.-voronoiDist));if(sparkleIntensity<flakeParams.w){float mixFactor=1.;roughnessFactor=mix(roughnessFactor,oldRoughnessFactor,mixFactor);metalnessFactor=mix(metalnessFactor,oldMetalnessFactor,mixFactor);normal=normalize(mix(normal,oldNormal,mixFactor));diffuseColor.rgb=mix(diffuseColor.rgb,oldDiffuseColor,mixFactor);}
#endif
`;
var nk = Object.defineProperty, sk = Object.getOwnPropertyDescriptor, SS = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? sk(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && nk(e, t, n), n;
};
let Lo = class extends Tt {
  constructor() {
    super(), this.enabled = !0, this._uniforms = {
      noiseBumpParams: { value: new ie() },
      // u scale, v scale,
      noiseBumpScale: { value: 0.05 },
      noiseBumpFlakeScale: { value: 1e3 },
      noiseFlakeClamp: { value: 1 },
      noiseFlakeRadius: { value: 0.5 },
      flakeParams: { value: new it(0, 1, 3, 0) },
      flakeFallOffParams: { value: new M(0, 1, 0) },
      useColorFlakes: { value: !1 }
    }, this.materialExtension = {
      parsFragmentSnippet: (s, e) => {
        var t;
        return this.isDisabled() || !((t = e == null ? void 0 : e.userData._noiseBumpMat) != null && t.hasBump) ? "" : tk;
      },
      shaderExtender: (s, e) => {
        var t;
        this.isDisabled() || !((t = e == null ? void 0 : e.userData._noiseBumpMat) != null && t.hasBump) || (s.fragmentShader = Ct(s.fragmentShader, "#glMarker beforeAccumulation", ik, { prepend: !0 }), s.defines.USE_UV = "", s.extensionDerivatives = !0);
      },
      onObjectRender: (s, e) => {
        const t = e.userData._noiseBumpMat;
        t != null && t.hasBump && (Array.isArray(t.bumpNoiseParams) ? this._uniforms.noiseBumpParams.value.fromArray(t.bumpNoiseParams) : this._uniforms.noiseBumpParams.value.copy(t.bumpNoiseParams), this._uniforms.noiseBumpScale.value = t.bumpScale, this._uniforms.noiseBumpFlakeScale.value = t.flakeScale, this._uniforms.noiseFlakeClamp.value = t.flakeClamp, this._uniforms.noiseFlakeRadius.value = t.flakeRadius, Array.isArray(t.flakeParams) ? this._uniforms.flakeParams.value.fromArray(t.flakeParams) : this._uniforms.flakeParams.value.copy(t.flakeParams), Array.isArray(t.flakeFallOffParams) ? this._uniforms.flakeFallOffParams.value.fromArray(t.flakeFallOffParams) : this._uniforms.flakeFallOffParams.value.copy(t.flakeFallOffParams), this._uniforms.useColorFlakes.value = t.useColorFlakes, Vo({
          // ...this._defines,
          NOISE_BUMP_MATERIAL_ENABLED: +!this.isDisabled()
        }, e));
      },
      extraUniforms: {
        // ...this._uniforms, // done in constructor
      },
      computeCacheKey: (s) => {
        var e;
        return (this.isDisabled() ? "0" : "1") + ((e = s.userData._noiseBumpMat) != null && e.hasBump ? "1" : "0");
      },
      isCompatible: (s) => s.isPhysicalMaterial,
      getUiConfig: (s) => {
        const e = this._viewer;
        s.userData._noiseBumpMat === void 0 && (s.userData._noiseBumpMat = {});
        const t = s.userData._noiseBumpMat, i = {
          type: "folder",
          label: "SparkleBump (NoiseBump)",
          onChange: (n) => {
            n.config && this.setDirty();
          },
          children: [
            {
              type: "checkbox",
              label: "Enabled",
              get value() {
                return t.hasBump || !1;
              },
              set value(n) {
                var r;
                n !== t.hasBump && (n ? Lo.AddNoiseBumpMaterial(s) || e.dialog.alert("Cannot add NoiseBumpMaterial.") : (t.hasBump = !1, s.setDirty && s.setDirty()), (r = i.uiRefresh) == null || r.call(i, !0, "postFrame"));
              }
            },
            {
              type: "vec4",
              label: "Bump Noise Params",
              bounds: [0, 1],
              hidden: () => !t.hasBump,
              property: [t, "bumpNoiseParams"]
            },
            {
              type: "slider",
              label: "Bump Scale",
              bounds: [0, 1e-3],
              stepSize: 1e-5,
              hidden: () => !t.hasBump,
              property: [t, "bumpScale"]
            },
            {
              type: "slider",
              label: "Flake Scale",
              bounds: [100, 1e4],
              stepSize: 1e-4,
              hidden: () => !t.hasBump,
              property: [t, "flakeScale"]
            },
            {
              type: "slider",
              label: "Flake Clamp",
              bounds: [0, 1],
              stepSize: 1,
              hidden: () => !t.hasBump,
              property: [t, "flakeClamp"]
            },
            {
              type: "slider",
              label: "Flake Radius",
              bounds: [0.01, 1],
              stepSize: 1e-3,
              hidden: () => !t.hasBump,
              property: [t, "flakeRadius"]
            },
            {
              type: "slider",
              label: "Flake Roughness",
              bounds: [0, 1],
              stepSize: 0.01,
              hidden: () => !t.hasBump,
              property: [t.flakeParams, "x"]
            },
            {
              type: "slider",
              label: "Flake Metalness",
              bounds: [0, 1],
              stepSize: 0.01,
              hidden: () => !t.hasBump,
              property: [t.flakeParams, "y"]
            },
            {
              type: "slider",
              label: "Flake Strength",
              bounds: [0, 100],
              stepSize: 1e-3,
              hidden: () => !t.hasBump,
              property: [t.flakeParams, "z"]
            },
            {
              type: "slider",
              label: "Flake Threshold",
              bounds: [0.1, 10],
              stepSize: 1e-3,
              hidden: () => !t.hasBump,
              property: [t.flakeParams, "w"]
            },
            {
              type: "slider",
              label: "Falloff",
              stepSize: 1,
              bounds: [0, 1],
              hidden: () => !t.hasBump,
              property: [t.flakeFallOffParams, "x"]
            },
            {
              type: "slider",
              label: "Linear falloff factor",
              bounds: [0, 10],
              stepSize: 1e-3,
              hidden: () => !t.hasBump,
              property: [t.flakeFallOffParams, "y"]
            },
            {
              type: "slider",
              label: "Quadratic falloff factor",
              bounds: [0, 10],
              stepSize: 1e-3,
              hidden: () => !t.hasBump,
              property: [t.flakeFallOffParams, "z"]
            },
            {
              type: "checkbox",
              label: "Colored Flakes",
              hidden: () => !t.hasBump,
              property: [t, "useColorFlakes"]
            }
          ]
        };
        return i;
      }
    }, this.setDirty = () => {
      var s, e, t;
      (e = (s = this.materialExtension).setDirty) == null || e.call(s), (t = this._viewer) == null || t.setDirty();
    }, Object.assign(this.materialExtension.extraUniforms, this._uniforms);
  }
  static AddNoiseBumpMaterial(s, e) {
    const t = s == null ? void 0 : s.userData;
    if (!t) return !1;
    t._noiseBumpMat || (t._noiseBumpMat = {});
    const i = t._noiseBumpMat;
    return i.hasBump = !0, i.bumpNoiseParams === void 0 && (i.bumpNoiseParams = new ie(0.5, 0.5)), i.bumpScale === void 0 && (i.bumpScale = 0.05), i.flakeScale === void 0 && (i.flakeScale = 0.05), i.flakeClamp === void 0 && (i.flakeClamp = 1), i.flakeRadius === void 0 && (i.flakeRadius = 0.3), i.useColorFlakes === void 0 && (i.useColorFlakes = !1), i.flakeParams === void 0 && (i.flakeParams = new it(0, 1, 3, 0)), i.flakeFallOffParams === void 0 && (i.flakeFallOffParams = new M(0, 1, 0)), e && Object.assign(i, e), s.setDirty && s.setDirty(), !0;
  }
  onAdded(s) {
    super.onAdded(s), s.assetManager.materials.registerMaterialExtension(this.materialExtension), s.assetManager.registerGltfExtension($h);
  }
  onRemove(s) {
    var e;
    return (e = s.assetManager.materials) == null || e.unregisterMaterialExtension(this.materialExtension), s.assetManager.unregisterGltfExtension($h.name), super.onRemove(s);
  }
};
Lo.PluginType = "NoiseBumpMaterialPlugin";
Lo.NOISE_BUMP_MATERIAL_GLTF_EXTENSION = "WEBGI_materials_noise_bump";
SS([
  ue("Enabled", (s) => ({ onChange: s.setDirty })),
  V()
], Lo.prototype, "enabled", 2);
Lo = SS([
  Lt("Noise/Sparkle Bump (MatExt)")
], Lo);
class rk {
  constructor(e) {
    this.parser = e, this.name = $h.name;
  }
  async extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return;
    const r = n.extensions[this.name];
    t.userData || (t.userData = {}), Lo.AddNoiseBumpMaterial(t), mt.Deserialize(r, t.userData._noiseBumpMat);
  }
}
const ak = (s) => ({
  writeMaterial: (e, t) => {
    var n;
    if (!e.isMeshStandardMaterial || !((n = e.userData._noiseBumpMat) != null && n.hasBump)) return;
    t.extensions = t.extensions || {};
    const i = mt.Serialize(e.userData._noiseBumpMat);
    t.extensions[$h.name] = i, s.extensionsUsed[$h.name] = !0;
  }
}), $h = {
  name: "WEBGI_materials_noise_bump",
  import: (s) => new rk(s),
  export: ak,
  textures: void 0
}, ok = `#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0
#if CUSTOM_BUMP_MAP_BICUBIC > 0
vec4 cubic_cb(float v){vec4 n=vec4(1.0,2.0,3.0,4.0)-v;vec4 s=n*n*n;float x=s.x;float y=s.y-4.0*s.x;float z=s.z-4.0*s.y+6.0*s.x;float w=6.0-x-y-z;return vec4(x,y,z,w)*(1.0/6.0);}vec4 textureBicubic_cb(sampler2D sampler,vec2 texCoords){vec2 texSize=vec2(textureSize(sampler,0));vec2 invTexSize=1.0/texSize;texCoords=texCoords*texSize-0.5;vec2 fxy=fract(texCoords);texCoords-=fxy;vec4 xcubic=cubic_cb(fxy.x);vec4 ycubic=cubic_cb(fxy.y);vec4 c=texCoords.xxyy+vec2(-0.5,+1.5).xyxy;vec4 s=vec4(xcubic.xz+xcubic.yw,ycubic.xz+ycubic.yw);vec4 offset=c+vec4(xcubic.yw,ycubic.yw)/s;offset*=invTexSize.xxyy;vec4 sample0=texture(sampler,offset.xz);vec4 sample1=texture(sampler,offset.yz);vec4 sample2=texture(sampler,offset.xw);vec4 sample3=texture(sampler,offset.yw);float sx=s.x/(s.x+s.y);float sy=s.z/(s.z+s.w);return mix(mix(sample3,sample2,sx),mix(sample1,sample0,sx),sy);}
#endif
varying vec2 vCustomBumpUv;uniform sampler2D customBumpMap;uniform float customBumpScale;vec2 dHdxy_fwd_cb(){vec2 dSTdx=dFdx(vCustomBumpUv);vec2 dSTdy=dFdy(vCustomBumpUv);
#if CUSTOM_BUMP_MAP_BICUBIC > 0
float Hll=customBumpScale*textureBicubic_cb(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*textureBicubic_cb(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*textureBicubic_cb(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;
#else
float Hll=customBumpScale*texture2D(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;
#endif
return vec2(dBx,dBy);}
#ifndef USE_BUMPMAP
vec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){
#ifdef BUMP_MAP_SCALE_LEGACY
vec3 vSigmaX=(dFdx(surf_pos.xyz));vec3 vSigmaY=(dFdy(surf_pos.xyz));
#else
vec3 vSigmaX=normalize(dFdx(surf_pos.xyz));vec3 vSigmaY=normalize(dFdy(surf_pos.xyz));
#endif
vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}
#endif
#endif
`;
var lk = Object.defineProperty, ck = Object.getOwnPropertyDescriptor, wy = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? ck(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && lk(e, t, n), n;
};
let Uo = class extends Tt {
  constructor() {
    super(), this.enabled = !0, this.bicubicFiltering = !0, this._defines = {
      CUSTOM_BUMP_MAP_DEBUG: !1,
      CUSTOM_BUMP_MAP_BICUBIC: !0
    }, this._uniforms = {
      customBumpUvTransform: { value: new yt() },
      customBumpScale: { value: 1e-3 },
      customBumpMap: { value: null }
    }, this.materialExtension = {
      parsFragmentSnippet: (s, e) => this.isDisabled() || !(e != null && e.userData._hasCustomBump) ? "" : ok,
      shaderExtender: (s, e) => {
        this.isDisabled() || !(e != null && e.userData._hasCustomBump) || !e.userData._customBumpMap || (s.fragmentShader = Ct(
          s.fragmentShader,
          "#glMarker beforeAccumulation",
          `
#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0
    normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd_cb(), faceDirection );
#endif
                `,
          { prepend: !0 }
        ), s.vertexShader = Ct(
          s.vertexShader,
          "#include <uv_pars_vertex>",
          `
#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0
    varying vec2 vCustomBumpUv;
    uniform mat3 customBumpUvTransform;
#endif
                `,
          { prepend: !0 }
        ), s.vertexShader = Ct(
          s.vertexShader,
          "#include <uv_vertex>",
          `
#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0
    vCustomBumpUv = ( customBumpUvTransform * vec3( uv, 1 ) ).xy;
#endif
                `,
          { prepend: !0 }
        ), s.defines.USE_UV = "");
      },
      onObjectRender: (s, e) => {
        var n;
        const t = e.userData;
        if (!(t != null && t._hasCustomBump) || !s.isMesh || !s.geometry) return;
        const i = (n = t._customBumpMap) != null && n.isTexture ? t._customBumpMap : null;
        this._uniforms.customBumpMap.value = i, this._uniforms.customBumpScale.value = i ? t._customBumpScale ?? 0 : 0, i && (i.updateMatrix(), this._uniforms.customBumpUvTransform.value.copy(i.matrix)), Vo({
          ...this._defines,
          CUSTOM_BUMP_MAP_ENABLED: +this.enabled
        }, e);
      },
      extraUniforms: {
        // ...this._uniforms, // done in constructor
      },
      computeCacheKey: (s) => {
        var e, t;
        return (this.enabled ? "1" : "0") + (s.userData._hasCustomBump ? "1" : "0") + ((t = (e = s.userData) == null ? void 0 : e._customBumpMap) == null ? void 0 : t.uuid);
      },
      isCompatible: (s) => s.isPhysicalMaterial,
      getUiConfig: (s) => {
        const e = this._viewer, t = this.enableCustomBump.bind(this), i = s.userData, n = {
          type: "folder",
          label: "CustomBumpMap",
          onChange: (r) => {
            r.config && this.setDirty();
          },
          children: [
            {
              type: "checkbox",
              label: "Enabled",
              get value() {
                return i._hasCustomBump || !1;
              },
              set value(r) {
                var a;
                r !== i._hasCustomBump && (r ? t(s) || e.dialog.alert("CustomBumpMapPlugin - Cannot add CustomBumpMap.") : (i._hasCustomBump = !1, s.setDirty && s.setDirty()), (a = n.uiRefresh) == null || a.call(n, !0, "postFrame"));
              }
            },
            {
              type: "slider",
              label: "Bump Scale",
              bounds: [-1, 1],
              hidden: () => !i._hasCustomBump,
              property: [i, "_customBumpScale"]
              // onChange: this.setDirty,
            },
            {
              type: "image",
              label: "Bump Map",
              hidden: () => !i._hasCustomBump,
              property: [i, "_customBumpMap"],
              onChange: () => {
                s.setDirty && s.setDirty();
              }
            },
            bi(i, "_customBumpMap", "Sampler", () => !i._hasCustomBump, () => s.setDirty && s.setDirty())
          ]
        };
        return n;
      }
    }, this.setDirty = () => {
      var s, e, t;
      (e = (s = this.materialExtension).setDirty) == null || e.call(s), (t = this._viewer) == null || t.setDirty();
    }, Object.assign(this.materialExtension.extraUniforms, this._uniforms);
  }
  enableCustomBump(s, e, t) {
    const i = s == null ? void 0 : s.userData;
    if (!i) return !1;
    if (i._hasCustomBump === void 0) {
      const n = s.appliedMeshes;
      let r = !0;
      if (n) for (const { geometry: a } of n)
        a && (!a.attributes.position || !a.attributes.normal || !a.attributes.uv) && (r = !1);
      if (!r)
        return !1;
    }
    return i._hasCustomBump = !0, i._customBumpScale = t ?? i._customBumpScale ?? 1e-3, i._customBumpMap = e ?? i._customBumpMap ?? null, s.setDirty && s.setDirty(), !0;
  }
  onAdded(s) {
    super.onAdded(s), s.assetManager.materials.registerMaterialExtension(this.materialExtension), s.assetManager.registerGltfExtension(Zh);
  }
  onRemove(s) {
    var e;
    return (e = s.assetManager.materials) == null || e.unregisterMaterialExtension(this.materialExtension), s.assetManager.unregisterGltfExtension(Zh.name), super.onRemove(s);
  }
};
Uo.PluginType = "CustomBumpMapPlugin";
Uo.CUSTOM_BUMP_MAP_GLTF_EXTENSION = "WEBGI_materials_custom_bump_map";
wy([
  ue("Enabled", (s) => ({ onChange: s.setDirty })),
  V()
], Uo.prototype, "enabled", 2);
wy([
  ue("Bicubic", (s) => ({ onChange: s.setDirty })),
  jA("CUSTOM_BUMP_MAP_BICUBIC", void 0, !0, Uo.prototype.setDirty),
  V()
], Uo.prototype, "bicubicFiltering", 2);
Uo = wy([
  Lt("Custom BumpMap (MatExt)")
], Uo);
class hk {
  constructor(e) {
    this.parser = e, this.name = Zh.name;
  }
  async extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return;
    const r = n.extensions[this.name];
    t.userData || (t.userData = {}), t.userData._hasCustomBump = !0, t.userData._customBumpScale = r.customBumpScale ?? 0;
    const a = [], o = r.customBumpMap;
    return o && a.push(i.assignTexture(t.userData, "_customBumpMap", o).then((l) => {
      l.colorSpace = dt;
    })), Promise.all(a);
  }
  // do any mesh or geometry processing here
  // afterRoot(result: GLTF): Promise<void> | null {
  //     result.scene.traverse((object: any) => {
  //         const mat = object.material?.userData?._hasCustomBump
  //         if (!mat) return
  //         const geom = object.geometry
  //         if (!geom.attributes.tangent) {
  //             geom.computeTangents()
  //             geom.attributes.tangent.needsUpdate = true
  //         }
  //     })
  //     return null
  // }
}
const uk = (s) => ({
  writeMaterial: (e, t) => {
    if (!e.isMeshStandardMaterial || !e.userData._hasCustomBump || (e.userData._customBumpScale || 0) < 1e-3) return;
    t.extensions = t.extensions || {};
    const i = {};
    if (i.customBumpScale = e.userData._customBumpScale || 1, s.checkEmptyMap(e.userData._customBumpMap)) {
      const n = { index: s.processTexture(e.userData._customBumpMap) };
      s.applyTextureTransform(n, e.userData._customBumpMap), i.customBumpMap = n;
    }
    t.extensions[Zh.name] = i, s.extensionsUsed[Zh.name] = !0;
  }
}), Zh = {
  name: "WEBGI_materials_custom_bump_map",
  import: (s) => new hk(s),
  export: uk,
  textures: {
    customBumpMap: "RGB"
  }
}, dk = `
#ifdef USE_BUMPMAP
mat3 mat3_inverse(mat3 A){mat3 M_t=mat3(vec3(A[0][0],A[1][0],A[2][0]),vec3(A[0][1],A[1][1],A[2][1]),vec3(A[0][2],A[1][2],A[2][2]));float det=dot(cross(M_t[0],M_t[1]),M_t[2]);mat3 adjugate=mat3(cross(M_t[1],M_t[2]),cross(M_t[2],M_t[0]),cross(M_t[0],M_t[1]));return adjugate/det;}float CalculateHeight(in vec2 texCoords){float height=texture2D(bumpMap,texCoords).x;return clamp(height,0.0,1.0);}const vec2 bumpMapSize=vec2(512,512);vec3 CalculateNormal(in vec2 texCoords){
#if defined( TANGENTSPACE_NORMALMAP ) && 0
vec3 mapN=texture2D(normalMap,texCoords).xyz;mapN.xy*=normalScale;return normalize(mapN);
#else
vec2 texOffs=1.0/bumpMapSize;
#if PARALLAX_NORMAL_MAP_QUALITY > 0
float hx[9];hx[0]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.0,-1.0)).r;hx[1]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.0,-1.0)).r;hx[2]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.0,-1.0)).r;hx[3]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.0,0.0)).r;hx[4]=texture2D(bumpMap,texCoords.st).r;hx[5]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.0,0.0)).r;hx[6]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.0,1.0)).r;hx[7]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.0,1.0)).r;hx[8]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.0,1.0)).r;vec2 deltaH=vec2(hx[0]-hx[2]+2.0*(hx[3]-hx[5])+hx[6]-hx[8],hx[0]-hx[6]+2.0*(hx[1]-hx[7])+hx[2]-hx[8]);
#else
float h_xa=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.0,0.0)).r;float h_xb=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.0,0.0)).r;float h_ya=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.0,-1.0)).r;float h_yb=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.0,1.0)).r;vec2 deltaH=vec2(h_xa-h_xb,h_ya-h_yb);
#endif
return normalize(vec3(deltaH/texOffs,1.0));
#endif
}vec3 ReliefParallax(in float frontFace,in vec3 texDir3D,in vec2 texCoord){float surf_sign=frontFace;float back_face=step(0.0,-surf_sign);vec2 texStep=surf_sign*texDir3D.xy/abs(texDir3D.z);vec2 texC=texCoord.st+surf_sign*texStep+back_face*texStep.xy;float mapHeight=1.0;float bumpHeightStep=1.0/float(PARALLAX_MAP_STEPS);float bestBumpHeight=mapHeight+bumpHeightStep;
#pragma unroll_loop_start
for(int i=0;i<PARALLAX_MAP_STEPS;i++){if(mapHeight<bestBumpHeight){bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);}}
#pragma unroll_loop_end
bestBumpHeight+=bumpHeightStep;
#pragma unroll_loop_start
for(int i=0;i<PARALLAX_MAP_B_STEPS;i++){bumpHeightStep*=0.5;bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);bestBumpHeight+=(bestBumpHeight<mapHeight)? bumpHeightStep : 0.0;}
#pragma unroll_loop_end
bestBumpHeight-=bumpHeightStep*clamp((bestBumpHeight-mapHeight)/bumpHeightStep,0.0,1.0);mapHeight=bestBumpHeight;texC-=mapHeight*texStep;return vec3(texC.xy,mapHeight);}vec3 reliefParallaxPerturbNormal(in float faceDirection,inout vec3 normal){if(abs(bumpScale)<0.001)return vec3(vBumpMapUv,0.);float parallaxHeight;vec2 texCoords=vBumpMapUv;float face_sign=sign(dot(normal,vViewPosition));vec3 N=normalize(normal);vec3 dp1=dFdx(-vViewPosition);vec3 dp2=dFdy(-vViewPosition);vec2 duv1=dFdx(vBumpMapUv);vec2 duv2=dFdy(vBumpMapUv);vec3 dp2perp=cross(dp2,N);vec3 dp1perp=cross(N,dp1);vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(T,T),dot(B,B)));mat3 tbnMat=mat3(T*invmax,B*invmax,N*bumpScale);vec3 tangentPos=normalize(mat3_inverse(tbnMat)*-vViewPosition);vec3 parallaxUv=ReliefParallax(face_sign,tangentPos,vBumpMapUv);tbnMat[2]=face_sign*N/bumpScale;normal=normalize(tbnMat*CalculateNormal(parallaxUv.xy).xyz);
#ifdef FLIP_SIDED
normal=-normal;
#endif
return parallaxUv;}
#endif
`;
var pk = Object.defineProperty, fk = Object.getOwnPropertyDescriptor, Qc = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? fk(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && pk(e, t, n), n;
};
let ms = class extends Tt {
  constructor(s = !0) {
    super(), this.enabled = !0, this.stepCount = 12, this.binaryStepCount = 3, this.debugNormals = !1, this.debugHitHeight = !1, this._defines = {
      PARALLAX_NORMAL_MAP_QUALITY: 0
    }, this._bumpMapExtension = {
      shaderExtender: (e, t, i) => {
        if (!(!t.bumpMap || this.isDisabled())) {
          e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_begin>", ""), e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_maps>", ""), e.fragmentShader = e.fragmentShader.replace(
            "#include <map_fragment>",
            `#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <map_fragment>`
          );
          for (const n of ["map_fragment", "alphamap_fragment", "roughnessmap_fragment", "metalnessmap_fragment", "emissivemap_fragment", "transmission_fragment"])
            e.fragmentShader = Ct(
              e.fragmentShader,
              `#include <${n}>`,
              ft[n].replace(/\bv\w+Uv\b/g, "parallaxUv.xy", { replaceAll: !0 })
            );
          (this.debugNormals || this.debugHitHeight) && (e.fragmentShader = Ct(
            e.fragmentShader,
            // .replace('texture2D( map, parallaxUv.xy )', 'texture2D( map, parallaxUv.xy )')
            "texture2D( map, parallaxUv.xy )",
            this.debugNormals ? "vec4(normal, 1.); normal = nonPerturbedNormal" : "vec4(parallaxUv.z,0., 0., 1.)"
          )), e.fragmentShader = Ct(
            e.fragmentShader,
            "#include <normal_fragment_maps>",
            Ct(
              Ct(
                ft.normal_fragment_maps,
                "#elif defined( USE_NORMALMAP_TANGENTSPACE )",
                "#elif defined( USE_NORMALMAP_TANGENTSPACE ) && !defined( USE_BUMPMAP )"
              ),
              "normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );",
              // 'diffuseColor.rgb = vec3(0, dHdxy_fwd());'
              // 'diffuseColor.rgb = CalculateNormal(vUv).rgb;'
              "vec3 parallaxUv = reliefParallaxPerturbNormal(faceDirection, normal);"
            )
          );
        }
      },
      parsFragmentSnippet: () => this.isDisabled() ? "" : (dk + `
`).replaceAll("PARALLAX_MAP_STEPS", this.stepCount.toString()).replaceAll("PARALLAX_MAP_B_STEPS", this.binaryStepCount.toString()),
      isCompatible: (e) => e.isPhysicalMaterial,
      computeCacheKey: (e) => {
        var t;
        return "" + !this.isDisabled() + ((t = e.bumpMap) == null ? void 0 : t.uuid) + this.debugNormals + this.debugHitHeight + this.stepCount.toString() + this.binaryStepCount.toString();
      },
      onObjectRender: (e, t, i) => {
        this.isDisabled() || Vo({
          ...this._defines
        }, t);
      }
    }, this.enabled = s, this._updateExtension = this._updateExtension.bind(this);
  }
  _updateExtension() {
    var s, e, t;
    (e = (s = this._bumpMapExtension) == null ? void 0 : s.setDirty) == null || e.call(s), (t = this._viewer) == null || t.setDirty();
  }
  onAdded(s) {
    return s.materialManager.registerMaterialExtension(this._bumpMapExtension), super.onAdded(s);
  }
  onRemove(s) {
    return s.materialManager.unregisterMaterialExtension(this._bumpMapExtension), super.onRemove(s);
  }
};
ms.PluginType = "ReliefParallaxMapping";
Qc([
  Oe(ms.prototype._updateExtension),
  V(),
  ue("Enabled")
], ms.prototype, "enabled", 2);
Qc([
  Ye("Step count", [1, 32], 1),
  Oe(ms.prototype._updateExtension),
  V()
], ms.prototype, "stepCount", 2);
Qc([
  Ye("Binary search steps", [1, 8], 1),
  Oe(ms.prototype._updateExtension),
  V()
], ms.prototype, "binaryStepCount", 2);
Qc([
  Oe(ms.prototype._updateExtension),
  ue("Debug Normals")
], ms.prototype, "debugNormals", 2);
Qc([
  Oe(ms.prototype._updateExtension),
  ue("Debug Hit Height")
], ms.prototype, "debugHitHeight", 2);
ms = Qc([
  Lt("Parallax Bump Mapping (MatExt)")
], ms);
const mk = `#include <simpleCameraHelpers>
uniform vec4 fragClippingPosition;uniform vec4 fragClippingParams;uniform float fragClippingCamAspect;
#if FRAG_CLIPPING_MODE == FragmentClippingMode.Circle
float fragClippingCircle(){vec2 pos=viewToScreen(vViewPosition.xyz).xy;float radius=fragClippingParams.x;vec2 center=fragClippingPosition.xy;pos.y/=fragClippingCamAspect;center.y/=fragClippingCamAspect;return length(pos-center)-radius;}
#elif FRAG_CLIPPING_MODE == FragmentClippingMode.Ellipse
float fragClippingEllipse(){vec2 pos=viewToScreen(vViewPosition.xyz).xy;vec2 radius=fragClippingParams.xy;vec2 center=fragClippingPosition.xy;pos.y/=fragClippingCamAspect;center.y/=fragClippingCamAspect;return length((pos-center)/radius)-1.0;}
#elif FRAG_CLIPPING_MODE == FragmentClippingMode.Rectangle
float fragClippingRectangle(){vec2 pos=viewToScreen(vViewPosition.xyz).xy;vec2 radius=fragClippingParams.xy;vec2 center=fragClippingPosition.xy;pos.y/=fragClippingCamAspect;center.y/=fragClippingCamAspect;vec2 d=abs(pos-center)-radius;return min(max(d.x,d.y),0.0)+length(max(d,0.0));}
#elif FRAG_CLIPPING_MODE == FragmentClippingMode.Plane
float fragClippingPlane(){vec3 pos=vViewPosition.xyz;vec3 normal=fragClippingParams.xyz;float d=dot(pos,normal)-fragClippingParams.w;return d;}
#elif FRAG_CLIPPING_MODE == FragmentClippingMode.Sphere
float fragClippingSphere(){vec3 pos=vViewPosition.xyz;vec3 center=fragClippingPosition.xyz;float radius=fragClippingParams.x;pos.y/=fragClippingCamAspect;center.y/=fragClippingCamAspect;return length(pos-center)-radius;}
#endif
`, gk = `float fragClippingDist=0.0;
#if FRAG_CLIPPING_MODE == FragmentClippingMode.Circle
fragClippingDist=fragClippingCircle();
#elif FRAG_CLIPPING_MODE == FragmentClippingMode.Ellipse
fragClippingDist=fragClippingEllipse();
#elif FRAG_CLIPPING_MODE == FragmentClippingMode.Rectangle
fragClippingDist=fragClippingRectangle();
#elif FRAG_CLIPPING_MODE == FragmentClippingMode.Plane
fragClippingDist=fragClippingPlane();
#elif FRAG_CLIPPING_MODE == FragmentClippingMode.Sphere
fragClippingDist=fragClippingSphere();
#endif
#if FRAG_CLIPPING_DEBUG
gl_FragColor=vec4(max(fragClippingDist,0.0),0.0,0.0,1.0);
#include <colorspace_fragment>
return;
#endif
#if FRAG_CLIPPING_INVERSE == 1
if(fragClippingDist>0.0)discard;
#else
if(fragClippingDist<0.0)discard;
#endif
`;
var Ak = Object.defineProperty, yk = Object.getOwnPropertyDescriptor, CS = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? yk(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && Ak(e, t, n), n;
};
let Fo = class extends Tt {
  constructor() {
    super(), this.enabled = !0, this._defines = {
      FRAG_CLIPPING_DEBUG: 0
    }, this._uniforms = {
      fragClippingPosition: { value: new it() },
      // point on plane, center of sphere, center of cylinder, etc
      fragClippingParams: { value: new it() },
      // normal of plane, radius of sphere, radius of cylinder, etc
      fragClippingCamAspect: { value: 1 }
    }, this._plane = new Nr(), this._viewNormalMatrix = new yt(), this._v4 = new it(), this.materialExtension = {
      parsFragmentSnippet: (s, e) => {
        var t;
        return !this.enabled || !((t = e == null ? void 0 : e.userData._fragmentClippingExt) != null && t.clipEnabled) ? "" : Object.entries(Wd).map((i) => ["FragmentClippingMode." + i[0], "" + i[1]]).reduce((i, n) => i.replace(n[0], n[1]), mk);
      },
      shaderExtender: (s, e) => {
        var t;
        !this.enabled || !((t = e == null ? void 0 : e.userData._fragmentClippingExt) != null && t.clipEnabled) || (s.fragmentShader = Ct(s.fragmentShader, "#glMarker mainStart", Object.entries(Wd).map((i) => ["FragmentClippingMode." + i[0], "" + i[1]]).reduce((i, n) => i.replace(n[0], n[1]), `
` + gk), { append: !0 }));
      },
      onObjectRender: (s, e) => {
        var i, n, r;
        let t = e.userData._fragmentClippingExt;
        if (e.userData.isGBufferMaterial && s && s.material && !Array.isArray(s.material) && (t = (i = s.material) == null ? void 0 : i.userData._fragmentClippingExt), !!(t != null && t.clipEnabled)) {
          if (Array.isArray(t.clipPosition) ? this._uniforms.fragClippingPosition.value.fromArray(t.clipPosition) : this._uniforms.fragClippingPosition.value.copy(t.clipPosition), t.clipMode === 3 && t.clipParams) {
            const a = Array.isArray(t.clipParams) ? this._v4.fromArray(t.clipParams) : this._v4.copy(t.clipParams), o = this._viewer.scene.mainCamera.matrixWorldInverse;
            this._plane.normal.set(a.x, a.y, a.z), this._plane.constant = a.w, this._viewNormalMatrix.getNormalMatrix(o), this._plane.applyMatrix4(o, this._viewNormalMatrix), this._uniforms.fragClippingParams.value.set(this._plane.normal.x, this._plane.normal.y, this._plane.normal.z, this._plane.constant);
          } else
            Array.isArray(t.clipPosition) ? this._uniforms.fragClippingParams.value.fromArray(t.clipParams) : this._uniforms.fragClippingParams.value.copy(t.clipParams);
          (n = this._viewer) != null && n.scene.mainCamera.isPerspectiveCamera ? this._uniforms.fragClippingCamAspect.value = (r = this._viewer) == null ? void 0 : r.scene.mainCamera.aspect : this._uniforms.fragClippingCamAspect.value = 1, Vo({
            ...this._defines,
            // ['FRAGMENT_CLIPPING_EXTENSION_ENABLED']: this.enabled,
            FRAG_CLIPPING_MODE: +(t.clipMode ?? 0),
            FRAG_CLIPPING_INVERSE: +(t.clipInvert ?? !1)
          }, e);
        }
      },
      extraUniforms: {
        // ...this._uniforms, // done in constructor
      },
      computeCacheKey: (s) => {
        var e;
        return (this.enabled ? "1" : "0") + ((e = s.userData._fragmentClippingExt) != null && e.clipEnabled ? "1" : "0");
      },
      isCompatible: (s) => s.isPhysicalMaterial || s.userData.isGBufferMaterial,
      getUiConfig: (s) => {
        const e = this._viewer;
        s.userData._fragmentClippingExt === void 0 && (s.userData._fragmentClippingExt = {});
        const t = s.userData._fragmentClippingExt, i = {
          type: "folder",
          label: "Fragment Clipping",
          onChange: (n) => {
            n.config && this.setDirty();
          },
          children: [
            {
              type: "checkbox",
              label: "Enabled",
              get value() {
                return t.clipEnabled || !1;
              },
              set value(n) {
                var r;
                n !== t.clipEnabled && (n ? Fo.AddFragmentClipping(s) || e.dialog.alert("Cannot add FragmentClippingExtension.") : (t.clipEnabled = !1, s.setDirty && s.setDirty()), (r = i.uiRefresh) == null || r.call(i, !0, "postFrame"));
              }
            },
            {
              type: "dropdown",
              label: "Mode",
              children: Object.entries(Wd).map((n) => ({ label: n[0], value: n[1] })),
              hidden: () => !t.clipEnabled,
              property: [t, "clipMode"]
            },
            {
              type: "vec4",
              label: "Position",
              bounds: [-1, 1],
              hidden: () => !t.clipEnabled,
              property: [t, "clipPosition"]
            },
            {
              type: "vec4",
              label: "Params",
              bounds: [0, 1],
              hidden: () => !t.clipEnabled,
              property: [t, "clipParams"]
            },
            {
              type: "toggle",
              label: "Invert",
              hidden: () => !t.clipEnabled,
              property: [t, "clipInvert"]
            }
          ]
        };
        return i;
      }
    }, this.setDirty = () => {
      var s, e, t;
      (e = (s = this.materialExtension).setDirty) == null || e.call(s), (t = this._viewer) == null || t.setDirty();
    }, Object.assign(this.materialExtension.extraUniforms, this._uniforms);
  }
  static AddFragmentClipping(s, e) {
    const t = s == null ? void 0 : s.userData;
    if (!t) return !1;
    t._fragmentClippingExt || (t._fragmentClippingExt = {});
    const i = t._fragmentClippingExt;
    return i.clipEnabled = !0, i.clipPosition === void 0 && (i.clipPosition = [0, 0, 0, 0]), i.clipParams === void 0 && (i.clipParams = [0, 0, 0, 0]), i.clipMode === void 0 !== void 0 && (i.clipMode = 0), i.clipInvert === void 0 !== void 0 && (i.clipInvert = !1), e && Object.assign(i, e), s.setDirty && s.setDirty(), !0;
  }
  onAdded(s) {
    super.onAdded(s), s.assetManager.materials.registerMaterialExtension(this.materialExtension), s.assetManager.registerGltfExtension(eu);
  }
  onRemove(s) {
    var e;
    return (e = s.assetManager.materials) == null || e.unregisterMaterialExtension(this.materialExtension), s.assetManager.unregisterGltfExtension(eu.name), super.onRemove(s);
  }
};
Fo.PluginType = "FragmentClippingExtensionPlugin1";
Fo.FRAGMENT_CLIPPING_EXTENSION_GLTF_EXTENSION = "WEBGI_materials_fragment_clipping_extension";
CS([
  ue("Enabled", (s) => ({ onChange: s.setDirty })),
  V()
], Fo.prototype, "enabled", 2);
Fo = CS([
  Lt("Fragment Clipping (MatExt)")
], Fo);
var Wd = /* @__PURE__ */ ((s) => (s[s.Circle = 0] = "Circle", s[s.Ellipse = 1] = "Ellipse", s[s.Rectangle = 2] = "Rectangle", s[s.Plane = 3] = "Plane", s[s.Sphere = 4] = "Sphere", s))(Wd || {});
class vk {
  constructor(e) {
    this.parser = e, this.name = eu.name;
  }
  async extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return;
    const r = n.extensions[this.name];
    t.userData || (t.userData = {}), Fo.AddFragmentClipping(t), mt.Deserialize(r, t.userData._fragmentClippingExt);
  }
}
const _k = (s) => ({
  writeMaterial: (e, t) => {
    var n;
    if (!e.isMeshStandardMaterial || !((n = e.userData._fragmentClippingExt) != null && n.clipEnabled)) return;
    t.extensions = t.extensions || {};
    const i = mt.Serialize(e.userData._fragmentClippingExt);
    t.extensions[eu.name] = i, s.extensionsUsed[eu.name] = !0;
  }
}), eu = {
  name: "WEBGI_materials_fragment_clipping",
  import: (s) => new vk(s),
  export: _k,
  textures: void 0
};
var xk = Object.defineProperty, wk = Object.getOwnPropertyDescriptor, MS = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? wk(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && xk(e, t, n), n;
};
let Ip = class extends Tt {
  // disable serialization
  constructor(s = !0) {
    super(), this.enabled = !0, this.toJSON = void 0, this.cameras = [], this._viewerListeners = {
      preRender: () => {
        if (this.isDisabled() || !this._viewer) return;
        const e = this._viewer;
        for (const t of this.cameras) {
          if (!t.enabled) continue;
          const i = t.camera;
          try {
            this.dispatchEvent({ type: "preRenderCamera", camera: t }), e.scene.renderCamera = i, e.renderManager.render(e.scene, !1);
            const n = e.renderManager.composer.readBuffer.texture;
            this.dispatchEvent({ type: "preBlitCamera", camera: t, readBuffer: n }), e.renderManager.blit(t.target, { source: n }), this.dispatchEvent({ type: "postRenderCamera", camera: t });
          } catch (n) {
            if (e.console.error(n), t.enabled = !1, e.debug) throw n;
          }
        }
      }
    }, this.enabled = s;
  }
  addCamera(s, e) {
    if (!this._viewer) throw "Plugin not added to viewer";
    e = e ?? this._viewer.renderManager.composerTarget.clone(!0), e.name = s.name + "_virtualCamTarget";
    const t = { camera: s, target: e, enabled: !0 };
    return this.cameras.push(t), t;
  }
};
Ip.PluginType = "VirtualCamerasPlugin";
MS([
  ue()
], Ip.prototype, "enabled", 2);
Ip = MS([
  Lt("Virtual Cameras")
], Ip);
var Ek = Object.defineProperty, bk = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && Ek(e, t, n), n;
};
const Wy = class Wy extends Tt {
  constructor() {
    super(), this.enabled = !0, this._uiNeedRefresh = !1, this.applyOnLoad = !0, this.variations = [], this._selectedMaterial = () => {
      var e, t;
      return ((t = (e = this._picking) == null ? void 0 : e.getSelectedObject()) == null ? void 0 : t.material) || void 0;
    }, this.uiConfig = {
      label: "Material Configurator",
      type: "folder",
      // expanded: true,
      children: [
        () => {
          var e;
          return [
            {
              type: "input",
              label: "uuid",
              property: [this._selectedMaterial(), "uuid"],
              hidden: () => !this._selectedMaterial(),
              disabled: !0
            },
            {
              type: "input",
              label: "mapping",
              hidden: () => !this._selectedMaterial(),
              property: () => [this.getSelectedVariation(), "uuid"],
              onChange: async () => this.refreshUi()
            },
            {
              type: "input",
              label: "title",
              hidden: () => !this._selectedMaterial(),
              property: () => [this.getSelectedVariation(), "title"],
              onChange: async () => this.refreshUi()
            },
            {
              type: "dropdown",
              label: "Preview Type",
              hidden: () => !this._selectedMaterial(),
              property: () => [this.getSelectedVariation(), "preview"],
              onChange: async () => this.refreshUi(),
              children: ["generate:sphere", "generate:cube", "color", "map", "emissive", ...Object.keys(Ds.MaterialProperties).filter((t) => t.endsWith("Map"))].map((t) => ({
                label: t,
                value: t
              }))
            },
            ...((e = this.getSelectedVariation()) == null ? void 0 : e.materials.map((t) => t.uiConfig ? Object.assign(t.uiConfig, { expanded: !1 }) : {})) || [],
            {
              type: "button",
              label: "Clear variations",
              hidden: () => !this._selectedMaterial(),
              value: async () => {
                const t = this.getSelectedVariation();
                t && await this._viewer.dialog.confirm("Material configurator: Remove all variations for this material?") && (t.materials = []), this.refreshUi();
              }
            },
            {
              type: "button",
              label: "Remove completely",
              hidden: () => !this._selectedMaterial(),
              value: async () => {
                const t = this.getSelectedVariation();
                t && await this._viewer.dialog.confirm("Material configurator: Remove this variation?") && this.removeVariation(t);
              }
            },
            {
              type: "button",
              label: "Add Variation",
              hidden: () => !this._selectedMaterial(),
              value: async () => {
                var i;
                const t = this._selectedMaterial();
                t && (!t.name && !await ((i = this._viewer) == null ? void 0 : i.dialog.confirm("Material configurator: Material has no name. Use uuid instead?")) || this.addVariation(t));
              }
            },
            {
              type: "button",
              label: "Refresh Ui",
              value: () => this.refreshUi()
            },
            {
              type: "button",
              label: "Apply All",
              value: () => {
                this.variations.forEach((t) => this.applyVariation(t, t.materials[0].uuid));
              }
            }
          ];
        }
      ]
    }, this.addEventListener("deserialize", this.refreshUi), this.refreshUi = this.refreshUi.bind(this), this._refreshUi = this._refreshUi.bind(this), this._refreshUiConfig = this._refreshUiConfig.bind(this);
  }
  onAdded(e) {
    super.onAdded(e), e.forPlugin(Dh, (t) => {
      var i;
      this._picking = t, (i = this._picking) == null || i.addEventListener("selectedObjectChanged", this._refreshUiConfig);
    }, () => {
      var t;
      (t = this._picking) == null || t.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this._picking = void 0;
    }), this._previewGenerator = new ZB(), e.addEventListener("preFrame", this._refreshUi);
  }
  /**
   * Reapply all selected variations again.
   * Useful when the scene is loaded or changed and the variations are not applied.
   */
  reapplyAll() {
    this.variations.forEach((e) => this.applyVariation(e, e.materials[e.selectedIndex ?? 0].uuid));
  }
  fromJSON(e, t) {
    return this.variations = [], super.fromJSON(e, t) ? (e.applyOnLoad === void 0 && (this.applyOnLoad = !1), this.applyOnLoad && this.reapplyAll(), this) : null;
  }
  onRemove(e) {
    var t, i;
    return (t = this._previewGenerator) == null || t.dispose(), this._previewGenerator = void 0, (i = this._picking) == null || i.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this.removeEventListener("deserialize", this.refreshUi), e.removeEventListener("preFrame", this._refreshUi), this._picking = void 0, super.onRemove(e);
  }
  findVariation(e) {
    return e ? this.variations.find((t) => t.uuid === e) : void 0;
  }
  getSelectedVariation() {
    var e, t;
    return this.findVariation((e = this._selectedMaterial()) == null ? void 0 : e.uuid) || this.findVariation((t = this._selectedMaterial()) == null ? void 0 : t.name);
  }
  /**
   * Apply a material variation based on index or uuid.
   * @param variations
   * @param matUuidOrIndex
   */
  applyVariation(e, t) {
    var r;
    const i = (r = this._viewer) == null ? void 0 : r.materialManager;
    if (!i) return !1;
    const n = typeof t == "string" ? e.materials.find((a) => a.uuid === t) : e.materials[t];
    return n ? (e.selectedIndex = e.materials.indexOf(n), i.applyMaterial(n, e.uuid)) : !1;
  }
  /**
   * Get the preview for a material variation
   * Should be called from preFrame ideally. (or preRender but set viewerSetDirty = false)
   * @param preview - Type of preview. Could be generate:sphere, generate:cube, color, map, emissive, etc.
   * @param material - Material or index of the material in the variation.
   * @param viewerSetDirty - call viewer.setDirty() after setting the preview. So that the preview is cleared from the canvas.
   */
  getPreview(e, t, i = !0) {
    if (!this._viewer) return "";
    const n = e;
    if (!n) return "";
    let r = "";
    if (t.startsWith("generate:"))
      r = this._previewGenerator.generate(
        n,
        this._viewer.renderManager.renderer,
        this._viewer.scene.environment,
        t.split(":")[1]
      );
    else {
      const a = n[t] || "#ff00ff";
      r = a.image ? oB(a.image, 100) : "", r.length || (r = hB(a.isColor ? a.getHexString() : a));
    }
    return i && this._viewer.setDirty(), r;
  }
  /**
   * Refreshes the UI in the next frame
   */
  refreshUi() {
    !this.enabled || !this._viewer || (this._uiNeedRefresh = !0);
  }
  _refreshUiConfig() {
    var e, t;
    this.enabled && ((t = (e = this.uiConfig).uiRefresh) == null || t.call(e));
  }
  // must be called from preFrame
  async _refreshUi() {
    return !this.enabled || !this._viewer || !this._uiNeedRefresh ? !1 : (this._uiNeedRefresh = !1, this._refreshUiConfig(), !0);
  }
  removeVariationForMaterial(e) {
    let t = this.findVariation(e.uuid);
    !t && e.name.length > 0 && (t = this.findVariation(e.name)), t && this.removeVariation(t);
  }
  removeVariation(e) {
    e && (this.variations.splice(this.variations.indexOf(e), 1), this.refreshUi());
  }
  addVariation(e, t, i = !0) {
    const n = i && (e != null && e.clone) ? e.clone() : e;
    if (e && n) {
      let r = this.findVariation(t ?? e.uuid);
      !r && !t && e.name.length > 0 && (r = this.findVariation(e.name)), r || (r = this.createVariation(e, t)), r.materials.push(n), this.refreshUi();
    }
  }
  createVariation(e, t) {
    return this.variations.push({
      uuid: t ?? e.name.length > 0 ? e.name : e.uuid,
      title: e.name.length > 0 ? e.name : "No Name",
      preview: "generate:sphere",
      materials: []
    }), this.variations[this.variations.length - 1];
  }
};
Wy.PluginType = "MaterialConfiguratorPlugin";
let Yg = Wy;
bk([
  V()
], Yg.prototype, "variations");
var Sk = Object.defineProperty, Ck = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && Sk(e, t, n), n;
};
const jy = class jy extends Tt {
  constructor() {
    super(), this.enabled = !0, this._uiNeedRefresh = !1, this.applyOnLoad = !0, this.variations = [], this._selectedSwitchNode = () => {
      var n;
      const e = (n = this._picking) == null ? void 0 : n.getSelectedObject();
      if (!e) return;
      const t = this.variations.map((r) => r.name);
      let i;
      return e.traverseAncestors((r) => {
        i || r.name && t.includes(r.name) && (i = r);
      }), i;
    }, this.autoSnapIcons = !1, this.uiConfig = {
      label: "Switch Node Plugin",
      type: "folder",
      // expanded: true,
      children: [
        {
          type: "checkbox",
          label: "Enabled",
          property: [this, "enabled"]
        },
        () => [
          {
            type: "folder",
            label: "All nodes",
            expanded: !0,
            children: [
              this.variations.map((e) => ({
                type: "input",
                label: e.title,
                property: [e, "name"],
                onChange: () => this.refreshUi()
              }))
            ]
          },
          {
            type: "button",
            label: "Add Node",
            value: () => {
              this.addNode({
                name: "switch_node",
                selected: "",
                title: "Switch Node",
                camView: "front",
                camDistance: 1
              });
            }
          },
          {
            type: "button",
            label: "Refresh UI",
            value: () => this.refreshUi()
          },
          {
            type: "input",
            label: "Selected node title",
            hidden: () => !this._selectedSwitchNode(),
            property: () => {
              const e = this._selectedSwitchNode();
              return e ? [this.variations.find((t) => t.name === e.name), "title"] : [];
            },
            onChange: () => this.refreshUi()
          },
          {
            type: "slider",
            bounds: [0.01, 2],
            stepSize: 0.01,
            label: "Cam Distance",
            hidden: () => !this._selectedSwitchNode(),
            property: () => {
              const e = this._selectedSwitchNode();
              return e ? [this.variations.find((t) => t.name === e.name), "camDistance"] : [];
            }
            // onChange: ()=> this.refreshUi(),
          },
          {
            type: "dropdown",
            label: "Cam View",
            hidden: () => !this._selectedSwitchNode(),
            property: () => {
              const e = this._selectedSwitchNode();
              return e ? [this.variations.find((t) => t.name === e.name), "camView"] : [];
            },
            onChange: () => this.refreshUi(),
            children: ["top", "bottom", "front", "back", "left", "right"].map((e) => ({
              label: e,
              value: e
            }))
          }
        ]
      ]
    }, this._postFrame = this._postFrame.bind(this), this.refreshUiConfig = this.refreshUiConfig.bind(this), this.addEventListener("deserialize", async () => {
      this.refreshUi();
    });
  }
  onAdded(e) {
    var t;
    super.onAdded(e), this._picking = e.getPlugin("Picking"), (t = this._picking) == null || t.addEventListener("selectedObjectChanged", this.refreshUiConfig), e.addEventListener("postFrame", this._postFrame);
  }
  onRemove(e) {
    var t;
    this._picking = e.getPlugin("Picking"), (t = this._picking) == null || t.removeEventListener("selectedObjectChanged", this.refreshUiConfig), e.removeEventListener("postFrame", this._postFrame), super.onRemove(e);
  }
  _postFrame() {
    this._uiNeedRefresh && this._refreshUi();
  }
  /**
   * Select a switch node variation with name or uuid.
   * @param node
   * @param nameOrUuid
   * @param setDirty - set dirty in the viewer after update.
   */
  selectNode(e, t, i = !0) {
    var o, l;
    const n = (o = this._viewer) == null ? void 0 : o.scene.getObjectByName(e.name);
    if (!n || n.children.length < 1) return;
    const r = typeof t == "number" ? n.children[t] : n.children.find((c) => c.name === t || c.uuid === t);
    if (!r)
      return (l = this._viewer) == null || l.console.warn("SwitchNodePlugin: child not found", t), !1;
    e.selected = r.name || r.uuid;
    let a = !1;
    for (const c of n.children) {
      const h = c.visible;
      c.visible = (c.name || c.uuid) === e.selected, a = a || h !== c.visible;
    }
    return a && i && this._viewer.scene.setDirty({ refreshScene: !0, frameFade: !0 }), a;
  }
  /**
   * Reapply all selected variations again.
   * Useful when the scene is loaded or changed and the variations are not applied.
   */
  reapplyAll() {
    this.variations.forEach((e) => this.selectNode(e, e.selected || 0, !1)), this._viewer.scene.setDirty({ refreshScene: !0, frameFade: !0 });
  }
  fromJSON(e, t) {
    return this.variations = [], super.fromJSON(e, t) ? (e.applyOnLoad === void 0 && (this.applyOnLoad = !0), this.applyOnLoad && this.reapplyAll(), this) : null;
  }
  refreshUi() {
    this.enabled && (this._uiNeedRefresh = !0);
  }
  _refreshUi() {
    return !this.enabled || !this._viewer ? !1 : (this._uiNeedRefresh = !1, this.autoSnapIcons && this.snapIcons(), this.refreshUiConfig(), !0);
  }
  refreshUiConfig() {
    var e, t;
    this.enabled && ((t = (e = this.uiConfig).uiRefresh) == null || t.call(e));
  }
  /**
   * Get the preview for a switch node variation
   * Should be called from preFrame ideally. (or preRender but set viewerSetDirty = false)
   * @param child - Child Object to get the preview for
   * @param variation - Switch node variation that contains the child.
   * @param viewerSetDirty - call viewer.setDirty() after setting the preview. So that the preview is cleared from the canvas.
   */
  getPreview(e, t, i = !0) {
    var o;
    if (!this._viewer || !e) return "";
    const n = e.camView, r = new M(
      (n.includes("right") ? 1 : 0) - (n.includes("left") ? 1 : 0),
      (n.includes("top") ? 1 : 0) - (n.includes("bottom") ? 1 : 0),
      (n.includes("front") ? 1 : 0) - (n.includes("back") ? 1 : 0)
    );
    e.camDistance || (e.camDistance = 1);
    const a = dE(this._viewer.renderManager.renderer, t, (o = this._viewer) == null ? void 0 : o.scene, 7, r.multiplyScalar(e.camDistance * 2));
    return i && this._viewer.setDirty(), a;
  }
  addNode(e, t = !0) {
    this.variations.push(e), t && this.refreshUi();
  }
  /**
   * Snapshots icons and puts in the userdata.__icon
   */
  snapIcons() {
    for (const e of this.variations) {
      const t = this._viewer.scene.getObjectByName(e.name);
      if (!t) {
        console.warn("no object found for variation, skipping", e);
        continue;
      }
      t.children.length < 1 && console.warn("SwitchNode does not have enough children", e);
      for (const i of t.children) {
        if (i.userData.__icon) return;
        const n = this.getPreview(e, i, !1);
        n && (i.userData.__icon = n);
      }
    }
  }
};
jy.PluginType = "SwitchNodePlugin";
let Kg = jy;
Ck([
  V()
], Kg.prototype, "variations");
const Mk = `
#ifdef HDRi_GROUND_PROJ
float intersectPlane1(const in vec3 r0,const in vec3 rd,const in vec3 n,const in vec3 p0){float t=dot(p0-r0,n)/(dot(n,rd)+1e-6);return t<0. ? 1000. : t;}float intersectSphere1(in vec3 ro,in vec3 rd,in vec3 sph,in float rad){vec3 oc=ro-sph;float b=dot(oc,rd);float c=dot(oc,oc)-rad*rad;float t=b*b-c;return t<0.0 ? t :-b+sqrt(t);}
#define PI_HALF 1.5707963267948966
uniform float worldRadius;uniform float tripodHeight;uniform vec3 originPosition;vec3 hdriProject(){vec3 p=normalize(vWorldDirection);vec3 camPos=cameraPosition;camPos.y-=tripodHeight;float t=intersectSphere1(camPos,p,originPosition,worldRadius);if(t>0.0){float t2=intersectPlane1(camPos,p,vec3(0,-1,0),originPosition+vec3(0.0,-tripodHeight,0.0));p=(camPos+min(t,t2)*p)/worldRadius;/*if(t2<t&&tripodHeight<0.001){float phi=atan(p.z,p.x);float p1=0.4;float l=length(p.xz);p1=(1.-p1*l)/(1.-p1);float theta=sin(l*PI_HALF)*PI_HALF;p.x=sin(theta)*cos(phi)*p1;p.y=-cos(theta);p.z=sin(theta)*sin(phi)*p1;}*/}else p=vec3(0.0,1.0,0.0);return p;}
#endif
`;
var Tk = Object.defineProperty, Ik = Object.getOwnPropertyDescriptor, Hc = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? Ik(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && Tk(e, t, n), n;
};
let gs = class extends Tt {
  // todo
  // /**
  //  * Automatically set the origin position based on the ground position in GroundPlugin
  //  */
  // @serialize()
  // @onChange(HDRiGroundPlugin.prototype.setDirty)
  // @uiToggle('Auto Ground Position')
  // autoGroundPosition = false
  constructor(s = !1, e = !0) {
    super(), this.enabled = !1, this.worldRadius = 100, this.tripodHeight = 10, this.originPosition = new M(0, 0, 0), this.promptOnBackgroundMismatch = !0, this.setDirty = this.setDirty.bind(this), this.enabled = s, this.promptOnBackgroundMismatch = e, this.addEventListener("deserialize", this.setDirty);
  }
  setDirty() {
    var i;
    if (!this._viewer) return;
    const s = this._viewer.scene.background;
    this.enabled && s !== this._viewer.scene.environment && s !== "environment" && (s && s.isDataTexture ? s.mapping = Ia : (this.promptOnBackgroundMismatch ? this._viewer.dialog.confirmSync("Background must be same as environment, do you want to change it?") : !0) ? this._viewer.scene.background = "environment" : this.enabled = !1);
    const e = (i = this._viewer.renderManager.renderer.background.getBoxMesh2()) == null ? void 0 : i.material, t = (e == null ? void 0 : e.uniforms) ?? Ci.backgroundCube.uniforms;
    t.tripodHeight || (t.tripodHeight = { value: 1 }), t.worldRadius || (t.worldRadius = { value: 1 }), t.originPosition || (t.originPosition = { value: new M() }), t.tripodHeight.value = this.tripodHeight, t.worldRadius.value = this.worldRadius, t.originPosition.value.copy(this.originPosition), e && (this.isDisabled() && e.defines.HDRi_GROUND_PROJ ? delete e.defines.HDRi_GROUND_PROJ : this.isDisabled() || (e.defines.HDRi_GROUND_PROJ = "1"), e.needsUpdate = !0), this._viewer.setDirty();
  }
  onAdded(s) {
    var e, t;
    super.onAdded(s), (t = (e = this._viewer) == null ? void 0 : e.renderManager.webglRenderer) != null && t.background.getBoxMesh() && s.console.error("HDRi Ground Plugin must be added before setting any cube or env map"), Ci.backgroundCube.fragmentShader.includes("#ifdef HDRi_GROUND_PROJ") || (Ci.backgroundCube.fragmentShader = Ct(Ci.backgroundCube.fragmentShader, "void main() {", Mk, { prepend: !0 }), Ci.backgroundCube.fragmentShader = Ct(Ci.backgroundCube.fragmentShader, "vec3 vReflect = vWorldDirection;", `
vec3 vReflect = 
#ifdef HDRi_GROUND_PROJ
hdriProject()
#else
vWorldDirection
#endif
;
`)), s.scene.addEventListener("environmentChanged", this.setDirty);
  }
};
gs.PluginType = "HDRiGroundPlugin";
Hc([
  V(),
  Oe(gs.prototype.setDirty),
  ue("Enabled")
], gs.prototype, "enabled", 2);
Hc([
  V(),
  Oe(gs.prototype.setDirty),
  Ye("World Radius", [1, 1e3], 0.01)
], gs.prototype, "worldRadius", 2);
Hc([
  V(),
  Oe(gs.prototype.setDirty),
  Ye("Tripod height", [0, 50], 0.01)
], gs.prototype, "tripodHeight", 2);
Hc([
  V(),
  Oe(gs.prototype.setDirty),
  Ji("Origin Position", void 0, 1e-3, (s) => ({
    onChange: s.setDirty
    // this is for x, y, z values.
  }))
], gs.prototype, "originPosition", 2);
Hc([
  V(),
  Oe(gs.prototype.setDirty)
], gs.prototype, "promptOnBackgroundMismatch", 2);
gs = Hc([
  Tn("HDRi Ground")
], gs);
var Dk = Object.defineProperty, Rk = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && Dk(e, t, n), n;
}, jl;
const Jg = (jl = class extends Tt {
  constructor(e = !0) {
    super(), this.enabled = !0, this.helpers = [
      _L,
      SL,
      EL,
      ny
    ], this.toJSON = null, this._widgetRoot = new ut(), this._addSceneObject = (t) => {
      this._createWidgets(t.object);
    }, this.widgets = [], this._widgetDisposed = (t) => this._unregisterWidget(t.target), this.uiConfig = {
      type: "folder",
      label: "Widgets",
      children: [
        {
          type: "checkbox",
          label: "Enabled",
          property: [this, "enabled"]
        },
        {
          type: "button",
          label: "Refresh",
          value: () => this.refresh()
        }
      ]
    }, this.enabled = e;
  }
  setDirty() {
    var e, t;
    (e = this.widgets) == null || e.forEach((i) => i.visible = !this.isDisabled()), (t = this._viewer) == null || t.setDirty();
  }
  onAdded(e) {
    super.onAdded(e), e.scene.addObject(this._widgetRoot, { addToRoot: !0, autoScale: !1, autoCenter: !1 }), e.scene.addEventListener("addSceneObject", this._addSceneObject);
  }
  onRemove(e) {
    e.scene.removeEventListener("addSceneObject", this._addSceneObject), this.widgets.forEach((t) => t.dispose && t.dispose()), this.widgets = [], this._widgetRoot.removeFromParent(), this._widgetRoot.clear(), super.onRemove(e);
  }
  refresh() {
    var e;
    this._createWidgets((e = this._viewer) == null ? void 0 : e.scene.modelRoot);
  }
  _registerWidget(e) {
    this.widgets.push(e), e.addEventListener("dispose", this._widgetDisposed);
  }
  _unregisterWidget(e) {
    e.removeEventListener("dispose", this._widgetDisposed);
    const t = this.widgets.indexOf(e);
    t >= 0 && this.widgets.splice(t, 1);
  }
  _createWidgets(e) {
    e == null || e.traverse((t) => {
      const i = this.widgets.find((r) => r.object === t);
      if (i) {
        i.update && i.update();
        return;
      }
      this.helpers.filter((r) => r.Check(t)).forEach((r) => {
        const a = r.Create(t);
        a.visible = !this.isDisabled(), this._widgetRoot.add(a), this._registerWidget(a);
      });
    });
  }
}, jl.PluginType = "Object3DWidgetsPlugin", jl);
Rk([
  Oe(Jg.prototype.setDirty)
], Jg.prototype, "enabled");
let u5 = Jg;
var Bk = Object.defineProperty, Pk = Object.getOwnPropertyDescriptor, Ey = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? Pk(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && Bk(e, t, n), n;
};
let tu = class extends Tt {
  constructor() {
    super(), this.enabled = !0, this.toJSON = void 0, this._selectedType = "", this.generators = {
      "camera-perspective": (s = {}) => {
        var t;
        const e = new mu(
          s.controlsMode ?? "",
          (t = this._viewer) == null ? void 0 : t.canvas,
          s.autoAspect,
          s.fov,
          s.aspect
        );
        return s.position ? e.position.copy(s.position) : e.position.set(0, 0, 5), s.target ? e.target.copy(s.target) : e.target.set(0, 0, 0), e.autoLookAtTarget = s.autoLookAtTarget ?? !0, e.setDirty(), e.name = s.name ?? "Perspective Camera", e;
      },
      "light-directional": (s = {}) => {
        const e = new Bi(s.color ?? 16711680, s.intensity ?? 3);
        return s.position ? e.position.copy(s.position) : e.position.set(5, 5, 5), e.lookAt(s.target ?? new M(0, 0, 0)), e.name = "Directional Light", e;
      },
      "light-ambient": (s = {}) => {
        const e = new Mo(s.color ?? 16777215, s.intensity ?? 1);
        return e.name = "Ambient Light", e;
      },
      "light-point": (s = {}) => {
        const e = new yi(s.color ?? 16711680, s.intensity ?? 3);
        return s.position ? e.position.copy(s.position) : e.position.set(5, 5, 5), e.name = "Point Light", e;
      },
      "light-spot": (s = {}) => {
        const e = new oi(s.color ?? 16711680, s.intensity ?? 3);
        return s.position ? e.position.copy(s.position) : e.position.set(5, 5, 5), e.lookAt(s.target ?? new M(0, 0, 0)), e.name = "Spot Light", e;
      },
      "light-hemisphere": (s = {}) => {
        const e = new Kr(s.color ?? 11184895, 5592131, s.intensity ?? 1);
        return e.name = "Hemisphere Light", e;
      },
      "light-rect-area": (s = {}) => {
        const e = new gr(s.color ?? 255, s.intensity ?? 3, 2, 2);
        return s.position ? e.position.copy(s.position) : e.position.set(5, 5, 5), e.lookAt(s.target ?? new M(0, 0, 0)), e.name = "Rect Area Light", e;
      }
    }, this._selectedType = Object.keys(this.generators)[0];
  }
  generate(s, e, t = !0, i = !0) {
    var r, a;
    if (!this._viewer) throw new Error("No viewer");
    const n = (a = (r = this.generators)[s ?? this._selectedType]) == null ? void 0 : a.call(r, e);
    return t && n && this._viewer.scene.addObject(n), i && n.dispatchEvent({ type: "select", value: n, object: n, ui: !0 }), n;
  }
};
tu.PluginType = "Object3DGeneratorPlugin";
Ey([
  er("Type", void 0, (s) => ({
    children: [() => Object.keys(s.generators).map((e) => ({ label: e }))]
  }))
], tu.prototype, "_selectedType", 2);
Ey([
  Pt("Generate", { sendArgs: !1 })
], tu.prototype, "generate", 1);
tu = Ey([
  Tn("Generate Scene Objects")
], tu);
var Lk = Object.defineProperty, Uk = Object.getOwnPropertyDescriptor, Eu = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? Uk(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && Lk(e, t, n), n;
};
let Js = class extends Hi {
  constructor() {
    super(), this.contactShadows = !0, this.shadowScale = 1, this.shadowHeight = 5, this.blurAmount = 1, this.shadowCamera = new _r(-1, 1, 1, -1, 1e-3, this.shadowHeight), this._refreshShadowCameraFrustum = this._refreshShadowCameraFrustum.bind(this), this.refresh = this.refresh.bind(this);
  }
  onAdded(s) {
    const e = s.renderManager.createTarget({
      type: Ft,
      format: ei,
      colorSpace: Wt,
      size: { width: 512, height: 512 },
      generateMipmaps: !1,
      depthBuffer: !0,
      minFilter: tt,
      magFilter: tt
      // isAntialiased: this._viewer.isAntialiased,
    });
    e.texture.name = "groundContactDepthTexture";
    const t = new Np({
      // depthPacking: RGBADepthPacking, // todo
      depthPacking: kl,
      transparent: !1,
      blending: _n
    });
    t.onBeforeCompile = (i) => {
      i.uniforms.opacity.value = 1, i.fragmentShader = Ct(
        i.fragmentShader,
        "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );",
        "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), 1.0 );"
        // 'gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );',
      );
    }, this._depthPass = new To("contactShadowGround", e, t, new se(0, 0, 0), 0), this._blurHelper = new $B(s), super.onAdded(s);
  }
  onRemove(s) {
    var t, i, n, r;
    const e = gi((t = this._depthPass) == null ? void 0 : t.target);
    return e && ((i = this._viewer) == null || i.renderManager.disposeTarget(e)), (n = this._depthPass) == null || n.dispose(), this._depthPass = void 0, (r = this._blurHelper) == null || r.dispose(), this._blurHelper = void 0, super.onRemove(s);
  }
  // todo: dispose target, material, pass and stuff
  _postFrame() {
    super._postFrame(), this._viewer;
  }
  _preRender() {
    if (super._preRender(), !this._viewer || !this._depthPass || !this._blurHelper) return;
    this._depthPass.scene = this._viewer.scene, this._depthPass.camera = this.shadowCamera, this._depthPass.render(this._viewer.renderManager.renderer, null);
    const s = gi(this._depthPass.target);
    if (!s) return;
    const e = this._viewer.renderManager.getTempTarget({
      type: Ft,
      format: ei,
      colorSpace: Wt,
      size: { width: 1024, height: 1024 },
      generateMipmaps: !1,
      depthBuffer: !1,
      minFilter: tt,
      magFilter: tt
      // isAntialiased: this._viewer.isAntialiased,
    });
    this._blurHelper.blur(s.texture, s, e, this.blurAmount / 256), this._blurHelper.blur(s.texture, s, e, 0.4 * this.blurAmount / 256), this._viewer.renderManager.releaseTempTarget(e);
  }
  _refreshTransform() {
    return !super._refreshTransform() || !this._mesh || !this._viewer ? !1 : (this.shadowCamera.position.copy(this._mesh.getWorldPosition(new M())), this.shadowCamera.setRotationFromEuler(new xi(Math.PI / 2, 0, 0)), this.shadowCamera.updateMatrixWorld(), this._refreshShadowCameraFrustum(), this._mesh.scale.y = -this.size, !0);
  }
  _refreshShadowCameraFrustum() {
    this.shadowCamera && (this.shadowCamera.left = -this.size / (2 * this.shadowScale), this.shadowCamera.right = this.size / (2 * this.shadowScale), this.shadowCamera.top = this.size / (2 * this.shadowScale), this.shadowCamera.bottom = -this.size / (2 * this.shadowScale), this.shadowCamera.far = this.shadowHeight, this.shadowCamera.updateProjectionMatrix(), this._setDirty());
  }
  _setDirty() {
    var s;
    (s = this._viewer) == null || s.setDirty();
  }
  _removeMaterial() {
    this._material && (this._material.alphaMap = null, this._material.userData.ssreflDisabled && delete this._material.userData.ssreflDisabled, this._material.userData.ssreflNonPhysical && delete this._material.userData.ssreflNonPhysical, super._removeMaterial());
  }
  refresh() {
    this._viewer && super.refresh();
  }
  _createMaterial(s) {
    const e = super._createMaterial(s);
    return e.roughness = 1, e.metalness = 0, e.color.set(1118481), e.transparent = !0, e.userData.ssreflDisabled = !0, e.userData.ssreflNonPhysical = !1, e;
  }
  _refreshMaterial() {
    var e, t;
    if (!this._viewer) return !1;
    const s = super._refreshMaterial();
    return this._material && (this._material.alphaMap = ((t = gi((e = this._depthPass) == null ? void 0 : e.target)) == null ? void 0 : t.texture) || null), s;
  }
};
Js.PluginType = "ContactShadowGroundPlugin";
Eu([
  ue("Contact Shadows"),
  Oe(Js.prototype.refresh),
  V()
], Js.prototype, "contactShadows", 2);
Eu([
  Ye("Shadow Scale", [0, 2]),
  V(),
  Oe(Js.prototype._refreshShadowCameraFrustum)
], Js.prototype, "shadowScale", 2);
Eu([
  Ye("Shadow Height", [0, 20]),
  V(),
  Oe(Js.prototype._refreshShadowCameraFrustum)
], Js.prototype, "shadowHeight", 2);
Eu([
  Ye("Blur Amount", [0, 10]),
  V(),
  Oe(Js.prototype._setDirty)
], Js.prototype, "blurAmount", 2);
Js = Eu([
  Tn("Contact Shadow Ground")
], Js);
var Fk = Object.defineProperty, Ok = Object.getOwnPropertyDescriptor, by = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? Ok(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && Fk(e, t, n), n;
};
const qy = class qy extends Tt {
  constructor() {
    super(), this.enabled = !0, this.toJSON = void 0, this.simplifyFactor = 0.5;
  }
  get initialized() {
    return !0;
  }
  async initialize() {
  }
  onAdded(e) {
    super.onAdded(e), this._pickingPlugin = e.getPlugin(Dh);
  }
  simplifyGeometries(e, t) {
    var n;
    if (!e) {
      const r = (n = this._pickingPlugin) == null ? void 0 : n.getSelectedObject(), a = [];
      if (r == null || r.traverse((o) => {
        o.geometry && !a.includes(o.geometry) && a.push(o.geometry);
      }), e = a, !e || !e.length) return;
    }
    Array.isArray(e) || (e = [e]);
    const i = [];
    for (const r of e)
      i.push(this.simplifyGeometry(r, t));
    return i;
  }
  simplifyGeometry(e, {
    factor: t,
    count: i,
    replace: n = !0,
    disposeOnReplace: r = !1
  } = {}) {
    var f, y, A;
    if (!e) {
      const m = (f = this._pickingPlugin) == null ? void 0 : f.getSelectedObject();
      if (e = m == null ? void 0 : m.geometry, !e) return;
    }
    if (!e.attributes.position)
      return (y = this._viewer) == null || y.console.error("SimplifyModifierPlugin: Geometry does not have position attribute", e), e;
    t = t || this.simplifyFactor, i = i || e.attributes.position.count * t, e.boundingBox || e.computeBoundingBox();
    const a = this._simplify(e, i);
    a.computeBoundingBox(), a.computeBoundingSphere(), a.computeVertexNormals();
    const o = a.boundingBox, l = o.getSize(new M());
    if (!isFinite(l.x) || !isFinite(l.y) || !isFinite(l.z))
      return (A = this._viewer) == null || A.console.error("SimplifyModifierPlugin: Unable to simplify", e, a, l), e;
    const c = e.boundingBox, h = c.getSize(new M()), u = l.clone().sub(h), d = u.clone().divide(h);
    if (d.lengthSq() > 1e-3 && console.warn("Simplify", e, a, o, c, l, h, u, d), !n) return a;
    const p = e.appliedMeshes;
    if (!p)
      return console.error("No meshes found for geometry, cannot replace", e), a;
    for (const m of p)
      m.geometry = a;
    return r && e.dispose(!0), a;
  }
  async simplifyAll(e, t) {
    var n;
    if (!e && this._viewer && (e = this._viewer.scene.modelRoot), !e) {
      console.error("SimplifyModifierPlugin: No root found");
      return;
    }
    if (!this.initialized && (await this.initialize(), !this.initialized)) {
      (n = this._viewer) == null || n.console.error("SimplifyModifierPlugin cannot be initialized");
      return;
    }
    const i = [];
    if (e.traverse((r) => {
      r.geometry && !i.includes(r.geometry) && i.push(r.geometry);
    }), !i.length) {
      console.error("SimplifyModifierPlugin: No geometries found");
      return;
    }
    return this.simplifyGeometries(i, t);
  }
  async simplifySelected() {
    var i;
    if (!this._viewer) return;
    if (!this.initialized && (await this.initialize(), !this.initialized)) {
      await this._viewer.dialog.alert("Simplify: SimplifyModifierPlugin cannot be initialized");
      return;
    }
    const e = (i = this._pickingPlugin) == null ? void 0 : i.getSelectedObject();
    if (!e) {
      await this._viewer.dialog.alert("Simplify: Nothing Selected");
      return;
    }
    let t = !1;
    e.geometry ? e.children.length === 0 && (t = !0) : t = !0, t || await this._viewer.dialog.confirm("Simplify: Simplify all in hierarchy?") && (t = !0), t ? this.simplifyGeometries() : this.simplifyGeometry(e.geometry);
  }
};
qy.PluginType = "SimplifyModifierPlugin";
let yc = qy;
by([
  Ye("Simplify Factor", [0, 1])
], yc.prototype, "simplifyFactor", 2);
by([
  Pt("Simplify All", { sendArgs: !1 })
], yc.prototype, "simplifyAll", 1);
by([
  Pt("Simplify Selected")
], yc.prototype, "simplifySelected", 1);
var Nk = Object.defineProperty, kk = Object.getOwnPropertyDescriptor, Sy = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? kk(e, t) : e, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = (i ? a(e, t, n) : a(n)) || n);
  return i && n && Nk(e, t, n), n;
};
let Oo = class extends yc {
  constructor(s = !0, e = document.head) {
    super(), this.rootNode = e, this._initializing = void 0, this.errorThreshold = 0.5, this.lockBorder = !1, s && this.initialize();
  }
  get initialized() {
    return !!window.MeshoptSimplifier;
  }
  onAdded(s) {
    super.onAdded(s);
  }
  async initialize() {
    if (this.initialized) return;
    if (this._initializing) return await this._initializing;
    const s = document.createElement("script");
    s.type = "module";
    const e = Math.random().toString(36).substring(7);
    return s.innerHTML = `
import { MeshoptSimplifier } from '${Oo.SIMPLIFIER_URL}';
MeshoptSimplifier.ready.then(() => {
window.MeshoptSimplifier = MeshoptSimplifier;
window.dispatchEvent(new CustomEvent('${e}'))
});
`, this._initializing = new Promise((t) => {
      window.addEventListener(e, () => t(), { once: !0 }), this.rootNode.appendChild(s), this._script = s;
    }), await this._initializing;
  }
  dispose() {
    this._script && (this._script.remove(), delete window.MeshoptSimplifier), this._script = void 0;
  }
  _simplify(s, e) {
    if (!this.initialized) throw new Error("MeshOptSimplifyModifierPlugin not initialized");
    s.index ? s = s.clone() : s = cE(s);
    const t = s.index.array, i = s.attributes.position.array, n = e / s.attributes.position.count, r = 3 * Math.floor(n * t.length / 3), [a, o] = window.MeshoptSimplifier.simplify(
      t,
      i,
      3,
      r,
      this.errorThreshold,
      this.lockBorder ? ["LockBorder"] : []
    );
    return console.log("srcCount", t.length / 3, "destCount", a.length / 3), o && console.warn("Simplify error", o), s.setIndex(new Je(new Uint32Array(a), 1)), ai.upgradeGeometry.call(s.toNonIndexed());
  }
};
Oo.PluginType = "MeshOptSimplifyModifierPlugin";
Oo.SIMPLIFIER_URL = "https://unpkg.com/meshoptimizer@0.20.0/meshopt_simplifier.module.js";
Sy([
  ii()
], Oo.prototype, "errorThreshold", 2);
Sy([
  ue()
], Oo.prototype, "lockBorder", 2);
Oo = Sy([
  Lt("Simplify Modifier (meshopt)")
], Oo);
const Gk = (s) => {
  const e = [], t = /* @__PURE__ */ new Set();
  for (const i of s) {
    let n = i, r = 0;
    for (; t.has(n); )
      n = i + "." + ++r;
    t.add(n), e.push(n);
  }
  return e;
}, zk = (s, e) => {
  const t = {};
  for (const i of s.mappings)
    for (const n of i.variants)
      t[e[n]] = {
        material: null,
        gltfMaterialIndex: i.material
      };
  return t;
}, Qk = (s) => s.material !== void 0 && // easier than (!object.isMesh && !object.isLine && !object.isPoints)
s.userData && // just in case
s.userData._variantMaterials, vc = "KHR_materials_variants";
class Hk {
  constructor(e) {
    this.parser = e, this.name = vc;
  }
  // Note that the following properties will be overridden even if they are pre-defined
  // - mesh.userData._variantMaterials
  async afterRoot(e) {
    const t = this.parser, i = t.json;
    if (!i.extensions || !i.extensions[this.name]) return;
    const r = i.extensions[this.name].variants || [], a = Gk(r.map((l) => l.name));
    for (const l of e.scenes)
      l.traverse((c) => {
        const h = t.associations.get(c);
        if (!h || h.meshes === void 0 || h.primitives === void 0)
          return;
        const p = i.meshes[h.meshes].primitives[h.primitives].extensions;
        !p || !p[this.name] || (c.userData._variantMaterials = zk(p[this.name], a));
      });
    const o = async (l) => {
      const c = l.material, h = l.userData._variantMaterials, u = [];
      for (const d in h) {
        const p = h[d];
        if (p.material)
          continue;
        const f = p.gltfMaterialIndex;
        u.push(t.getDependency("material", f).then((y) => {
          l.material = y, t.assignFinalMaterial(l), h[d].material = l.material;
        }));
      }
      return Promise.all(u).then(() => {
        l.material = c;
      });
    };
    await Promise.all(e.scenes.map(async (l) => {
      const c = [];
      return l.traverse((h) => Qk(h) && c.push(o(h))), l.userData.__importData || (l.userData.__importData = {}), l.userData.__importData[vc] = {
        names: a
      }, Promise.all(c);
    }));
  }
}
const kx = (s) => s.material !== void 0 && // easier than (!object.isMesh && !object.isLine && !object.isPoints)
s.userData && // just in case
s.userData._variantMaterials && !!Object.values(s.userData._variantMaterials).filter((e) => jd(e == null ? void 0 : e.material)), jd = (s) => s && s.isMaterial && !Array.isArray(s);
class Vk {
  constructor(e) {
    this.writer = e, this.name = vc, this.variantNames = [];
  }
  beforeParse(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of e)
      i.traverse((n) => {
        if (!kx(n))
          return;
        const r = n.userData._variantMaterials;
        for (const a in r) {
          const o = r[a];
          jd(o.material) && t.add(a);
        }
      });
    t.forEach((i) => this.variantNames.push(i));
  }
  writeMesh(e, t) {
    if (!kx(e))
      return;
    const i = e.userData, n = i._variantMaterials, r = {};
    for (const l in n) {
      const c = n[l].material;
      if (!jd(c))
        continue;
      const h = this.variantNames.indexOf(l), u = this.writer.processMaterial(c);
      r[u] || (r[u] = {
        material: u,
        variants: []
      }), r[u].variants.push(h);
    }
    const a = Object.values(r).map((l) => l.variants.sort((c, h) => c - h) && l).sort((l, c) => l.material - c.material);
    if (a.length === 0)
      return;
    const o = jd(i._originalMaterial) ? this.writer.processMaterial(i._originalMaterial) ?? -1 : -1;
    for (const l of t.primitives)
      o >= 0 && (l.material = o), l.extensions = l.extensions || {}, l.extensions[this.name] = { mappings: a };
  }
  afterParse(e) {
    if (this.variantNames.length === 0)
      return;
    const t = this.writer.json;
    t.extensions = t.extensions || {};
    const i = this.variantNames.map((n) => ({ name: n }));
    t.extensions[this.name] = { variants: i }, this.writer.extensionsUsed[this.name] = !0;
  }
}
function Wk(s) {
  return new Vk(s);
}
var jk = Object.defineProperty, TS = (s, e, t, i) => {
  for (var n = void 0, r = s.length - 1, a; r >= 0; r--)
    (a = s[r]) && (n = a(e, t, n) || n);
  return n && jk(e, t, n), n;
}, ql;
const Dp = (ql = class extends Tt {
  constructor() {
    super(), this.enabled = !0, this.variants = {}, this.selectedVariant = "", this.applyFirstVariantOnLoad = !0, this._objectAdded = (e) => {
      var i, n;
      const t = e.object;
      t != null && t.isObject3D && this._viewer && (t.traverse((r) => {
        var l, c, h;
        if (r.userData._variantMaterials)
          for (const u of Object.values(r.userData._variantMaterials))
            u != null && u.material && (u.material = ((l = this._viewer) == null ? void 0 : l.materialManager.convertToIMaterial(u.material, {})) || u.material);
        const a = (h = (c = r.userData) == null ? void 0 : c.__importData) == null ? void 0 : h[vc];
        if (!a) return;
        const o = a.names || [];
        for (const u of o)
          this.variants[u] || (this.variants[u] = []), this.variants[u].push(r);
        delete r.userData.__importData[vc];
      }), !this.selectedVariant && this.applyFirstVariantOnLoad && (this.selectedVariant = Object.keys(this.variants)[0] || ""), (n = (i = this.uiConfig).uiRefresh) == null || n.call(i));
    }, this.uiConfig = {
      type: "folder",
      label: "KHR Material Variants",
      children: [
        () => ({
          children: [null, ...Object.keys(this.variants)].map((e) => e ? { label: e } : { label: "none", value: "" }),
          type: "dropdown",
          label: "Variant",
          property: [this, "selectedVariant"]
        })
      ]
    };
  }
  onAdded(e) {
    super.onAdded(e), e.scene.addEventListener("addSceneObject", this._objectAdded), e.assetManager.registerGltfExtension(Gx);
  }
  onRemove(e) {
    return e.scene.removeEventListener("addSceneObject", this._objectAdded), e.assetManager.unregisterGltfExtension(Gx.name), this.variants = {}, super.onRemove(e);
  }
  _variantChanged() {
    this.applyVariant(this.selectedVariant || "", !0);
  }
  /**
   * Apply the variant to objects.
   * It will also change the `selectedVariant` if `root` is not provided.
   * @param name
   * @param force
   * @param root
   * @param doTraverse
   */
  applyVariant(e, t = !1, i, n = !0) {
    if (!t && !i && this.selectedVariant === e || !e) return;
    i || (this.selectedVariant = e);
    const r = i ? Array.isArray(i) ? i : [i] : e ? this.variants[e] || [] : Object.values(this.variants).flat();
    for (const a of r) {
      const o = /* @__PURE__ */ new Set(), l = (c) => {
        var u;
        if (!c.userData._variantMaterials || o.has(c)) return;
        const h = e ? (u = c.userData._variantMaterials[e]) == null ? void 0 : u.material : c.userData._originalMaterial;
        h && (c.userData._originalMaterial || (c.userData._originalMaterial = c.material), c.material = h), o.add(c);
      };
      n ? a.traverse(l) : l(a);
    }
  }
}, ql.PluginType = "GLTFKHRMaterialVariantsPlugin", ql);
TS([
  Oe(Dp.prototype._variantChanged),
  V()
], Dp.prototype, "selectedVariant");
TS([
  V()
], Dp.prototype, "applyFirstVariantOnLoad");
let d5 = Dp;
const Gx = {
  name: vc,
  import: (s) => new Hk(s),
  export: Wk
  // textures: undefined,
};
function p5() {
  window.dispatchEvent(new Event("threepipe-test-finished")), document.body.classList.add("_testFinish");
}
function f5() {
  window.dispatchEvent(new Event("threepipe-test-started")), document.body.classList.add("_testStarted");
}
function m5(s) {
  return ct.autoCenter.call(s);
}
function g5(s, e, t, i) {
  return ct.autoScale.call(s, e, t, i);
}
export {
  y3 as AAssetManagerProcessStatePlugin,
  C4 as ACESFilmicToneMapping,
  Ay as ACameraControlsPlugin,
  pL as ACameraHelperWidget,
  qE as AHelperWidget,
  iy as ALightHelperWidget,
  of as AScreenPassExtensionPlugin,
  pp as AViewerPlugin,
  Rz as AViewerPluginAsync,
  Tt as AViewerPluginSync,
  WQ as AddEquation,
  x4 as AddOperation,
  rV as AdditiveAnimationBlendMode,
  zQ as AdditiveBlending,
  aH as AlphaFormat,
  XV as AlwaysCompare,
  d4 as AlwaysDepth,
  GV as AlwaysStencilFunc,
  UA as AmbientLight,
  Mo as AmbientLight2,
  ic as AnimationClip,
  rG as AnimationLoader,
  PR as AnimationMixer,
  dG as AnimationObjectGroup,
  sG as AnimationUtils,
  yD as ArcCurve,
  aD as ArrayCamera,
  MG as ArrowHelper,
  HO as AssetExporter,
  Xg as AssetExporterPlugin,
  qh as AssetImporter,
  Hg as AssetManager,
  qz as AsyncCompress,
  Jz as AsyncDecompress,
  PU as AsyncDeflate,
  UU as AsyncGunzip,
  qz as AsyncGzip,
  Db as AsyncInflate,
  oQ as AsyncUnzipInflate,
  OU as AsyncUnzlib,
  nQ as AsyncZipDeflate,
  Yz as AsyncZlib,
  T4 as AttachedBindMode,
  vR as Audio,
  uG as AudioAnalyser,
  Ww as AudioContext,
  cG as AudioListener,
  oG as AudioLoader,
  TG as AxesHelper,
  FQ as BackSide,
  Hi as BaseGroundPlugin,
  Gc as BaseImporterPlugin,
  uV as BasicDepthPacking,
  RQ as BasicShadowMap,
  Uh as Bone,
  Cc as BooleanKeyframeTrack,
  jw as Box2,
  is as Box3,
  Nn as Box3B,
  SG as Box3Helper,
  Si as BoxGeometry,
  bG as BoxHelper,
  AL as BoxSelectionWidget,
  Je as BufferAttribute,
  Ze as BufferGeometry,
  Vz as BufferGeometry2,
  Vw as BufferGeometryLoader,
  K4 as ByteType,
  us as Cache,
  Up as Camera,
  EG as CameraHelper,
  ny as CameraHelper2,
  hn as CameraView,
  rN as CameraViewPlugin,
  dp as CanvasSnapshot,
  Ks as CanvasSnapshotPlugin,
  Fx as CanvasSnipperPlugin,
  Qp as CanvasTexture,
  vA as CapsuleGeometry,
  vD as CatmullRomCurve3,
  Ac as ChromaticAberrationPlugin,
  S4 as CineonToneMapping,
  _A as CircleGeometry,
  O4 as ClampToEdgeWrapping,
  Po as ClearcoatTintPlugin,
  NA as Clock,
  se as Color,
  Gw as ColorKeyframeTrack,
  Rt as ColorManagement,
  ex as Compress,
  gD as CompressedArrayTexture,
  ba as CompressedTexture,
  hR as CompressedTextureLoader,
  xA as ConeGeometry,
  c4 as ConstantAlphaFactor,
  o4 as ConstantColorFactor,
  Js as ContactShadowGroundPlugin,
  rc as CopyShader,
  BC as CubeCamera,
  R4 as CubeReflectionMapping,
  B4 as CubeRefractionMapping,
  Fp as CubeTexture,
  aG as CubeTextureLoader,
  U4 as CubeUVReflectionMapping,
  Mw as CubicBezierCurve,
  MD as CubicBezierCurve3,
  sR as CubicInterpolant,
  TQ as CullFaceBack,
  IQ as CullFaceFront,
  DQ as CullFaceFrontBack,
  MQ as CullFaceNone,
  Zs as Curve,
  ID as CurvePath,
  VQ as CustomBlending,
  Uo as CustomBumpMapPlugin,
  cp as CustomContextMenu,
  M4 as CustomToneMapping,
  yn as CylinderGeometry,
  mG as Cylindrical,
  kg as DRACOLoader2,
  BG as Damper,
  lA as Data3DTexture,
  oA as DataArrayTexture,
  Wr as DataTexture,
  Qw as DataTextureLoader,
  Gn as DataUtils,
  eQ as DecodeUTF8,
  kU as Decompress,
  IV as DecrementStencilOp,
  RV as DecrementWrapStencilOp,
  zw as DefaultLoadingManager,
  Zr as Deflate,
  dc as DepthBufferPlugin,
  hH as DepthFormat,
  EQ as DepthNormalMaterial,
  uH as DepthStencilFormat,
  bw as DepthTexture,
  I4 as DetachedBindMode,
  bo as DeviceOrientationControls2,
  wx as DeviceOrientationControlsPlugin,
  hu as DirectionalLight,
  Bi as DirectionalLight2,
  wG as DirectionalLightHelper,
  _L as DirectionalLightHelper2,
  rR as DiscreteInterpolant,
  yV as DisplayP3ColorSpace,
  wA as DodecahedronGeometry,
  OQ as DoubleSide,
  cg as Dropzone,
  Ys as DropzonePlugin,
  i4 as DstAlphaFactor,
  s4 as DstColorFactor,
  i5 as DynamicCopyUsage,
  KV as DynamicDrawUsage,
  ZV as DynamicReadUsage,
  $b as EXRExporter2,
  ey as EasingFunctions,
  DD as EdgesGeometry,
  gc as EditorViewWidgetPlugin,
  _U as EffectComposer,
  xU as EffectComposer2,
  AA as EllipseCurve,
  tQ as EncodeUTF8,
  HV as EqualCompare,
  m4 as EqualDepth,
  UV as EqualStencilFunc,
  P4 as EquirectangularReflectionMapping,
  L4 as EquirectangularRefractionMapping,
  xi as Euler,
  Vi as EventDispatcher,
  ob as ExtendedCopyPass,
  ab as ExtendedRenderPass,
  UL as ExtendedShaderMaterial,
  gu as ExtendedShaderPass,
  EA as ExtrudeGeometry,
  oF as FBXLoader2,
  ti as FileLoader,
  Ox as FileTransferPlugin,
  Bo as FilmicGrainPlugin,
  cn as FirstPersonControls2,
  eG as Float16BufferAttribute,
  Te as Float32BufferAttribute,
  tG as Float64BufferAttribute,
  tH as FloatType,
  qp as FnCaller,
  fA as Fog,
  pA as FogExp2,
  Fo as FragmentClippingExtensionPlugin,
  Wd as FragmentClippingMode,
  P3 as FrameFadeBlendPass,
  Do as FrameFadePlugin,
  nG as FramebufferTexture,
  UQ as FrontSide,
  uA as Frustum,
  pc as FullScreenPlugin,
  aU as FullScreenQuad,
  tS as GBufferMaterial,
  yr as GBufferPlugin,
  To as GBufferRenderPass,
  fG as GLBufferAttribute,
  s5 as GLSL1,
  r5 as GLSL3,
  CB as GLStatsJS,
  li as GLTFAnimationPlugin,
  jb as GLTFBinaryExtension,
  rf as GLTFExporter,
  zg as GLTFExporter2,
  d5 as GLTFKHRMaterialVariantsPlugin,
  wp as GLTFLightExtrasExtension,
  zt as GLTFLoader,
  Ng as GLTFLoader2,
  Ep as GLTFMaterialExtrasExtension,
  lc as GLTFMaterialsAlphaMapExtension,
  cc as GLTFMaterialsBumpMapExtension,
  hc as GLTFMaterialsDisplacementMapExtension,
  uc as GLTFMaterialsLightMapExtension,
  Ux as GLTFMeshOptDecodePlugin,
  bp as GLTFObject3DExtrasExtension,
  NF as GLTFParser,
  Sp as GLTFViewerConfigExtension,
  bO as GLTFWriter2,
  cU as GenericBlendTexturePass,
  Yh as GeometryUVPreviewPlugin,
  WV as GreaterCompare,
  A4 as GreaterDepth,
  qV as GreaterEqualCompare,
  g4 as GreaterEqualDepth,
  kV as GreaterEqualStencilFunc,
  OV as GreaterStencilFunc,
  _G as GridHelper,
  Kn as Group,
  Rg as Gunzip,
  ex as Gzip,
  gs as HDRiGroundPlugin,
  $B as HVBlurHelper,
  iH as HalfFloatType,
  PA as HemisphereLight,
  Kr as HemisphereLight2,
  vG as HemisphereLightHelper,
  bA as IcosahedronGeometry,
  AR as ImageBitmapLoader,
  Gh as ImageLoader,
  aA as ImageUtils,
  $i as Importer,
  TV as IncrementStencilOp,
  DV as IncrementWrapStencilOp,
  fs as Inflate,
  Da as InstancedBufferAttribute,
  Hw as InstancedBufferGeometry,
  op as InstancedInterleavedBuffer,
  zp as InstancedMesh,
  $k as Int16BufferAttribute,
  Zk as Int32BufferAttribute,
  Yk as Int8BufferAttribute,
  Z4 as IntType,
  wi as InteractionPromptPlugin,
  au as InterleavedBuffer,
  Cn as InterleavedBufferAttribute,
  lu as Interpolant,
  $H as InterpolateDiscrete,
  ZH as InterpolateLinear,
  eV as InterpolateSmooth,
  BV as InvertStencilOp,
  Ap as JSONMaterialLoader,
  NR as JSUndoManager,
  Px as KHR_TEXTURE_BASISU,
  Tp as KTX2LoadPlugin,
  UN as KTX2Loader2,
  Tx as KTXLoadPlugin,
  CV as KeepStencilOp,
  xr as KeyframeTrack,
  dD as LOD,
  Hp as LatheGeometry,
  cA as Layers,
  Sg as LegacyPhongMaterial,
  QV as LessCompare,
  p4 as LessDepth,
  VV as LessEqualCompare,
  f4 as LessEqualDepth,
  FV as LessEqualStencilFunc,
  LV as LessStencilFunc,
  zo as Light,
  mR as LightProbe,
  an as Line,
  Eg as Line2,
  UR as Line3,
  Ri as LineBasicMaterial,
  Gz as LineBasicMaterial2,
  Tw as LineCurve,
  TD as LineCurve3,
  tR as LineDashedMaterial,
  mp as LineGeometry,
  kL as LineGeometry2,
  Cw as LineLoop,
  uu as LineMaterial,
  Xs as LineMaterial2,
  Is as LineSegments,
  Tc as LineSegments2,
  ea as LineSegmentsGeometry,
  GL as LineSegmentsGeometry2,
  vV as LinearDisplayP3ColorSpace,
  cV as LinearEncoding,
  V4 as LinearFilter,
  kw as LinearInterpolant,
  X4 as LinearMipMapLinearFilter,
  j4 as LinearMipMapNearestFilter,
  q4 as LinearMipmapLinearFilter,
  W4 as LinearMipmapNearestFilter,
  AV as LinearSRGBColorSpace,
  YR as LinearToSRGB,
  E4 as LinearToneMapping,
  xV as LinearTransfer,
  ui as Loader,
  hr as LoaderUtils,
  BA as LoadingManager,
  kt as LoadingScreenPlugin,
  YH as LoopOnce,
  JH as LoopPingPong,
  KH as LoopRepeat,
  cH as LuminanceAlphaFormat,
  lH as LuminanceFormat,
  SQ as MOUSE,
  hb as MTLLoader2,
  Yi as Material,
  Yg as MaterialConfiguratorBasePlugin,
  Dl as MaterialExtender,
  Wp as MaterialLoader,
  VO as MaterialManager,
  ZB as MaterialPreviewGenerator,
  ri as MathUtils,
  iS as Matrix2,
  yt as Matrix3,
  Ue as Matrix4,
  YQ as MaxEquation,
  Se as Mesh,
  FL as Mesh2,
  $s as MeshBasicMaterial,
  Nz as MeshBasicMaterial2,
  Np as MeshDepthMaterial,
  Ew as MeshDistanceMaterial,
  Fw as MeshLambertMaterial,
  OL as MeshLine,
  Oz as MeshLineMaterial,
  NL as MeshLineSegments,
  eR as MeshMatcapMaterial,
  Uw as MeshNormalMaterial,
  Oo as MeshOptSimplifyModifierPlugin,
  Hl as MeshPhongMaterial,
  Sc as MeshPhysicalMaterial,
  Go as MeshStandardMaterial,
  kz as MeshStandardMaterial2,
  ZD as MeshToonMaterial,
  WA as MetaImporter,
  XQ as MinEquation,
  N4 as MirroredRepeatWrapping,
  _4 as MixOperation,
  HQ as MultiplyBlending,
  v4 as MultiplyOperation,
  k4 as NearestFilter,
  H4 as NearestMipMapLinearFilter,
  z4 as NearestMipMapNearestFilter,
  Q4 as NearestMipmapLinearFilter,
  G4 as NearestMipmapNearestFilter,
  zV as NeverCompare,
  u4 as NeverDepth,
  PV as NeverStencilFunc,
  kQ as NoBlending,
  mV as NoColorSpace,
  w4 as NoToneMapping,
  Lo as NoiseBumpMaterialPlugin,
  sV as NormalAnimationBlendMode,
  GQ as NormalBlending,
  Mp as NormalBufferPlugin,
  jV as NotEqualCompare,
  y4 as NotEqualDepth,
  NV as NotEqualStencilFunc,
  vo as NumberKeyframeTrack,
  DU as OBJLoader2,
  ut as Object3D,
  tu as Object3DGeneratorPlugin,
  u5 as Object3DWidgetsPlugin,
  OA as ObjectLoader,
  pg as ObjectPicker,
  bg as ObjectShaderMaterial,
  fV as ObjectSpaceNormalMap,
  ya as OctahedronGeometry,
  JQ as OneFactor,
  h4 as OneMinusConstantAlphaFactor,
  l4 as OneMinusConstantColorFactor,
  n4 as OneMinusDstAlphaFactor,
  r4 as OneMinusDstColorFactor,
  t4 as OneMinusSrcAlphaFactor,
  ZQ as OneMinusSrcColorFactor,
  jE as OrbitControls,
  Uz as OrbitControls2,
  jt as OrbitControls3,
  _r as OrthographicCamera,
  Hz as OrthographicCamera0,
  eb as OrthographicCamera2,
  bV as P3Primaries,
  BQ as PCFShadowMap,
  PQ as PCFSoftShadowMap,
  Cx as PLYLoadPlugin,
  O0 as PMREMGenerator,
  ms as ParallaxMappingPlugin,
  tf as Pass,
  ap as Path,
  ki as PerspectiveCamera,
  BL as PerspectiveCamera0,
  mu as PerspectiveCamera2,
  Ds as PhysicalMaterial,
  Dh as PickingPlugin,
  kc as PipelinePassPlugin,
  Nr as Plane,
  No as PlaneGeometry,
  CG as PlaneHelper,
  nc as PointLight,
  yi as PointLight2,
  yG as PointLightHelper,
  EL as PointLightHelper2,
  OR as PointerDragHelper,
  Ba as PointerLockControls2,
  Ex as PointerLockControlsPlugin,
  zl as Points,
  Qr as PointsMaterial,
  xG as PolarGridHelper,
  ko as PolyhedronGeometry,
  fc as PopmotionPlugin,
  hG as PositionalAudio,
  E3 as ProgressiveBlendPass,
  vr as ProgressivePlugin,
  _t as PropertyBinding,
  xR as PropertyMixer,
  Iw as QuadraticBezierCurve,
  Dw as QuadraticBezierCurve3,
  rt as Quaternion,
  Ra as QuaternionKeyframeTrack,
  aR as QuaternionLinearInterpolant,
  qH as RED_GREEN_RGTC2_Format,
  WH as RED_RGTC1_Format,
  bQ as REVISION,
  dV as RGBADepthPacking,
  oH as RGBAFormat,
  gH as RGBAIntegerFormat,
  kH as RGBA_ASTC_10x10_Format,
  FH as RGBA_ASTC_10x5_Format,
  OH as RGBA_ASTC_10x6_Format,
  NH as RGBA_ASTC_10x8_Format,
  GH as RGBA_ASTC_12x10_Format,
  zH as RGBA_ASTC_12x12_Format,
  TH as RGBA_ASTC_4x4_Format,
  IH as RGBA_ASTC_5x4_Format,
  DH as RGBA_ASTC_5x5_Format,
  RH as RGBA_ASTC_6x5_Format,
  BH as RGBA_ASTC_6x6_Format,
  PH as RGBA_ASTC_8x5_Format,
  LH as RGBA_ASTC_8x6_Format,
  UH as RGBA_ASTC_8x8_Format,
  QH as RGBA_BPTC_Format,
  MH as RGBA_ETC2_EAC_Format,
  bH as RGBA_PVRTC_2BPPV1_Format,
  EH as RGBA_PVRTC_4BPPV1_Format,
  yH as RGBA_S3TC_DXT1_Format,
  vH as RGBA_S3TC_DXT3_Format,
  _H as RGBA_S3TC_DXT5_Format,
  XF as RGBEPNGLoader,
  _V as RGBM16ColorSpace,
  HH as RGB_BPTC_SIGNED_Format,
  VH as RGB_BPTC_UNSIGNED_Format,
  SH as RGB_ETC1_Format,
  CH as RGB_ETC2_Format,
  wH as RGB_PVRTC_2BPPV1_Format,
  xH as RGB_PVRTC_4BPPV1_Format,
  AH as RGB_S3TC_DXT1_Format,
  fH as RGFormat,
  mH as RGIntegerFormat,
  $D as RawShaderMaterial,
  wc as Ray,
  QA as Raycaster,
  EV as Rec709Primaries,
  FA as RectAreaLight,
  gr as RectAreaLight2,
  dH as RedFormat,
  pH as RedIntegerFormat,
  b4 as ReinhardToneMapping,
  Mn as RenderManager,
  sb as RenderPass,
  EU as RenderTargetManager,
  Xh as RenderTargetPreviewPlugin,
  F4 as RepeatWrapping,
  MV as ReplaceStencilOp,
  qQ as ReverseSubtractEquation,
  Vn as Rhino3dmLoadPlugin,
  lr as Rhino3dmLoader2,
  SA as RingGeometry,
  Qi as RootScene,
  XH as SIGNED_RED_GREEN_RGTC2_Format,
  jH as SIGNED_RED_RGTC1_Format,
  gV as SRGBColorSpace,
  HG as SRGBToLinear,
  wV as SRGBTransfer,
  Bs as SSAAPlugin,
  Ua as SSAOPlugin,
  ts as SSAOPluginPass,
  Mx as STLLoadPlugin,
  Gg as SVGTextureLoader,
  tc as Scene,
  jg as SceneUiConfigPlugin,
  La as ScreenPass,
  hL as SelectionWidget,
  Sn as Serialization,
  ft as ShaderChunk,
  Ci as ShaderLib,
  ln as ShaderMaterial,
  gp as ShaderMaterial2,
  rb as ShaderPass,
  JD as ShadowMaterial,
  Ql as Shape,
  CA as ShapeGeometry,
  IG as ShapePath,
  jr as ShapeUtils,
  J4 as ShortType,
  Xw as SimpleEventDispatcher,
  SO as SimpleJSONExporter,
  cb as SimpleJSONLoader,
  CO as SimpleTextExporter,
  yc as SimplifyModifierPlugin,
  ou as Skeleton,
  AG as SkeletonHelper,
  gA as SkinnedMesh,
  Aa as Source,
  ns as Sphere,
  fr as SphereGeometry,
  sc as Spherical,
  fR as SphericalHarmonics3,
  Rw as SplineCurve,
  cu as SpotLight,
  oi as SpotLight2,
  gG as SpotLightHelper,
  SL as SpotLightHelper2,
  mA as Sprite,
  Gp as SpriteMaterial,
  e4 as SrcAlphaFactor,
  a4 as SrcAlphaSaturateFactor,
  $Q as SrcColorFactor,
  t5 as StaticCopyUsage,
  YV as StaticDrawUsage,
  $V as StaticReadUsage,
  lG as StereoCamera,
  n5 as StreamCopyUsage,
  JV as StreamDrawUsage,
  e5 as StreamReadUsage,
  Mc as StringKeyframeTrack,
  jQ as SubtractEquation,
  QQ as SubtractiveBlending,
  Kg as SwitchNodeBasePlugin,
  CQ as TOUCH,
  QR as TYPED_ARRAYS,
  pV as TangentSpaceNormalMap,
  MA as TetrahedronGeometry,
  Nt as Texture,
  xo as TextureLoader,
  bx as ThreeFirstPersonControlsPlugin,
  mt as ThreeSerialization,
  $t as ThreeViewer,
  es as TonemapPlugin,
  kh as TorusGeometry,
  TA as TorusKnotGeometry,
  Nx as TransformAnimationPlugin,
  Eo as TransformControls,
  Yr as TransformControls2,
  V2 as TransformControlsGizmo,
  W2 as TransformControlsPlane,
  Fa as TransformControlsPlugin,
  hs as Triangle,
  lV as TriangleFanDrawMode,
  oV as TriangleStripDrawMode,
  aV as TrianglesDrawMode,
  IA as TubeGeometry,
  NQ as TwoPassDoubleSide,
  Sx as USDZLoadPlugin,
  D4 as UVMapping,
  U2 as UiConfigMethods,
  Lz as UiConfigRendererBase,
  Ch as UiConfigTypeMap,
  hA as Uint16BufferAttribute,
  mw as Uint32BufferAttribute,
  Kk as Uint8BufferAttribute,
  Jk as Uint8ClampedBufferAttribute,
  h5 as UndoManagerPlugin,
  zA as Uniform,
  pG as UniformsGroup,
  Re as UniformsLib,
  Ec as UniformsUtils,
  pr as UnlitLineMaterial,
  Pa as UnlitMaterial,
  Y4 as UnsignedByteType,
  rH as UnsignedInt248Type,
  eH as UnsignedIntType,
  nH as UnsignedShort4444Type,
  sH as UnsignedShort5551Type,
  $4 as UnsignedShortType,
  lQ as Unzip,
  aQ as UnzipInflate,
  GU as UnzipPassThrough,
  Lg as Unzlib,
  LQ as VSMShadowMap,
  ie as Vector2,
  M as Vector3,
  it as Vector4,
  _o as VectorKeyframeTrack,
  iG as VideoTexture,
  fE as ViewHelper2,
  Ar as ViewerRenderManager,
  Wg as ViewerUiConfigPlugin,
  Ro as VignettePlugin,
  Ip as VirtualCamerasPlugin,
  uD as WebGL1Renderer,
  Xk as WebGL3DRenderTarget,
  qk as WebGLArrayRenderTarget,
  o5 as WebGLCoordinateSystem,
  Aw as WebGLCubeRenderTarget,
  gC as WebGLMultipleRenderTargets,
  Zn as WebGLRenderTarget,
  kp as WebGLRenderer,
  rD as WebGLUtils,
  l5 as WebGPUCoordinateSystem,
  xL as Wireframe,
  DA as WireframeGeometry,
  YE as WireframeGeometry2,
  Wz as WireframeGeometry3,
  nV as WrapAroundEnding,
  tV as ZeroCurvatureEnding,
  KQ as ZeroFactor,
  iV as ZeroSlopeEnding,
  SV as ZeroStencilOp,
  sQ as Zip,
  iQ as ZipDeflate,
  lF as ZipLoader,
  xp as ZipPassThrough,
  ix as Zlib,
  a5 as _SRGBAFormat,
  p5 as _testFinish,
  f5 as _testStart,
  pB as absMax,
  rB as aesGcmDecrypt,
  sB as aesGcmEncrypt,
  QE as animate,
  _2 as animateAsync,
  w2 as animateCameraToViewLinear,
  x2 as animateCameraToViewSpherical,
  Tz as animateTarget,
  $f as arrayBufferToBase64,
  m5 as autoCenterObject3D,
  uE as autoGPUInstanceMeshes,
  g5 as autoScaleObject3D,
  Yw as base64ToArrayBuffer,
  Ht as bindToValue,
  Kw as blobToDataURL,
  iz as blobToImage,
  Dz as cLinearToRGBM,
  Iz as cRGBMToLinear,
  eE as canvasFlipY,
  lz as clearBit,
  Jh as clearCoatTintGLTFExtension,
  zR as cloneScriptTag,
  VG as colorToDataUrl,
  Xz as compress,
  tx as compressSync,
  Az as computeMikkTSpaceTangents,
  wz as computeMorphedAttributes,
  e_ as computeScreenSpaceBoundingBox,
  Xv as convertArrayBufferToStringsInMeta,
  RB as convertStringsToArrayBuffersInMeta,
  aE as copyMaterialUserData,
  hg as copyObject3DUserData,
  $R as copyProps,
  rE as copyTextureUserData,
  Xp as copyUserData,
  kR as createCanvasElement,
  po as createDiv,
  GR as createImage,
  wU as createRenderTargetKey,
  PG as createScriptFromURL,
  zh as createStyles,
  WR as css,
  Zh as customBumpMapGLTFExtension,
  mz as dataTextureFromColor,
  gz as dataTextureFromVec4,
  $z as decompress,
  Zz as decompressSync,
  jG as deepAccessObject,
  yz as deepCloneAttribute,
  LU as deflate,
  sf as deflateSync,
  dg as deinterleaveAttribute,
  _z as deinterleaveGeometry,
  jp as downloadBlob,
  qR as downloadFile,
  rz as embedUrlRefs,
  VR as escapeRegExp,
  xz as estimateBytesUsed,
  eB as findLastIndex,
  eu as fragmentClippingGLTFExtension,
  Ss as generateUUID,
  mr as generateUiConfig,
  ty as generateUiFolder,
  C_ as generateValueConfig,
  Sa as getEmptyMeta,
  XG as getFileHandle,
  OG as getFilenameFromPath,
  qG as getKeyByValue,
  YG as getNewFileHandle,
  gi as getOrCall,
  KR as getPropertyDescriptor,
  lE as getTexelDecoding,
  zB as getTexelDecodingFunction,
  qv as getTextureDataType,
  HR as getTypedArray,
  HA as getUrlQueryParam,
  JF as glbEncryptionPreparser,
  KF as glbEncryptionProcessor,
  Oa as glsl,
  FU as gunzip,
  Bg as gunzipSync,
  Xz as gzip,
  tx as gzipSync,
  GB as halfFloatToRgbe,
  GG as html,
  az as htmlToCanvas,
  oz as htmlToPng,
  iE as htmlToSvg,
  Zi as iCameraCommons,
  ai as iGeometryCommons,
  en as iLightCommons,
  ge as iMaterialCommons,
  ct as iObjectCommons,
  oB as imageBitmapToBase64,
  ZG as imageBitmapToBlob,
  Zw as imageBitmapToCanvas,
  ez as imageDataToCanvas,
  cB as imageToCanvas,
  lB as imageUrlToImageData,
  ZR as includesAll,
  Rb as inflate,
  _u as inflateSync,
  vz as interleaveAttributes,
  Qh as isInScene,
  JR as isPropertyWritable,
  tz as isWebpExportSupported,
  Yv as jsonToBlob,
  xg as lerp,
  E_ as lerpAngle,
  Mz as localToWorldQuaternion,
  kG as longestCommonPrefix,
  nz as makeColorSvg,
  hB as makeColorSvgCircle,
  NB as makeGLBFile,
  bi as makeSamplerUi,
  HE as makeSetterFor,
  sz as makeTextSvg,
  jA as matDefine,
  Yp as matDefineBool,
  ug as mergeAttributes,
  Cz as mergeBufferAttributes,
  Sz as mergeBufferGeometries,
  QB as mergeGeometries,
  Ez as mergeGroups,
  HB as mergeVertices,
  oE as metaFromResources,
  Zf as metaToResources,
  QG as mobileAndTabletCheck,
  $h as noiseBumpMaterialGLTFExtension,
  zn as now,
  Jn as objectHasOwn,
  iB as objectMap,
  Wv as objectMap2,
  Oe as onChange,
  Pi as onChange2,
  bt as onChange3,
  nB as onChangeDispatchEvent,
  kB as overrideThreeCache,
  og as parseFileExtension,
  uz as pathJoin,
  zG as prettyScrollbar,
  KG as readFile,
  dz as remoteWorkerURL,
  Pn as replaceAll,
  hV as sRGBEncoding,
  NG as safeReplaceString,
  wo as safeSetProperty,
  $w as serializable,
  V as serialize,
  BB as serializeTextureInExtras,
  LG as setInnerHTMLWithScripts,
  jz as setThreeRendererMode,
  hz as setUrlQueryParam,
  Ct as shaderReplaceString,
  lp as shaderUtils,
  dE as snapObject,
  yU as sortPasses,
  b_ as sphericalFromCameraView,
  _p as strFromU8,
  Io as strToU8,
  tE as svgToCanvas,
  uB as svgToPng,
  jR as svgUrl,
  TB as texImageToCanvas,
  sE as textureDataToImageData,
  fz as textureToBlob,
  VA as textureToCanvas,
  pz as textureToDataUrl,
  hE as threeConstMappings,
  bs as timeout,
  FG as toCamelCase,
  bz as toCreasedNormals,
  cE as toIndexedGeometry,
  UG as toTitleCase,
  t_ as toTrianglesDrawMode,
  Pt as uiButton,
  wr as uiColor,
  Ki as uiConfig,
  fL as uiConfigMaterialExtension,
  WE as uiContainer,
  er as uiDropdown,
  Lt as uiFolderContainer,
  ta as uiImage,
  pt as uiInput,
  Ic as uiMonitor,
  ii as uiNumber,
  Tn as uiPanelContainer,
  Ye as uiSlider,
  ue as uiToggle,
  Ji as uiVector,
  Qo as uniform,
  cQ as unzip,
  kb as unzipSync,
  NU as unzlib,
  xa as unzlibSync,
  nE as updateBit,
  Vo as updateMaterialDefines,
  tb as upgradeTexture,
  eU as upgradeWebGLRenderer,
  XR as uploadFile,
  cz as uuidV4,
  b2 as vLinearToRGBM,
  E2 as vRGBMToLinear,
  $G as verifyPermission,
  _B as windowDialogWrapper,
  VB as worldToLocalQuaternion,
  WG as wrapThisFunction,
  tB as wrapThisFunction2,
  JG as writeFile,
  rQ as zip,
  Nb as zipSync,
  Kz as zlib,
  Pg as zlibSync
};
//# sourceMappingURL=index.mjs.map
