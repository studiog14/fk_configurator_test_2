import { Color, EventListener, IUniform, Object3D, Scene, Vector3 } from 'three';
import type { IObject3D, IObject3DEventMap, IObjectProcessor } from '../IObject';
import { type ICamera } from '../ICamera';
import { Box3B } from '../../three';
import { AnyOptions } from 'ts-browser-helpers';
import { ITexture } from '../ITexture';
import { AddObjectOptions, IScene, ISceneEventMap, ISceneSetDirtyOptions } from '../IScene';
import { RootSceneImportResult } from '../../assetmanager';
import { UiObjectConfig } from 'uiconfig.js';
export declare class RootScene<TE extends ISceneEventMap = ISceneEventMap> extends Scene<TE & ISceneEventMap> implements IScene<TE> {
    readonly isRootScene = true;
    assetType: "model";
    uiConfig: UiObjectConfig;
    private _mainCamera;
    /**
     * The root object where all imported objects are added.
     */
    readonly modelRoot: IObject3D;
    backgroundColor: Color | null;
    background: null | Color | ITexture | 'environment';
    /**
     * The intensity for the environment light.
     */
    backgroundIntensity: number;
    /**
     * The default environment map used when rendering materials in the scene
     */
    environment: ITexture | null;
    /**
     * The intensity for the environment light.
     */
    envMapIntensity: number;
    /**
     * Rotation in radians of the default environment map.
     * Same as {@link environment}.rotation.
     *
     * Note - this is not serialized here, but inside the texture.
     */
    envMapRotation: number;
    /**
     * Extra textures/envmaps that can be used by objects/materials/plugins and will be serialized.
     */
    textureSlots: Record<string, ITexture>;
    /**
     * Fixed direction environment reflections irrespective of camera position.
     */
    fixedEnvMapDirection: boolean;
    /**
     * The default camera in the scene
     */
    readonly defaultCamera: ICamera;
    /**
     * Calls dispose on current old environment map, background map when it is changed.
     * Runtime only (not serialized)
     */
    autoDisposeSceneMaps: boolean;
    private _dummyCam;
    get mainCamera(): ICamera;
    set mainCamera(camera: ICamera | undefined);
    private _renderCamera;
    get renderCamera(): ICamera;
    set renderCamera(camera: ICamera);
    /**
     * Create a scene instance. This is done automatically in the {@link ThreeViewer} and must not be created separately.
     * @param camera
     * @param objectProcessor
     */
    constructor(camera: ICamera, objectProcessor?: IObjectProcessor);
    /**
     * Add a widget (non-physical/interactive) object to the scene. like gizmos, ui components etc.
     * @param model
     * @param options
     */
    /**
     * Add any object to the scene.
     * @param imported
     * @param options
     */
    addObject<T extends IObject3D | Object3D = IObject3D>(imported: T, options?: AddObjectOptions): T & IObject3D;
    /**
     * Load model root scene exported to GLTF format. Used internally by {@link ThreeViewer.addSceneObject}.
     * @param obj
     * @param options
     */
    loadModelRoot(obj: RootSceneImportResult, options?: AddObjectOptions): (Object3D<import("three").Object3DEventMap> & IObject3D<IObject3DEventMap>)[];
    private _addObject3D;
    centerAllGeometries(keepPosition?: boolean, obj?: IObject3D): () => void;
    clearSceneModels(dispose?: boolean, setDirty?: boolean): void;
    disposeSceneModels(setDirty?: boolean, clear?: boolean): void;
    private _onEnvironmentChange;
    onBackgroundChange(ev?: {
        value: ITexture | null;
        oldValue: ITexture | null;
    }): void;
    /**
     * @deprecated Use {@link addObject}
     */
    add(...object: Object3D[]): this;
    /**
     * Sets the backgroundColor property from a string, number or Color, and updates the scene.
     * @param color
     */
    setBackgroundColor(color: string | number | Color | null): void;
    /**
     * Mark the scene dirty, and force render in the next frame.
     * @param options - set `refreshScene` to true to mark that any object transformations have changed. It might trigger effects like frame fade depening on plugins.
     * @returns {this}
     */
    setDirty(options?: ISceneSetDirtyOptions): this;
    private _mainCameraUpdate;
    private _sceneBounds;
    private _sceneBoundingRadius;
    /**
     * For visualizing the scene bounds. API incomplete.
     * @type {Box3Helper}
     */
    refreshScene(event?: Partial<(ISceneEventMap['objectUpdate'] | ISceneEventMap['geometryUpdate'] | ISceneEventMap['geometryChanged'])> & ISceneSetDirtyOptions & {
        type?: keyof ISceneEventMap;
    }): this;
    refreshUi: any;
    /**
     * Dispose the scene and clear all resources.
     * WARNING - Not fully implemented yet, just clears the scene.
     */
    dispose(clear?: boolean): void;
    /**
     * Returns the bounding box of the whole scene (model root and other meta objects).
     * To get the bounds of just the objects added by the user(not by plugins) use `new Box3B().expandByObject(scene.modelRoot)`
     * @param precise
     * @param ignoreInvisible
     * @param ignoreWidgets
     * @param ignoreObject
     * @returns {Box3B}
     */
    getBounds(precise?: boolean, ignoreInvisible?: boolean, ignoreWidgets?: boolean, ignoreObject?: (obj: Object3D) => boolean): Box3B;
    /**
     * Similar to {@link getBounds}, but returns the bounding box of just the {@link modelRoot}.
     * @param precise
     * @param ignoreInvisible
     * @param ignoreWidgets
     * @param ignoreObject
     * @returns {Box3B}
     */
    getModelBounds(precise?: boolean, ignoreInvisible?: boolean, ignoreWidgets?: boolean, ignoreObject?: (obj: Object3D) => boolean): Box3B;
    autoGPUInstanceMeshes(): void;
    private _v1;
    private _v2;
    /**
     * For Programmatically toggling autoNearFar. This property is not supposed to be in the UI or serialized.
     * Use camera.userData.autoNearFar for UI and serialization
     * This is used in PickingPlugin
     * autoNearFar will still be disabled if this is true and camera.userData.autoNearFar is false
     */
    autoNearFarEnabled: boolean;
    /**
     * Refreshes the scene active camera near far values, based on the scene bounding box.
     * This is called automatically every time the camera is updated.
     */
    refreshActiveCameraNearFar(): void;
    /**
     * Refreshes the scene active camera near far values, based on the scene bounding box.
     * This is called automatically every time the camera fov is updated.
     */
    dollyActiveCameraFov(): void;
    updateShaderProperties(material: {
        defines: Record<string, string | number | undefined>;
        uniforms: {
            [name: string]: IUniform;
        };
    }): this;
    /**
     * Serialize the scene properties
     * @param meta
     * @returns {any}
     */
    toJSON(meta?: any): any;
    /**
     * Deserialize the scene properties
     * @param json - object from {@link toJSON}
     * @param meta
     * @returns {this<ICamera>}
     */
    fromJSON(json: any, meta?: any): this;
    addEventListener<T extends keyof ISceneEventMap>(type: T, listener: EventListener<ISceneEventMap[T], T, this>): void;
    traverse: (callback: (object: IObject3D) => void) => void;
    traverseVisible: (callback: (object: IObject3D) => void) => void;
    traverseAncestors: (callback: (object: IObject3D) => void) => void;
    getObjectById: <T extends IObject3D = IObject3D>(id: number) => T | undefined;
    getObjectByName: <T extends IObject3D = IObject3D>(name: string) => T | undefined;
    getObjectByProperty: <T extends IObject3D = IObject3D>(name: string, value: string) => T | undefined;
    copy: (source: this, recursive?: boolean, ...args: any[]) => this;
    clone: (recursive?: boolean) => this;
    remove: (...object: IObject3D[]) => this;
    parent: IObject3D | null;
    children: IObject3D[];
    /**
     * Find objects by name exact match in the complete hierarchy.
     * @deprecated Use {@link getObjectByName} instead.
     * @param name - name
     * @param parent - optional root node to start search from
     * @returns Array of found objects
     */
    findObjectsByName(name: string, parent?: IObject3D): IObject3D[];
    /**
     * @deprecated
     * Sets the camera pointing towards the object at a specific distance.
     * @param rootObject - The object to point at.
     * @param centerOffset - The distance offset from the object to point at.
     * @param targetOffset - The distance offset for the target from the center of object to point at.
     * @param options - Not used yet.
     */
    resetCamera(rootObject?: Object3D | undefined, centerOffset?: Vector3, targetOffset?: Vector3): void;
    /**
     * Minimum Camera near plane
     * @deprecated - use camera.minNearPlane instead
     */
    get minNearDistance(): number;
    /**
     * @deprecated - use camera.minNearPlane instead
     */
    set minNearDistance(value: number);
    /**
     * @deprecated
     */
    get activeCamera(): ICamera;
    /**
     * @deprecated
     */
    set activeCamera(camera: ICamera | undefined);
    /**
     * Get the threejs scene object
     * @deprecated
     */
    get modelObject(): this;
    /**
     * @deprecated use {@link envMapIntensity} instead
     */
    get environmentIntensity(): number;
    /**
     * @deprecated use {@link envMapIntensity} instead
     */
    set environmentIntensity(value: number);
    /**
     * Add any processed scene object to the scene.
     * @deprecated renamed to {@link addObject}
     * @param imported
     * @param options
     */
    addSceneObject<T extends IObject3D | Object3D = IObject3D>(imported: T, options?: AddObjectOptions): T;
    /**
     * Equivalent to setDirty({refreshScene: true}), dispatches 'sceneUpdate' event with the specified options.
     * @deprecated use refreshScene
     * @param options
     */
    updateScene(options?: AnyOptions): this;
    /**
     * @deprecated renamed to {@link clearSceneModels}
     */
    removeSceneModels(): void;
}
//# sourceMappingURL=RootScene.d.ts.map