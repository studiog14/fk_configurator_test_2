var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { generateUiConfig, uiColor, uiInput, uiNumber, uiToggle, uiVector } from 'uiconfig.js';
import { Color, Vector2, } from 'three';
import { shaderReplaceString, ThreeSerialization } from '../../utils';
import { iMaterialCommons, threeMaterialPropList } from './iMaterialCommons';
import { iMaterialUI } from './IMaterialUi';
import { LineMaterial } from 'three/examples/jsm/lines/LineMaterial.js';
/**
 * And extension of three.js LineMaterial that can be assigned to lines, and support threepipe features, uiconfig, and serialization.
 *
 * @category Materials
 */
export class LineMaterial2 extends LineMaterial {
    dispose() { return iMaterialCommons.dispose(super.dispose).call(this); }
    clone(track = false) { return iMaterialCommons.clone(super.clone).call(this, track); }
    dispatchEvent(event) { iMaterialCommons.dispatchEvent(super.dispatchEvent).call(this, event); }
    constructor({ customMaterialExtensions, ...parameters } = {}) {
        super();
        this.assetType = 'material';
        this.isLineMaterial2 = true;
        this.appliedMeshes = new Set();
        this.setDirty = iMaterialCommons.setDirty;
        // region Material Extension
        this.materialExtensions = [];
        this.extraUniformsToUpload = {};
        this.registerMaterialExtensions = iMaterialCommons.registerMaterialExtensions;
        this.unregisterMaterialExtensions = iMaterialCommons.unregisterMaterialExtensions;
        this.autoUpdateResolution = true;
        // @uiToggle() declare fog = true
        // todo dispose ui config
        this.uiConfig = {
            type: 'folder',
            label: 'Line Material',
            uuid: 'MPM2_' + this.uuid,
            expanded: true,
            onChange: (ev) => {
                if (!ev.config || ev.config.onChange)
                    return;
                // this.uniformsNeedUpdate = true
                // this.appliedMeshes.forEach(m=>{
                //     if ((m.isLineSegments2 || m.isLineSegments) && m.computeLineDistances) {
                //         m.computeLineDistances()
                //     }
                // })
                // todo set needsUpdate true only for properties that require it like maps.
                this.setDirty({ uiChangeEvent: ev, needsUpdate: !!ev.last, refreshUi: !!ev.last });
            },
            children: [
                ...generateUiConfig(this) || [],
                iMaterialUI.blending(this),
                iMaterialUI.polygonOffset(this),
                ...iMaterialUI.misc(this),
            ],
        };
        this.fog = false;
        this.setDirty = this.setDirty.bind(this);
        if (customMaterialExtensions)
            this.registerMaterialExtensions(customMaterialExtensions);
        iMaterialCommons.upgradeMaterial.call(this);
        this.setValues(parameters);
        // this.userData.renderToGBuffer = false
        // this.userData.renderToDepth = false
    }
    customProgramCacheKey() {
        return super.customProgramCacheKey() + iMaterialCommons.customProgramCacheKey.call(this);
    }
    onBeforeCompile(shader, renderer) {
        const f = [
            ['vec4 diffuseColor = ', 'beforeAccumulation'],
            ['#include <clipping_planes_fragment>', 'mainStart'],
        ];
        const v = [
            ['#ifdef USE_COLOR', 'mainStart'],
        ];
        for (const vElement of v)
            shader.vertexShader = shaderReplaceString(shader.vertexShader, vElement[0], '#glMarker ' + vElement[1] + '\n' + vElement[0]);
        for (const fElement of f)
            shader.fragmentShader = shaderReplaceString(shader.fragmentShader, fElement[0], '#glMarker ' + fElement[1] + '\n' + fElement[0]);
        iMaterialCommons.onBeforeCompile.call(this, shader, renderer);
        super.onBeforeCompile(shader, renderer);
    }
    onBeforeRender(renderer, scene, camera, geometry, object) {
        if (this.autoUpdateResolution)
            renderer.getSize(this.resolution);
        super.onBeforeRender(renderer, scene, camera, geometry, object);
        iMaterialCommons.onBeforeRender.call(this, renderer, scene, camera, geometry, object);
    }
    onAfterRender(renderer, scene, camera, geometry, object) {
        super.onAfterRender(renderer, scene, camera, geometry, object);
        iMaterialCommons.onAfterRender.call(this, renderer, scene, camera, geometry, object);
    }
    // endregion UI Config
    // region Serialization
    /**
     * Sets the values of this material based on the values of the passed material or an object with material properties
     * The input is expected to be a valid material or a deserialized material parameters object(including the deserialized userdata)
     * @param parameters - material or material parameters object
     * @param allowInvalidType - if true, the type of the oldMaterial is not checked. Objects without type are always allowed.
     * @param clearCurrentUserData - if undefined, then depends on material.isMaterial. if true, the current userdata is cleared before setting the new values, because it can have data which wont be overwritten if not present in the new material.
     */
    setValues(parameters, allowInvalidType = true, clearCurrentUserData = undefined) {
        if (!parameters)
            return this;
        if (parameters.type && !allowInvalidType && !['LineMaterial', this.constructor.TYPE].includes(parameters.type) && !parameters.isLineMaterial && !parameters.isLineMaterial2) {
            console.error('Material type is not supported:', parameters.type);
            return this;
        }
        if (clearCurrentUserData === undefined)
            clearCurrentUserData = parameters.isMaterial;
        if (clearCurrentUserData)
            this.userData = {};
        iMaterialCommons.setValues(super.setValues).call(this, parameters);
        this.userData.uuid = this.uuid;
        return this;
    }
    copy(source) {
        return this.setValues(source, false);
    }
    /**
     * Serializes this material to JSON.
     * @param meta - metadata for serialization
     * @param _internal - Calls only super.toJSON, does internal three.js serialization and `@serialize` tags. Set it to true only if you know what you are doing. This is used in Serialization->serializer->material
     */
    toJSON(meta, _internal = false) {
        if (_internal)
            return {
                ...super.toJSON(meta),
                ...ThreeSerialization.Serialize(this, meta, true), // this will serialize the properties of this class(like defined with @serialize and @serialize attribute)
            };
        return ThreeSerialization.Serialize(this, meta, false); // this will call toJSON again, but with baseOnly=true, that's why we set isThis to false.
    }
    /**
     * Deserializes the material from JSON.
     * Note: some properties that are not serialized in Material.toJSON when they are default values (like side, alphaTest, blending, maps), they wont be reverted back if not present in JSON
     * If _internal = true, Textures should be loaded and in meta.textures before calling this method.
     * @param data
     * @param meta
     * @param _internal
     */
    fromJSON(data, meta, _internal = false) {
        if (_internal) {
            ThreeSerialization.Deserialize(data, this, meta, true);
            return this.setValues(data); // todo remove this and add @serialize decorator to properties
        }
        this.dispatchEvent({ type: 'beforeDeserialize', data, meta, bubbleToObject: true, bubbleToParent: true });
        return this;
    }
}
LineMaterial2.TypeSlug = 'lmat';
LineMaterial2.TYPE = 'LineMaterial2'; // not using .type because it is used by three.js
// endregion
// used for serialization and used in setValues
LineMaterial2.MaterialProperties = {
    // keep updated with properties in LineMaterial.js
    ...threeMaterialPropList,
    color: new Color(0xffffff),
    dashed: false,
    dashScale: 1,
    dashSize: 1,
    dashOffset: 0,
    gapSize: 1,
    linewidth: 1,
    resolution: new Vector2(1, 1),
    alphaToCoverage: false,
    worldUnits: false,
    uniforms: {},
    defines: {},
    extensions: {},
    clipping: false,
    fog: true,
    fragmentShader: '',
    vertexShader: '',
};
LineMaterial2.MaterialTemplate = {
    materialType: LineMaterial2.TYPE,
    name: 'line',
    typeSlug: LineMaterial2.TypeSlug,
    alias: ['line', 'line_physical', LineMaterial2.TYPE, LineMaterial2.TypeSlug, 'LineMaterial'],
    params: {
        color: new Color(1, 1, 1),
    },
    generator: (params) => {
        return new LineMaterial2(params);
    },
};
__decorate([
    uiInput()
], LineMaterial2.prototype, "name", void 0);
__decorate([
    uiColor()
], LineMaterial2.prototype, "color", void 0);
__decorate([
    uiToggle()
], LineMaterial2.prototype, "dashed", void 0);
__decorate([
    uiNumber()
], LineMaterial2.prototype, "dashScale", void 0);
__decorate([
    uiNumber()
], LineMaterial2.prototype, "dashSize", void 0);
__decorate([
    uiNumber()
], LineMaterial2.prototype, "dashOffset", void 0);
__decorate([
    uiNumber()
], LineMaterial2.prototype, "gapSize", void 0);
__decorate([
    uiNumber()
], LineMaterial2.prototype, "linewidth", void 0);
__decorate([
    uiVector()
], LineMaterial2.prototype, "resolution", void 0);
__decorate([
    uiToggle()
], LineMaterial2.prototype, "alphaToCoverage", void 0);
__decorate([
    uiToggle()
], LineMaterial2.prototype, "worldUnits", void 0);
export class MeshLineMaterial extends LineMaterial2 {
}
//# sourceMappingURL=LineMaterial2.js.map