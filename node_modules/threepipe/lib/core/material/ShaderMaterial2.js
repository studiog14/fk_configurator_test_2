import { ShaderMaterial, } from 'three';
import { iMaterialCommons, threeMaterialPropList } from './iMaterialCommons';
export class ShaderMaterial2 extends ShaderMaterial {
    dispose() { return iMaterialCommons.dispose(super.dispose).call(this); }
    clone(track = false) { return iMaterialCommons.clone(super.clone).call(this, track); }
    dispatchEvent(event) { iMaterialCommons.dispatchEvent(super.dispatchEvent).call(this, event); }
    constructor({ customMaterialExtensions, ...parameters } = {}, isRawShaderMaterial = false) {
        super();
        this.assetType = 'material';
        this.isAShaderMaterial = true;
        this.appliedMeshes = new Set();
        this.setDirty = iMaterialCommons.setDirty;
        this.type = 'ShaderMaterial';
        // region Material Extension
        this.materialExtensions = [];
        this.extraUniformsToUpload = {};
        this.registerMaterialExtensions = iMaterialCommons.registerMaterialExtensions;
        this.unregisterMaterialExtensions = iMaterialCommons.unregisterMaterialExtensions;
        this.isRawShaderMaterial = isRawShaderMaterial;
        if (isRawShaderMaterial) {
            this.type = 'RawShaderMaterial';
        }
        if (customMaterialExtensions)
            this.registerMaterialExtensions(customMaterialExtensions);
        iMaterialCommons.upgradeMaterial.call(this);
        this.setValues(parameters);
    }
    customProgramCacheKey() {
        return super.customProgramCacheKey() + iMaterialCommons.customProgramCacheKey.call(this);
    }
    onBeforeCompile(shader, renderer) {
        iMaterialCommons.onBeforeCompile.call(this, shader, renderer);
        super.onBeforeCompile(shader, renderer);
    }
    onBeforeRender(renderer, scene, camera, geometry, object) {
        super.onBeforeRender(renderer, scene, camera, geometry, object);
        iMaterialCommons.onBeforeRender.call(this, renderer, scene, camera, geometry, object);
    }
    onAfterRender(renderer, scene, camera, geometry, object) {
        super.onAfterRender(renderer, scene, camera, geometry, object);
        iMaterialCommons.onAfterRender.call(this, renderer, scene, camera, geometry, object);
    }
    // endregion
    /**
     * Sets the values of this material based on the values of the passed material or an object with material properties
     * The input is expected to be a valid material or a deserialized material parameters object(including the deserialized userdata)
     * @param parameters - material or material parameters object
     */
    setValues(parameters) {
        return iMaterialCommons.setValues(super.setValues).call(this, parameters);
    }
    toJSON(_) {
        throw new Error('Method not supported for this material.');
    }
    fromJSON(_, _2) {
        throw new Error('Method not supported for this material.');
    }
    /**
     * @deprecated use this directly
     */
    get materialObject() {
        return this;
    }
}
ShaderMaterial2.TypeSlug = 'shaderMat';
ShaderMaterial2.TYPE = 'ShaderMaterial2';
ShaderMaterial2.MaterialProperties = {
    ...threeMaterialPropList,
    fragmentShader: '',
    vertexShader: '',
    uniforms: {},
    defines: {},
    extensions: {},
    isRawShaderMaterial: false,
    uniformsGroups: {},
    wireframe: false,
    wireframeLinewidth: 1,
    clipping: false,
    lights: false,
    fog: false,
    glslVersion: null,
    defaultAttributeValues: {},
};
//# sourceMappingURL=ShaderMaterial2.js.map