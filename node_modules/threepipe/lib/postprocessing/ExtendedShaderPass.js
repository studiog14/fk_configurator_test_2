var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import { ExtendedShaderMaterial } from '../core';
import { uiToggle } from 'uiconfig.js';
import { onChange2, serialize } from 'ts-browser-helpers';
export class ExtendedShaderPass extends ShaderPass {
    constructor(shader, ...textureID) {
        super(shader.isMaterial ? shader : new ExtendedShaderMaterial(shader, textureID), textureID.length < 1 ? ExtendedShaderPass.DEFAULT_TEX_ID : textureID[0]);
        this.overrideReadBuffer = null;
        this.isExtendedShaderPass = true;
        // private _textureIDs: string[]
        this.enabled = true;
        this.onDirty = [];
        this.setDirty = this.setDirty.bind(this);
    }
    // writes to writeBuffer
    render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
        if (!this.enabled)
            return;
        renderer.renderWithModes({
            backgroundRender: false,
        }, () => {
            // @ts-expect-error todo fix render target ts?
            super.render(renderer, writeBuffer || null, this.overrideReadBuffer || readBuffer, deltaTime, maskActive);
        });
    }
    /**
     * to be called from beforeRender or onObjectRender or similar.
     * @param updater
     */
    updateShaderProperties(updater) {
        if (!updater)
            return;
        if (!Array.isArray(updater))
            updater = [updater];
        updater.forEach(value => value?.updateShaderProperties(this.material));
    }
    dispose() {
        this.material?.dispose?.();
        this.fsQuad?.dispose?.();
        this.onDirty = [];
    }
    setDirty() {
        if (this.material)
            this.material.needsUpdate = true; // do this when material defines etc are changed
        this.onDirty?.forEach(v => v());
    }
    // legacy
    /**
     * @deprecated renamed to {@link isExtendedShaderPass}
     */
    get isShaderPass2() {
        console.error('isShaderPass2 is deprecated, use isExtendedShaderPass instead');
        return true;
    }
}
ExtendedShaderPass.DEFAULT_TEX_ID = 'tDiffuse';
__decorate([
    uiToggle('Enabled'),
    serialize(),
    onChange2(ExtendedShaderPass.prototype.setDirty)
], ExtendedShaderPass.prototype, "enabled", void 0);
/**
 * @deprecated renamed to {@link ExtendedShaderPass}
 */
export class ShaderPass2 extends ExtendedShaderPass {
    constructor(shader, ...textureID) {
        console.error('ShaderPass2 is renamed to ExtendedShaderPass');
        super(shader, ...textureID);
    }
}
//# sourceMappingURL=ExtendedShaderPass.js.map