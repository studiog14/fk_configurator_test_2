import { Texture, TextureDataType, Vector4, WebGLRenderTarget } from 'three';
import { ExtendedShaderPass, IPassID, IPipelinePass } from '../../postprocessing';
import { ThreeViewer } from '../../viewer';
import { PipelinePassPlugin } from '../base/PipelinePassPlugin';
import { ICamera, IMaterial, IRenderManager, IScene, IWebGLRenderer } from '../../core';
import { ValOrFunc } from 'ts-browser-helpers';
import { MaterialExtension } from '../../materials';
import { GBufferPlugin, GBufferUpdaterContext } from './GBufferPlugin';
export type SSAOPluginTarget = WebGLRenderTarget;
/**
 * SSAO Plugin
 *
 * Adds Screen Space Ambient Occlusion (SSAO) to the scene.
 * Adds a pass to calculate AO, which is then read by materials in the render pass.
 * @category Plugins
 */
export declare class SSAOPlugin extends PipelinePassPlugin<SSAOPluginPass, 'ssao'> {
    readonly passId = "ssao";
    static readonly PluginType = "SSAOPlugin";
    static readonly OldPluginType = "SSAO";
    dependencies: (typeof GBufferPlugin)[];
    target?: SSAOPluginTarget;
    texture?: Texture;
    protected _pass?: SSAOPluginPass;
    readonly bufferType: TextureDataType;
    readonly sizeMultiplier: number;
    constructor(bufferType?: TextureDataType, sizeMultiplier?: number, enabled?: boolean);
    protected _createTarget(recreate?: boolean): void;
    protected _disposeTarget(): void;
    private _gbufferUnpackExtension;
    private _gbufferUnpackExtensionChanged;
    protected _createPass(): SSAOPluginPass;
    onAdded(viewer: ThreeViewer): void;
    onRemove(viewer: ThreeViewer): void;
    fromJSON(data: any, meta?: any): this | null | Promise<this | null>;
    updateGBufferFlags(data: Vector4, c: GBufferUpdaterContext): void;
    /**
     * @deprecated use {@link target} instead
     */
    get aoTarget(): SSAOPluginTarget | undefined;
}
export declare class SSAOPluginPass extends ExtendedShaderPass implements IPipelinePass {
    readonly passId: IPassID;
    target?: ValOrFunc<WebGLRenderTarget | undefined>;
    before: string[];
    after: string[];
    required: string[];
    intensity: number;
    occlusionWorldRadius: number;
    bias: number;
    falloff: number;
    numSamples: number;
    /**
     * Whether to check for gbuffer flag or not. This is used to disable SSAO casting by some objects. its enabled automatically by the SSAOPlugin when required.
     * This is disabled by default so that we dont read texture for no reason.
     */
    checkGBufferFlag: boolean;
    constructor(passId: IPassID, target?: ValOrFunc<WebGLRenderTarget | undefined>);
    render(renderer: IWebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, deltaTime: number, maskActive: boolean): void;
    private _updateParameters;
    beforeRender(_: IScene, camera: ICamera, renderManager: IRenderManager): void;
    readonly materialExtension: MaterialExtension;
    /**
     * Returns a uiConfig to toggle SSAO on a material.
     * This uiConfig is added to each material by extension
     * @param material
     * @private
     */
    protected _getUiConfig(material: IMaterial): {
        type: string;
        label: string;
        children: {
            type: string;
            label: string;
            value: boolean;
            onChange: () => void;
        }[];
    };
}
declare module '../../core/IMaterial' {
    interface IMaterialUserData {
        /**
         * Disable SSAOPlugin for this material.
         */
        ssaoDisabled?: boolean;
        /**
         * Cast SSAO on other objects.
         * if casting is not working when this is false, ensure render to depth is true, like for transparent objects
         */
        ssaoCastDisabled?: boolean;
    }
}
//# sourceMappingURL=SSAOPlugin.d.ts.map