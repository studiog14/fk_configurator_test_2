var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Color, DoubleSide, HalfFloatType, LinearSRGBColorSpace, MeshNormalMaterial, NearestFilter, NoBlending, TangentSpaceNormalMap, } from 'three';
import { GBufferRenderPass } from '../../postprocessing';
import { PipelinePassPlugin } from '../base/PipelinePassPlugin';
import { uiFolderContainer, uiImage } from 'uiconfig.js';
/**
 * Normal Buffer Plugin
 *
 * Adds a pre-render pass to render the normal buffer to a render target that can be used for postprocessing.
 * @category Plugins
 */
let NormalBufferPlugin = class NormalBufferPlugin extends PipelinePassPlugin {
    _createTarget(recreate = true) {
        if (!this._viewer)
            return;
        if (recreate)
            this._disposeTarget();
        // const rm = this._viewer.renderManager
        if (!this.target)
            this.target = this._viewer.renderManager.createTarget({
                depthBuffer: true,
                // samples: rm.msaa ? typeof rm.msaa !== 'number' ? ViewerRenderManager.DEFAULT_MSAA_SAMPLES : rm.msaa : 0,
                samples: 0,
                type: this.bufferType,
                magFilter: NearestFilter,
                minFilter: NearestFilter,
                generateMipmaps: false,
                colorSpace: LinearSRGBColorSpace,
            });
        this.texture = this.target.texture;
        this.texture.name = 'normalBuffer';
        // if (this._pass) this._pass.target = this.target
    }
    _disposeTarget() {
        if (!this._viewer)
            return;
        if (this.target) {
            this._viewer.renderManager.disposeTarget(this.target);
            this.target = undefined;
        }
        this.texture = undefined;
    }
    _createPass() {
        this._createTarget(true);
        if (!this.target)
            throw new Error('NormalBufferPlugin: target not created');
        this.material.userData.isGBufferMaterial = true;
        const pass = new GBufferRenderPass(this.passId, () => this.target, this.material, new Color(0, 0, 0), 1);
        const preprocessMaterial = pass.preprocessMaterial;
        pass.preprocessMaterial = (m) => preprocessMaterial(m, true);
        pass.before = ['render'];
        pass.after = [];
        pass.required = ['render'];
        return pass;
    }
    constructor(bufferType = HalfFloatType, enabled = true) {
        super();
        this.passId = 'normal';
        this.material = new MeshNormalMaterialOverride({
            blending: NoBlending,
        });
        this.enabled = enabled;
        this.bufferType = bufferType;
    }
    onRemove(viewer) {
        this._disposeTarget();
        return super.onRemove(viewer);
    }
};
NormalBufferPlugin.PluginType = 'NormalBufferPlugin';
__decorate([
    uiImage('Normal Buffer', { readOnly: true })
], NormalBufferPlugin.prototype, "texture", void 0);
NormalBufferPlugin = __decorate([
    uiFolderContainer('Normal Buffer Plugin')
], NormalBufferPlugin);
export { NormalBufferPlugin };
class MeshNormalMaterialOverride extends MeshNormalMaterial {
    constructor(parameters) {
        super(parameters);
        this.reset();
    }
    onBeforeRender(renderer, scene, camera, geometry, object) {
        super.onBeforeRender(renderer, scene, camera, geometry, object);
        if (!object.material)
            return;
        const material = object.material;
        if (material.bumpMap !== undefined)
            this.bumpMap = material.bumpMap;
        if (material.bumpScale !== undefined)
            this.bumpScale = material.bumpScale;
        // if (material.alphaMap !== undefined) this.alphaMap = material.alphaMap
        if (material.alphaTest !== undefined)
            this.alphaTest = material.alphaTest < 1e-4 ? 1e-4 : material.alphaTest;
        if (material.alphaHash !== undefined)
            this.alphaHash = material.alphaHash;
        if (material.normalMap !== undefined)
            this.normalMap = material.normalMap;
        if (material.normalMapType !== undefined)
            this.normalMapType = material.normalMapType;
        if (material.normalScale !== undefined)
            this.normalScale.copy(material.normalScale);
        if (material.displacementMap !== undefined)
            this.displacementMap = material.displacementMap;
        if (material.displacementScale !== undefined)
            this.displacementScale = material.displacementScale;
        if (material.displacementBias !== undefined)
            this.displacementBias = material.displacementBias;
        if (material.flatShading !== undefined)
            this.flatShading = material.flatShading;
        if (material.side !== undefined)
            this.side = material.side;
        if (material.wireframe !== undefined)
            this.wireframe = material.wireframe;
        if (material.wireframeLinewidth !== undefined)
            this.wireframeLinewidth = material.wireframeLinewidth;
    }
    onAfterRender(renderer, scene, camera, geometry, object) {
        super.onAfterRender(renderer, scene, camera, geometry, object);
        this.reset();
    }
    reset() {
        this.bumpMap = null;
        this.bumpScale = 1;
        // this.alphaMap = null
        this.alphaTest = 0;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.flatShading = false;
        this.side = DoubleSide;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
    }
}
//# sourceMappingURL=NormalBufferPlugin.js.map