import { GLTFExporter, GLTFExporterOptions } from 'three/examples/jsm/exporters/GLTFExporter.js';
import { BufferGeometry, Material, MeshStandardMaterial, Object3D, PixelFormat, Texture } from 'three';
import type { GLTFExporter2Options } from './GLTFExporter2';
export declare class GLTFWriter2 extends GLTFExporter.Utils.GLTFWriter {
    readonly TPAssetVersion = 1;
    constructor();
    options: GLTFExporterOptions & {
        externalImagesInExtras: boolean;
        exporterOptions: GLTFExporter2Options;
    };
    serializeUserData(object: Object3D | Material | BufferGeometry, objectDef: any): void;
    processObjects(objects: Object3D[]): void;
    protected _defaultMaterial: MeshStandardMaterial<import("three").MaterialEventMap>;
    /**
     * Checks for shader material and does the same thing...
     * @param material
     */
    processMaterial(material: Material): number | null;
    /**
     * Same as processImage but for image blobs
     * @param blob
     * @param texture
     */
    processImageBlob(blob: Blob, texture: Texture): any;
    processSampler(map: Texture): number;
    processTexture(map: Texture): number;
    processImage(image: any, format: PixelFormat, flipY: boolean, mimeType?: string): number;
    /**
     * Used in GLTFWriter2.processTexture for rootPath. Note that this does not check for options.exporterOptions.embedUrlImages, it must be done separately.
     * @param image
     * @param uri
     * @param flipY
     * @param mimeType
     */
    processImageUri(image: any, uri: string, flipY: boolean, mimeType?: string): any;
}
//# sourceMappingURL=GLTFWriter2.d.ts.map