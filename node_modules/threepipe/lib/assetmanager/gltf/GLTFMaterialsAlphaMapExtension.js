/**
 * Alpha Map Extension
 *
 * alphaTexture is added to the material
 * This is separate from the alpha in base color texture. This is used when that is not supported in the viewer
 *
 * Specification: https://webgi.xyz/docs/gltf-extensions/WEBGI_materials_alphamap.html
 */
export class GLTFMaterialsAlphaMapExtension {
}
GLTFMaterialsAlphaMapExtension.WebGiMaterialsAlphaMapExtension = 'WEBGI_materials_alphamap';
GLTFMaterialsAlphaMapExtension.Import = (parser) => new GLTFMaterialsAlphaMapExtensionImport(parser);
GLTFMaterialsAlphaMapExtension.Export = (writer) => new GLTFMaterialsAlphaMapExtensionExport(writer);
// see GLTFDracoExportPlugin
GLTFMaterialsAlphaMapExtension.Textures = {
    alphaTexture: 'G',
};
class GLTFMaterialsAlphaMapExtensionImport {
    constructor(parser) {
        this.parser = parser;
        this.name = GLTFMaterialsAlphaMapExtension.WebGiMaterialsAlphaMapExtension;
    }
    // getMaterialType(materialIndex: number) { // todo: required?
    //
    //     const parser = this.parser
    //     const materialDef = parser.json.materials[ materialIndex ]
    //
    //     if (!materialDef.extensions || !materialDef.extensions[ this.name ]) return null
    //
    //     return MeshPhysicalMaterial
    //
    // }
    async extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const pending = [];
        const extension = materialDef.extensions[this.name];
        if (extension.alphaTexture !== undefined) {
            pending.push(parser.assignTexture(materialParams, 'alphaMap', extension.alphaTexture));
        }
        return Promise.all(pending);
    }
}
class GLTFMaterialsAlphaMapExtensionExport {
    constructor(writer) {
        this.writer = writer;
        this.name = GLTFMaterialsAlphaMapExtension.WebGiMaterialsAlphaMapExtension;
    }
    writeMaterial(material, materialDef) {
        if (!material.isMeshStandardMaterial || !material.alphaMap)
            return;
        const writer = this.writer;
        const extensionsUsed = writer.extensionsUsed;
        const extensionDef = {};
        if (material.alphaMap && writer.checkEmptyMap(material.alphaMap)) {
            const alphaMapDef = { index: writer.processTexture(material.alphaMap) };
            writer.applyTextureTransform(alphaMapDef, material.alphaMap);
            extensionDef.alphaTexture = alphaMapDef;
        }
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[this.name] = extensionDef;
        extensionsUsed[this.name] = true;
    }
}
//# sourceMappingURL=GLTFMaterialsAlphaMapExtension.js.map