var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Vector3 } from 'three';
import { LineSegments2 } from 'three/examples/jsm/lines/LineSegments2.js';
import { LineSegmentsGeometry } from 'three/examples/jsm/lines/LineSegmentsGeometry.js';
import { onChange } from 'ts-browser-helpers';
import { ALightHelperWidget } from './ALightHelperWidget';
import { uiSlider } from 'uiconfig.js';
import { LineMaterial2 } from '../../core';
export class SpotLightHelper2 extends ALightHelperWidget {
    constructor(light, size, color) {
        super(light);
        this.lineWidth = 5;
        this._v1 = new Vector3();
        this.color = color;
        if (size === undefined)
            size = 0.5;
        const geometry = new LineSegmentsGeometry();
        const positions = [
            0, 0, 0, 0, 0, 1,
            0, 0, 0, 1, 0, 1,
            0, 0, 0, -1, 0, 1,
            0, 0, 0, 0, 1, 1,
            0, 0, 0, 0, -1, 1,
        ];
        for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
            const p1 = i / l * Math.PI * 2;
            const p2 = j / l * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.setPositions(positions);
        this.material = new LineMaterial2({
            color: 0xff0000,
            linewidth: 5, // in world units with size attenuation, pixels otherwise
            vertexColors: false,
            worldUnits: false,
            dashed: false,
            alphaToCoverage: true,
            toneMapped: false,
            transparent: true,
            depthTest: false,
            depthWrite: false,
        });
        this.material.userData.renderToGBuffer = false;
        this.material.userData.renderToDepth = false;
        this.cone = new LineSegments2(geometry, this.material);
        this.add(this.cone);
        this.update();
        this.traverse(o => {
            o.userData.__keepShadowDef = true;
            o.castShadow = false;
            o.receiveShadow = false;
        });
    }
    dispose() {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
        super.dispose();
    }
    update() {
        if (!this.light || !this.cone)
            return;
        this.light.updateWorldMatrix(true, false);
        this.light.target.updateWorldMatrix(true, false);
        const coneLength = this.light.distance ? this.light.distance : 1000;
        const coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        this._v1.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(this._v1);
        this.material.color.set(this.color ?? this.light.color);
        this.material.linewidth = this.lineWidth;
        super.update();
    }
    static Check(light) {
        return light.isSpotLight;
    }
    static Create(light) {
        return new SpotLightHelper2(light);
    }
}
__decorate([
    onChange(SpotLightHelper2.prototype.update)
], SpotLightHelper2.prototype, "material", void 0);
__decorate([
    onChange(SpotLightHelper2.prototype.update),
    uiSlider(undefined, [0.1, 20], 0.01)
], SpotLightHelper2.prototype, "lineWidth", void 0);
//# sourceMappingURL=SpotLightHelper2.js.map