var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { SphereGeometry } from 'three';
import { WireframeGeometry2 } from 'three/examples/jsm/lines/WireframeGeometry2.js';
import { Wireframe } from 'three/examples/jsm/lines/Wireframe.js';
import { onChange } from 'ts-browser-helpers';
import { ALightHelperWidget } from './ALightHelperWidget';
import { uiSlider } from 'uiconfig.js';
import { LineMaterial2 } from '../../core';
export class PointLightHelper2 extends ALightHelperWidget {
    constructor(light, size, color) {
        super(light);
        this.lineWidth = 5;
        this.size = 0.5;
        this.color = color;
        if (size !== undefined)
            this.size = size;
        const geometry = new WireframeGeometry2(new SphereGeometry(0.5, 4, 2));
        this.material = new LineMaterial2({
            color: 0xff0000,
            linewidth: 5, // in world units with size attenuation, pixels otherwise
            vertexColors: false,
            worldUnits: false,
            dashed: false,
            alphaToCoverage: true,
            toneMapped: false,
            transparent: true,
            depthTest: false,
            depthWrite: false,
        });
        this.material.userData.renderToGBuffer = false;
        this.material.userData.renderToDepth = false;
        this.lightSphere = new Wireframe(geometry, this.material);
        this.lightSphere.computeLineDistances();
        this.add(this.lightSphere);
        this.update();
        this.traverse(o => {
            o.userData.__keepShadowDef = true;
            o.castShadow = false;
            o.receiveShadow = false;
        });
    }
    dispose() {
        this.lightSphere.geometry.dispose();
        this.lightSphere.material.dispose();
        super.dispose();
    }
    update() {
        if (!this.light || !this.lightSphere)
            return;
        this.material.color.set(this.color ?? this.light.color);
        this.material.linewidth = this.lineWidth;
        this.lightSphere.scale.setScalar(this.size);
        super.update();
    }
    static Check(light) {
        return light.isPointLight;
    }
    static Create(light) {
        return new PointLightHelper2(light);
    }
}
__decorate([
    onChange(PointLightHelper2.prototype.update)
], PointLightHelper2.prototype, "material", void 0);
__decorate([
    onChange(PointLightHelper2.prototype.update),
    uiSlider(undefined, [0.1, 20], 0.01)
], PointLightHelper2.prototype, "lineWidth", void 0);
__decorate([
    onChange(PointLightHelper2.prototype.update),
    uiSlider(undefined, [0.01, 10], 0.01)
], PointLightHelper2.prototype, "size", void 0);
//# sourceMappingURL=PointLightHelper2.js.map